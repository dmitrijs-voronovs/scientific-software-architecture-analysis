quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Usability,"ientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode==AClean ? (flipAClean() ? ADirty : AClean ) : _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). » Last changed: Sat Oct 9 22:38:27 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:40771,clear,clearValueDirty,40771,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,2,['clear'],"['clearShapeDirty', 'clearValueDirty']"
Usability,"ier(float* working_space, Int_t num, Int_t hartley, Int_t direction, Int_t zt_clear). AUXILIARY FUNCION. This function calculates Fourier based transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -hartley-1 if it is Hartley transform, 0 othewise; -direction-forward or inverse transform. void BitReverseHaar(float* working_space, Int_t shift, Int_t num, Int_t start). AUXILIARY FUNCION. This function carries out bir-reverse reordering for Haar transform; Function parameters:; -working_space-pointer to vector of processed data; -shift-shift of position of processing; -start-initial position of processed data; -num-length of processed data. int GeneralExe(float* working_space, Int_t zt_clear, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates generalized (mixed) transforms of different degrees; Function parameters:; -working_space-pointer to vector of transformed data; -zt_clear-flag to clear imaginary data before staring; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). int GeneralInv(float* working_space, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates inverse generalized (mixed) transforms; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). void Transform(const float* source, float* destVector). ONE-DIMENSIONAL TRANSFORM FUNCTION; This function transforms the source spectrum. The calling program; should fill in input parameters.; Transformed data are written into dest spectrum. Function parameters:; source-pointer to the vector of source spectrum, its length should; be size except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR; transform. These need 2*size length to supply real and; imaginary coefficients.; destVector-p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumTransform.html:10461,clear,clear,10461,root/html528/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html528/TSpectrumTransform.html,6,['clear'],['clear']
Usability,"ies column lower-bound index. SetColIndexArray (Int_t *data); for sparse matrices, set the column index. The array data should contains at least fNelems entries. SetSparseIndex (Int_t nelems new); allocate memory for a sparse map of nelems_new elements and copy (if exists) at most nelems_new matrix elements over to the new structure. SetSparseIndex (const TMatrixDBase &a); copy the sparse map from matrix a Note that this can be a dense matrix!. SetSparseIndexAB (const TMatrixDSparse &a, const TMatrixDSparse &b); set the sparse map to the same of the map of matrix a and b. The second half of the table is only relevant for sparse matrices. These methods define the sparse structure. It should be clear that a call to any of these methods has to be followed by a SetMatrixArray (…) which will supply the matrix data, see the next chapter “Creating and Filling a Matrix”.; 14.3 Creating and Filling a Matrix; The matrix constructors are listed in the next table. In the simplest ones, only the number of rows and columns is given. In a slightly more elaborate version, one can define the row and column index range. Finally, one can also define the matrix data in the constructor. In Matrix Operators and Methods we will encounter more fancy constructors that will allow arithmetic operations. TMatrixD(Int_t nrows,Int_t ncols); TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb); TMatrixD(Int_t nrows,Int_t ncols,const Double_t *data, Option_t option= """"); TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,; const Double_t *data,Option_t *option=""""). TMatrixDSym(Int_t nrows); TMatrixDSym(Int_t row_lwb,Int_t row_upb); TMatrixDSym(Int_t nrows,const Double_t *data,Option_t *option=""""); TMatrixDSym(Int_t row_lwb,Int_t row_upb,const Double_t *data, Option_t *opt=""""). TMatrixDSparse(Int_t nrows,Int_t ncols); TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb, Int_t col_upb ); TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,; Int_t nr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:775040,simpl,simplest,775040,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simplest']
Usability,"ies the mask and the values to be set. (see also the GCValues_t structure) ; Reimplemented from TVirtualX.; Definition at line 3012 of file TGCocoa.mm. ◆ ChangeProperties(). void TGCocoa::ChangeProperties ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . Int_t ; format, . UChar_t * ; data, . Int_t ; len . ). overridevirtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Reimplemented from TVirtualX.; Definition at line 3859 of file TGCocoa.mm. ◆ ChangeProperty(). void TGCocoa::ChangeProperty ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . UChar_t * ; data, . Int_t ; len . ). overridevirtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Parameters. [in]idthe window whose property you want to change ; [in]propertyspecifies the property name ; [in]typethe type of the property; the X server does not interpret the type but simply passes it back to an application that might ask about the window properties ; [in]datathe property data ; [in]lenthe length of the specified data format . Reimplemented from TVirtualX.; Definition at line 3816 of file TGCocoa.mm. ◆ ChangeWindowAttributes(). void TGCocoa::ChangeWindowAttributes ; (; Window_t ; id, . SetWindowAttributes_t * ; attr . ). overridevirtual . Changes the attributes of the specified window ""id"" according the values provided in ""attr"". ; The mask data member of ""attr"" specifies which window attributes are defined in the attributes argument. This mask is the bitwise inclusive OR of the valid attribute mask bits; if it is zero, the attributes are ignored. ; Reimplemented from TVirtualX.; Definition at line 1006 of file TGCocoa.mm. ◆ CheckEvent(). Bool_t TGCocoa::CheckEvent ; (; Window_t ; id, . EGEventType ; type, . Event_t & ; ev . ). overridevirtual . Check if there is for window ""id"" an event of type ""type"". ; If there is it fills in the event str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:55711,simpl,simply,55711,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['simpl'],['simply']
Usability,"ies. Function documentation; RooMappedCategory(const char* name, const char* title, RooAbsCategory& inputCat, const char* defCatName = ""NotMapped"", Int_t defCatIdx = NoCatIdx); Constructor with input category and name of default output state, which is assigned; to all input category states that do not follow any mapping rule. RooMappedCategory(const RooMappedCategory& other, const char* name = 0). ~RooMappedCategory(); Destructor. Bool_t map(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); Add mapping rule: any input category state label matching the 'inKeyRegExp'; wildcard expression will be mapped to an output state with name 'outKey'. Rules are evaluated in the order they were added. In case an input state; matches more than one rule, the first rules output state will be assigned. RooCatType evaluate() const; Calculate the current value of the object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this mapped category to the specified stream. In addition to the info; from RooAbsCategory::printStream() we add:. Standard : input category; Shape : default value; Verbose : list of mapping rules. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the; product operator construction. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooMappedCategory(); { }. TObject* clone(const char* newname) const; { return new RooMappedCategory(*this,newname); }. Entry& operator=(const RooMappedCategory& ). » Last changed: Tue Jun 2 15:32:03 2015 » Last generated: 2015-06-02 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooMappedCategory.html:25576,intuit,intuitively,25576,root/html604/RooMappedCategory.html,https://root.cern,https://root.cern/root/html604/RooMappedCategory.html,2,['intuit'],['intuitively']
Usability,"ies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22531,guid,guide,22531,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['guid'],['guide']
Usability,"iewer.cxx. ◆ Progress() [1/3]. void TSessionQueryFrame::Progress ; (; Long64_t ; total, . Long64_t ; processed . ). Update progress bar and status labels. ; Definition at line 2615 of file TSessionViewer.cxx. ◆ Progress() [2/3]. void TSessionQueryFrame::Progress ; (; Long64_t ; total, . Long64_t ; processed, . Long64_t ; bytesread, . Float_t ; initTime, . Float_t ; procTime, . Float_t ; evtrti, . Float_t ; mbrti . ). inline . Definition at line 428 of file TSessionViewer.h. ◆ Progress() [3/3]. void TSessionQueryFrame::Progress ; (; Long64_t ; total, . Long64_t ; processed, . Long64_t ; bytesread, . Float_t ; initTime, . Float_t ; procTime, . Float_t ; evtrti, . Float_t ; mbrti, . Int_t ; actw, . Int_t ; tses, . Float_t ; eses . ). New version of Progress (just forward to the old version for the time being). ; Definition at line 2733 of file TSessionViewer.cxx. ◆ ProgressLocal(). void TSessionQueryFrame::ProgressLocal ; (; Long64_t ; total, . Long64_t ; processed . ). Update progress bar and status labels. ; Definition at line 2745 of file TSessionViewer.cxx. ◆ ResetProgressDialog(). void TSessionQueryFrame::ResetProgressDialog ; (; const char * ; selec, . Int_t ; files, . Long64_t ; first, . Long64_t ; entries . ). Reset progress frame information fields. ; Definition at line 2905 of file TSessionViewer.cxx. ◆ Streamer(). void TSessionQueryFrame::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGCompositeFrame. ◆ StreamerNVirtual(). void TSessionQueryFrame::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 448 of file TSessionViewer.h. ◆ UpdateButtons(). void TSessionQueryFrame::UpdateButtons ; (; TQueryDescription * ; desc). Update buttons state for the current query status. ; Definition at line 3229 of file TSessionViewer.cxx. ◆ UpdateHistos(). void TSessionQueryFrame::UpdateHistos ; (; TList * ; objs). Update feedback histograms. ; Definition at line 2572 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionQueryFrame.html:37302,progress bar,progress bar,37302,doc/master/classTSessionQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionQueryFrame.html,1,['progress bar'],['progress bar']
Usability,"iewer3D Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; List of all members ; TVirtualViewer3D Class ReferenceabstractCore ROOT classes » Base ROOT classes. ; Abstract 3D shapes viewer. ; The concrete implementations are:. TViewerX3D : X3d viewer; TGLViewer : OpenGL viewer. 3D Viewer Infrastructure Overview; The 3D Viewer infrastructure consists of:. TVirtualViewer3D interface: An abstract handle to the viewer, allowing client to test preferences, add objects, control the viewer via scripting (to be added) etc. -TBuffer3D class hierarchy: Used to describe 3D objects (""shapes""); filled /added by negotiation with viewer via TVirtualViewer3D. Together these allow clients to publish objects to any one of the 3D viewers (currently OpenGL/x3d,TPad), free of viewer specific drawing code. They allow our simple x3d viewer, and considerably more sophisticated OpenGL one to both work with both geometry libraries (g3d and geom) efficiently.; Publishing to a viewer consists of the following steps:. Create / obtain viewer handle; Begin scene on viewer; Fill mandatory parts of TBuffer3D describing object; Add to viewer; Fill optional parts of TBuffer3D if requested by viewer, and add again ... repeat 3/4/5 as required; End scene on viewer. Creating / Obtaining Viewer; Create/obtain the viewer handle via local/global pad - the viewer is always bound to a TPad object at present [This may be removed as a restriction in the future] . You should perform the publishing to the viewer described below in the Paint() method of the object you attach to the pad (via Draw()) TVirtualViewer3D * v = gPad->GetViewer3D(""xxxx"");; gPad#define gPadDefinition TVirtualPad.h:308; TVirtualViewer3DAbstract 3D shapes viewer.Definition TVirtualViewer3D.h:34; v@ vDefinition rootcling_impl.cxx:3699; "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or Pad ""pad"" (default). The view",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:958,simpl,simple,958,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['simpl'],['simple']
Usability,"ifferent package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); qfloat * qDefinition THbookFile.cxx:89; v3@ v3Definition rootcling_impl.cxx:3703. Arithmetic Operations; The following operations are possible between vector classes, even of different coordinate system types:; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; a#define a(i)Definition RSha256.hxx:99; v2@ v2Definition rootcling_impl.cxx:3702; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous. Other Methods; The vector classes support methods for:. computation of the dot product via Dot(),; computation of the cross product via Cross(),; construction of a unit vector via Unit(). Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors using the operator() or the operator * and the transformations can also be combined via the operator *. In more detail the transformations available are:. 3D Rotations. ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein definition.; ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; ROOT::Math::AxisAngle, rotation described by a vector (axis) and an angle; ROOT::Math::Quaternion, rotatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:7371,simpl,simple,7371,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['simpl'],['simple']
Usability,"ifies the type of tick marks on the axis.; If tx = gPad->GetTickx() and ty = gPad->GetTicky() then:. tx = 1; tick marks on top side are drawn (inside); tx = 2; tick marks and labels on top side are drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (tx = ty = 0); TPad::SetTicks(tx,ty) allows to set these options.; See also The TAxis functions to set specific axis attributes.; In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any TLatex string.; The titles are part of the persistent histogram.; The option ""SAME""; By default, when an histogram is drawn, the current pad is cleared before; drawing. In order to keep the previous drawing and draw on top of it the; option ""SAME"" should be use. The histogram drawn with the option; ""SAME"" uses the coordinates system available in the current pad. This option can be used alone or combined with any valid drawing option but; some combinations must be use with care.; Limitations. It does not work when; combined with the ""LEGO"" and ""SURF"" options unless the; histogram plotted with the option ""SAME"" has exactly the same; ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; lego plots histograms' stacks should be used. Superimposing two histograms with different scales in the same pad; The following example creates two histograms, the second histogram is the bins; integral of the first one. It shows a procedure to draw the two histograms in; the same pad and it draws the scale of the second histogram using a new vertical; axis on the right side. See also the tutor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:12541,clear,cleared,12541,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,10,['clear'],['cleared']
Usability,"ig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->GetName() : 0 ; }. const RooAbsReal& integrand() const; { return _function.arg() ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealIntegral.html:37016,intuit,intuitively,37016,root/html528/RooRealIntegral.html,https://root.cern,https://root.cern/root/html528/RooRealIntegral.html,1,['intuit'],['intuitively']
Usability,"ig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:36306,intuit,intuitively,36306,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,1,['intuit'],['intuitively']
Usability,"ig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealIntegral.html:37141,intuit,intuitively,37141,root/html530/RooRealIntegral.html,https://root.cern,https://root.cern/root/html530/RooRealIntegral.html,1,['intuit'],['intuitively']
Usability,"ighlighted() is similar TCanvas::Picked(). when selected object (histogram as a whole) is different from previous then emit Picked() signal; when selected (highlighted) bin from histogram is different from previous then emit Highlighted() signal. Any user function (or functions) has to be defined UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y). In example (see below) has name PrintInfo(). All parameters of user function are taken from void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y). pad is pointer to pad with highlighted histogram; obj is pointer to highlighted histogram; x is highlighted x bin for 1D histogram; y is highlighted y bin for 2D histogram (for 1D histogram not in use). Example how to create a connection from any TCanvas object to a user UserFunction() slot (see also TQObject::Connect() for additional info) TQObject::Connect(""TCanvas"", ""Highlighted(TVirtualPad*,TObject*,Int_t,Int_t)"",; 0, 0, ""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; or use non-static ""simplified"" function TCanvas::HighlightConnect(const char *slot) c1->HighlightConnect(""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; NOTE the signal and slot string must have a form ""(TVirtualPad*,TObject*,Int_t,Int_t)"" root [0] .x $ROOTSYS/tutorials/hsimple.C; root [1] hpx->SetHighlight(kTRUE); root [2] .x hlprint.C; file hlprint.C void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); {; auto h = (TH1F *)obj;; if (!h->IsHighlight()) // after highlight disabled; h->SetTitle(""highlight disable"");; else; h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; h->GetBinCenter(x), h->GetBinContent(x)));; pad->Update();; }; ; void hlprint(); {; if (!gPad) return;; gPad->GetCanvas()->HighlightConnect(""PrintInfo(TVirtualPad*,TObject*,Int_t,Int_t)"");; }; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:130728,simpl,simplified,130728,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simplified']
Usability,"ightGradientsAt (size_t i);  ; const Matrix_t & GetWeightGradientsAt (size_t i) const;  ; std::vector< Matrix_t > & GetWeights ();  ; const std::vector< Matrix_t > & GetWeights () const;  ; Matrix_t & GetWeightsAt (size_t i);  ; const Matrix_t & GetWeightsAt (size_t i) const;  ; size_t GetWidth () const;  ; virtual void Initialize ();  Initialize the weights and biases according to the given initialization method. ;  ; bool IsTraining () const;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html:5893,learn,learningRate,5893,doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"ights ;  CTBinStatNo-op; this class does not provide per-bin statistics ;  ►CTHistStatUncertaintyHistogram statistics to keep track of the Poisson uncertainty per bin ;  CTBinStatModifying view on a THistStatUncertainty for a given bin ;  CTConstBinStatConst view on a THistStatUncertainty for a given bin ;  CTHistViewA view on a histogram, selecting a range on a subset of dimensions ;  CTHistViewOutOfRange;  CTLogEntry;  CTLogHandlerAbstract TLogHandler base class ;  CTLogManager;  ►NFitNamespace for the fitting classes ;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types: Stores the coordinates and the DataOptions ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:18001,simpl,simple,18001,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,"ights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The parameters for this method are Eta, EtaDecay, Delta and; Epsilon.; Steepest descent with fixed step size; (batch learning): It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:4793,learn,learning,4793,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,10,['learn'],['learning']
Usability,"ignal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTProofPlayer::Feedback(TList* objs)SIGNAL ; voidTProofPlayer::FeedBackCanvas(const char* name, Bool_t create); virtual Long64_tTProofPlayer::Finalize(TQueryResult* qr); virtual Long64_tTProofPlayer::Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTProofPlayer::GetCacheSize(); virtual TQueryResult*TProofPlayer::GetCurrentQuery() const; virtual Int_tTProofPlayer::GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTProofPlayer::GetEventsProcessed() const; virtual TVirtualProofPlayer::EExitStatusTProofPlayer::GetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual TList*TProofPlayer::GetInputList() const; virtual Int_tTProofPlayer::GetLearnEntries(); TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLocal.html:5106,FeedBack,FeedBackCanvas,5106,root/html602/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLocal.html,4,['FeedBack'],['FeedBackCanvas']
Usability,"ignal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions;  TApplication ();  Default ctor. Can be used by classes deriving from TApplication. ;  ; virtual void Forum (const char *line);  The function ("".forum <type>"") submits a new post on the ROOT forum via web browser. ;  ; virtual void GitHub (const char *line);  The function ("".gh <type>"") submits a new issue on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Member Functions; static void Close (TApplication *app);  Static function used to close a remote application. ;  ; static TApplication * Open (const char *url, Int_t debug, const char *script);  Static fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:18046,guid,guide,18046,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['guid'],['guide']
Usability,"ignal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TGLColorSet & GetDefaultColorSet ();  Returns reference to the default color-set. ;  ; static Bool_t IsUsingDefaultColorSetForNewViewers ();  Returns the value of the static flag that determines if new viewers should use the default color-set. ;  ; static void SetAxisLabelScale (Float_t als);  Sets static scaling facor that allows simple guide axies to have label values scaled relative to actual scene dimensions. ;  ; static void UseDefaultColorSetForNewViewers (Bool_t x);  Sets static flag that determines if new viewers should use the default color-set. ;  ;  Static Public Member Functions inherited from TVirtualViewer3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TVirtualViewer3D * Viewer3D (TVirtualPad *pad=nullptr, Option_t *type="""");  Create a Viewer 3D of specified type. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:27759,simpl,simple,27759,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"igned intNPoints() const; ROOT::Math::IntegratorOneDimOptions&operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNPoints(unsigned int n); static voidSetDefaultRelTolerance(double tol); static voidSetDefaultWKSize(unsigned int size); voidROOT::Math::BaseIntegratorOptions::SetExtraOptions(const ROOT::Math::IOptions& opt); voidSetIntegrator(const char* name); voidSetNPoints(unsigned int n); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IntegratorOneDimOptions.html:2440,Clear,ClearExtra,2440,root/html532/ROOT__Math__IntegratorOneDimOptions.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IntegratorOneDimOptions.html,2,['Clear'],['ClearExtra']
Usability,"ignments. Creating functions and p.d.f.s. MyPdf::g(x,m,s) - Create p.d.f or function of type MyPdf with name g with argument x,m,s; Interpretation and number of arguments are mapped to the constructor arguments of the class; (after the name and title). MyPdf(x,m,s) - As above, but with an implicitly defined (unique) object name. Creating sets and lists (to be used as inputs above). {a,b,c} - Create RooArgSet or RooArgList (as determined by context) from given contents. Objects that are not created, are assumed to exist in the workspace; Object creation expressions as shown above can be nested, e.g. one can do. RooGaussian::g(x[-10,10],m[0],3). to create a p.d.f and its variables in one go. This nesting can be applied recursively e.g. SUM::model( f[0.5,0,1] * RooGaussian::g( x[-10,10], m[0], 3] ),; RooChebychev::c( x, {a0[0.1],a1[0.2],a2[-0.3]} )). creates the sum of a Gaussian and a Chebychev and all its variables. A seperate series of operator meta-type exists to simplify the construction of composite expressions; meta-types in all capitals (SUM) create p.d.f.s, meta types in lower case (sum) create; functions. SUM::name(f1*pdf1,f2*pdf2,pdf3] -- Create sum p.d.f name with value f1*pdf1+f2*pdf2+(1-f1-f2)*pdf3; RSUM::name(f1*pdf1,f2*pdf2,pdf3] -- Create recursive sum p.d.f. name with value f1*pdf1 + (1-f1)(f2*pdf2 + (1-f2)pdf3); ASUM::name(f1*amp1,f2*amp2,amp3] -- Create sum p.d.f. name with value f1*amp1+f2*amp2+(1-f1-f2)*amp3 where amplX are amplitudes of type RooAbsReal; sum::name(a1,a2,a3] -- Create sum function with value a1+a2+a3; sum::name(a1*b1,a2*b2,a3*b 3] -- Create sum function with value a1*b1+a2*b2+a3*b3. PROD::name(pdf1,pdf2] -- Create product of p.d.f with 'name' with given input p.d.fs; PROD::name(pdf1|x,pdf2] -- Create product of conditional p.d.f. pdf1 given x and pdf2; prod::name(a,b,c] -- Create production function with value a*b*c. SIMUL::name(cat,a=pdf1,b=pdf2] -- Create simultaneous p.d.f index category cat. Make pdf1 to state a, pdf2 to state b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFactoryWSTool.html:13530,simpl,simplify,13530,root/html526/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html526/RooFactoryWSTool.html,11,['simpl'],['simplify']
Usability,"igurable; void EnableLooseOptions (Bool_t b=kTRUE);  ; const TString & GetReferenceFile () const;  ; Bool_t LooseOptionCheckingEnabled () const;  ; void ResetSetFlag ();  resets the IsSet flag for all declare options to be called before options are read from stream ;  ; void WriteOptionsReferenceToFile ();  write complete options to output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; void CalculateMulticlassValues (const TMVA::Event *&evt, std::vector< Double_t > &parameters, std::vector< Float_t > &values);  calculate the values for multiclass ;  ; void ClearAll ();  delete and clear all class members ;  ; void CreateFormula ();  translate formula string into TFormula, and parameter string into par ranges ;  ; void DeclareOptions ();  define the options (their key words) that can be set in the option string ;  ; Double_t InterpretFormula (const Event *, std::vector< Double_t >::iterator begin, std::vector< Double_t >::iterator end);  formula interpretation ;  ; void PrintResults (const TString &, std::vector< Double_t > &, const Double_t) const;  display fit parameters check maximum length of variable name ;  ; void ProcessOptions ();  the option string is decoded, for available options see ""DeclareOptions"" ;  . Private Attributes; std::vector< Double_t > fBestPars;  the pars that optimise (minimise) the estimator ;  ; TString fConverger;  fit method uses fConverger as intermediate step to converge into local minimas ;  ; IFitterTarget * fConvergerFitter;  intermediate fitter ;  ; TString fFitMethod;  estimator optimisation method ;  ; FitterBase * fFitter;  the fitter used in the training ;  ; TFormula * fFormula;  the discrimination function ;  ; TString fFormulaStringP;  string with function ;  ; TString fFormulaStringT;  string with function ;  ; UInt_t fNPars;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFDA.html:26872,clear,clear,26872,doc/master/classTMVA_1_1MethodFDA.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFDA.html,1,['clear'],['clear']
Usability,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:56969,simpl,simplex,56969,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,30,['simpl'],['simplex']
Usability,"ikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for tools which can produce both a RooStats HypoTestResult and ConfInterval). More...;  ; class  ProfileLikelihoodTestStat;  ProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset. More...;  ; class  ProofConfig;  Holds configuration options for proof and proof-lite. More...;  ; class  ProposalFunction;  ProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm. More...;  ; class  ProposalHelper;  ; class  RatioOfProfiledLikelihoodsTestStat;  TestStatistic that returns the ratio of profiled likelihoods. More...;  ; struct  RooStatsConfig;  ; class  SamplingDistPlot;  This class provides simple and straightforward utilities to plot SamplingDistribution objects. More...;  ; class  SamplingDistribution;  This class simply holds a sampling distribution of some test statistic. More...;  ; class  SamplingSummary;  ; class  SamplingSummaryLookup;  ; class  SequentialProposal;  Class implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step. More...;  ; class  SimpleInterval;  SimpleInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  SimpleLikelihoodRatioTestStat;  TestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood. More...;  ; class  SPlot;  A class to calculate ""sWeights"" used to create an ""sPlot"". More...;  ; class  TestStatistic;  TestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class. More...;  ; class  TestStatSampler;  TestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions. More...;  ; class  ToyMCImportanceSampler;  ToyMCImportanceSampler is an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:7179,simpl,simply,7179,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['simpl'],['simply']
Usability,"ikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(const RooStats::SimpleLikelihoodRatioTestStat&); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. RooArgSet*fAltParameters; RooAbsPdf*fAltPdf; RooArgSetfConditionalObs; RooArgSet*fDetailedOutput!; boolfDetailedOutputEnabled; boolfFirstEval; RooAbsReal*fNllAlt! transient copy of the alt NLL; RooAbsReal*fNllNull! transient copy of the null NLL; RooArgSet*fNullParameters; RooAbsPdf*fNullPdf; Bool_tfReuseNll; static Bool_tfgAlwaysReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleLikelihoodRatioTestStat(). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters). virtual ~SimpleLikelihoodRatioTestStat(). void SetAlwaysReuseNLL(Bool_t flag). void SetReuseNLL(Bool_t flag); { fReuseNll = flag ; }. void SetNullParameters(const RooArgSet& nullParameters). void SetAltParameters(const RooArgSet& altParameters). bool ParamsAreEqual(). void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. Double_t Evaluate(RooAbsData& data, RooArgSet& nullPOI). void EnableDetailedOutput(bool e = true); { fDetailedOutputEnabled = e; fDetailedOutput = NULL; }. const RooArgSet* GetDetailedOutput(void); { return fDetailedOutput; }. const TString GetVarName() const. » Author: Kyle Cranmer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__SimpleLikelihoodRatioTestStat.html:2352,Simpl,SimpleLikelihoodRatioTestStat,2352,root/html534/RooStats__SimpleLikelihoodRatioTestStat.html,https://root.cern,https://root.cern/root/html534/RooStats__SimpleLikelihoodRatioTestStat.html,1,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,"ile *GetCurrentFile() const;; 459 Int_t GetDefaultEntryOffsetLen() const {return fDefaultEntryOffsetLen;}; 460 Long64_t GetDebugMax() const { return fDebugMax; }; 461 Long64_t GetDebugMin() const { return fDebugMin; }; 462 TDirectory *GetDirectory() const { return fDirectory; }; 463 virtual Long64_t GetEntries() const { return fEntries; }; 464 virtual Long64_t GetEntries(const char *selection);; 465 /// Return a number greater or equal to the total number of entries in the; 466 /// dataset.; 467 ///; 468 /// \note If you are interested in the total number of entries in a TChain,; 469 /// this function will give that number once the last file of the chain; 470 /// is opened. In general, using this instead of GetEntries will avoid; 471 /// opening all files in the chain which could be very costly for very; 472 /// large number of files stored at a remote location.; 473 ///; 474 /// The logic depends on whether the dataset is a TTree or a TChain. In the; 475 /// first case, it simply returns the total number of entries in the tree. In; 476 /// the latter case, it depends on which point of the processing of the chain; 477 /// this function is called. During most of the chain processing, this; 478 /// function will return TTree::kMaxEntries. When the chain arrives at the; 479 /// last file, then the function will return the accumulated total number of; 480 /// entries in the whole chain. A notable use case where this function; 481 /// becomes quite useful is when writing the following for loop to traverse; 482 /// the entries in the dataset:; 483 ///; 484 /// \code{.cpp}; 485 /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In the example above, independently on whether the dataset is a TTree or; 491 /// a TChain, the GetEntriesFast call will provide the correct stopping; 492 /// condition for the loop (i.e. the total number of entries). In the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:25301,simpl,simply,25301,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['simpl'],['simply']
Usability,"ile Histo1D<float>(""x"") does not; the latter spelling should be preferred for performance-critical applications.; Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame. See Efficient analysis in Python for possible ways to speed up hot paths in this case.; Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations for all RDataFrame computation graphs before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See Activating RDataFrame execution logs. Memory usage; There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:50683,simpl,simplifies,50683,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simplifies']
Usability,"ile RooLognormal.h. ◆ getShapeK(). RooAbsReal const & RooLognormal::getShapeK ; (; ); const. inline . Get the shape parameter. ; Definition at line 42 of file RooLognormal.h. ◆ getX(). RooAbsReal const & RooLognormal::getX ; (; ); const. inline . Get the x variable. ; Definition at line 36 of file RooLognormal.h. ◆ IsA(). TClass * RooLognormal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 57 of file RooLognormal.h. ◆ Streamer(). void RooLognormal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooLognormal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 57 of file RooLognormal.h. ◆ translate(). void RooLognormal::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 85 of file RooLognormal.cxx. ◆ useStandardParametrization(). bool RooLognormal::useStandardParametrization ; (; ); const. inline . Definition at line 44 of file RooLognormal.h. Member Data Documentation. ◆ _useStandardParametrization. bool RooLognormal::_useStandardParametrization = false. protected . Definition at line 50 of file RooLognormal.h. ◆ k. RooRealProxy RooLognormal::k. protected . the shape parameter, exp(sigma) ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLognormal.html:80536,simpl,simple,80536,doc/master/classRooLognormal.html,https://root.cern,https://root.cern/doc/master/classRooLognormal.html,1,['simpl'],['simple']
Usability,"ile TProofPlayer.h. ◆ Progress() [4/6]. void TProofPlayerSuperMaster::Progress ; (; TSlave * ; sl, . Long64_t ; total, . Long64_t ; processed . ). overridevirtual . Report progress. ; Reimplemented from TProofPlayerRemote.; Definition at line 4680 of file TProofPlayer.cxx. ◆ Progress() [5/6]. void TProofPlayerSuperMaster::Progress ; (; TSlave * ; sl, . Long64_t ; total, . Long64_t ; processed, . Long64_t ; bytesread, . Float_t ; initTime, . Float_t ; procTime, . Float_t ; evtrti, . Float_t ; mbrti . ). overridevirtual . Report progress. ; Reimplemented from TProofPlayerRemote.; Definition at line 4700 of file TProofPlayer.cxx. ◆ Progress() [6/6]. void TProofPlayerSuperMaster::Progress ; (; TSlave * ; sl, . TProofProgressInfo * ; pi . ). overridevirtual . Progress signal. ; Reimplemented from TProofPlayerRemote.; Definition at line 4761 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerSuperMaster::SetupFeedback ; (; ). overrideprotectedvirtual . Setup reporting of feedback objects and progress messages. ; Reimplemented from TProofPlayerRemote.; Definition at line 4892 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayerSuperMaster::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProofPlayerRemote. ◆ StreamerNVirtual(). void TProofPlayerSuperMaster::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 442 of file TProofPlayer.h. Member Data Documentation. ◆ fReturnFeedback. Bool_t TProofPlayerSuperMaster::fReturnFeedback. private . Definition at line 409 of file TProofPlayer.h. ◆ fSlaveActW. TArrayI TProofPlayerSuperMaster::fSlaveActW. private . Definition at line 405 of file TProofPlayer.h. ◆ fSlaveBytesRead. TArrayL64 TProofPlayerSuperMaster::fSlaveBytesRead. private . Definition at line 400 of file TProofPlayer.h. ◆ fSlaveEffS. TArrayF TProofPlayerSuperMaster::fSlaveEffS. private . Definition at line 407 of file TProofPlayer.h. ◆ fSlaveEvtRti. TArrayF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:30741,feedback,feedback,30741,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"ile TQCommand.cxx. ◆ CanCompress(). Bool_t TQCommand::CanCompress ; (; TQCommand * ; c); const. virtual . By default, commands can be compressed if they are: . equal; setter commands. More complicated commands might want to override this function. ; Definition at line 387 of file TQCommand.cxx. ◆ CanMerge(). Bool_t TQCommand::CanMerge ; (; TQCommand * ; c); const. virtual . Two commands can be merged if they can be composed into a single command (Macro command). ; To allow merging commands user might override this function. ; Definition at line 314 of file TQCommand.cxx. ◆ CanRedo(). Bool_t TQCommand::CanRedo ; (; ); const. virtual . Returns kTRUE if Redo action is possible, kFALSE if it's not. ; By default, only single sequential redo action is possible. ; Reimplemented in TQUndoManager.; Definition at line 571 of file TQCommand.cxx. ◆ CanUndo(). Bool_t TQCommand::CanUndo ; (; ); const. virtual . Returns kTRUE if Undo action is possible, kFALSE if it's not. ; By default, only single trial undo action is possible. ; Reimplemented in TQUndoManager.; Definition at line 580 of file TQCommand.cxx. ◆ Class(). static TClass * TQCommand::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TQCommand::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TQCommand::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 98 of file TQCommand.h. ◆ Compress(). void TQCommand::Compress ; (; TQCommand * ; c). virtual . Compress command. ; Compression is analogous to arithmetic ""addition operation"".; Note:; The compressed command will be deleted.; Execution Compress method invokes Redo action with new redo arguments inherited from compressed command. More complicated commands might want to override this function. ; Definition at line 402 of file TQCommand.cxx. ◆ DeclFileName(). static const char * TQCommand::DeclFileName ; (; ). inlinestatic . Returns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:35113,undo,undo,35113,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"ile-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::WriteInt_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::FillInt_t Fill(const Double_t *v)Definition TProfile.h:55; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandom3::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom3.cxx:99; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; TStringBasic string class.Definition TString.h:139; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8C.html:6266,simpl,simple,6266,doc/master/hsimple_8C.html,https://root.cern,https://root.cern/doc/master/hsimple_8C.html,1,['simpl'],['simple']
Usability,"ile.C, the file will be interpreted. If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded. The corresponding binary file and shared library will be deleted at the end of the function. If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded.; The static function returns a pointer to a TSelector object ; Definition at line 142 of file TSelector.cxx. ◆ GetStatus(). virtual Long64_t TSelector::GetStatus ; (; ); const. inlinevirtual . Definition at line 58 of file TSelector.h. ◆ ImportOutput(). void TSelector::ImportOutput ; (; TList * ; output). virtual . Imports the content of 'output' in the internal output list. ; Existing content in the output list is discarded (unless found also in 'output'). In particular, if 'output' is nullptr or empty, reset the internal list. On return, the content of 'output' is cleared to avoid double deletion issues. (The caller is responsible of 'output' as container: its content is transferred under the selector ownership). ; Definition at line 270 of file TSelector.cxx. ◆ Init(). virtual void TSelector::Init ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelVerifyDataSet, TSelHandleDataSet, TProofDraw, TProofDrawHist, TProofDrawEventList, TProofDrawEntryList, TProofDrawProfile, TProofDrawProfile2D, h1analysisTreeReader, TSelEvent, TSelEventGen, TProofDrawGraph, TProofDrawPolyMarker3D, RooProofDriverSelector, TSelectorEntries, and h1analysis.; Definition at line 53 of file TSelector.h. ◆ IsA(). TClass * TSelector::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TSelVerifyDataSet, TSelEvent, TSelEventGen, TSelHandleDataSet, TSelHist, TSelectorDraw, and TSelectorEntries.; Definition at line 79 of file TSelector.h. ◆ IsStandardDraw(). bool TSelector::IsStandardDraw ; (; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:19056,clear,cleared,19056,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['clear'],['cleared']
Usability,"ile1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; The metadata information from the specification file can be then accessed using the DefinePerSample function. For example, to access luminosity information (stored as a double):; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); or sample_category information (stored as a string):; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); or directly the filename:; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also provides a corresponding exemplary JSON file for the dataset specification. Adding a progress bar; A progress bar showing the processed event statistics can be added to any RDataFrame program. The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled.; ProgressBar is added after creating the dataframe object (df): ROOT::RDataFrame df(""tree"", ""file.root"");; ROOT::RDF::Experimental::AddProgressBar(df);; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility For example, it can be called at any computational node, such as Filter or Define, not only the head node, with no change to the ProgressBar function itself (please see the Eff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:78186,progress bar,progress bar,78186,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,4,['progress bar'],['progress bar']
Usability,"ileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void FadeView (Float_t alpha);  Draw a rectangle (background color and given alpha) across the whole viewport. ;  ; void InitGL ();  Initialise GL state. ;  ; void MakeCurrent () const;  Make GL context current. ;  ; void PostDraw ();  Perform GL work which must be done after each draw. ;  ; void PreDraw ();  Perform GL work which must be done before each draw. ;  ; void SetupCameras (Bool_t reset);  Setup cameras for current bounding box. ;  ; void SetupClipObject () override;  allow simple guide axes labels to be scaled relative to scene units ;  ; void SetViewport (const TGLRect &vp);  ; void SetViewport (Int_t x, Int_t y, Int_t width, Int_t height);  Set viewer viewport (window area) with bottom/left at (x,y), with dimensions 'width'/'height'. ;  ; void SwapBuffers () const;  Swap GL buffers. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TGLViewerBase; SceneInfoList_i FindScene (TGLSceneBase *scene);  Find scene-info corresponding to scene. ;  ; void SubRenderScenes (SubRender_foo render_foo);  Call sub-rendering function render_foo on all currently visible scenes. ;  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; TGLAutoRotator * fAutoRotator;  ; Bool_t fAxesDepthTest;  axes type ;  ; Int_t fAxesType;  smooth line edge rendering ;  ; TGLCameraOver",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:31160,simpl,simple,31160,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"ill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfRmaxellipse semi-axis in X outside; Float_tfRminellipse semi-axis in X inside; Double_t*fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TTUBE. ←. TCONE. TELTU. THYPE. TTUBS; ←. TCONS. TCTUB. Function documentation; TTUBE(); TUBE shape default constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); TUBE shape normal constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TUBE shape ""simplified"" constructor. TTUBE(const TTUBE& ); copy constructor. TTUBE& operator=(const TTUBE& ); assignement operator. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBE(); TUBE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetNumberOfDivisions(Int_t ndiv); Set number of divisions used to draw this tube. void SetPoints(Double_t* points) const; Create TUBE points. void SetSegsAndPols(TBuffer3D& buffer) const; Set segments and polygons. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void Streamer(TBuffer& ); Stream an object of class TTUBE. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. Float_t GetRmin() const; {return fRmin;}. Float_t GetRmax() const; {return fRmax;}. Float_t GetDz() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTUBE.html:9654,simpl,simplified,9654,root/html602/TTUBE.html,https://root.cern,https://root.cern/root/html602/TTUBE.html,4,['simpl'],['simplified']
Usability,"ill be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *list = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:46658,simpl,simply,46658,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['simpl'],['simply']
Usability,"ill be no result produced; 1057by applying multiple systematic variations at the same time.; 1058For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; 1059""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:; 1060 ; 1061~~~{.cpp}; 1062auto df = _df.Vary(""pt"",; 1063 ""ROOT::RVecD{pt*0.9, pt*1.1}"",; 1064 {""down"", ""up""}); 1065 .Vary(""eta"",; 1066 [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; 1067 {""eta""},; 1068 2);; 1069 ; 1070auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; 1071auto all_hs = VariationsFor(nom_h);; 1072all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; 1073~~~; 1074 ; 1075Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; 1076shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1).; 1077 ; 1078\note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; 1079 interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; 1080 programming model will be streamlined in future versions.; 1081 ; 1082\note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; 1083 call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases.; 1084 ; 1085See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1086for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1087 ; 1088\anchor rnode; 1089### RDataFrame objects as function arguments and return values; 1090RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); 1091functions and to return them from functions. Howev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:63283,feedback,feedback,63283,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['feedback'],['feedback']
Usability,"ill be no result produced; 1097by applying multiple systematic variations at the same time.; 1098For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; 1099""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:; 1100 ; 1101~~~{.cpp}; 1102auto df = _df.Vary(""pt"",; 1103 ""ROOT::RVecD{pt*0.9, pt*1.1}"",; 1104 {""down"", ""up""}); 1105 .Vary(""eta"",; 1106 [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; 1107 {""eta""},; 1108 2);; 1109 ; 1110auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; 1111auto all_hs = VariationsFor(nom_h);; 1112all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; 1113~~~; 1114 ; 1115Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; 1116shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1).; 1117 ; 1118\note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; 1119 interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; 1120 programming model will be streamlined in future versions.; 1121 ; 1122\note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; 1123 call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases.; 1124 ; 1125See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1126for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1127 ; 1128\anchor rnode; 1129### RDataFrame objects as function arguments and return values; 1130RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); 1131functions and to return them from functions. Howev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:64963,feedback,feedback,64963,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['feedback'],['feedback']
Usability,"ill return the name of the last clicked button.; {; // run macro from tutorials directory of ROOT!; TControlBar bar(""vertical"");; bar.AddButton(""Help to run demos"","".x demoshelp.C"",; ""Explains how to run the demos"");; bar.AddButton(""framework"", "".x graphics/framework.C"",; ""An Example of Object Oriented User Interface"");; bar.AddButton(""hsimple"", "".x hsimple.C"",; ""An Example Creating Histograms/Ntuples on File"");; bar.AddButton(""hsum"", "".x hist/hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x graphics/canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x graphics/formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x hist/fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit/fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""draw2dopt"", "".x hist/draw2dopt.C"",; ""Drawing Options for 2D Histograms"");; bar.AddButton(""graph"", "".x graphs/graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x graphics/tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x geom/shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""file_layout"", "".x io/file.C"",; ""The ROOT file format"");; bar.AddButton(""tree_layout"", "".x tree/tree.C"",; ""The Tree Data Structure"");; bar.AddButton(""ntuple1"", "".x tree/ntuple1.C"",; ""Ntuples and Selections"");; bar.AddButton(""run benchmarks"", "".x legacy/benchmarks.C"",; ""Runs all the ROOT benchmarks"");; bar.AddButton(""rootmarks"", "".x legacy/rootmarks.C"",; ""Prints an estimated ROOTMARKS for your machine"");; bar.AddButton(""edit_hsimple"", "".!vi hsimple.C &"",; ""Invokes the text editor on file hsimple.C"");; bar.AddButton(""Close Bar"", ""bar.Hide()"",; ""Close ControlBar"");; bar.Show();; }; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; . Definition at line 26 of file TControlBar.h. Public Types; enum  { kVertical = 1; , ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTControlBar.html:1904,simpl,simple,1904,doc/master/classTControlBar.html,https://root.cern,https://root.cern/doc/master/classTControlBar.html,1,['simpl'],['simple']
Usability,"illRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::GetRandom can be used to return a random number distributed according to the contents of a histogram. Making a copy of a histogram; Like for any other ROOT object derived from TObject, one can use the Clone() function. This makes an identical copy of the original histogram including all associated errors and functions, e.g.: TH1F *hnew = (TH1F*)h->Clone(""hnew"");; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752. Normalizing histograms; One can scale a histogram such that the bins integral is equal to the normalization parameter via TH1::Scale(Double_t norm), where norm is the desired normalization divided by the integral of the histogram. Drawing histograms; Histograms are drawn via the THistPainter class. Each histogram has a pointer to its own painter (to be usable in a multithreaded program). Many drawing options are supported. See THistPainter::Paint() for more details.; The same histogram can be drawn with different options in different pads. When a histogram drawn in a pad is deleted, the histogram is automatically removed from the pad or pads where it was drawn. If a histogram is drawn in a pad, then filled again, the new status of the histogram will be automatically shown in the pad next time the pad is updated. One does not need to redraw the histogram. To draw the current version of a histogram in a pad, one can use h->DrawCopy();; This makes a clone (see Clone below) of the histogram. Once the clone is drawn, the original histogram may be modified or deleted without affecting the aspect of the clone.; One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular value for the maximum or the minimum scale on the plot. (For 1-D histograms this means the y-axis, while for 2-D histograms these functions affect th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:17050,usab,usable,17050,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['usab'],['usable']
Usability,"im; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAllowDirectiveswhether directives are to be interpreted; Bool_tfCheckForMethodwhether to check the current line for a method; TStringfClassDescrTagtag for finding the class description; enum(anonymous)fClassDocStatewhether we found the class description; TStringfCommentcurrent comment; Bool_tfCommentAtBOLat the beginning of the current line, fParseContext contained kComment; TClass*fCurrentClasscurrent class context of sources being parsed; TStringfCurrentFilecurrent source / header file name; TStringfCurrentMethodTagname_idx of the currently parsed method; TStringfCurrentModulecurrent module context of sources being parsed; TListfDataMembers[6]data members (by access, plus enums); Int_tfDirectiveCountindex of directive for current method; TListfDirectiveHandlershandler for doc directives (TDocDirective objects); TDocParser::EDocContextfDocContextcurrent context of parsed sources for documenting; TDocOutput*fDocOutputTDocOutput invoking us; set<UInt_t>fExtraLinesWithAnchorlines that need an additional anchor; TStringfFirstClassDocfirst class-doc found - per file, taken if fLastClassDoc is empty; THtml*fHtmlTHtml object using us; TStringfLastClassDoclast class-doc found - becomes class doc at ClassImp or first method; TStringfLineCommentcurrent line with links and directives for doc; UInt_tfLineNocurrent line number; Long_tfLineNumbersource line number; TStringfLineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source inf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDocParser.html:11158,undo,undocumented,11158,root/html602/TDocParser.html,https://root.cern,https://root.cern/root/html602/TDocParser.html,4,['undo'],['undocumented']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTBase_double_.html:6950,simpl,simple,6950,root/html602/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTBase_double_.html,4,['simpl'],['simple']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTBase_float_.html:6947,simpl,simple,6947,root/html602/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTBase_float_.html,4,['simpl'],['simple']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixDBase, TMatrixTBase<Double_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:6950,simpl,simple,6950,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,4,['simpl'],['simple']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixFBase, TMatrixTBase<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<flo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_float_.html:6947,simpl,simple,6947,root/html528/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html,3,['simpl'],['simple']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Double_t>, TMatrixDBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixTBase_double_.html:6950,simpl,simple,6950,root/html532/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html,2,['simpl'],['simple']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Float_t>, TMatrixFBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<flo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTBase_float_.html:6947,simpl,simple,6947,root/html530/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html530/TMatrixTBase_float_.html,3,['simpl'],['simple']
Usability,"imate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:89926,simpl,simple,89926,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,12,['simpl'],['simple']
Usability,"ime Date and time 950130 124559; TDecayChannel Class describing a particle decay channel; TDecompBK Matrix Decomposition Bunch-Kaufman; TDecompBase Matrix Decomposition Base; TDecompChol Matrix Decompositition Cholesky; TDecompLU Matrix Decompositition LU; TDecompQRH Matrix Decompositition QRH; TDecompSVD Matrix Decompositition SVD; TDecompSparse Matrix Decompositition LU; TDialogCanvas A specialized canvas to set attributes.; TDiamond Diamond class; TDictionary ABC defining interface to dictionary; TDirectory Describe directory structure in memory; TDirectoryFile Describe directory structure in a ROOT file; TDocDirective THtml directive handler; TDocHtmlDirective Handler for ""Begin_Html""/""End_Html"" for raw HTML in documentation comments; TDocLatexDirective Handler for ""Begin_Latex""/""End_Latex"" to generate an image from latex; TDocMacroDirective Handler for ""Begin_Macro""/""End_Macro"" for code that is executed and that can generate an image for documentation; TDocOutput generates documentation web pages; TDocParser parser for reference documentation; TDrawFeedback Present PROOF query feedback; TELTU ELTU shape; TEditQueryFrame Edit query frame; TEllipse An ellipse; TEmulatedCollectionProxy ; TEmulatedMapProxy ; TEntryList A list of entries in a TTree; TEntryListBlock Used internally in TEntryList to store the entry numbers; TEntryListFromFile Manager for entry lists from different files; TEnv Handle ROOT configuration resources; TEnvRec Individual TEnv records; TEve3DProjection 3D scaling ""projection""; TEveArrow Class for gl visualisation of arrow.; TEveArrowEditor GUI editor for TEveArrow.; TEveArrowGL GL renderer class for TEveArrow.; TEveBoxSet Collection of 3D primitives (fixed-size boxes, boxes of different sizes, or arbitrary sexto-epipeds); each primitive can be assigned a signal value and a TRef.; TEveBoxSetGL GL-renderer for TEveBoxSet class.; TEveBrowser Specialization of TRootBrowser for Eve.; TEveCalo2D Class for visualization of projected calorimeter event",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:54492,feedback,feedback,54492,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['feedback'],['feedback']
Usability,"imental::RCanvas Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; ROOT::Experimental::RCanvas Class ReferenceGraphics » ROOT7 Graphics » ROOT7 Pad related classes. ; A window's topmost RPad. ; AuthorAxel Naumann axel@.nosp@m.cern.nosp@m..ch ; Date2015-07-08 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition at line 47 of file RCanvas.hxx. Public Member Functions;  RCanvas ();  Create a temporary RCanvas; for long-lived ones please use Create(). ;  ;  ~RCanvas () override=default;  ; template<class PANEL > ; bool AddPanel (std::shared_ptr< PANEL > &panel);  Insert panel into the canvas, canvas should be shown at this moment. ;  ; void ClearOnClose (const std::shared_ptr< void > &handle);  Set handle which will be cleared when connection is closed. ;  ; void ClearShown ();  clear IsShown() flag ;  ; void ClearUpdated ();  clear IsUpdated() flag ;  ; std::string CreateJSON ();  Provide JSON which can be used for offline display. ;  ; const RCanvas * GetCanvas () const override;  Access to the top-most canvas, if any (const version). ;  ; RCanvas * GetCanvas () override;  Access to the top-most canvas, if any (non-const version). ;  ; int GetHeight () const;  Get canvas height. ;  ; uint64_t GetModified () const;  Get modify counter. ;  ; const std::string & GetTitle () const;  Get the canvas's title. ;  ; std::string GetUID () const;  Return unique identifier for the canvas Used in iPython display. ;  ; int GetWidth () const;  Get canvas width. ;  ; std::string GetWindowAddr () const;  Returns window name used to display canvas. ;  ; std::string GetWindowUrl (bool remote);  Returns window URL which can be used for connection. ;  ; void Hide ();  Hide all canvas display",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html:1048,clear,cleared,1048,doc/master/classROOT_1_1Experimental_1_1RCanvas.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html,1,['clear'],['cleared']
Usability,"imize \(\chi^2 = g^2(\vec\theta)\) where g is arbitrary function.; Approximate value is:; \[; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}\approx Z_{ik}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}{\frac{\partial f_j}{\theta_i}}; {\frac{\partial f_j}{\theta_k}}; \]; Then the equations for parameter increments are:; \[; \left(\frac{\partial\chi^2}{\partial\theta_i}\right)_; {\vec\theta={\vec\theta}^0} +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) =; 0, \qquad i=1\ldots m; \]; Remarkable feature of algorithm is the technique for step restriction. For an initial value of parameter \({\vec\theta}^0\) a parallelepiped \(P_0\) is built with the center at \({\vec\theta}^0\) and axes parallel to coordinate axes \(\theta_i\). The lengths of parallelepiped sides along i-th axis is \(2b_i\), where \(b_i\) is such a value that the functions \(f_j(\vec\theta)\) are quasi-linear all over the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; \[ \theta_i^{min}\le\theta_i\le\theta^{max}_i\]; They form parallelepiped \(P\) (\(P_0\) may be deformed by \(P\)). Very similar step formulae are used in FUMILI for negative logarithm of the likelihood function with the same idea - linearization of function argument.; 5.12 Neural Networks; 5.12.1 Introduction; Neural Networks are used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are image analysis, financial movements’ predictions and analysis, or sales forecast and product shipping optimization. In particles physics neural networks are mainly used for classification tasks (signal over background discrimination). A vast majority of commonly used neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package, which remains one of the fastest tools for neural networks studies.; 5.12.2 The MLP; The multilayer perceptron is a simple feed-forward network with the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:229992,simpl,simple,229992,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"imp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); virtual~TBrowser(); voidTObject::AbstractMethod(const char* method) const; voidAdd(TObject* obj, const char* name = 0, Int_t check = -1); voidAdd(void* obj, TClass* cl, const char* name = 0, Int_t check = -1); voidAddCheckBox(TObject* obj, Bool_t check = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBrowseObject(TObject* obj); voidCheckObjectItem(TObject* obj, Bool_t check = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = 1, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBrowser.html:2435,Clear,Clear,2435,root/html532/TBrowser.html,https://root.cern,https://root.cern/root/html532/TBrowser.html,2,['Clear'],['Clear']
Usability,"implemented from RooAbsReal.; Definition at line 108 of file RooCBShape.cxx. ◆ IsA(). TClass * RooCBShape::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 62 of file RooCBShape.h. ◆ maxVal(). double RooCBShape::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 120 of file RooCBShape.cxx. ◆ Streamer(). void RooCBShape::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooCBShape::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 62 of file RooCBShape.h. ◆ translate(). void RooCBShape::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 67 of file RooCBShape.cxx. Member Data Documentation. ◆ alpha. RooRealProxy RooCBShape::alpha. protected . Definition at line 52 of file RooCBShape.h. ◆ m. RooRealProxy RooCBShape::m. protected . Definition at line 49 of file RooCBShape.h. ◆ m0. RooRealProxy RooCBShape::m0. protected . Definition at line 50 of file RooCBShape.h. ◆ n. RooRealProxy RooCBShape::n. protected . Definition at line 53 of file RooCBShape.h. ◆ sigma. R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCBShape.html:78418,simpl,simple,78418,doc/master/classRooCBShape.html,https://root.cern,https://root.cern/doc/master/classRooCBShape.html,1,['simpl'],['simple']
Usability,"imum value for the counter so far ;  ; std::deque< Short_t > fSuccessList;  to calculate the improvement-speed ;  . #include <TMVA/ConvergenceTest.h>. Inheritance diagram for TMVA::ConvergenceTest:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ConvergenceTest(). TMVA::ConvergenceTest::ConvergenceTest ; (; ). constructor ; Definition at line 40 of file ConvergenceTest.cxx. ◆ ~ConvergenceTest(). TMVA::ConvergenceTest::~ConvergenceTest ; (; ). destructor ; Definition at line 55 of file ConvergenceTest.cxx. Member Function Documentation. ◆ GetCurrentValue(). Float_t TMVA::ConvergenceTest::GetCurrentValue ; (; ). inline . Definition at line 57 of file ConvergenceTest.h. ◆ HasConverged(). Bool_t TMVA::ConvergenceTest::HasConverged ; (; Bool_t ; withinConvergenceBand = kFALSE). gives back true if the last ""steps"" steps have lead to an improvement of the ""fitness"" of the ""individuals"" of at least ""improvement"" ; this gives a simple measure of if the estimator of the MLP is converging and no major improvement is to be expected. ; Definition at line 66 of file ConvergenceTest.cxx. ◆ Progress(). Float_t TMVA::ConvergenceTest::Progress ; (; ). returns a float from 0 (just started) to 1 (finished) ; Definition at line 91 of file ConvergenceTest.cxx. ◆ ResetConvergenceCounter(). void TMVA::ConvergenceTest::ResetConvergenceCounter ; (; ). inline . Definition at line 58 of file ConvergenceTest.h. ◆ SetConvergenceParameters(). void TMVA::ConvergenceTest::SetConvergenceParameters ; (; Int_t ; steps, . Double_t ; improvement . ). inline . Definition at line 54 of file ConvergenceTest.h. ◆ SetCurrentValue(). void TMVA::ConvergenceTest::SetCurrentValue ; (; Float_t ; value). inline . Definition at line 56 of file ConvergenceTest.h. ◆ SpeedControl(). Float_t TMVA::ConvergenceTest::SpeedControl ; (; UInt_t ; ofSteps). this function provides the ability to change the learning rate according to the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ConvergenceTest.html:2553,simpl,simple,2553,doc/master/classTMVA_1_1ConvergenceTest.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ConvergenceTest.html,1,['simpl'],['simple']
Usability,"in Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:7930,simpl,simple,7930,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['simpl'],['simple']
Usability,"in fQueries. ;  ; void Browse (TBrowser *b) override;  Build the PROOF's structure in the browser. ;  ; void cd (Int_t id=-1);  Set session with 'id' the default one. ;  ; Int_t CleanupSession (const char *sessiontag);  Send cleanup request for the session specified by tag. ;  ; void ClearData (UInt_t what=kUnregistered, const char *dsname=0);  Remove files for the data directory. ;  ; void ClearFeedback ();  Clear feedback list. ;  ; void ClearInput ();  Clear input object list. ;  ; void ClearInputData (const char *name);  Remove obj 'name' form the input data list;. ;  ; void ClearInputData (TObject *obj=0);  Remove obj form the input data list; if obj is null (default), clear the input data info. ;  ; Int_t ClearPackage (const char *package);  Remove a specific package. ;  ; Int_t ClearPackages ();  Remove all packages. ;  ; void Close (Option_t *option="""");  Close all open slave servers. ;  ; void CloseProgressDialog ();  Close progress dialog. ;  ; TDrawFeedback * CreateDrawFeedback ();  Draw feedback creation proxy. ;  ; void DataSetStatus (const char *msg, Bool_t status, Int_t done, Int_t total);  Send dataset preparation status. ;  ; Int_t DeactivateWorker (const char *ord, Bool_t save=kTRUE);  Remove the worker identified by the ordinal number 'ord' from the the active list. ;  ; void DeleteDrawFeedback (TDrawFeedback *f);  Delete draw feedback object. ;  ; void DeleteParameters (const char *wildcard);  Delete the input list parameters specified by a wildcard (e.g. ;  ; void Detach (Option_t *opt="""");  Detach this instance to its proofserv. ;  ; void DisableGoAsyn ();  Signal to disable related switches. ;  ; Int_t DownloadPackage (const char *par, const char *dstdir=0);  Download a PROOF archive (PAR file) from the master package repository. ;  ; Long64_t DrawSelect (const char *dsetname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Execute the specified drawing action on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:7980,feedback,feedback,7980,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['feedback'],['feedback']
Usability,"in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQCommand::fStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:17726,undo,undo,17726,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,16,"['Undo', 'undo']","['Undo', 'undo', 'undoing']"
Usability,"in the corresponding popup menu. It should also have a defined character as its unique access key. The second parameter is the popup menu we would like to add. The third one is an object of TGLayoutHints type that defines how the menu title will be laid out in the menu bar. In our example the File and Test menus will be laid out to the left of the menu bar with 4 pixels distance in between, the Help menu - will be laid out to the right.; The menu classes provide a very flexible menu system: you can enable, disable, add or remove menu items dynamically. The method HideEntry(menuID) hides the menu entry (the entry will not be shown in the popup menu). To enable a hidden entry you should call EnableEntry(menuID) method. By default all entries are enabled. The method DisableEntry(menuID) helps you to disable a menu entry - it will appear in sunken relieve. The DeleteEntry(menuID) method will delete the specified entry from the menu.; A few words about the menu design. A menu should be kept consistent and simple. All related items need to be in a popup menu. The cascade menus should be used judiciously. Try to limit them to one, maximum two levels.; There are some rules for naming the menu objects:. Define unique names within a menu; Use capitalized one-word names allowing the quick scan of the menu; Define unique access key for any menu item; Indicate by ellipsis (…) after the title with no space when a menu item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every application success and depends of three main factors:. number of presented items in the menu; how often the menu is used; how often the menu contents may change. 25.8.5 Toolbar. A toolbar (TGToolBar) is a composite frame that contains TGPictureButtonobjects. It provides an easy and fast access to most frequently used commands or options across multiple application screens. Also, it invokes easily a sub application within an application. All its functions can be obtained by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1194105,simpl,simple,1194105,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"in the same Postscript file: case 1; The following macro is an example illustrating how to open a Postscript; file and draw several pictures. The generation of a new Postscript page; is automatic when TCanvas::Clear is called by; object->Draw(). {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);; // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;; // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page; // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }. Making several pictures in the same Postscript file: case 2; This example shows 2 pages. The canvas is divided.; TPostScript::NewPage must be called before starting a new; picture.object->Draw does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that c1->Update must be called at the end of the first; picture. {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);; c1->Divide(2,1);; // picture 1; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Update();; // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();; // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }. Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opened (it is not closed). If the Postscript file name; finishes with "")"" and the file has been opened with ""("", the file is closed.; Example:. {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPostScript.html:4483,clear,clear,4483,root/html528/TPostScript.html,https://root.cern,https://root.cern/root/html528/TPostScript.html,8,['clear'],['clear']
Usability,"in(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new bin to the histogram. The bin shape is a rectangle.; It returns the bin number of the bin in the histogram. Bool_t Add(const TH1* h1, Double_t c1); Performs the operation: this = this + c1*h1. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. Bool_t Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Replace contents of this histogram by the addition of h1 and h2. void AddBinToPartition(TH2PolyBin* bin); Adds the input bin into the partition cell matrix. This method is called; in AddBin() and ChangePartition(). void ChangePartition(Int_t n, Int_t m); Changes the number of partition cells in the histogram.; Deletes the old partition and constructs a new one. TObject* Clone(const char* newname = """") const; Make a complete copy of the underlying object. If 'newname' is set,; the copy's name will be set to that name. void ClearBinContents(); Clears the contents of all bins in the histogram. void Reset(Option_t* option); Reset this histogram: contents, errors, etc. Int_t FindBin(Double_t x, Double_t y, Double_t z = 0); Returns the bin number of the bin at the given coordinate. -1 to -9 are; the overflow and underflow bins. overflow bin -5 is the unbinned areas in; the histogram (also called ""the sea""). The third parameter can be left; blank.; The overflow/underflow bins are:. -1 | -2 | -3. -4 | -5 | -6. -7 | -8 | -9. where -5 means is the ""sea"" bin (i.e. unbinned areas). Int_t Fill(Double_t x, Double_t y); Increment the bin containing (x,y) by 1.; Uses the partitioning algorithm. Int_t Fill(Double_t x, Double_t y, Double_t w); Increment the bin containing (x,y) by w.; Uses the partitioning algorithm. Int_t Fill(const char* name, Double_t w); Increment the bin named ""name"" by w. void FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); Fills a 2-D histogram with an array of values and weights. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2Poly.html:35781,Clear,ClearBinContents,35781,root/html602/TH2Poly.html,https://root.cern,https://root.cern/root/html602/TH2Poly.html,4,['Clear'],"['ClearBinContents', 'Clears']"
Usability,"in) in multi-thread runs.; 903 ; 904\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 905a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 906~~~{.cpp}; 907ROOT::EnableImplicitMT(i); 908~~~; 909replacing `i` with the number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 915 ; 916Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 917expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 918which eliminates all risks of race conditions.; 919 ; 920In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 924where `slot` will be a number between 0 and `GetNSlots() - 1`.; 925In other words, within a slot, computation runs sequentially and events are processed sequentially.; 926Note that the same slot might be associated to differen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:51846,simpl,simple,51846,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"in) in multi-thread runs.; 943 ; 944\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 945a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 946~~~{.cpp}; 947ROOT::EnableImplicitMT(i); 948~~~; 949replacing `i` with the number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 955 ; 956Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 957expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 958which eliminates all risks of race conditions.; 959 ; 960In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 964where `slot` will be a number between 0 and `GetNSlots() - 1`.; 965In other words, within a slot, computation runs sequentially and events are processed sequentially.; 966Note that the same slot might be associated to differen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:53486,simpl,simple,53486,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"in,Xmax,""X"");; Create a new volume by dividing an existing one (GEANT3 like).; Divides MOTHER into NDIV divisions called NAME along axis IAXIS starting at coordinate value START and having size STEP. The created volumes will have tracking media ID=NUMED (if NUMED=0 -> same media as MOTHER).; The behavior of the division operation can be triggered using OPTION (case insensitive):. Ndivide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NXdivide range starting with START in NDIV cells (GSDVN2 in G3); Sdivide all range with given STEP; NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SXsame as DVS, but from START position (GSDVS2, GSDVT2 in G3). 18.4.2.10 Volume Assemblies; In general, geometry contains structures of positioned volumes that have to be grouped and handled together, for different possible reasons. One of these is that the structure has to be replicated in several parts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as “overlapping” (see also "" Overlapping Volumes ""); Representing the container as a composite shape - the Boolean union of all components (see also "" Composite Shapes ""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:958226,simpl,simply,958226,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"inContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayF::Adopt(Int_t n, Float_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_tTArrayF::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1K.html:2233,Clear,Clear,2233,root/html602/TH1K.html,https://root.cern,https://root.cern/root/html602/TH1K.html,2,['Clear'],['Clear']
Usability,"inMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:25735,clear,clearEmat,25735,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,12,['clear'],"['clear', 'clearEmat']"
Usability,inVolume = 1.0;; 632 for ( unsigned int j = 0; j < fDim; j++ ); 633 {; 634 binVolume *= ( xup[j] - xlow[j] );; 635 }; 636 ; 637 // store the minimum bin volume found as reference for future normalizations; 638 if ( fNPoints == 1 ); 639 fRefVolume = binVolume;; 640 else if ( binVolume < fRefVolume ); 641 fRefVolume = binVolume;; 642 }; 643 ; 644 ; 645 void BinData::InitDataVector (); 646 {; 647 fData.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 648 fDataPtr = fData.empty() ? nullptr : &fData.front();; 649 }; 650 ; 651 void BinData::InitializeErrors(); 652 {; 653 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 654 kAsymError == fErrorType || kNoError == fErrorType );; 655 ; 656 if ( fpTmpCoordErrorVector ); 657 {; 658 delete[] fpTmpCoordErrorVector;; 659 fpTmpCoordErrorVector = nullptr;; 660 }; 661 ; 662 if ( kNoError == fErrorType ); 663 {; 664 fCoordErrors.clear();; 665 fCoordErrorsPtr.clear();; 666 ; 667 fDataErrorHigh.clear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704 fDataErrorHighPtr = nullptr;; 705 fDataErrorLow.cl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:20496,clear,clear,20496,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"include <TGProgressBar.h>. Inheritance diagram for TGProgressBar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkProgressBarStandardWidth ; kProgressBarTextWidth ; kBlockSize ; kBlockSpace . Definition at line 24 of file TGProgressBar.h. ◆ EBarType. enum TGProgressBar::EBarType. EnumeratorkStandard ; kFancy . Definition at line 22 of file TGProgressBar.h. ◆ EFillType. enum TGProgressBar::EFillType. EnumeratorkSolidFill ; kBlockFill . Definition at line 23 of file TGProgressBar.h. Constructor & Destructor Documentation. ◆ TGProgressBar(). TGProgressBar::TGProgressBar ; (; const TGWindow * ; p, . UInt_t ; w, . UInt_t ; h, . Pixel_t ; back = GetWhitePixel(), . Pixel_t ; barcolor = GetDefaultSelectedBackground(), . GContext_t ; norm = GetDefaultGC()(), . FontStruct_t ; font = GetDefaultFontStruct(), . UInt_t ; options = kDoubleBorder | kSunkenFrame . ). Create progress bar. ; Definition at line 42 of file TGProgressBar.cxx. ◆ ~TGProgressBar(). TGProgressBar::~TGProgressBar ; (; ). inlineoverride . Definition at line 58 of file TGProgressBar.h. Member Function Documentation. ◆ Class(). static TClass * TGProgressBar::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGProgressBar::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGProgressBar::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 90 of file TGProgressBar.h. ◆ DeclFileName(). static const char * TGProgressBar::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 90 of file TGProgressBar.h. ◆ DoRedraw(). void TGProgressBar::DoRedraw ; (; ). overrideprotectedpure virtual . Redraw the frame. ; Reimplemented from TGFrame.; Implemented in TGHProgressBar, and TGVProgressBar. ◆ Format(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGProgressBar.html:31084,progress bar,progress bar,31084,doc/master/classTGProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGProgressBar.html,1,['progress bar'],['progress bar']
Usability,"indVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:4587,Clear,Clear,4587,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,2,['Clear'],['Clear']
Usability,"index should be <= %d"", fNpoints);; 1758 return;; 1759 }; 1760 ; 1761 if (ipoint == fNpoints) {; 1762 SetPoint(ipoint, x, y);; 1763 return;; 1764 }; 1765 ; 1766 Double_t **ps = ExpandAndCopy(fNpoints + 1, ipoint);; 1767 CopyAndRelease(ps, ipoint, fNpoints++, ipoint + 1);; 1768 ; 1769 // To avoid redefinitions in descendant classes; 1770 FillZero(ipoint, ipoint + 1);; 1771 ; 1772 fX[ipoint] = x;; 1773 fY[ipoint] = y;; 1774}; 1775 ; 1776 ; 1777////////////////////////////////////////////////////////////////////////////////; 1778/// Integrate the TGraph data within a given (index) range.; 1779/// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; 1780/// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; 1781/// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; 1782/// with the first one. It is clear that the order of the point is essential in defining the polygon.; 1783/// Also note that the segments should not intersect.; 1784///; 1785/// NB:; 1786/// - if last=-1 (default) last is set to the last point.; 1787/// - if (first <0) the first point (0) is taken.; 1788///; 1789/// ### Method:; 1790///; 1791/// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; 1792/// you have to deal with. The most evident solution would be to divide the polygon in triangles and; 1793/// calculate the surface of them. But this can quickly become complicated as you will have to test; 1794/// every segments of every triangles and check if they are intersecting with a current polygon's; 1795/// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; 1796///; 1797/// ### The solution (implemented by R.Brun); 1798/// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; 1799/// segments don't intersect.; 1800",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:63798,clear,clear,63798,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['clear'],['clear']
Usability,"ine 59 of file TXMLParser.h. ◆ GetParseCodeMessage(). const char * TXMLParser::GetParseCodeMessage ; (; Int_t ; parseCode); const. Returns the parse code message. ; Definition at line 122 of file TXMLParser.cxx. ◆ GetReplaceEntities(). Bool_t TXMLParser::GetReplaceEntities ; (; ); const. inline . Definition at line 53 of file TXMLParser.h. ◆ GetStopOnError(). Bool_t TXMLParser::GetStopOnError ; (; ); const. inline . Definition at line 64 of file TXMLParser.h. ◆ GetValidate(). Bool_t TXMLParser::GetValidate ; (; ); const. inline . Definition at line 50 of file TXMLParser.h. ◆ GetValidateError(). const char * TXMLParser::GetValidateError ; (; ); const. inline . Definition at line 66 of file TXMLParser.h. ◆ GetValidateWarning(). const char * TXMLParser::GetValidateWarning ; (; ); const. inline . Definition at line 67 of file TXMLParser.h. ◆ InitializeContext(). void TXMLParser::InitializeContext ; (; ). protectedvirtual . Initialize parser parameters, such as, disactivate non-standards libxml1 features, on/off validation, clear error and warning messages. ; Definition at line 152 of file TXMLParser.cxx. ◆ IsA(). TClass * TXMLParser::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 69 of file TXMLParser.h. ◆ OnValidateError(). void TXMLParser::OnValidateError ; (; const TString & ; message). protectedvirtual . This function is called when an error from the parser has occurred. ; Message is the parse error. ; Definition at line 105 of file TXMLParser.cxx. ◆ OnValidateWarning(). void TXMLParser::OnValidateWarning ; (; const TString & ; message). protectedvirtual . This function is called when a warning from the parser has occurred. ; Message is the parse error. ; Definition at line 114 of file TXMLParser.cxx. ◆ operator=(). TXMLParser & TXMLParser::operator= ; (; const TXMLParser & ; ). privatedelete . ◆ ParseBuffer(). virtual Int_t TXMLParser::ParseBuffer ; (; const char * ; contents, . I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLParser.html:18926,clear,clear,18926,doc/master/classTXMLParser.html,https://root.cern,https://root.cern/doc/master/classTXMLParser.html,1,['clear'],['clear']
Usability,"ine color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TTUBE. ←; TTUBS. ←. TCONS. TCTUB. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TTUBS(). Float_t GetPhi1() const; {return fPhi1;}. Float_t GetPhi2() const; {return fPhi2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTUBS.html:10129,simpl,simplified,10129,root/html604/TTUBS.html,https://root.cern,https://root.cern/root/html604/TTUBS.html,2,['simpl'],['simplified']
Usability,"ine color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TTUBE. ←; TTUBS. ←. TCONS. TCTUB. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TTUBS(). Float_t GetPhi1() const; {return fPhi1;}. Float_t GetPhi2() const; {return fPhi2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTUBS.html:10129,simpl,simplified,10129,root/html602/TTUBS.html,https://root.cern,https://root.cern/root/html602/TTUBS.html,2,['simpl'],['simplified']
Usability,"ine command. Now let us execute a multi-line command:; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; Here we note:. A multi-line command starts with a { and ends with a }.; Inside continuation, every line has to be correctly terminated with a ; (like in ""real’’ C++).; All objects are created in global scope.; There is no way to back up; you are better off writing a script.; Use .q to exit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of statements like in the multi command line example given above, but also arbitrarily complex class and function definitions.; The most frequent interaction with the ROOT prompt uses .x to “run” a file:; root [] .x myScript.C; This loads myScript.C into the interpreter and calls the function myScript(). You can pass arguments using .x myScript.C(12, ""A String"").; Alternatively you can load the script and then run a function explicitly:; root [] .L myScript.C; root [] myScript(); The above is equivalent to .x myScript.C.; In a named script, the objects created on the stack are deleted when the function exits. In a common scenario you create a histogram in a named script on the stack. You draw the histogram, but when the function exits the canvas is empty and the histogram has disappeared. To avoid the histogram from disappearing you can create it on the heap (by using new). This will leave the histogram object intact, but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:263194,simpl,simple,263194,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"ine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCurlyArcImplements curly or wavy arcs used to draw Feynman diagrams.Definition TCurlyArc.h:16; TCurlyLineImplements curly or wavy polylines used to draw Feynman diagrams.Definition TCurlyLine.h:19; TCurlyLine::TCurlyLineTCurlyLine()Default constructor.Definition TCurlyLine.cxx:46; TCurlyLine::SetWavyvirtual void SetWavy()Set wavy.Definition TCurlyLine.cxx:369; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPolyLine::Drawvoid Draw(Option_t *option="""") overrideDraw this polyline with its current attributes.Definition TPolyLine.cxx:215; int; c1return c1Definition legend1.C:41; ginitstatic int ginitDefinition rsalib.cxx:256; lTLine lDefinition textangle.C:4; . Definition at line 19 of file TCurlyLine.h. Public Member Functions;  TCurlyLine ();  Default constructor. ;  ;  TCurlyLine (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t wl=.02, Double_t amp=.01);  Create a new TCurlyLine with starting point (x1, y1), end point (x2,y2). ;  ;  ~TCurlyLine () override;  ; virtual void Build ();  Create a curly (Gluon) or wavy (Gamma) line. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCurlyLine.html:3260,simpl,simple,3260,doc/master/classTCurlyLine.html,https://root.cern,https://root.cern/doc/master/classTCurlyLine.html,1,['simpl'],['simple']
Usability,"ineColor=""kP6Blue+1"", ShiftToZero=True, Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, LineColor=""kP6Blue+2"", ShiftToZero=True, Name=""morphed""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); ; # Plot the likelihood functions; frame2 = x_var.frame(Title=""Likelihood ratio r(x|#mu=2.5);x;p_{gauss}/p_{uniform}""); llhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); llhr_calc.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; legend1 = ROOT.TLegend(0.43, 0.63, 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf615_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf615_plot_2.png""); ; # Compute the minimum via minuit and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5) # Adjust the error level in the minimization to work with likelihoods; minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); ROOT.SetOwnership(result, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:8590,learn,learned,8590,doc/master/rf615__simulation__based__inference_8py.html,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html,2,['learn'],['learned']
Usability,"ineoverridevirtual . Implements TVirtualPadPainter.; Definition at line 83 of file TWebPadPainter.h. ◆ DrawBox(). void TWebPadPainter::DrawBox ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2, . EBoxMode ; mode . ). overridevirtual . Paint a simple box. ; Implements TVirtualPadPainter.; Definition at line 102 of file TWebPadPainter.cxx. ◆ DrawFillArea() [1/2]. void TWebPadPainter::DrawFillArea ; (; Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). overridevirtual . Paint filled area. ; Implements TVirtualPadPainter.; Definition at line 124 of file TWebPadPainter.cxx. ◆ DrawFillArea() [2/2]. void TWebPadPainter::DrawFillArea ; (; Int_t ; n, . const Float_t * ; x, . const Float_t * ; y . ). overridevirtual . Paint filled area. ; Implements TVirtualPadPainter.; Definition at line 140 of file TWebPadPainter.cxx. ◆ DrawLine(). void TWebPadPainter::DrawLine ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2 . ). overridevirtual . Paint a simple line. ; Implements TVirtualPadPainter.; Definition at line 65 of file TWebPadPainter.cxx. ◆ DrawLineNDC(). void TWebPadPainter::DrawLineNDC ; (; Double_t ; u1, . Double_t ; v1, . Double_t ; u2, . Double_t ; v2 . ). overridevirtual . Paint a simple line in normalized coordinates. ; Implements TVirtualPadPainter.; Definition at line 83 of file TWebPadPainter.cxx. ◆ DrawPixels(). void TWebPadPainter::DrawPixels ; (; const unsigned char * ; pixelData, . UInt_t ; width, . UInt_t ; height, . Int_t ; dstX, . Int_t ; dstY, . Bool_t ; enableAlphaBlending . ). overridevirtual . Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. ; Implements TVirtualPadPainter.; Definition at line 55 of file TWebPadPainter.cxx. ◆ DrawPolyLine() [1/2]. void TWebPadPainter::DrawPolyLine ; (; Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). overridevirtual . Paint Polyline. ; Implements TVirtualPadPainter.; Definition at line 156 of file TWebPadPainter.cxx. ◆ DrawPolyLine() [2/2]. void TWebP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebPadPainter.html:15315,simpl,simple,15315,doc/master/classTWebPadPainter.html,https://root.cern,https://root.cern/doc/master/classTWebPadPainter.html,1,['simpl'],['simple']
Usability,"ing () const;  Returns kTRUE if logging is ON. ;  ; void ls (Option_t *option="""") const override;  Lists all commands in stack. ;  ; void Redo (Option_t *option="""") override;  Performs redo action. Move cursor position forward in history stack. ;  ; virtual void SetLimit (UInt_t limit);  Returns a maximum number of commands which could be located in stack. ;  ; virtual void SetLogging (Bool_t on=kTRUE);  Start logging. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Undo (Option_t *option="""") override;  Performs undo action. Move cursor position backward in history stack. ;  ;  Public Member Functions inherited from TQCommand;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:2221,undo,undo,2221,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"ing C++ user code to be used from Python with; 23# PyROOT, please see:; 24# https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; 25ROOT.gInterpreter.Declare('''; 26class MyClass {};; 27'''); 28 ; 29# Next, we define a pythonizor function: the function that will be responsible; 30# for injecting new behaviour in our C++ class `MyClass`.; 31#; 32# To convert a given Python function into a pythonizor, we need to decorate it; 33# with the @pythonization decorator. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).; 43#; 44# Let's see all this with a simple example. Suppose I would like to define how; 45# `MyClass` objects are represented as a string in Python (i.e. what would be; 46# shown when I print that object). For that purpose, I can define the following; 47# pythonizor function. There are two important things to be noted here:; 48# - The @pythonization decorator has one argument that specifies our target; 49# class is `MyClass`.; 50# - The pythonizor function `pythonizor_of_myclass` provides and injects a new; 51# implementation for `__str__`, the mechanism that Python provides to define; 52# how to represent objects as strings. This new implementation; 53# always returns the string ""This is a MyClass object"".; 54@pythonization('MyClass'); 55def pythonizor_of_myclass(klass):; 56 klass.__str__ = lambda o : 'This is a MyClass object'; 57 ; 58# Once we have defined our pythonizor function, let's see it in action.; 59# We will now use the `MyClass` class for the first time from Python: we will; 60# create a new insta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html:2037,simpl,simple,2037,doc/master/pyroot002__pythonizationDecorator_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html,1,['simpl'],['simple']
Usability,"ing Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Coding Conventions. Naming conventions; Class definition conventions. Inline; Declaration Order. Avoid raw C types; Exception handling; Namespaces; Using comments to document the code; Source file layout. Header file layout; Implementation file layout. Preferred Coding Style. Indentation; Placing Braces and Spaces. ClangFormat; Astyle; Where to go from here. Naming conventions; For naming conventions we follow the Taligent rules. They have written a very large body of C++ and their rules seem well thought out. No need to invent something new. The only addition/change we made is to append an _t to typedefs and simple structs, e.g.:; typedef int Int_t ; struct Simple_t { ..... } ; ; Addherence to the rules is mandatory. After a while one really gets used to the fact that all class fields start with an f followed by a capitalized word, fEnergy, or that TStreamerInfo is a class. If the convention is sporadically violated debugging becomes a nightmare. The usage of a standard begin letter or token for the different types also makes it easy to parse and search the code using simple tools.; Class definition conventions; Also here the Taligent guide is quite reasonable. Of course, no class data member should ever be public. Make the data fields always private. Or protected, if you want to grant an inherited class direct access.; Inline; Add trivial get or setters directly in the class definition. This improves reading time since one does not have to look for it somewhere else. Add more complex inlines (longer than one line) at the bottom of the .h file. Creating separate .i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:2484,simpl,simple,2484,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['simpl'],['simple']
Usability,"ing H -> ZZ -> 4 mu generated by Pythia ;  quadset.CDemonstates usage of 2D digit class TEveQuadSet ;  selection_sigs.CTest signals from TEveSelection class ;  show_extract.CHelper script for showing of extracted / simplified geometries ;  SplitGLView.CHelper classes for the alice_esd_split.C demo ;  text.CDemonstrates usage of class TEveText - 2D & 3D text in GL ;  track.CDemonstrates usage of TEveTrackPRopagator with different magnetic field configurations ;  triangleset.CDemonstrates usage of class TEveTriangleSet ;  view3ds.CLoading and display of basic 3DS models ;  window_manager.CDemonstrates usage of EVE window-manager ;  ► eve7;  collection.CThis example display collection of ??? in web browser ;  compound.C;  csgdemo.CCombinatorial Solid Geometry example ;  event_demo.CThis example display geometry, tracks and hits in web browser ;  geom_cms.C;  points.CThis example display only points in web browser ;  projection_prescale.C;  show_extract.CHelper script for showing of extracted / simplified geometries ;  table.CThis example display table in web browser ;  tracks.CThis example display only points in web browser ;  ► fft;  FFT.C This tutorial illustrates the Fast Fourier Transforms interface in ROOT ;  ► fit;  combinedFit.C Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ConfidenceIntervals.C Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ;  ErrorIntegral.C Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit ;  exampleFit3D.C example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ;  fit1.C Simple fitting example (1-d histogram with an interpreted function) ;  fit2.C Fitting a 2-D histogram This tutorial illustrates : ;  fit2a.C Fitting a 2-D histogram (a variant) This tutorial illustrates : ;  fit2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:106278,simpl,simplified,106278,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simplified']
Usability,"ing point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; . Function Members (Methods); public:. virtual~MethodCuts(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodCuts.html:1931,Simpl,Simplex,1931,root/html532/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodCuts.html,3,['Simpl'],['Simplex']
Usability,"ing point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; ; . Function Members (Methods); public:. virtual~MethodCuts(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodCuts.html:1931,Simpl,Simplex,1931,root/html534/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodCuts.html,1,['Simpl'],['Simplex']
Usability,"ing state""); mixState.defineType(""mixed"", -1); mixState.defineType(""unmixed"", 1); ; # With pythonization :; mixState = ROOT.RooCategory(""mixState"", ""B0/B0bar mixing state"", {""mixed"" : -1, ""unmixed"" : 1}). Definition at line 28 of file RooCategory.h. Public Member Functions;  RooCategory ();  ;  RooCategory (const char *name, const char *title);  Constructor. Types must be defined using defineType() before variable can be used. ;  ;  RooCategory (const char *name, const char *title, const std::map< std::string, int > &allowedStates);  Create a new category and define allowed states. ;  ;  RooCategory (const RooCategory &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooCategory () override;  Destructor. ;  ; void addToRange (const char *rangeName, const char *stateNameList);  Add the list of state names to the given range. ;  ; void addToRange (const char *rangeName, RooAbsCategory::value_type stateIndex);  Add the given state to the given range. ;  ; void clear ();  Clear all defined category states. ;  ; void clearRange (const char *name, bool silent);  Clear the named range. ;  ; TObject * clone (const char *newname) const override;  ; bool defineType (const std::string &label);  Define a state with given name. ;  ; bool defineType (const std::string &label, Int_t index);  Define a state with given name and index. ;  ; void defineTypes (const std::map< std::string, int > &allowedStates);  Define multiple states in a single call. ;  ; value_type getCurrentIndex () const final;  Return current index. ;  ; TClass * IsA () const override;  ; RooCategory & operator= (const RooCategory &)=delete;  ; value_type & operator[] (const std::string &stateName);  Access a named state. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from given stream. ;  ; bool setIndex (const std::pair< std::string, value_type > &nameIdxPair, bool printError=true);  Change category state to state specified by another cat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:3137,clear,clear,3137,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['clear'],['clear']
Usability,"ing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  hlGraph1.CThis tutorial demonstrates how to use the highlight mode on graph ;  hlGraph2.CThis tutorial demonstrates how to use the highlight mode on graph ;  labels1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:118369,simpl,simple,118369,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"ing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  labels1.C Setting alphanumeric labels in a 1-d histogram ;  labels2.C Setting alphanumeric labels ;  motorcycle.C Macro to test scatterplot smoothers: ksmooth, lowes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:114572,simpl,simple,114572,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['simpl'],['simple']
Usability,"ing the error, and a test dataset that will avoid bias. Those two datasets can be built aside and then given to the network, or can be built from a standard expression. By default, half of the events are put in both datasets.; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; The method TMultiLayerPerceptron::SetLearningMethod() defines the learning method. Learning methods are:; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; The training can start with TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options). The first argument is the number of epochs while option is a string that can contain “text” (simple text output), “graph” (evaluating graphical training curves), “update = X” (step for the text/graph output update) or “+” (will skip the randomization and start from the previous values). All combinations are available.; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; The weights can be saved to a file (DumpWeights) and then reloaded (LoadWeights) to a new compatible network. The output can also be evaluated (Evaluate) for a given output neuron and an array of double input parameters or the network can be exported (Export) as a standalone code. Up to now, this is only as a C++ or PYTHON class, but other languages could be implemented.; 5.12.5 Examples; An example of how to use TMultiLayerPerceptron is the macro mlpHiggs.C in $ROOTSYS/tutorials. Using some standard simulated information that could have been obtained at LEP, a neural network is build, which can make the difference between WW events and events containin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:237036,simpl,simple,237036,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"ing the user coordinate system. But sometimes, you will want to use NDC. For example, if you want to draw text always at the same place over a histogram, no matter what the histogram coordinates are. There are two ways to do this. You can set the NDC for one object or may convert NDC to user coordinates. Most graphical objects offer an option to be drawn in NDC. For instance, a line (TLine) may be drawn in NDC by using DrawLineNDC(). A latex formula or a text may use TText::SetNDC() to be drawn in NDC coordinates.; 9.3.3 Converting between Coordinate Systems; There are a few utility functions in TPad to convert from one system of coordinates to another. In the following table, a point is defined by (px,py) in pixel coordinates, (ux,uy) in user coordinates, (ndcx,ndcy) in normalized coordinates, (apx, apy) are in absolute pixel coordinates. Conversion; TPad’s Methods; Returns. NDC to Pixel; UtoPixel(ndcx); VtoPixel(ndcy); Int_t; Int_t. Pixel to User; PixeltoX(px); PixeltoY(py); PixeltoXY(px,py,&ux,&uy); Double_t; Double_t; Double_t ux,uy. User to Pixel; XtoPixel(ux); YtoPixel(uy); XYtoPixel(ux,uy,&px,&py); Int_t; Int_t; Int_t px,py. User to absolute pixel; XtoAbsPixel(ux); YtoAbsPixel(uy); XYtoAbsPixel(ux,uy,&apx,&apy); Int_t; Int_t; Int_t apx,apy. Absolute pixel to user; AbsPixeltoX(apx); AbsPixeltoY(apy); AbsPixeltoXY(apx,apy,&ux,&uy); Double_t; Double_t; Double_t ux,uy. Note: all the pixel conversion functions along the Y axis consider that py=0 is at the top of the pad except PixeltoY() which assume that the position py=0 is at the bottom of the pad. To make PixeltoY() converting the same way as the other conversion functions, it should be used the following way (p is a pointer to a TPad):; p->PixeltoY(py - p->GetWh());; 9.3.4 Dividing a Pad into Sub-pads; Dividing a pad into sub pads in order for instance to draw a few histograms, may be done in two ways. The first is to build pad objects and to draw them into a parent pad, which may be a canvas. The second is to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:310819,ux,ux,310819,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['ux'],['ux']
Usability,"ing using OpenGL](\ref HP29); 118 - [General information: plot types and supported options](\ref HP29a); 119 - [TH3 as color boxes](\ref HP290); 120 - [TH3 as boxes (spheres)](\ref HP29b); 121 - [TH3 as iso-surface(s)](\ref HP29c); 122 - [TF3 (implicit function)](\ref HP29d); 123 - [Parametric surfaces](\ref HP29e); 124 - [Interaction with the plots](\ref HP29f); 125 - [Selectable parts](\ref HP29g); 126 - [Rotation and zooming](\ref HP29h); 127 - [Panning](\ref HP29i); 128 - [Box cut](\ref HP29j); 129 - [Plot specific interactions (dynamic slicing etc.)](\ref HP29k); 130 - [Surface with option ""GLSURF""](\ref HP29l); 131 - [TF3](\ref HP29m); 132 - [Box](\ref HP29n); 133 - [Iso](\ref HP29o); 134 - [Parametric plot](\ref HP29p); 135- [Highlight mode for histogram](\ref HP30); 136 - [Highlight mode and user function](\ref HP30a); 137 ; 138 ; 139\anchor HP00; 140## Introduction; 141 ; 142 ; 143Histograms are drawn via the `THistPainter` class. Each histogram has a; 144pointer to its own painter (to be usable in a multithreaded program). When the; 145canvas has to be redrawn, the `Paint` function of each objects in the; 146pad is called. In case of histograms, `TH1::Paint` invokes directly; 147`THistPainter::Paint`.; 148 ; 149To draw a histogram `h` it is enough to do:; 150 ; 151 h->Draw();; 152 ; 153`h` can be of any kind: 1D, 2D or 3D. To choose how the histogram will; 154be drawn, the `Draw()` method can be invoked with an option. For instance; 155to draw a 2D histogram as a lego plot it is enough to do:; 156 ; 157 h->Draw(""lego"");; 158 ; 159`THistPainter` offers many options to paint 1D, 2D and 3D histograms.; 160 ; 161When the `Draw()` method of a histogram is called for the first time; 162(`TH1::Draw`), it creates a `THistPainter` object and saves a; 163pointer to this ""painter"" as a data member of the histogram. The; 164`THistPainter` class specializes in the drawing of histograms. It is; 165separated from the histogram so that one can have histograms without the; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:5413,usab,usable,5413,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['usab'],['usable']
Usability,"ing when produce pointer by buf.P() function ; Definition at line 333 of file TXMLPlayer.cxx. ◆ ElementSetter(). const char * TXMLPlayer::ElementSetter ; (; TClass * ; cl, . const char * ; membername, . char * ; endch . ). protected . Produce code to set value to given data member. ; endch should be output after value is specified. ; Definition at line 392 of file TXMLPlayer.cxx. ◆ GetBasicTypeName(). TString TXMLPlayer::GetBasicTypeName ; (; TStreamerElement * ; el). protected . return simple data types for given TStreamerElement object ; Definition at line 260 of file TXMLPlayer.cxx. ◆ GetBasicTypeReaderMethodName(). TString TXMLPlayer::GetBasicTypeReaderMethodName ; (; Int_t ; type, . const char * ; realname . ). protected . return functions name to read simple data type from xml file ; Definition at line 293 of file TXMLPlayer.cxx. ◆ GetMemberTypeName(). TString TXMLPlayer::GetMemberTypeName ; (; TDataMember * ; member). protected . returns name of simple data type for given data member ; Definition at line 222 of file TXMLPlayer.cxx. ◆ GetStreamerName(). TString TXMLPlayer::GetStreamerName ; (; TClass * ; cl). protected . returns streamer function name for given class ; Definition at line 150 of file TXMLPlayer.cxx. ◆ IsA(). TClass * TXMLPlayer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 52 of file TXMLPlayer.h. ◆ ProduceCode(). Bool_t TXMLPlayer::ProduceCode ; (; TList * ; cllist, . const char * ; filename . ). Produce streamers for provide class list TList should include list of classes, for which code should be generated. ; filename specify name of file (without extension), where streamers should be created. Function produces two files: header file and source file. For instance, if filename is ""streamers"", files ""streamers.h"" and ""streamers.cxx"" will be created. ; Definition at line 167 of file TXMLPlayer.cxx. ◆ ProduceSTLstreamer(). Bool_t TXMLPlayer::ProduceSTLstreame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLPlayer.html:14064,simpl,simple,14064,doc/master/classTXMLPlayer.html,https://root.cern,https://root.cern/doc/master/classTXMLPlayer.html,1,['simpl'],['simple']
Usability,ing! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; TTree*TTreeCache::fOwner! pointer to the owner Tree/chain; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCacheUnzip.html:11806,learn,learning,11806,root/html530/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html530/TTreeCacheUnzip.html,3,['learn'],['learning']
Usability,"ing...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; Friends |; List of all members ; RooMCStudy Class ReferenceRooFit » RooFit Core. ; Helper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets. ; These may be generated from either same PDF or from a different PDF with similar parameters.; Given a fit and a generator PDF (they might be identical), RooMCStudy can produce toyMC samples and/or fit these. It accumulates the post-fit parameters of each iteration in a dataset. These can be retrieved using fitParams() or fitParDataSet(). This dataset additionally contains the variables; NLL: The value of the negative log-likelihood for each run.; ngen: The number of events generated for each run. Additional plotting routines simplify the task of plotting the distribution of the minimized likelihood, the fitted parameter values, fitted error and pull distribution.; RooMCStudy provides the option to insert add-in modules that modify the generate-and-fit cycle and allow to perform extra steps in the cycle. Output of these modules can be stored alongside the fit results in the aggregate results dataset. These study modules should derive from the class RooAbsMCStudyModule.; Check the RooFit tutorials; rf801_mcstudy.C; rf802_mcstudy_addons.C; rf803_mcstudy_addons2.C; rf804_mcstudy_constr.C for usage examples. PyROOT; Some member functions of RooMCStudy that take a RooCmdArg as argument also support keyword arguments. So far, this applies to constructor RooMCStudy(), RooMCStudy::plotParamOn, RooMCStudy::plotParam, RooMCStudy::plotNLL, RooMCStudy::plotError and RooMCStudy::plotPull. For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; frame3 = mcstudy.plotPull(mean, ROOT.RooFit.Bins(40), ROOT.RooFit.FitGauss(True)); ; # With keywor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:1042,simpl,simplify,1042,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['simpl'],['simplify']
Usability,"ing::GetFunctionTemplate(ClassInfo_t *opaque_cl, const char* name); 5178{; 5179 R__LOCKGUARD(gInterpreterMutex);; 5180 DeclId_t f;; 5181 TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;; 5182 if (cl) {; 5183 f = cl->GetFunctionTemplate(name);; 5184 }; 5185 else {; 5186 TClingClassInfo gcl(GetInterpreterImpl());; 5187 f = gcl.GetFunctionTemplate(name);; 5188 }; 5189 return f;; 5190 ; 5191}; 5192 ; 5193////////////////////////////////////////////////////////////////////////////////; 5194/// The 'name' is known to the interpreter, this function returns; 5195/// the internal version of this name (usually just resolving typedefs); 5196/// This is used in particular to synchronize between the name used; 5197/// by rootcling and by the run-time environment (TClass); 5198/// Return 0 if the name is not known.; 5199 ; 5200void TCling::GetInterpreterTypeName(const char* name, std::string &output, Bool_t full); 5201{; 5202 output.clear();; 5203 ; 5204 R__LOCKGUARD(gInterpreterMutex);; 5205 ; 5206 TClingClassInfo cl(GetInterpreterImpl(), name);; 5207 if (!cl.IsValid()) {; 5208 return ;; 5209 }; 5210 if (full) {; 5211 cl.FullName(output,*fNormalizedCtxt);; 5212 return;; 5213 }; 5214 // Well well well, for backward compatibility we need to act a bit too; 5215 // much like CINT.; 5216 TClassEdit::TSplitType splitname( cl.Name(), TClassEdit::kDropStd );; 5217 splitname.ShortType(output, TClassEdit::kDropStd );; 5218 ; 5219 return;; 5220}; 5221 ; 5222////////////////////////////////////////////////////////////////////////////////; 5223/// Execute a global function with arguments params.; 5224///; 5225/// FIXME: The cint-based version of this code does not check if the; 5226/// SetFunc() call works, and does not do any real checking; 5227/// for errors from the Exec() call. It did fetch the most; 5228/// recent cint security error and return that in error, but; 5229/// this does not really translate well to cling/clang. We; 5230/// should enhance these interfaces so that we can rep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:202413,clear,clear,202413,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['clear'],['clear']
Usability,"ing; 1190/// function is a polynomial, a linear fitter is initialised.; 1191/// To create a linear function, use the following syntax: linear parts; 1192/// separated by `++` sign.; 1193/// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; 1194/// TF1 object as; 1195///; 1196/// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; 1197///; 1198/// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; 1199/// Going via the linear fitter for functions, linear in parameters, gives a; 1200/// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:43124,simpl,simple,43124,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['simpl'],['simple']
Usability,ings: SC_factor. ; Definition at line 201 of file MethodMLP.h. ◆ fGA_SC_rate. Int_t TMVA::MethodMLP::fGA_SC_rate. private . GA settings: SC_rate. ; Definition at line 200 of file MethodMLP.h. ◆ fGA_SC_steps. Int_t TMVA::MethodMLP::fGA_SC_steps. private . GA settings: SC_steps. ; Definition at line 199 of file MethodMLP.h. ◆ fgPRINT_BATCH. const Bool_t TMVA::MethodMLP::fgPRINT_BATCH = kFALSE. staticprivate . debug flags ; Definition at line 217 of file MethodMLP.h. ◆ fgPRINT_ESTIMATOR_INC. const Int_t TMVA::MethodMLP::fgPRINT_ESTIMATOR_INC = 10. staticprivate . debug flags ; Definition at line 215 of file MethodMLP.h. ◆ fgPRINT_SEQ. const Bool_t TMVA::MethodMLP::fgPRINT_SEQ = kFALSE. staticprivate . debug flags ; Definition at line 216 of file MethodMLP.h. ◆ fLastAlpha. Double_t TMVA::MethodMLP::fLastAlpha. private . line search variable ; Definition at line 183 of file MethodMLP.h. ◆ fLearnRate. Double_t TMVA::MethodMLP::fLearnRate. private . learning rate for synapse weight adjustments ; Definition at line 188 of file MethodMLP.h. ◆ fPrior. Double_t TMVA::MethodMLP::fPrior. private . zjh ; Definition at line 166 of file MethodMLP.h. ◆ fPriorDev. std::vector<Double_t> TMVA::MethodMLP::fPriorDev. private . zjh ; Definition at line 167 of file MethodMLP.h. ◆ fResetStep. Int_t TMVA::MethodMLP::fResetStep. private . reset time (how often we clear hessian matrix) ; Definition at line 185 of file MethodMLP.h. ◆ fSamplingEpoch. Float_t TMVA::MethodMLP::fSamplingEpoch. private . fraction of epochs where sampling is used ; Definition at line 177 of file MethodMLP.h. ◆ fSamplingFraction. Float_t TMVA::MethodMLP::fSamplingFraction. private . fraction of events which is sampled for training ; Definition at line 176 of file MethodMLP.h. ◆ fSamplingTesting. Bool_t TMVA::MethodMLP::fSamplingTesting. private . The testing sample is sampled. ; Definition at line 180 of file MethodMLP.h. ◆ fSamplingTraining. Bool_t TMVA::MethodMLP::fSamplingTraining. private . The training sample is s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:52218,learn,learning,52218,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,ings::m_batchSize. mini-batch size ; Definition at line 838 of file NeuralNet.h. ◆ m_convergenceCount. size_t TMVA::DNN::Settings::m_convergenceCount. Definition at line 857 of file NeuralNet.h. ◆ m_convergenceSteps. size_t TMVA::DNN::Settings::m_convergenceSteps. number of steps without improvement to consider the DNN to have converged ; Definition at line 837 of file NeuralNet.h. ◆ m_dropOut. std::vector<double> TMVA::DNN::Settings::m_dropOut. Definition at line 850 of file NeuralNet.h. ◆ m_dropRepetitions. double TMVA::DNN::Settings::m_dropRepetitions. Definition at line 849 of file NeuralNet.h. ◆ m_factorWeightDecay. double TMVA::DNN::Settings::m_factorWeightDecay. Definition at line 840 of file NeuralNet.h. ◆ m_maxConvergenceCount. size_t TMVA::DNN::Settings::m_maxConvergenceCount. Definition at line 858 of file NeuralNet.h. ◆ m_maxProgress. double TMVA::DNN::Settings::m_maxProgress. current limits for the progress bar ; Definition at line 834 of file NeuralNet.h. ◆ m_minError. double TMVA::DNN::Settings::m_minError. Definition at line 859 of file NeuralNet.h. ◆ m_minProgress. double TMVA::DNN::Settings::m_minProgress. current limits for the progress bar ; Definition at line 833 of file NeuralNet.h. ◆ m_regularization. EnumRegularization TMVA::DNN::Settings::m_regularization. Definition at line 847 of file NeuralNet.h. ◆ m_testRepetitions. size_t TMVA::DNN::Settings::m_testRepetitions. Definition at line 839 of file NeuralNet.h. ◆ m_timer. Timer TMVA::DNN::Settings::m_timer. timer for monitoring ; Definition at line 832 of file NeuralNet.h. ◆ m_useMultithreading. bool TMVA::DNN::Settings::m_useMultithreading. protected . Definition at line 863 of file NeuralNet.h. Libraries for TMVA::DNN::Settings:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/NeuralNet.h; tmva/tmva/src/NeuralNet.cxx. TMVADNNSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:45 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:15225,progress bar,progress bar,15225,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['progress bar'],['progress bar']
Usability,inimumErrorUpdator.h;  MinimumParameters.h;  MinimumSeed.h;  MinimumSeedGenerator.h;  MinimumState.h;  MinosError.h;  Minuit2Minimizer.h;  MinuitParameter.h;  MnApplication.h;  MnConfig.h;  MnContours.h;  MnCovarianceSqueeze.h;  MnCross.h;  MnEigen.h;  MnFcn.h;  MnFumiliMinimize.h;  MnFunctionCross.h;  MnGlobalCorrelationCoeff.h;  MnHesse.h;  MnLineSearch.h;  MnMachinePrecision.h;  MnMatrix.h;  MnMigrad.h;  MnMinimize.h;  MnMinos.h;  MnParabola.h;  MnParabolaFactory.h;  MnParabolaPoint.h;  MnParameterScan.h;  MnPlot.h;  MnPosDef.h;  MnPrint.h;  MnRefCountedPointer.h;  MnReferenceCounter.h;  MnScan.h;  MnSeedGenerator.h;  MnSimplex.h;  MnStrategy.h;  MnTiny.h;  MnTraceObject.h;  MnUserCovariance.h;  MnUserFcn.h;  MnUserParameters.h;  MnUserParameterState.h;  MnUserTransformation.h;  MnVectorTransform.h;  ModularFunctionMinimizer.h;  MPIProcess.h;  NegativeG2LineSearch.h;  Numerical2PGradientCalculator.h;  ParametricFunction.h;  ScanBuilder.h;  ScanMinimizer.h;  SimplexBuilder.h;  SimplexMinimizer.h;  SimplexParameters.h;  SimplexSeedGenerator.h;  SinParameterTransformation.h;  SqrtLowParameterTransformation.h;  SqrtUpParameterTransformation.h;  StackAllocator.h;  VariableMetricBuilder.h;  VariableMetricEDMEstimator.h;  VariableMetricMinimizer.h;  VectorOuterProduct.h;  LinkDef.h;  TMinuit2TraceObject.h;  ► src;  AnalyticalGradientCalculator.cxx;  BasicMinimumError.cxx;  CombinedMinimumBuilder.cxx;  DavidonErrorUpdator.cxx;  FitterUtil.h;  FumiliBuilder.cxx;  FumiliErrorUpdator.cxx;  FumiliGradientCalculator.cxx;  FumiliMinimizer.cxx;  FumiliStandardChi2FCN.cxx;  FumiliStandardMaximumLikelihoodFCN.cxx;  HessianGradientCalculator.cxx;  InitialGradientCalculator.cxx;  LaEigenValues.cxx;  LaInnerProduct.cxx;  LaInverse.cxx;  LaOuterProduct.cxx;  LaSumOfElements.cxx;  LaVtMVSimilarity.cxx;  MinimumBuilder.cxx;  Minuit2Minimizer.cxx;  MnApplication.cxx;  mnbins.cxx;  MnContours.cxx;  MnCovarianceSqueeze.cxx;  mndasum.cxx;  mndaxpy.cxx;  mnddot.cxx;  mndscal.cxx;  mndspmv.cx,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:52518,Simpl,SimplexMinimizer,52518,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Simpl'],['SimplexMinimizer']
Usability,"inition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2144; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:8373,learn,learning,8373,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"inition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:8374,learn,learning,8374,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"inition TAttLine.h:43; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCurlyArcImplements curly or wavy arcs used to draw Feynman diagrams.Definition TCurlyArc.h:16; TCurlyArc::TCurlyArcTCurlyArc()Default constructor.Definition TCurlyArc.cxx:45; TCurlyLineImplements curly or wavy polylines used to draw Feynman diagrams.Definition TCurlyLine.h:19; TCurlyLine::TCurlyLineTCurlyLine()Default constructor.Definition TCurlyLine.cxx:46; TCurlyLine::SetWavyvirtual void SetWavy()Set wavy.Definition TCurlyLine.cxx:369; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPolyLine::Drawvoid Draw(Option_t *option="""") overrideDraw this polyline with its current attributes.Definition TPolyLine.cxx:215; int; c1return c1Definition legend1.C:41; ginitstatic int ginitDefinition rsalib.cxx:256; lTLine lDefinition textangle.C:4; . Definition at line 16 of file TCurlyArc.h. Public Member Functions;  TCurlyArc ();  Default constructor. ;  ;  TCurlyArc (Double_t x1, Double_t y1, Double_t rad, Double_t phimin, Double_t phimax, Double_t wl=.02, Double_t amp=.01);  Create a new TCurlyArc with center (x1, y1) and radius rad. ;  ;  ~TCurlyArc () override;  ; void Build () override;  Create a curly (Gluon) or wavy (Gamma) arc. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to an arc. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Exe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCurlyArc.html:3330,simpl,simple,3330,doc/master/classTCurlyArc.html,https://root.cern,https://root.cern/doc/master/classTCurlyArc.html,1,['simpl'],['simple']
Usability,"inition TGWin32VirtualXProxy.cxx:104; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TMatrixDSym.h; TMatrixD.h; TPaveText.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::clearValueAndShapeDirtyvoid clearValueAndShapeDirty() constDefinition RooAbsArg.h:571; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsArg::dependsOnbool dependsOn(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) constTest whether we depend on (ie, are served by) any object in the specified collection.Definition RooAbsArg.cxx:850; RooAbsArg::constR__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg constDefinition RooAbsArg.h:145; RooAbsArg::setOperModevoid setOperMode(OperMode mode, bool recurseADirty=true)Set the operation mode of this node.Definition RooAbsArg.cxx:1963; RooAbsArg::getParametersRooFit::OwningPtr< RooArgSet > getParameters(const RooAbsData *data, bool stripDisconnected=true) constCreate a list of leaf nodes in the arg tree starti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:135347,clear,clearValueAndShapeDirtyvoid,135347,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,['clear'],"['clearValueAndShapeDirty', 'clearValueAndShapeDirtyvoid']"
Usability,"inition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:138827,simpl,simple,138827,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,4,['simpl'],['simple']
Usability,"inition at line 41 of file TEveScene.cxx. ◆ TEveScene() [3/3]. TEveScene::TEveScene ; (; TGLScenePad * ; gl_scene, . const char * ; n = ""TEveScene"", . const char * ; t = """" . ). Constructor. ; Definition at line 60 of file TEveScene.cxx. ◆ ~TEveScene(). TEveScene::~TEveScene ; (; ). override . Destructor. ; Definition at line 79 of file TEveScene.cxx. Member Function Documentation. ◆ Changed(). void TEveScene::Changed ; (; ). inline . Definition at line 51 of file TEveScene.h. ◆ Class(). static TClass * TEveScene::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEveScene::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveScene::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 71 of file TEveScene.h. ◆ CollectSceneParents(). void TEveScene::CollectSceneParents ; (; List_t & ; scenes). overridevirtual . Virtual from TEveElement; here we simply append this scene to the list. ; Reimplemented from TEveElement.; Definition at line 93 of file TEveScene.cxx. ◆ DeclFileName(). static const char * TEveScene::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 71 of file TEveScene.h. ◆ DestroyElementRenderers() [1/2]. void TEveScene::DestroyElementRenderers ; (; TEveElement * ; element). Remove element from the scene. ; It is not an error if the element is not found in the scene. ; Definition at line 199 of file TEveScene.cxx. ◆ DestroyElementRenderers() [2/2]. void TEveScene::DestroyElementRenderers ; (; TObject * ; rnrObj). Remove element represented by object rnrObj from the scene. ; It is not an error if the element is not found in the scene. ; Definition at line 212 of file TEveScene.cxx. ◆ GetGLScene(). TGLScenePad * TEveScene::GetGLScene ; (; ); const. inline . Definition at line 60 of file TEveScene.h. ◆ GetHierarchical(). Bool_t TEveScene::GetHierarchical ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveScene.html:35651,simpl,simply,35651,doc/master/classTEveScene.html,https://root.cern,https://root.cern/doc/master/classTEveScene.html,1,['simpl'],['simply']
Usability,"inition at line 449 of file RooAbsCategory.cxx. ◆ attachToVStore(). void RooAbsCategory::attachToVStore ; (; RooVectorDataStore & ; vstore). overrideprotectedvirtual . Attach the category index and label to as branches to the given vector store. ; Implements RooAbsArg.; Definition at line 436 of file RooAbsCategory.cxx. ◆ begin(). std::map< std::string, value_type >::const_iterator RooAbsCategory::begin ; (; ); const. inline . Iterator for category state names. Points to pairs of index and name. ; Definition at line 91 of file RooAbsCategory.h. ◆ Class(). static TClass * RooAbsCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCategory::Class_Version ; (; ). inlinestaticconstexpr . A buffer for reading values from trees. ; ReturnsVersion of this class ; Definition at line 226 of file RooAbsCategory.h. ◆ clearTypes(). void RooAbsCategory::clearTypes ; (; ). protected . Delete all currently defined states. ; Definition at line 277 of file RooAbsCategory.cxx. ◆ copyCache(). void RooAbsCategory::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value from given source and raise dirty flag. ; It is the callers responsibility to ensure that the sources cache is clean(valid) before this function is called, e.g. by calling syncCache() on the source. ; Implements RooAbsArg.; Reimplemented in RooAbsCategoryLValue.; Definition at line 560 of file RooAbsCategory.cxx. ◆ createFundamental(). RooFit::OwningPtr< RooAbsArg > RooAbsCategory::createFundamental ; (; const char * ; newname = nullptr); const. overridevirtual . Create a RooCategory fundamental object with our properties. ; Implements RooAbsArg.; Definition at line 642 of file RooAbsCategory.cxx. ◆ createTable(). Roo1DTable * RooAbsCategory::createTab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:47963,clear,clearTypes,47963,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['clear'],['clearTypes']
Usability,"inition for most cases without need for a RooFormulaVar object: e.g. a Gaussian resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5) Note that for a 'wide' Gaussian the -inf to +inf integration may converge more quickly than that over a finite range! The default numeric precision is 1e-7, i.e. the global default for numeric integration but you should experiment with this value to see if it is sufficient for example by studying the number of function calls that MINUIT needs to fit your function as function of the convolution precision. ; Definition at line 26 of file RooNumConvPdf.h. Public Member Functions;  RooNumConvPdf ();  ;  RooNumConvPdf (const char *name, const char *title, RooRealVar &convVar, RooAbsPdf &pdf, RooAbsPdf &resmodel);  ;  RooNumConvPdf (const RooNumConvPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooNumConvPdf () override;  Destructor. ;  ; void clearConvolutionWindow ();  ; TObject * clone (const char *newname) const override;  ; RooNumIntConfig & convIntConfig ();  ; double evaluate () const override;  Calculate and return value of p.d.f. ;  ; TClass * IsA () const override;  ; RooAbsReal & model () const;  ; RooAbsReal & pdf () const;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the product operator construction. ;  ; const TH2 * profileData () const;  ; void setCallProfiling (bool flag, Int_t nbinX=40, Int_t nbinCall=40, Int_t nCallHigh=1000);  ; void setCallWarning (Int_t threshold=2000);  ; void setConvolutionWindow (RooAbsReal &centerParam, RooAbsReal &widthParam, double widthScaleFactor=1);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; RooRealVar & var () const;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:2952,clear,clearConvolutionWindow,2952,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,1,['clear'],['clearConvolutionWindow']
Usability,"ink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidPrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTQCommand::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TQCommand*fCurrentthe latest executed command; TObjLink*fCursorcurrent position in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:17475,undo,undo,17475,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,6,['undo'],['undo']
Usability,"inkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:5343,clear,clearEvalErrorLog,5343,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,2,['clear'],['clearEvalErrorLog']
Usability,"inkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Jun 30 14:30:02 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCollection.html:22627,clear,clearStructureTags,22627,root/html602/RooAbsCollection.html,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html,2,['clear'],['clearStructureTags']
Usability,"inkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Mar 10 17:13:56 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCollection.html:21117,clear,clearStructureTags,21117,root/html534/RooAbsCollection.html,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html,2,['clear'],['clearStructureTags']
Usability,"inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 98 of file TQCommand.h. ◆ Delete(). void TQCommand::Delete ; (; Option_t * ; opt = """"). overridevirtual . If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ; If ""opt"" is zero - delete all merged commands. ; Reimplemented from TList.; Definition at line 285 of file TQCommand.cxx. ◆ GetCommand(). TQCommand * TQCommand::GetCommand ; (; ). static . Return a command which is doing redo/undo action. ; This static method allows to set undo parameters dynamically, i.e. during execution of Redo function.; Example: For redo actions like TGTextEdit::DelChar() it is not possible to know ahead what character will be deleted. To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)), one needs to call TQCommand::SetUndoArgs(1, character) from inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);; TQCommand::GetCommandstatic TQCommand * GetCommand()Return a command which is doing redo/undo action.Definition TQCommand.cxx:276. Definition at line 276 of file TQCommand.cxx. ◆ GetName(). const char * TQCommand::GetName ; (; ); const. overridevirtual . Returns the command name. ; Default name is ""ClassName::RedoName(args)"" If list of merged commands is not empty the name is ""ClassName::RedoName(args):cname1:cname2 ..."" ; Reimplemented from TCollection.; Definition at line 670 of file TQCommand.cxx. ◆ GetNRargs(). Int_t TQCommand::GetNRargs ; (; ); const. Returns a number of redo arguments. ; Definition at line 768 of file TQCommand.cxx. ◆ GetNUargs(). Int_t TQCommand::GetNUargs ; (; ); const. Returns a number of undo arguments. ; Definition at line 776 of file TQCommand.cxx. ◆ GetObject(). void * TQCommand::GetObject ; (; ); const. Returns an object for which undo redo actions are applied. ; Definition at line 784 of file TQCommand.cxx. ◆ GetRedo(). TQConnection * TQCommand::GetRedo ; (; ); const. inline . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:37152,undo,undo,37152,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"int const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; Note that RResult<void> can be used for a function without return value, like this; RResult<void> DoSomething(); {; if (failure); return R__FAIL(""user-facing error messge"");; return RResult<void>::Success();; }; RResult<T>::Unwrap() can be used as a short hand for ""give me the wrapped value or, in case of an error, throw"". For instance:; int value = FuncThatReturnsRResultOfInt().Unwrap(); // may throw; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; There is no implict operator that converts RResult<T> to T. This is intentional to make it clear in the calling code where an exception may be thrown. ; Definition at line 194 of file RError.hxx. Public Member Functions;  RResult (const RResult &other)=delete;  ;  RResult (const T &value);  ;  RResult (RError &&error);  ;  RResult (RResult &&other)=default;  ;  RResult (T &&value);  ;  ~RResult ()=default;  ; RResult & Forward (RError::RLocation &&sourceLocation);  Used by R__FORWARD_RESULT in order to keep track of the stack trace in case of errors. ;  ; const T & Inspect ();  If the operation was successful, returns a const reference to the inner type. ;  ;  operator bool ();  ; RResult & operator= (const RResult &other)=delete;  ; RResult & operator= (RResult &&other)=default;  ; T Unwrap ();  If the operation was successful, returns the inner type by value. ;  ;  Public Member Functions inherited from ROOT::Experimental::RResultBase;  RResultBase (const RResultBase &other)=delete;  ;  RResultBase (RResultBase &&other)=default;  ;  ~RResultBase () noexcept(false);  ; RError * GetError ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RResult.html:2770,clear,clear,2770,doc/master/classROOT_1_1Experimental_1_1RResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RResult.html,1,['clear'],['clear']
Usability,"int nElements, TBuffer& b); voidWriteMap(UInt_t nElements, TBuffer& b). private:. TEmulatedMapProxy&operator=(const TEmulatedMapProxy& rhs). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tTGenCollectionProxy::fCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tTGenCollectionProxy::fConstructContainer accessors: block construct; map<string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tTGenCollectionProxy::fDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*TGenCollectionProxy::fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tTGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::fFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::fFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::fFunctionDeleteI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedMapProxy.html:5390,clear,clear,5390,root/html602/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedMapProxy.html,4,['clear'],['clear']
Usability,"inted using ELogLevel.kDebug and even more (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using ELogLevel.kDebug+10. Creating an RDataFrame from a dataset specification file; RDataFrame can be created using a dataset specification JSON file:; import ROOT; ; df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ROOT::RDF::Experimental::FromSpecROOT::RDataFrame FromSpec(const std::string &jsonFile)Factory method to create an RDataFrame from a JSON specification file.Definition RDataFrame.cxx:1729; The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each sample in the ""metadata"" key.; A simple example for the formatting of the specification in the JSON file is the following:; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; The metadata information from the specification file can be then accessed using the DefinePerSample function. For example, to access luminosity information (stored as a double):; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); or sample_category information (stored as a string):; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); or directly the filename:; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also provides a corresponding exemplary JSON file for the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:77070,simpl,simple,77070,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"inted using ELogLevel.kDebug and even more (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using ELogLevel.kDebug+10. Creating an RDataFrame from a dataset specification file; RDataFrame can be created using a dataset specification JSON file:; import ROOT; ; df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ROOT::RDF::Experimental::FromSpecROOT::RDataFrame FromSpec(const std::string &jsonFile)Factory method to create an RDataFrame from a JSON specification file.Definition RDataFrame.cxx:1906; The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each sample in the ""metadata"" key.; A simple example for the formatting of the specification in the JSON file is the following:; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; The metadata information from the specification file can be then accessed using the DefinePerSample function. For example, to access luminosity information (stored as a double):; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); or sample_category information (stored as a string):; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); or directly the filename:; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also provides a corresponding exemplary JSON file for the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:78492,simpl,simple,78492,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"inter to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. » Last change",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:4364,clear,clearOnRedirect,4364,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,2,['clear'],['clearOnRedirect']
Usability,"inter to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooObjCacheManager.html:4447,clear,clearOnRedirect,4447,root/html530/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html530/RooObjCacheManager.html,1,['clear'],['clearOnRedirect']
Usability,"interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is strongly encouraged and appreciated.; Removal of some memory-unsafe interfaces. The final bool takeOwnership parameter of the RooAddition and RooStats::HistFactory::PiecewiseInterpolation constructors was removed. This is to avoid situations where ownership is not clear to the compiler. Now, ownership of the input RooAbsArgs is never passed in the constructor. If you want the pass input ownership to the created object, please use addOwnedComponents. If you want to be extra safe, make sure the inputs are in an owning collection and then std::move the collection, so that the ownership is always clear.; Example:; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; should become:; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));. Deprecation of legacy iterators; The following methods related to the RooFit legacy iterators are deprecated and will be removed in ROOT 6.34. They should be replaced with the suitable STL-compatible interfaces, or you can just use range-based loops:. RooAbsArg::clientIterator(): use clients() and begin(), end() or range-based loops instead; RooAbsArg::valueClientIterator(): use valueClients(); RooAbsArg::shapeClientIterator(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:11783,clear,clear,11783,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['clear'],['clear']
Usability,"interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 686 of file ParamHistFunc.cxx. ◆ setConstant(). void ParamHistFunc::setConstant ; (; bool ; constant). Definition at line 233 of file ParamHistFunc.cxx. ◆ setParamConst(). void ParamHistFunc::setParamConst ; (; Int_t ; index, . bool ; varConst = true . ). Definition at line 227 of file ParamHistFunc.cxx. ◆ setShape(). void ParamHistFunc::setShape ; (; TH1 * ; shape). Definition at line 242 of file ParamHistFunc.cxx. ◆ Streamer(). void ParamHistFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void ParamHistFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 111 of file ParamHistFunc.h. ◆ translate(). void ParamHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 563 of file ParamHistFunc.cxx. Member Data Documentation. ◆ _dataSet. RooDataHist ParamHistFunc::_dataSet. mutableprotected . Definition at line 98 of file ParamHistFunc.h. ◆ _dataVars. RooListProxy ParamHistFunc::_dataVars. protected . The RooRealVars. ; Definition at line 82 of file ParamHistFunc.h. ◆ _normIntMgr. RooObjCacheManager ParamHistFunc::_normIntMgr. mutableprotected . ! The integration cache manager ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:73449,simpl,simple,73449,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['simpl'],['simple']
Usability,"inuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMinuitMinimizer.html:6335,Simpl,Simplex,6335,root/html532/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html,2,['Simpl'],['Simplex']
Usability,"inuit*fMinuit; vector<double>fParamsvector of output values; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMinuitMinimizer.html:6723,Simpl,Simplex,6723,root/html534/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html534/TMinuitMinimizer.html,2,['Simpl'],['Simplex']
Usability,"ion RCanvas.cxx:211; ROOT::Experimental::RCanvas::SetHeightvoid SetHeight(int height)Set canvas height.Definition RCanvas.hxx:108; ROOT::Experimental::RCanvas::IsShownbool IsShown() constreturns true if Show() method was calledDefinition RCanvas.hxx:120; ROOT::Experimental::RCanvas::fPainterstd::unique_ptr< Internal::RVirtualCanvasPainter > fPainterThe painter of this canvas, bootstrapping the graphics connection.Definition RCanvas.hxx:67; ROOT::Experimental::RCanvas::fWidthint fWidthWidth of the canvas in pixels.Definition RCanvas.hxx:56; ROOT::Experimental::RCanvas::fUpdatedbool fUpdatedindicate if Update() method was called beforeDefinition RCanvas.hxx:73; ROOT::Experimental::RCanvas::Createstatic std::shared_ptr< RCanvas > Create(const std::string &title)Create new canvas instance.Definition RCanvas.cxx:89; ROOT::Experimental::RCanvas::ClearShownvoid ClearShown()clear IsShown() flagDefinition RCanvas.hxx:123; ROOT::Experimental::RCanvas::ClearOnClosevoid ClearOnClose(const std::shared_ptr< void > &handle)Set handle which will be cleared when connection is closed.Definition RCanvas.cxx:239; ROOT::Experimental::RCanvas::SetWidthvoid SetWidth(int width)Set canvas width.Definition RCanvas.hxx:105; ROOT::Experimental::RCanvas::GetCanvasconst RCanvas * GetCanvas() const overrideAccess to the top-most canvas, if any (const version).Definition RCanvas.hxx:92; ROOT::Experimental::RCanvas::RCanvasRCanvas()Create a temporary RCanvas; for long-lived ones please use Create().Definition RCanvas.hxx:88; ROOT::Experimental::RCanvas::Modifiedvoid Modified(std::shared_ptr< RDrawable > drawable)Set newest version to specified drawable.Definition RCanvas.hxx:152; ROOT::Experimental::RCanvas::Modifiedvoid Modified()Definition RCanvas.hxx:149; ROOT::Experimental::RCanvas::GetWidthint GetWidth() constGet canvas width.Definition RCanvas.hxx:111; ROOT::Experimental::RCanvas::AddPanelbool AddPanel(std::shared_ptr< PANEL > &panel)Insert panel into the canvas, canvas should be shown at this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8hxx_source.html:12474,clear,cleared,12474,doc/master/RCanvas_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8hxx_source.html,1,['clear'],['cleared']
Usability,"ion TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TStyle::SetPaperSizevoid SetPaperSize(EPaperSize size)Set paper size for PostScript output.Definition TStyle.cxx:1704; Then, the generated file (hpx.tex) can be included in a LaTeX document (simple.tex) in the following way: \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; TTeXDumpInterface to TeX.Definition TTeXDump.h:20; Rcpp::asTString as(SEXP s)Definition RExports.h:86; TMVA_SOFIE_GNN.endendDefinition TMVA_SOFIE_GNN.py:207; Note the three directives needed at the top of the LaTeX file: \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; Then including the picture in the document is done with the \input directive.; The command pdflatex simple.tex will generate the corresponding pdf file simple.pdf. ; Definition at line 20 of file TTeXDump.h. Public Member Functions;  TTeXDump ();  Default TeX constructor. ;  ;  TTeXDump (const char *filename, Int_t type=-113);  Initialize the TeX interface. ;  ;  ~TTeXDump () override;  Default TeX destructor. ;  ; void CellArrayBegin (Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2) override;  Begin the Cell Array painting. ;  ; void CellArrayEnd () override;  End the Cell Array painting. ;  ; void CellArrayFill (Int_t r, Int_t g, Int_t b) override;  Paint the Cell Array. ;  ; void Close (Option_t *opt="""") override;  Close a TeX file. ;  ; Int_t CMtoTeX (Double_t u);  ; void DefineMarkers ();  add additional pgfplotmarks ;  ; void DrawBox (Double_t x1, Double_t y1, Double_t x2, Double_t y2) override;  Draw a Box. ;  ; void DrawFrame (Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light) override;  Draw a Frame around a box. ;  ; void DrawPolyLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTeXDump.html:1861,simpl,simple,1861,doc/master/classTTeXDump.html,https://root.cern,https://root.cern/doc/master/classTTeXDump.html,1,['simpl'],['simple']
Usability,"ion about the; function. void CreateGeneralTab(); Create 'General' tab. void CreateMinimizationTab(); Create 'Minimization' tab. void ConnectSlots(); Connect GUI signals to fit panel slots. void DisconnectSlots(); Disconnect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to additi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitEditor.html:32744,clear,clear,32744,root/html528/TFitEditor.html,https://root.cern,https://root.cern/root/html528/TFitEditor.html,10,['clear'],['clear']
Usability,"ion depends on the entry number. For details about entry numbers in multi-threaded runs, see here. . Filter() Filter rows based on user-defined conditions. . FilterAvailable() Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. . FilterMissing() Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. . Range() Filter rows based on entry number (single-thread only). . Redefine() Overwrite the value and/or type of an existing column. See Define() for more information. . RedefineSlot() Overwrite the value and/or type of an existing column. See DefineSlot() for more information. . RedefineSlotEntry() Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. . Vary() Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). . Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide.; In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to produce many different results in one event loop. Instant actions trigger the event loop instantly. Lazy action Description . Aggregate() Execute a user-defined accumulation operation on the processed column values. . Book() Book execution of a custom action using a user-defined helper object. . Cache() Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). . Count() Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. . Display() Provides a printable representation of the dataset contents. The method retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:4960,guid,guide,4960,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['guid'],['guide']
Usability,"ion documentation; TEveWindow(const char* n = ""TEveWindow"", const char* t = """"); Constructor. ~TEveWindow(); Destructor. void PreDeleteElement(); Called before the element is deleted, thus offering the last chance; to detach from acquired resources and from the framework itself.; Here the request is just passed to TEveManager.; If you override it, make sure to call base-class version. void PreUndock(); Virtual function called before a window is undocked. void PostDock(); Virtual function called after a window is docked. void NameTitleChanged(); Name or title of the window changed - propagate to frames.; Virtual from TEveElement. void PopulateEmptyFrame(TEveCompositeFrame* ef); Populate given frame-slot - intended for initial population; of a new slot or low-level window-swapping.; No layout or window-mapping is done. void SwapWindow(TEveWindow* w); Swap frames with the given window. void SwapWindowWithCurrent(); Swap frames with the current window. void UndockWindow(); Undock the window - put it into a dedicated main-frame. void UndockWindowDestroySlot(); Undock the window - put it into a dedicated main-frame.; The old window slot is destroyed. void ReplaceWindow(TEveWindow* w); Replace this window with the passed one.; Eve parentship is properly handled.; This will most likely lead to the destruction of this window.; Layout is called on the frame. void DestroyWindow(); Destroy eve-window - replace it with an empty frame-slot. void DestroyWindowAndSlot(); Destroy eve-window and its frame-slot. void ClearEveFrame(); Clears eve-frame associated with this window.; This is used in special case when the window is embedded in a foreign; GUI container and gets deleted from this side.; In particular, this happens when TRootBrowser closes a tab. void SetShowTitleBar(Bool_t x); Set display state of the title-bar.; This is forwarded to eve-frame. Bool_t IsCurrent() const; Returns true if this window is the current one. void MakeCurrent(); Make this window current. void SetCurre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveWindow.html:23178,Undo,UndockWindow,23178,root/html602/TEveWindow.html,https://root.cern,https://root.cern/root/html602/TEveWindow.html,4,['Undo'],"['Undock', 'UndockWindow']"
Usability,"ion nodes. void Streamer(TBuffer& b); Stream an object of class TGeoVolume. void SetOption(const char* option); Set the current options (none implemented). void SetLineColor(Color_t lcolor); Set the line color. void SetLineStyle(Style_t lstyle); Set the line style. void SetLineWidth(Width_t lwidth); Set the line width. TGeoNode * GetNode(const char* name) const; get the pointer to a daughter node. Int_t GetByteCount() const; get the total size in bytes for this volume. void FindOverlaps() const; loop all nodes marked as overlaps and find overlaping brothers. void RemoveNode(TGeoNode* node); Remove an existing daughter. TGeoNode * ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); Replace an existing daughter with a new volume having the same name but; possibly a new shape, position or medium. Not allowed for positioned assemblies.; For division cells, the new shape/matrix are ignored. void SelectVolume(Bool_t clear = kFALSE); Select this volume as matching an arbitrary criteria. The volume is added to; a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; to be reset at the end by calling the method with CLEAR=true. This will also clear; the list. void SetVisibility(Bool_t vis = kTRUE); set visibility of this volume. void SetVisContainers(Bool_t flag = kTRUE); Set visibility for containers. void SetVisLeaves(Bool_t flag = kTRUE); Set visibility for leaves. void SetVisOnly(Bool_t flag = kTRUE); Set visibility for leaves. Bool_t Valid() const; Check if the shape of this volume is valid. Bool_t FindMatrixOfDaughterVolume(TGeoVolume* vol) const; Find a daughter node having VOL as volume and fill TGeoManager::fHMatrix; with its global matrix. void VisibleDaughters(Bool_t vis = kTRUE); set visibility for daughters. void Voxelize(Option_t* option); build the voxels for this volume. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate the weight of a volume (in kg) with ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:30655,clear,clear,30655,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,4,['clear'],['clear']
Usability,"ion transforms the source spectrum.Definition TSpectrumTransform.cxx:1269. Definition at line 1269 of file TSpectrumTransform.cxx. ◆ Fourier(). void TSpectrumTransform::Fourier ; (; Double_t * ; working_space, . Int_t ; num, . Int_t ; hartley, . Int_t ; direction, . Int_t ; zt_clear . ). protected . This function calculates Fourier based transform of a part of data Function parameters: . working_space-pointer to vector of transformed data; num-length of processed data; hartley-1 if it is Hartley transform, 0 otherwise; direction-forward or inverse transform . Definition at line 265 of file TSpectrumTransform.cxx. ◆ GeneralExe(). int TSpectrumTransform::GeneralExe ; (; Double_t * ; working_space, . Int_t ; zt_clear, . Int_t ; num, . Int_t ; degree, . Int_t ; type . ). protected . This function calculates generalized (mixed) transforms of different degrees Function parameters: . working_space-pointer to vector of transformed data; zt_clear-flag to clear imaginary data before staring; num-length of processed data; degree-degree of transform (see manual); type-type of mixed transform (see manual) . Definition at line 431 of file TSpectrumTransform.cxx. ◆ GeneralInv(). int TSpectrumTransform::GeneralInv ; (; Double_t * ; working_space, . Int_t ; num, . Int_t ; degree, . Int_t ; type . ). protected . This function calculates inverse generalized (mixed) transforms Function parameters: . working_space-pointer to vector of transformed data; num-length of processed data; degree-degree of transform (see manual); type-type of mixed transform (see manual) . Definition at line 547 of file TSpectrumTransform.cxx. ◆ Haar(). void TSpectrumTransform::Haar ; (; Double_t * ; working_space, . Int_t ; num, . Int_t ; direction . ). protected . This function calculates Haar transform of a part of data Function parameters: . working_space-pointer to vector of transformed data; num-length of processed data; direction-forward or inverse transform . Definition at line 96 of file TSpectrumTrans",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumTransform.html:26037,clear,clear,26037,doc/master/classTSpectrumTransform.html,https://root.cern,https://root.cern/doc/master/classTSpectrumTransform.html,1,['clear'],['clear']
Usability,"ion with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TSelector. ◆ Process(). Bool_t TSelEvent::Process ; (; Long64_t ; entry). virtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TTree::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms. ; Reimplemented from TSelector.; Definition at line 201 of file TSelEvent.cxx. ◆ SetInputList(). virtual void TSelEvent::SetInputList ; (; TList * ; input). inlinevirtual . Reimplemented from TSelector.; Definition at line 113 of file TSelEvent.h. ◆ SetObject(). virtual void TSelEvent::SetObject ; (; TObject * ; obj). inlinevirtual . Reimplemented from TSelector.; Definition at line 112 of file TSelEvent.h. ◆ SetOption(). virtual void TSelEvent::SetOption ; (; const char * ; option). inlinevirtual . Reimplemented from TSelector.; Definition at line 111 of file TSelEvent.h. ◆ SlaveBegin(). void TSelEvent::SlaveBegin ; (; TTree * ; tree). virtual . The SlaveBegin() function is called after the Begin() function. ; When running with PROOF SlaveBegin() is called on each slave server. The tree argument is deprecated (on PROOF 0 is passed). ; Reimplemented from TSelector.; Definition at line 129 of file TSelEvent.cxx. ◆ SlaveTerm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEvent.html:18043,simpl,simple,18043,doc/master/classTSelEvent.html,https://root.cern,https://root.cern/doc/master/classTSelEvent.html,1,['simpl'],['simple']
Usability,"ion “N”- do not store the function and do not draw it.; 5.6.4 Advances Options; The advance option button is enabled only after having performed the fit and provides additional drawing options that can be used after having done the fit. These new drawing tools, which can be selected by the “Advanced Drawing Tool” panel that pops up when clicking the “Advanced” button, are:. Contour: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour (more points might require more time to compute it), the parameters and the desired confidence level .; Scan : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter.; Conf Interval : to plot the confidence interval of the fitted function as a filled coloured band around its central value. One can select the desired confidence level for the band to be plotted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information is printed.; ‘Default’ - between Verbose and Quiet.; 5.6.6 Command Buttons; Fit button - performs a fit taking different option settings via the Fit Panel interface.; Reset - sets the GUI elements and related fit settings to the default ones.; Close - closes the Fit panel window.; 5.6.7 Minimization Options; With this tab one can select specific options for minimization. These include. The minimizer library ( Minuit, Minuit2, Fumili, GSL, Genetics ); The method (algorithm) for minimization. For example for Minuit one can choose between (Migrad, Simplex or Scan); Error definition; Minimization tolerance; Number of iterations/function calls; Print Level: (Default, Verbose or Quiet). 5.7 New ROOT::Fit classes; The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes, which are defined in the ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:187380,feedback,feedback,187380,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['feedback'],['feedback']
Usability,"ion'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooFormulaVar * identity ();  Return identity formula pointer. ;  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooResolutionModel.html:59175,clear,clearEvalErrorLog,59175,doc/master/classRooResolutionModel.html,https://root.cern,https://root.cern/doc/master/classRooResolutionModel.html,1,['clear'],['clearEvalErrorLog']
Usability,"ion. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fMomentum;  The momentum used for training. ;  ; std::vector< std::vector< Matrix_t > > fPastBiasGradients;  The sum of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastWeightGradients;  The sum of the past weight gradients associated with the deep net. ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/SGD.h>. Inheritance diagram for TMVA::DNN::TSGD< Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TSGD< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 48 of file SGD.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TSGD< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 49 of file SGD.h. Constructor & Destructor Documentation. ◆ TSGD(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TSGD.html:3172,learn,learning,3172,doc/master/classTMVA_1_1DNN_1_1TSGD.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TSGD.html,1,['learn'],['learning']
Usability,"ion. ◆ TKDTree() [1/4]. template<typename Index , typename Value > . TKDTree< Index, Value >::TKDTree. Default constructor. Nothing is built. ; Definition at line 270 of file TKDTree.cxx. ◆ TKDTree() [2/4]. template<typename Index , typename Value > . TKDTree< Index, Value >::TKDTree ; (; Index ; npoints, . Index ; ndim, . UInt_t ; bsize . ). Definition at line 292 of file TKDTree.cxx. ◆ TKDTree() [3/4]. template<typename Index , typename Value > . TKDTree< Index, Value >::TKDTree ; (; Index ; npoints, . Index ; ndim, . UInt_t ; bsize, . Value ** ; data . ). Create a kd-tree from the provided data array. ; This function only sets the data, call Build() to build the tree!!! Parameters:; npoints - total number of points. Adding points after the tree is built is not supported; ndim - number of dimensions; bsize - maximal number of points in the terminal nodes; data - the data array. The data should be placed columnwise (like in a TTree). The columnwise orientation is chosen to simplify the usage together with TTree::GetV1() like functions. An example of filling such an array for a 2d case: Double_t **data = new Double_t*[2]; data[0] = new Double_t[npoints]; data[1] = new Double_t[npoints]; for (Int_t i=0; i<npoints; i++){ data[0][i]=gRandom->Uniform(-1, 1); //fill the x-coordinate data[1][i]=gRandom->Uniform(-1, 1); //fill the y-coordinate }; By default, the kd-tree doesn't own the data. If you want the kd-tree to delete the data array, call kdtree->SetOwner(kTRUE). ; Definition at line 344 of file TKDTree.cxx. ◆ ~TKDTree(). template<typename Index , typename Value > . TKDTree< Index, Value >::~TKDTree. override . Destructor By default, the original data is not owned by kd-tree and is not deleted with it. ; If you want to delete the data along with the kd-tree, call SetOwner(kTRUE). ; Definition at line 373 of file TKDTree.cxx. ◆ TKDTree() [4/4]. template<typename Index , typename Value > . TKDTree< Index, Value >::TKDTree ; (; const TKDTree< Index, Value > & ; ). priv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTree.html:29402,simpl,simplify,29402,doc/master/classTKDTree.html,https://root.cern,https://root.cern/doc/master/classTKDTree.html,1,['simpl'],['simplify']
Usability,"ionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:153734,simpl,simple,153734,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,3,['simpl'],['simple']
Usability,ionRL_wide.C Example to illustrate deconvolution function (class TSpectrum) ;  DeconvolutionRL_wide_boost.C Example to illustrate deconvolution function (class TSpectrum) ;  peaks.C Getting Contours From TH2D ;  peaks2.C Example to illustrate the 2-d peak finder (class TSpectrum2) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TM,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:152552,simpl,simple,152552,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"ionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tTBufferFile::ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableSchemaEvolution(Bool_t enable = kTRUE); static voidEnableSchemaEvolutionForAll(Bool_t enable = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMessage.html:1860,Clear,Clear,1860,root/html532/TMessage.html,https://root.cern,https://root.cern/root/html532/TMessage.html,4,['Clear'],['Clear']
Usability,"ionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tTBufferFile::ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBufferSQL.html:2046,Clear,Clear,2046,root/html532/TBufferSQL.html,https://root.cern,https://root.cern/root/html532/TBufferSQL.html,4,['Clear'],['Clear']
Usability,"ion_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TDSetElement * GetNextPacket (TSlave *slave, TMessage *r) override;  Get next packet (may not be used in this class). ;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TVirtualPacketizer * GetPacketizer () const override;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleGetTreeHeader (TMessage *mess) override;  Handle tree header request. ;  ; void HandleRecvHisto (TMessage *mess) override;  Receive histo from slave. ;  ; Bool_t JoinProcess (TList *workers) override;  Not implemented: meaningful only in the remote player. Returns kFALSE. ;  ; void Progres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:3464,learn,learning,3464,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,1,['learn'],['learning']
Usability,"ion_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TDSetElement * GetNextPacket (TSlave *slave, TMessage *r) override;  Get next packet (may not be used in this class). ;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TVirtualPacketizer * GetPacketizer () const override;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleGetTreeHeader (TMessage *mess) override;  Handle tree header request. ;  ; void HandleRecvHisto (TMessage *mess) override;  Receive histo from slave. ;  ; TClass * IsA () const override;  ; Bool_t IsClient () const override;  ; Bool_t JoinProcess (TList *workers) override;  Not implemented",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:4082,learn,learning,4082,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['learn'],['learning']
Usability,"ion_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TDSetElement * GetNextPacket (TSlave *slave, TMessage *r) override;  Get next packet (may not be used in this class). ;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TVirtualPacketizer * GetPacketizer () const override;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleRecvHisto (TMessage *mess) override;  Receive histo from slave. ;  ; Bool_t IsClient () const override;  ; Bool_t JoinProcess (TList *workers) override;  Not implemented: meaningful only in the remote player. Returns kFALSE. ;  ; Long64_t Process (TDSet *set, const char *selector, Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSlave.html:2754,learn,learning,2754,doc/master/classTProofPlayerSlave.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSlave.html,1,['learn'],['learning']
Usability,"ion_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TPaveText.h; TVirtualPaveStats.h; TBoxCreate a Box.Definition TBox.h:22; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObjectMother of all ROOT objects.Definition TObject.h:41; TPaveStatsThe histogram statistics painter class.Definition TPaveStats.h:18; TPaveStats::TPaveStatsTPaveStats()TPaveStats default constructor.Definition TPaveStats.cxx:231; TPaveStats::GetOptStatInt_t GetOptStat() constReturn the stat option.Definition TPaveStats.cxx:271; TPaveStats::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TPaveStats.cxx:504; TPaveStats::EditTextvoid EditText() overrideEdit text at the mouse position.Definition TPaveStats.h:34; TPaveStats::UseCurrentStylevoid UseCurrentStyle() overrideReplace current attributes by current style.Definition TPaveStats.cxx:570; TPaveStats::InsertTextvoid InsertText(const char *) overrideAdd a new Text line at the mouse position.Definition TPaveStats.h:41; TPaveStats::InsertLinevoid InsertLine() overrideAdd a new line at t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPaveStats_8h_source.html:4239,simpl,simple,4239,doc/master/TPaveStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TPaveStats_8h_source.html,1,['simpl'],['simple']
Usability,"ional case you can use the same options as for the ; TGraphAsymmErrors::Draw; method. For 2-dimensional TEfficiency objects you can pass the same options as; for a TH2::Draw object.; VII. TEfficiency class. Function Members (Methods); public:. virtual~TEfficiency(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TEfficiency& rEff); static Double_tAgrestiCoull(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBayesian(Int_t total, Int_t passed, Double_t level, Double_t alpha, Double_t beta, Bool_t bUpper, Bool_t bShortest = false); static Double_tBetaCentralInterval(Double_t level, Double_t alpha, Double_t beta, Bool_t bUpper); static Double_tBetaMean(Double_t alpha, Double_t beta); static Double_tBetaMode(Double_t alpha, Double_t beta); static Bool_tBetaShortestInterval(Double_t level, Double_t alpha, Double_t beta, Double_t& lower, Double_t& upper); virtual voidBrowse(TBrowser*); static Bool_tCheckBinning(const TH1& pass, const TH1& total); static Bool_tCheckConsistency(const TH1& pass, const TH1& total, Option_t* opt = """"); static Bool_tCheckEntries(const TH1& pass, const TH1& total, Option_t* opt = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; static Double_tClopperPearson(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); static TGraphAsymmErrors*Combine(TCollection* pList, Option_t* opt = """", Int_t n = 0, const Double_t* w = 0); static Double_tCombine(Double_t& up, Double_t& low, Int_t n, const Int_t* pass, const Int_t* total, Double_t alpha, Double_t beta, Double_t level = 0.68300000000000005, const Double_t* w = 0, Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; TGraphAsymmErrors*CreateGraph(Option_t* opt = """") const; TH2*CreateHistogram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEfficiency.html:21664,Clear,Clear,21664,root/html604/TEfficiency.html,https://root.cern,https://root.cern/root/html604/TEfficiency.html,1,['Clear'],['Clear']
Usability,"ions . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » About Contact Us. You can contact the ROOT developers in the following ways, in order of preference:. Via the RootTalk web forum. Use this forum to post your questions. ROOT team members are actively reading this forum and answering the questions. And if the developers don't happen to be online your question might be answered by a fellow user. Remember, before posting a question, do a search to see if the issue has already been discussed.; Via the roottalk mailing list. Check the digest to see if your question has already been discussed.; Direct mail to the ROOT Developers. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/contact-us.html:2664,guid,guidelines,2664,d/contact-us.html,https://root.cern,https://root.cern/d/contact-us.html,1,['guid'],['guidelines']
Usability,"ions not valid for graphs; 993 HFit::CheckGraphFitOptions(foption);; 994 // TMultiGraph fitting; 995 return HFit::Fit(gr,f1,foption,moption,goption,range);; 996}; 997 ; 998TFitResultPtr ROOT::Fit::FitObject(TGraph2D * gr, TF1 *f1 , Foption_t & foption , const ROOT::Math::MinimizerOptions & moption, const char *goption, ROOT::Fit::DataRange & range) {; 999 // exclude options not valid for graphs; 1000 HFit::CheckGraphFitOptions(foption);; 1001 // TGraph2D fitting; 1002 return HFit::Fit(gr,f1,foption,moption,goption,range);; 1003}; 1004 ; 1005TFitResultPtr ROOT::Fit::FitObject(THnBase * s1, TF1 *f1 , Foption_t & foption , const ROOT::Math::MinimizerOptions & moption, const char *goption, ROOT::Fit::DataRange & range) {; 1006 // sparse histogram fitting; 1007 return HFit::Fit(s1,f1,foption,moption,goption,range);; 1008}; 1009 ; 1010 ; 1011 ; 1012// Int_t TGraph2D::DoFit(TF2 *f2 ,Option_t *option ,Option_t *goption) {; 1013// // internal graph2D fitting methods; 1014// Foption_t fitOption;; 1015// ROOT::Fit::FitOptionsMake(option,fitOption);; 1016 ; 1017// // create range and minimizer options with default values; 1018// ROOT::Fit::DataRange range(2);; 1019// ROOT::Math::MinimizerOptions minOption;; 1020// return ROOT::Fit::FitObject(this, f2 , fitOption , minOption, goption, range);; 1021// }; 1022 ; 1023 ; 1024// function to compute the simple chi2 for graphs and histograms; 1025 ; 1026 ; 1027double ROOT::Fit::Chisquare(const TH1 & h1, TF1 & f1, bool useRange, ROOT::Fit::EChisquareType type) {; 1028 return HFit::ComputeChi2(h1,f1,useRange, type);; 1029}; 1030 ; 1031double ROOT::Fit::Chisquare(const TGraph & g, TF1 & f1, bool useRange) {; 1032 return HFit::ComputeChi2(g,f1, useRange, ROOT::Fit::EChisquareType::kNeyman);; 1033}; 1034 ; 1035template<class FitObject>; 1036double HFit::ComputeChi2(const FitObject & obj, TF1 & f1, bool useRange, ROOT::Fit::EChisquareType type ) {; 1037 ; 1038 // implement using the fitting classes; 1039 ROOT::Fit::DataOptions opt;; 1040 opt.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:38802,simpl,simple,38802,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['simpl'],['simple']
Usability,"ions; 14914 *; 14915 * If we just look for 's' anywhere in the string, ""localhost:80""; 14916 * will be detected as SSL (false positive).; 14917 * Looking for 's' after a digit may cause false positives in; 14918 * ""my24service:8080"".; 14919 * Looking from 's' backward if there are only ':' and numbers; 14920 * before will not work for ""24service:8080"" (non SSL, port 8080); 14921 * or ""24s"" (SSL, port 24).; 14922 *; 14923 * Remark: Initially hostnames were not allowed to start with a; 14924 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14925 * Section 2.1).; 14926 *; 14927 * To get this correct, the entire string must be parsed as a whole,; 14928 * reading it as a list element for element and parsing with an; 14929 * algorithm equivalent to parse_port_string.; 14930 *; 14931 * In fact, we use local interface names here, not arbitrary; 14932 * hostnames, so in most cases the only name will be ""localhost"".; 14933 *; 14934 * So, for now, we use this simple algorithm, that may still return; 14935 * a false positive in bizarre cases.; 14936 */; 14937 int i;; 14938 int portslen = (int)strlen(ports);; 14939 char prevIsNumber = 0;; 14940 ; 14941 for (i = 0; i < portslen; i++) {; 14942 if (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {; 14943 return 1;; 14944 }; 14945 if (ports[i] >= '0' && ports[i] <= '9') {; 14946 prevIsNumber = 1;; 14947 } else {; 14948 prevIsNumber = 0;; 14949 }; 14950 }; 14951 }; 14952 return 0;; 14953}; 14954 ; 14955 ; 14956static int; 14957set_ports_option(struct mg_context *phys_ctx); 14958{; 14959 const char *list;; 14960 int on = 1;; 14961#if defined(USE_IPV6); 14962 int off = 0;; 14963#endif; 14964 struct vec vec;; 14965 struct socket so, *ptr;; 14966 ; 14967 struct mg_pollfd *pfd;; 14968 union usa usa;; 14969 socklen_t len;; 14970 int ip_version;; 14971 ; 14972 int portsTotal = 0;; 14973 int portsOk = 0;; 14974 ; 14975 const char *opt_txt;; 14976 long opt_listen_backlog;; 14977 ; 14978 if (!phys_ctx) {; 14979 return 0;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:442335,simpl,simple,442335,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['simpl'],['simple']
Usability,"ions; 14915 *; 14916 * If we just look for 's' anywhere in the string, ""localhost:80""; 14917 * will be detected as SSL (false positive).; 14918 * Looking for 's' after a digit may cause false positives in; 14919 * ""my24service:8080"".; 14920 * Looking from 's' backward if there are only ':' and numbers; 14921 * before will not work for ""24service:8080"" (non SSL, port 8080); 14922 * or ""24s"" (SSL, port 24).; 14923 *; 14924 * Remark: Initially hostnames were not allowed to start with a; 14925 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14926 * Section 2.1).; 14927 *; 14928 * To get this correct, the entire string must be parsed as a whole,; 14929 * reading it as a list element for element and parsing with an; 14930 * algorithm equivalent to parse_port_string.; 14931 *; 14932 * In fact, we use local interface names here, not arbitrary; 14933 * hostnames, so in most cases the only name will be ""localhost"".; 14934 *; 14935 * So, for now, we use this simple algorithm, that may still return; 14936 * a false positive in bizarre cases.; 14937 */; 14938 int i;; 14939 int portslen = (int)strlen(ports);; 14940 char prevIsNumber = 0;; 14941 ; 14942 for (i = 0; i < portslen; i++) {; 14943 if (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {; 14944 return 1;; 14945 }; 14946 if (ports[i] >= '0' && ports[i] <= '9') {; 14947 prevIsNumber = 1;; 14948 } else {; 14949 prevIsNumber = 0;; 14950 }; 14951 }; 14952 }; 14953 return 0;; 14954}; 14955 ; 14956 ; 14957static int; 14958set_ports_option(struct mg_context *phys_ctx); 14959{; 14960 const char *list;; 14961 int on = 1;; 14962#if defined(USE_IPV6); 14963 int off = 0;; 14964#endif; 14965 struct vec vec;; 14966 struct socket so, *ptr;; 14967 ; 14968 struct mg_pollfd *pfd;; 14969 union usa usa;; 14970 socklen_t len;; 14971 int ip_version;; 14972 ; 14973 int portsTotal = 0;; 14974 int portsOk = 0;; 14975 ; 14976 const char *opt_txt;; 14977 long opt_listen_backlog;; 14978 ; 14979 if (!phys_ctx) {; 14980 return 0;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:442368,simpl,simple,442368,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['simpl'],['simple']
Usability,"ions;  LayerData (const LayerData &other);  copy c'tor of LayerData ;  ;  LayerData (const_iterator_type itInputBegin, const_iterator_type itInputEnd, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (LayerData &&other);  move c'tor of LayerData ;  ;  LayerData (size_t inputSize);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, iterator_type itGradientBegin, std::shared_ptr< std::function< double(double)> > activationFunction, std::shared_ptr< std::function< double(double)> > inverseActivationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, std::shared_ptr< std::function< double(double)> > activationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  ~LayerData ();  ; std::shared_ptr< std::function< double(double)> > activationFunction () const;  ; void clear ();  clear the values and the deltas ;  ; void clearDropOut ();  clear the drop-out-data for this layer ;  ; iterator_type deltasBegin ();  returns iterator to the begin of the deltas (back-propagation) ;  ; const_iterator_type deltasBegin () const;  returns const iterator to the begin of the deltas (back-propagation) ;  ; iterator_type deltasEnd ();  returns iterator to the end of the deltas (back-propagation) ;  ; const_iterator_type deltasEnd () const;  returns const iterator to the end of the deltas (back-propagation) ;  ; const_dropout_iterator dropOut () const;  return the begin of the drop-out information ;  ; iterator_type gradientsBegin ();  returns iterator to the begin of the gradients ;  ; const_iterator_type gradientsBegin () const;  returns const iterator to the begin of the gradients ;  ; bool hasDropOut () const;  has this layer drop-out turned on? ;  ; std::shared_ptr< std::function< double(double)> > inverseActivationFunction () const;  ; ModeOutputValues outputMode () const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html:1940,clear,clear,1940,doc/master/classTMVA_1_1DNN_1_1LayerData.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html,1,['clear'],['clear']
Usability,"ionship between the pieces is not defined by neighbors, but by containment. In other words, volumes are put one inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the “world” of the model. We will often call this master reference system (MARS). Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong… We will call these leaves (by analogy with a tree structure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:; 18.1.1 Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does make map in root folder.; root[] gSystem->Load(""libGeom"");; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:876657,simpl,simplest,876657,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simplest']
Usability,"ionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDimdimension of the function to be minimized; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char* type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. void Clear(); clear resources (parameters) for consecutives minimizations. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__Minuit2Minimizer.html:6348,clear,clear,6348,root/html602/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__Minuit2Minimizer.html,6,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"iour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:55846,simpl,simply,55846,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['simpl'],['simply']
Usability,"ious Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » First Steps With ROOT Processing data with ROOT. The ROOT framework consists of many classes, grouped into several categories. Finally, the latter are grouped into few top-level categories. Each top-level category comes with a basic description of the framework design and of the purpose of its categories, which also have more detailed documentation about their use. The most complete documentation is the Reference Guide, that contains the automatically generated documentation of each class.; This document is about the top-level categories related to data processing. . ‹ First Steps With ROOT; up; CINT and RootCint ›. Navigate through this book; Processing data with ROOTCINT and RootCint; About PROOF; Bindings; Analyzing data with ROOT; Math; RooFit; TMVA. Showing results with ROOT; Simulation in ROOT; ROOT I/O. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/processing-data-root.html:2920,guid,guidelines,2920,d/processing-data-root.html,https://root.cern,https://root.cern/d/processing-data-root.html,1,['guid'],['guidelines']
Usability,ip.cxx;  TTreeCloner.cxx;  TTreeResult.cxx;  TTreeRow.cxx;  TTreeSQL.cxx;  TVirtualIndex.cxx;  TVirtualTreePlayer.cxx;  ► treeplayer;  ► inc;  LinkDef.h;  TBranchProxy.h;  TBranchProxyClassDescriptor.h;  TBranchProxyDescriptor.h;  TBranchProxyDirector.h;  TBranchProxyTemplate.h;  TChainIndex.h;  TFileDrawMap.h;  TFormLeafInfo.h;  TFormLeafInfoReference.h;  TFriendProxy.h;  TFriendProxyDescriptor.h;  TRefArrayProxy.h;  TRefProxy.h;  TSelectorDraw.h;  TSelectorEntries.h;  TTreeDrawArgsParser.h;  TTreeFormula.h;  TTreeFormulaManager.h;  TTreeGeneratorBase.h;  TTreeIndex.h;  TTreePerfStats.h;  TTreePlayer.h;  TTreeProxyGenerator.h;  TTreeReader.h;  TTreeReaderArray.h;  TTreeReaderGenerator.h;  TTreeReaderUtils.h;  TTreeReaderValue.h;  TTreeTableInterface.h;  ► src;  TBranchProxy.cxx;  TBranchProxyClassDescriptor.cxx;  TBranchProxyDescriptor.cxx;  TBranchProxyDirector.cxx;  TChainIndex.cxx;  TFileDrawMap.cxx;  TFormLeafInfo.cxx;  TFormLeafInfoReference.cxx;  TFriendProxy.cxx;  TFriendProxyDescriptor.cxx;  TRefArrayProxy.cxx;  TRefProxy.cxx;  TSelectorDraw.cxx;  TSelectorEntries.cxx;  TTreeDrawArgsParser.cxx;  TTreeFormula.cxx;  TTreeFormulaManager.cxx;  TTreeGeneratorBase.cxx;  TTreeIndex.cxx;  TTreePerfStats.cxx;  TTreePlayer.cxx;  TTreeProxyGenerator.cxx;  TTreeReader.cxx;  TTreeReaderArray.cxx;  TTreeReaderGenerator.cxx;  TTreeReaderValue.cxx;  TTreeTableInterface.cxx;  ► treeviewer;  ► inc;  HelpTextTV.h;  LinkDef.h;  LinkDefWin32.h;  TGTreeTable.h;  TMemStatShow.h;  TParallelCoord.h;  TParallelCoordEditor.h;  TParallelCoordRange.h;  TParallelCoordVar.h;  TSpider.h;  TSpiderEditor.h;  TTreeViewer.h;  TTVLVContainer.h;  TTVSession.h;  ► src;  HelpTextTV.cxx;  TGTreeTable.cxx;  TMemStatShow.cxx;  TParallelCoord.cxx;  TParallelCoordEditor.cxx;  TParallelCoordRange.cxx;  TParallelCoordVar.cxx;  TSpider.cxx;  TSpiderEditor.cxx;  TTreeViewer.cxx;  TTVLVContainer.cxx;  TTVSession.cxx. ROOT 6.06/09 - Reference Guide Generated on Sun Dec 10 2017 22:29:07 using Doxygen 1.8.9. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:99181,Guid,Guide,99181,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Guid'],['Guide']
Usability,"ipped;; however, this may cause problems if You try to unfold something; which depends on these input bins. code fragment (with histograms A and y filled):. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. will create histograms ""x"" and ""correlation"" from A and y.; if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:5282,simpl,simple,5282,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,4,['simpl'],['simple']
Usability,"ipt showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads ;  ► gui;  buttonChangelabel.CThis macro gives an example for changing text button labels anytime the Start or Pause buttons are clicked ;  buttongroupState.CA simple example that shows the enabled and disabled state of a button group with radio and check buttons ;  buttonsLayout.CThis macro gives an example of different buttons' layout ;  buttonTest.CThis macro gives an example of how to set/change text button attributes ;  calendar.CThis macro gives an example of how to use html widget to display tabular data ;  CPUMeter.CSimple macro showing capabilities of the TGSpeedo widget ;  customContextMenu.CExample showing how to add a function to the class context menu ;  customTH1Fmenu.CExample showing how to customize a context menu for a class ;  drag_and_drop.CThis tutorial illustrates how to use drag and drop within ROOT ;  exec3.CExample of using signal/slot in TCanvas/TPad to get feedback about processed events ;  exec_macro.CThis utility macro executes the macro ""macro"" given as first argument and save a capture in a png file ;  games.CThis macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT ;  gtreeTableTest.CThis TableTest class is a simple example of how to use a TGTreeTable ;  guilabels.CThis macro gives an example of how to create different kind of labels and the possibility to enable/disable them ;  guitest.CTest program for ROOT native GUI classes Exactly like $ROOTSYS/test/guitest.cxx but using the new signal and slots communication mechanism ;  guitest_playback.CThis macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved ;  guiWithCINT.CA simple example of entering CINT commands and having the CINT output in a ROOT GUI application window ;  iconAsXPMData.CA simpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:118418,feedback,feedback,118418,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['feedback'],['feedback']
Usability,"iption; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool. class RooSimWSTool: public TNamed, public RooPrintable. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool.html:1090,simpl,simple,1090,root/html526/RooSimWSTool.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool.html,5,['simpl'],['simple']
Usability,"ir/*"" in all; directories under ""/dir"", and ""/*/*"" to look in all directories; two levels deep.; For backward compatibility the type can also be passed via 'name',; in which case 'type' is ignored. TDSet(const TChain& chain, Bool_t withfriends = kTRUE); Create a named TDSet object from existing TChain 'chain'.; If 'withfriends' is kTRUE add also friends.; This constructor substituted the static methods TChain::MakeTDSet; removing any residual dependence of 'tree' on 'proof'. ~TDSet(); Cleanup. Long64_t Process(const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0, TObject* enl = 0); Process TDSet on currently active PROOF session.; The last argument 'enl' specifies an entry- or event-list to be used as; event selection.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void AddInput(TObject* obj); Add objects that might be needed during the processing of; the selector (see Process()). void ClearInput(); Clear input object list. TObject * GetOutput(const char* name); Get specified object that has been produced during the processing; (see Process()). TList * GetOutputList(); Get list with all object created during processing (see Process()). void Print(Option_t* option = """") const; Print TDSet basic or full data. When option=""a"" print full data. void SetObjName(const char* objname); Set/change object name. void SetDirectory(const char* dir); Set/change directory. Bool_t Add(const char* file, const char* objname = 0, const char* dir = 0, Long64_t first = 0, Long64_t num = -1, const char* msd = 0); Add file to list of files to be analyzed. Optionally with the; objname and dir arguments the default, TDSet wide, objname and; dir can be overridden. Bool_t Add(TDSet* set); Add specified data set to the this set. Bool_t Add(TCollection* fileinfo, const char* meta = 0, Bool_t availableOnly = kFALSE, TCollection* badlist = 0); Add files passed as list of TFileInfo, TUrl or TObjString objects .; If",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDSet.html:10839,Clear,ClearInput,10839,root/html532/TDSet.html,https://root.cern,https://root.cern/root/html532/TDSet.html,2,['Clear'],"['Clear', 'ClearInput']"
Usability,"ironment. ;  ; TClass * IsA () const override;  ; virtual void SetActive ();  ; virtual void SetActive (Bool_t active);  Suspend or resume PROOF via Condor. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProof;  TProof (const char *masterurl, const char *conffile=kPROOF_ConfFile, const char *confdir=kPROOF_ConfDir, Int_t loglevel=0, const char *alias=0, TProofMgr *mgr=0);  Create a PROOF environment. ;  ;  ~TProof () override;  Clean up PROOF environment. ;  ; Int_t ActivateWorker (const char *ord, Bool_t save=kTRUE);  Make sure that the worker identified by the ordinal number 'ord' is in the active list. ;  ; void AddChain (TChain *chain);  Add chain to data set. ;  ; Int_t AddDynamicPath (const char *libpath, Bool_t onClient=kFALSE, TList *wrks=0, Bool_t doCollect=kTRUE);  Add 'libpath' to the lib path search. ;  ; void AddFeedback (const char *name);  Add object to feedback list. ;  ; Int_t AddIncludePath (const char *incpath, Bool_t onClient=kFALSE, TList *wrks=0, Bool_t doCollect=kTRUE);  Add 'incpath' to the inc path search. ;  ; void AddInput (TObject *obj);  Add objects that might be needed during the processing of the selector (see Process()). ;  ; void AddInputData (TObject *obj, Bool_t push=kFALSE);  Add data objects that might be needed during the processing of the selector (see Process()). ;  ; Int_t Archive (const char *queryref, const char *url=0);  Send archive request for the query specified by ref. ;  ; Int_t Archive (Int_t query, const char *url);  Send archive request for the qry-th query in fQueries. ;  ; void Browse (TBrowser *b) override;  Build the PROOF's structure in the browser. ;  ; virtual Bool_t CancelStagingDataSet (const char *dataset);  Cancels a dataset staging request. ;  ; void cd (Int_t id=-1);  Set session with 'id' the default one. ;  ; Int_t CleanupSession (const char *sessiontag);  Send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofCondor.html:1669,feedback,feedback,1669,doc/master/classTProofCondor.html,https://root.cern,https://root.cern/doc/master/classTProofCondor.html,1,['feedback'],['feedback']
Usability,"ironment.Definition TApplication.cxx:244; TApplication::Openvirtual void Open()Definition TApplication.h:132; TApplication::LoadGraphicsLibsvirtual void LoadGraphicsLibs()Load shared libs necessary for graphics.Definition TApplication.cxx:1333; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::kDefaultApplication@ kDefaultApplicationDefinition TApplication.h:45; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::~TApplicationvirtual ~TApplication()TApplication dtor.Definition TApplication.cxx:210; TApplication::OpenReferenceGuideForvoid OpenReferenceGuideFor(const TString &strippedClass)It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/st...Definition TApplication.cxx:1065; TApplication::HandleExceptionvirtual void HandleException(Int_t sig)Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingExcepti...Definition TApplication.cxx:590; TApplication::MakeBatchvirtual void MakeBatch()Switch to batch mode.Definition TApplication.cxx:1395; TApplication::OpenGitHubIssuevoid OpenGitHubIssue(const TString &type)It opens a GitHub issue in a web browser with prefilled ROOT version.Definition TApplication.cxx:1034; TApplication::fReturnFromRunBool_t fReturnFromRunDefinition TApplication.h:62; TApplication::Initvirtual void Init()Definition TApplication.h:117; TApplication::fIdleCommandTString fIdleCommandDefinition TApplication.h:68; TApplication::Argvchar ** Argv() constDefinition TApplication.h:141; TApplication::fgGraphNeededstatic Bool_t fgGraphNeededDefinition TApplication.h:73; TApplic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:89086,guid,guide,89086,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['guid'],['guide']
Usability,"irtual . Implements RooAbsDataStore.; Definition at line 1041 of file RooVectorDataStore.cxx. ◆ attachCache(). void RooVectorDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overridevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 982 of file RooVectorDataStore.cxx. ◆ cache(). const RooVectorDataStore * RooVectorDataStore::cache ; (; ); const. inline . Definition at line 171 of file RooVectorDataStore.h. ◆ cacheArgs(). void RooVectorDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = true . ). overridevirtual . Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 764 of file RooVectorDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooVectorDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 163 of file RooVectorDataStore.h. ◆ catStoreList(). std::vector< CatVector * > & RooVectorDataStore::catStoreList ; (; ). inline . Definition at line 542 of file RooVectorDataStore.h. ◆ changeObservableName(). bool RooVectorDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 595 of file RooVectorDataStore.cxx. ◆ Class(). static TClass * RooVectorDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooVectorDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooVectorDataStore::Class_V",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:27552,clear,cleared,27552,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['clear'],['cleared']
Usability,"irtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring and logging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 788 of file NeuralNet.h. ◆ exists(). bool TMVA::DNN::Settings::exists ; (; std::string ; histoName). inline . for monitoring ; Definition at line 825 of file NeuralNet.h. ◆ factorWeightDecay(). double TMVA::DNN::Settings::factorWeightDecay ; (; ); const. inline . get the weight-decay factor ; Definition at line 769 of file NeuralNet.h. ◆ hasConverged(). bool TMVA::DNN::Settings::hasConverged ; (; double ; testError). virtual . has this training converged already? ; check for convergence; Definition at line 485 of file NeuralNet.cxx. ◆ learningRate(). double TMVA::DNN::Settings::learningRate ; (; ); const. inline . get the learning rate ; Definition at line 771 of file NeuralNet.h. ◆ maxConvergenceCount(). size_t TMVA::DNN::Settings::maxConvergenceCount ; (; ); const. inline . returns the max convergence count so far ; Definition at line 828 of file NeuralNet.h. ◆ minError(). size_t TMVA::DNN::Settings::minError ; (; ); const. inline . returns the smallest error so far ; Definition at line 829 of file NeuralNet.h. ◆ minimizerType(). MinimizerType TMVA::DNN::Settings::minimizerType ; (; ); const. inline . which minimizer shall be used (e.g. SGD) ; Definition at line 774 of file NeuralNet.h. ◆ momentum(). double TMVA::DNN::Settings::momentum ; (; ); const. inline . get the momentum (e.g. for SGD) ; Definition at line 772 of file NeuralNet.h. ◆ pads(). void TMVA::DNN::Settings::pads ; (; int ; numPads). inline . preparation for monitoring ; Definition at line 818 of file NeuralNet.h. ◆ plot(). void TMVA::DNN::Settings::plot ; (; std::string ; histoName, . std::s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:9044,learn,learningRate,9044,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['learn'],['learningRate']
Usability,"irtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelTrivial(); Default constructor for streamer. PDEFoamKernelTrivial(const TMVA::PDEFoamKernelTrivial& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Simple kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates). Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. virtual ~PDEFoamKernelTrivial(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2010: *; » Last changed: root/tmva $Id: PDEFoamKernelTrivial.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__PDEFoamKernelTrivial.html:5891,Simpl,Simple,5891,root/html532/TMVA__PDEFoamKernelTrivial.html,https://root.cern,https://root.cern/root/html532/TMVA__PDEFoamKernelTrivial.html,1,['Simpl'],['Simple']
Usability,"irtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGLVContainer::AddItem(TGLVEntry* item); virtual voidAddThisItem(TTVLVEntry* item); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGContainer::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidTGContainer::ClearViewPort(); virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn)SIGNAL ; virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGContainer::CurrentChanged(TGFrame* f)SIGNAL ; virtual voidTGContaine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTVLVContainer.html:1597,Clear,Clear,1597,root/html532/TTVLVContainer.html,https://root.cern,https://root.cern/root/html532/TTVLVContainer.html,4,['Clear'],['Clear']
Usability,"irtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); virtual voidTGPopupMenu::CheckEntry(Int_t id); virtual voidTGPopupMenu::CheckEntryByData(void* user_data); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGPopupMenu::DefaultEntry(Int_t id); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGPopupMenu::DeleteEntry(Int_t id); virtual voidTGPopupMenu::DeleteEntry(TGMenuEntry* entry); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootContextMenu.html:2491,Clear,Clear,2491,root/html532/TRootContextMenu.html,https://root.cern,https://root.cern/root/html532/TRootContextMenu.html,4,['Clear'],['Clear']
Usability,"irtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tCanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTriangleSet.html:2547,Clear,ClearStamps,2547,root/html532/TEveTriangleSet.html,https://root.cern,https://root.cern/root/html532/TEveTriangleSet.html,4,['Clear'],['ClearStamps']
Usability,"irtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; TDrawFeedback*TProof::CreateDrawFeedback(); voidTProof::DataSetStatus(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; Int_tTProof::DeactivateWorker(const char* ord); static voidTProof:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLite.html:2312,Clear,ClearPackage,2312,root/html532/TProofLite.html,https://root.cern,https://root.cern/root/html532/TProofLite.html,1,['Clear'],['ClearPackage']
Usability,"irtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCLsCleanupThreshold(Double_t th); virtual voidSetConfidenceLevel(Double_t cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTestSize(Double_t size); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name = 0); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval& other, const char* name); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tUpperLimit(); Double_tUpperLimitEstimatedError(); voidUseCLs(bool on = true); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html:6930,Simpl,SimpleInterval,6930,root/html534/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html,1,['Simpl'],['SimpleInterval']
Usability,"irtual voidUpdateBackgroundStart(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual Bool_tItemLayout(); voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); virtual voidUpdateRegion(Int_t x, Int_t y, UInt_t w, UInt_t h). private:. TGView&operator=(const TGView&); TGView(const TGView&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGView.html:16344,Clear,ClearFlags,16344,root/html602/TGView.html,https://root.cern,https://root.cern/root/html602/TGView.html,2,['Clear'],['ClearFlags']
Usability,"irtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLFontManager(). protected:. static voidInitStatics(). private:. TGLFontManager&operator=(const TGLFontManager&); TGLFontManager(const TGLFontManager&). Data Members; protected:. TGLFontManager::FontMap_tfFontMapmap of created fonts; TGLFontManager::FontList_tfFontTrashfonts to purge; static Int_tfgExtendedFontStart; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static TGLFontManager::FontSizeVec_tfgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetExtendedFontStartIndex(). Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLFontManager.html:2629,Clear,ClearFontTrash,2629,root/html604/TGLFontManager.html,https://root.cern,https://root.cern/root/html604/TGLFontManager.html,1,['Clear'],['ClearFontTrash']
Usability,"irtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLFontManager(). protected:. static voidInitStatics(). private:. TGLFontManager&operator=(const TGLFontManager&); TGLFontManager(const TGLFontManager&). Data Members; protected:. TGLFontManager::FontMap_tfFontMapmap of created fonts; TGLFontManager::FontList_tfFontTrashfonts to purge; static Int_tfgExtendedFontStart; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static TGLFontManager::FontSizeVec_tfgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetExtendedFontStartIndex(). Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLFontManager.html:2629,Clear,ClearFontTrash,2629,root/html602/TGLFontManager.html,https://root.cern,https://root.cern/root/html602/TGLFontManager.html,1,['Clear'],['ClearFontTrash']
Usability,"irtualCollectionProxy::EProperty. { return fProperties; }. void * New() const; Return a new container object. void * New(void* arena) const; Execute the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Othe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualCollectionProxy.html:4380,simpl,simple,4380,root/html528/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TVirtualCollectionProxy.html,4,['simpl'],['simple']
Usability,"irtualGLPainter&); virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector&); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. Bool_tBuildTesselation(Rgl::Pad::Tesselator& tess, const TGraph* g, Double_t z); Bool_tBuildTesselation(Rgl::Pad::Tesselator& tess, const TMultiGraph* mg, Double_t z); Bool_tCacheGeometry(); Bool_tClampZ(Double_t& zVal) const; virtual voidDeInitGL() const; voidDrawCap(TGLH2PolyPainter::CIter_t cap, Int_t bin) const; voidDrawCaps() const; voidDrawExtrusion() const; voidDrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; voidDrawExtrusion(const TMultiGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidFillTemporaryP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLH2PolyPainter.html:1624,Clear,ClearBuffers,1624,root/html534/TGLH2PolyPainter.html,https://root.cern,https://root.cern/root/html534/TGLH2PolyPainter.html,1,['Clear'],['ClearBuffers']
Usability,"irtualGLPainter&); virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector&); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. voidClampZ(Double_t& zVal) const; virtual voidDeInitGL() const; voidDrawContoursProjection() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; voidDrawProjections() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidGenTexMap() const; Bool_tHasProjections() const; Bool_tHasSections() const; Bool_tInitGeometryCartesian(); Bool_tInitGeometryCylindrical(); Bool_tInitGeometryPolar(); Bool_tInitGeometrySpherical(); virtual voidInitGL() const; Bool_tPreparePalette() const; voidSetNormals(); voidSetSurfaceColor() const; Bool_tTextured() const; char*WindowPointTo3DPoint(Int_t px, Int_t py) const. Data Members; public:. enum ESurfaceType { kSurf; kSurf1;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLSurfacePainter.html:1676,Clear,ClearBuffers,1676,root/html534/TGLSurfacePainter.html,https://root.cern,https://root.cern/root/html534/TGLSurfacePainter.html,1,['Clear'],['ClearBuffers']
Usability,"irtualX(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tAddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tAllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginModalSessionFor(Window_t window); virtual voidBell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidChangeGC(GContext_t gc, GCValues_t* gval); virtual voidChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tCheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidClearWindow(); virtual voidClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseDisplay(); virtual voidClosePixmap(); virtual voidCloseWindow(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidCopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidCopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual Pixmap_tCreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height); virtual Cursor_tCreateCursor(ECursor cursor); virtual GC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualX.html:1708,Clear,Clear,1708,root/html534/TVirtualX.html,https://root.cern,https://root.cern/root/html534/TVirtualX.html,3,['Clear'],['Clear']
Usability,"irtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TArrow::Drawvoid Draw(Option_t *option="""") overrideDraw this arrow with its current attributes.Definition TArrow.cxx:120; TArrow::SetAnglevirtual void SetAngle(Float_t angle=60)Definition TArrow.h:60; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::Cconstexpr Double_t C()Velocity of light in .Definition TMath.h:114; lTLine lDefinition textangle.C:4; AuthorOlivier Couet ; Definition in file mass_spectrum.C. tutorialsgraphicsmass_spectrum.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mass__spectrum_8C.html:5858,simpl,simple,5858,doc/master/mass__spectrum_8C.html,https://root.cern,https://root.cern/doc/master/mass__spectrum_8C.html,1,['simpl'],['simple']
Usability,"is a simple example of how to use a TGTreeTable ;  guilabels.CThis macro gives an example of how to create different kind of labels and the possibility to enable/disable them ;  guitest.CTest program for ROOT native GUI classes Exactly like $ROOTSYS/test/guitest.cxx but using the new signal and slots communication mechanism ;  guitest_playback.CThis macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved ;  guiWithCINT.CA simple example of entering CINT commands and having the CINT output in a ROOT GUI application window ;  iconAsXPMData.CA simple example of creating icon image from XPM data, included into the code ;  listBox.CThis macro gives an example of how to create a list box and how to set and use its multiple selection feature ;  mditest.CGUI MDI features ;  ntupleTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that show",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:119683,simpl,simple,119683,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability,"is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:4192,learn,learning,4192,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['learn'],['learning']
Usability,"is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:7287,learn,learning,7287,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['learn'],['learning']
Usability,"is case, we will name it histogram-race-condition-fix, but you may name it differently according to what your contribution will be.; git checkout -b histogram-race-condition-fix; After implementing your changes, add and commit your changes (More about how to use git here):; git add hist/hist/somefile.cxx; git commit -m ""Avoid race condition on Ubuntu 16.04""; git push --set-upstream origin histogram-race-condition-fix; Your changes are now in your forked repository on GitHub. We will now make the pull request.; Making the pull request on GitHub; If you go to https://github.com/<your GitHub username>/root, you will see a notification saying ""Your recently pushed branches: histogram-race-condition-fix (some minutes ago)"":. You can now hit the green ""Compare & pull request"" button which lets you create the pull request.; Fill in a reasonable description of what your new feature is, and hit ""Create pull request"". A project member will later initiate a build of your pull request and then review your pull request before giving feedback and in the end hopefully merge it. More about how what happens after submitting the pull request can be found in the contributing readme.; Pulling the last changes from upstream/master; Often, there might have been changes in the upstream/master repository that you want to have together with your new changes. This section will describe how to pull the new changes.; Add the ROOT repository upstream as a remote:; git remote add upstream https://github.com/root-project/root; Make sure you are on the master branch locally and pull the latest changes from upstream:; git checkout master; git pull upstream master; Go back to your local branch and rebase the last changes from master:; git checkout histogram-race-condition-fix; git rebase master; Push your new updated local branch to your GitHub repository (origin):; git push --force; Summary. The entire workflow is summarized in the image above. First, we cloned root-project/root, and cloned it to o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/creating-pull-request.html:3515,feedback,feedback,3515,d/creating-pull-request.html,https://root.cern,https://root.cern/d/creating-pull-request.html,1,['feedback'],['feedback']
Usability,"is is a static function.; Set object delete option.; When this option is activated (default), ReadBuffer automatically; delete objects when a data member is a pointer to an object.; If your constructor is not presetting pointers to 0, you must; call this static function TStreamerInfo::SetCanDelete(kFALSE);. void SetFactory(TVirtualStreamerInfo* factory); static function: Set the StreamerInfo factory. Bool_t SetStreamMemberWise(Bool_t enable = kTRUE); Set whether the TStreamerInfos will save the collections in; ""member-wise"" order whenever possible. The default is to store member-wise.; kTRUE indicates member-wise storing; kFALSE inddicates object-wise storing; This function returns the previous value of fgStreamMemberWise. void Streamer(TBuffer& b); Stream an object of class TVirtualStreamerInfo. void Build(). void BuildCheck(). void BuildEmulated(TFile* file). void BuildOld(). Bool_t BuildFor(const TClass* cl). void CallShowMembers(void* obj, TMemberInspector& insp) const. void Clear(Option_t* ). Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete). void Compile(). void ForceWriteInfo(TFile* file, Bool_t force = kFALSE). Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0). TClass * GetActualClass(const void* obj) const. TClass * GetClass() const. UInt_t GetCheckSum() const. Int_t GetClassVersion() const. ULong_t * GetElems() const. TObjArray * GetElements() const. Int_t GetOffset(const char* ) const. Int_t * GetOffsets() const. Version_t GetOldVersion() const. Int_t GetOnFileClassVersion() const. Int_t GetNumber() const. Int_t GetSize() const. TStreamerElement * GetStreamerElement(const char* datamember, Int_t& offset) const. Bool_t IsBuilt() const; { return fIsBuilt; }. Bool_t IsCompiled() const; { return TestBit(kIsCompiled); }. Bool_t IsOptimized() const; { return fOptimized; }. Int_t IsRecovered() const; { return TestBit(kRecovered); }. void ls(Option_t* option = """") cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualStreamerInfo.html:11471,Clear,Clear,11471,root/html532/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html,1,['Clear'],['Clear']
Usability,"is is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TArray(); static TClass*Class(); virtual Double_tGetAt(Int_t i) const; Int_tGetSize() const; virtual TClass*IsA() const; TArray&operator=(const TArray& rhs); static TArray*ReadArray(TBuffer& b, const TClass* clReq); virtual voidSet(Int_t n); virtual voidSetAt(Double_t v, Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidWriteArray(TBuffer& b, const TArray* a). protected:. Bool_tBoundsOk(const char* where, Int_t at) const; Bool_tOutOfBoundsError(const char* where, Int_t i) const. Data Members; public:. Int_tfNNumber of array elements. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t OutOfBoundsError(const char* where, Int_t i) const; Generate an out-of-bounds error. Always returns false. TArray * ReadArray(TBuffer& b, const TClass* clReq); Read TArray object from buffer. Simplified version of; TBuffer::ReadObject (does not keep track of multiple; references to same array). void WriteArray(TBuffer& b, const TArray* a); Write TArray object to buffer. Simplified version of; TBuffer::WriteObject (does not keep track of multiple; references to the same array). Bool_t BoundsOk(const char* where, Int_t at) const. TArray & operator=(const TArray& rhs); {if(this!=&rhs) fN = rhs.fN; return *this; }. virtual ~TArray(); { fN = 0; }. Int_t GetSize() const; { return fN; }. void Set(Int_t n). Double_t GetAt(Int_t i) const. void SetAt(Double_t v, Int_t i). » Author: Fons Rademakers 21/10/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TArray.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TArray.html:1505,Simpl,Simplified,1505,root/html532/TArray.html,https://root.cern,https://root.cern/root/html532/TArray.html,2,['Simpl'],['Simplified']
Usability,"is method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* FindObject(const char* name) const; Return pointer to obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. RooAbsArg* findArg(const RooAbsArg* ) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. RooLinkedListIter iterator(Bool_t dir = kTRUE) const. RooFIter fwdIterator() const. TIterator* MakeIterator(Bool_t dir = kT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinkedList.html:8249,Clear,Clear,8249,root/html532/RooLinkedList.html,https://root.cern,https://root.cern/root/html532/RooLinkedList.html,4,['Clear'],['Clear']
Usability,"is name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. Double_t EvalInstance(Int_t i = 0, const char** stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall cor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:22690,simpl,simple,22690,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,4,['simpl'],['simple']
Usability,"is name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char** stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall correspond",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormula.html:23008,simpl,simple,23008,root/html534/TTreeFormula.html,https://root.cern,https://root.cern/root/html534/TTreeFormula.html,2,['simpl'],['simple']
Usability,"is name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall correspon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:28258,simpl,simple,28258,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,4,['simpl'],['simple']
Usability,"is of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the –full-dataset argument and you can also run only on a fraction of the original dataset using the argument –lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.001 # The preskimmed dataset contains only 0.01 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.2f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:1382,usab,usable,1382,doc/master/df105__WBosonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html,1,['usab'],['usable']
Usability,"is option is activated (default), ReadBuffer automatically; delete objects when a data member is a pointer to an object.; If your constructor is not presetting pointers to 0, you must; call this static function TStreamerInfo::SetCanDelete(kFALSE);. void SetFactory(TVirtualStreamerInfo* factory); static function: Set the StreamerInfo factory. Bool_t SetStreamMemberWise(Bool_t enable = kTRUE); Set whether the TStreamerInfos will save the collections in; ""member-wise"" order whenever possible. The default is to store member-wise.; kTRUE indicates member-wise storing; kFALSE inddicates object-wise storing; This function returns the previous value of fgStreamMemberWise. void Streamer(TBuffer& ); Stream an object of class TVirtualStreamerInfo. void ResetIsCompiled(). void SetIsCompiled(). void Build(). void BuildCheck(TFile* file = 0). void BuildEmulated(TFile* file). void BuildOld(). Bool_t BuildFor(const TClass* cl). void CallShowMembers(void* obj, TMemberInspector& insp) const. void Clear(Option_t* ). Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file). void Compile(). void ForceWriteInfo(TFile* file, Bool_t force = kFALSE). Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0). TClass * GetActualClass(const void* obj) const. TClass * GetClass() const. UInt_t GetCheckSum() const. Int_t GetClassVersion() const. TStreamerElement * GetElem(Int_t id) const. TStreamerElement * GetElement(Int_t id) const. TObjArray * GetElements() const. Int_t GetOffset(const char* ) const. Int_t GetOffset(Int_t id) const. Int_t GetElementOffset(Int_t id) const. Version_t GetOldVersion() const. Int_t GetOnFileClassVersion() const. Int_t GetNumber() const. Int_t GetSize() const. TStreamerElement * GetStreamerElement(const char* datamember, Int_t& offset) const. Bool_t IsBuilt() const; { return fIsBuilt; }. Bool_t IsCompiled() const; { return fIsCompiled; }. Bool_t IsOptimized() const; { retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualStreamerInfo.html:11767,Clear,Clear,11767,root/html534/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TVirtualStreamerInfo.html,1,['Clear'],['Clear']
Usability,"is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:4680,simpl,simple,4680,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,10,['simpl'],['simple']
Usability,"is sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula syntax:; -Additive parts are separated by 2 plus signes ""++""; --for example ""1 ++ x"" - for fitting a straight line; -All standard functions, undrestood by TFormula, can be used; as additive parts; --TMath functions can be used too; -Functions, used as additive parts, shouldn't have any parameters,; even if those parameters are set.; --for example, if normalizing a sum of a gaus(0, 1) and a; gaus(0, 2), don't use the built-in ""gaus"" of TFormula,; because it has parameters, take TMath::Gaus(x, 0, 1) instead.; -Polynomials can be used like ""pol3"", ..""polN""; -If fitting a more than 3-dimensional formula, variables should; be numbered as follows:; -- x[0], x[1], x[2]... For example, to fit ""1 ++ x[0] ++ x[1] ++ x[2] ++ x[3]*x[3]""; 2.2 Setting the formula:; 2.2.1 If fitting a 1-2-3-dimensional",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:1669,simpl,simply,1669,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,10,['simpl'],['simply']
Usability,"is static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. Bool_t IsDynamic() const; accessors. {return fDynamic; }. Double_t GetOriginalWeight() const; { return fWeight; }. Double_t GetBoostWeight() const; { return TMath::Max(Double_t(0.0001),fBoostWeight); }. UInt_t GetClass() const; { return fClass; }. std::vector<Float_t>& GetValues(); For a detailed explanation, please see the heading ""Avoid Duplication in const and Non-const Member Function,"" on p. 23, in Item 3 ""Use const whenever possible,"" in Effective C++, 3d ed by Scott Meyers, ISBN-13: 9780321334879.; http://stackoverflow.com/questions/123758/how-do-i-remove-code-duplication-between-similar-const-and-non-const-member-func. Float_t GetTarget(UInt_t itgt) const; { return fTargets.at(itgt); }. std::vector<Float_t>& GetTargets(); { return fTargets; }. const std::vector<Float_t>& GetTargets() const; { return fTargets; }. std::vector<Float_t>& GetSpectators(); { return fSpectators; }. const std::vector<Float_t>& GetSpectators() const; { return fSpectators; }. void SetWeight(Double_t w); { fWeight=w; }. void SetBoostWeight(Double_t w) const; { fDoNotBoost ? fDoNotBoost = kFALSE : fBoostWeight=w; }. void ScaleBoostWeight(Double_t s) const; { fDoNotBoost ? fDoNotBoost = kFALSE : fBoostWeight *= s; }. void SetClass(UInt_t t); { fClass=t; }. void SetDoNotBoost() const; { fDoNotBoost = kTRUE; }. void ClearDynamicVariables(); {}. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Event.html:6710,Clear,ClearDynamicVariables,6710,root/html602/TMVA__Event.html,https://root.cern,https://root.cern/root/html602/TMVA__Event.html,1,['Clear'],['ClearDynamicVariables']
Usability,"is static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. Bool_t IsDynamic() const; accessors. {return fDynamic; }. Double_t GetOriginalWeight() const; { return fWeight; }. Double_t GetBoostWeight() const; { return TMath::Max(Double_t(0.0001),fBoostWeight); }. UInt_t GetClass() const; { return fClass; }. std::vector<Float_t>& GetValues(); For a detailed explanation, please see the heading ""Avoid Duplication in const and Non-const Member Function,"" on p. 23, in Item 3 ""Use const whenever possible,"" in Effective C++, 3d ed by Scott Meyers, ISBN-13: 9780321334879.; http://stackoverflow.com/questions/123758/how-do-i-remove-code-duplication-between-similar-const-and-non-const-member-func. Float_t GetTarget(UInt_t itgt) const; { return fTargets.at(itgt); }. std::vector<Float_t>& GetTargets(); { return fTargets; }. const std::vector<Float_t>& GetTargets() const; { return fTargets; }. std::vector<Float_t>& GetSpectators(); { return fSpectators; }. const std::vector<Float_t>& GetSpectators() const; { return fSpectators; }. void SetWeight(Double_t w); { fWeight=w; }. void SetBoostWeight(Double_t w) const; { fDoNotBoost ? fDoNotBoost = kFALSE : fBoostWeight=w; }. void ScaleBoostWeight(Double_t s) const; { fDoNotBoost ? fDoNotBoost = kFALSE : fBoostWeight *= s; }. void SetClass(UInt_t t); { fClass=t; }. void SetDoNotBoost() const; { fDoNotBoost = kTRUE; }. void ClearDynamicVariables(); {}. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__Event.html:6718,Clear,ClearDynamicVariables,6718,root/html604/TMVA__Event.html,https://root.cern,https://root.cern/root/html604/TMVA__Event.html,1,['Clear'],['ClearDynamicVariables']
Usability,"is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate. If first derivatives are a problem, they can be calculated analytically inside \(\mbox{FCN}\) (see [howto:fcn]) or if this is not feasible, the user can try to improve the accuracy of M ’s numerical approximation by adjusting values of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and [api:strategy]).; 6.1.2 \(\mbox{MINIMIZE}\); This is equivalent to \(\mbox{MIGRAD}\), except that if \(\mbox{MIGRAD}\) fails, it reverts to \(\mbox{SIMPLEX}\) and then calls \(\mbox{MIGRAD}\) again.; 6.1.3 \(\mbox{SCAN}\); This is not intended to minimize, and just scans the function, one parameter at a time. It does however retain the best value after each scan, so it does some sort of highly primitive minimization.; 6.1.4 \(\mbox{SIMPLEX}\); This genuine multidimensional minimization routine is usually much slower than \(\mbox{MIGRAD}\), but it does not use first derivatives, so it should not be so sensitive to the precision of the \(\mbox{FCN}\) calculations, and is even rather robust with respect to gross fluctuations in the function value. However, it gives no reliable information about parameter errors, no information whatsoever about parameter correlations, and worst of all cannot be expected to converge accurately to the minimum in a finite time. Its estimate of the expected distance to the minimum \(\mbox{EDM}\) is largely fantasy, so it would not even know if it did converge.; 6.2 Floating point precision; M figures out at execution time the machine precision [api:epsmac], and assumes that \(\mbox{FCN}\) provides about the same precision. That means not just the length of the numbers used and returned by \(\mbox{FCN}\), but the actual mathematical accuracy of the calculations. Section [install:epsmac] describes what to do if this is not the case.; 6.3 Parameter limits; Putting limits (absolute bounds) on the allowed values for a given parameter, causes M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:67299,SIMPL,SIMPLEX,67299,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['SIMPL'],['SIMPLEX']
Usability,"is the address of a pointer to an object of class; 2362/// classname. The class dictionary must be available (ClassDef; 2363/// in class header).; 2364///; 2365/// Note: See the comments in TBranchElement::SetAddress() for a more; 2366/// detailed discussion of the meaning of the addr parameter.; 2367///; 2368/// This option requires access to the library where the; 2369/// corresponding class is defined. Accessing one single data; 2370/// member in the object implies reading the full object.; 2371///; 2372/// By default the branch buffers are stored in the same file as the Tree.; 2373/// use TBranch::SetFile to specify a different file; 2374///; 2375/// IMPORTANT NOTE about branch names:; 2376///; 2377/// And in general, in case two or more master branches contain subbranches; 2378/// with identical names, one must add a ""."" (dot) character at the end; 2379/// of the master branch name. This will force the name of the subbranches; 2380/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2381/// This situation happens when the top level object; 2382/// has two or more members referencing the same class.; 2383/// For example, if a Tree has two branches B1 and B2 corresponding; 2384/// to objects of the same class MyClass, one can do:; 2385/// ~~~ {.cpp}; 2386/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2387/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2388/// ~~~; 2389/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2390/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2391///; 2392/// bufsize is the buffer size in bytes for this branch; 2393/// The default value is 32000 bytes and should be ok for most cases.; 2394/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2395/// and each entry is large (Megabytes); 2396/// A small value for bufsize is optimum if you intend to access; 2397/// the entries in the Tree randomly and your Tree is in split mode.; 2398///; 2399/// Use splitlevel < 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:94442,simpl,simply,94442,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simply']
Usability,"is tutorial shows how a histogram can be filled in parallel with a multiprocess approach ;  mt001_fillHistos.CFill histograms in parallel and write them on file ;  mt101_fillNtuples.CFill n-tuples in distinct workers ;  mt102_readNtuplesFillHistosAndFit.CRead n-tuples in distinct workers, fill histograms, merge them and fit ;  mt201_parallelHistoFill.CParallel fill of a histogram ;  mtbb001_fillHistos.CFill histograms in parallel and write them on file ;  mtbb101_fillNtuples.CFill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.CParallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:133906,simpl,simple,133906,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"isable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4254 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 548 of file RooAbsReal.h. ◆ clearEvalErrorLog(). void RooAbsReal::clearEvalErrorLog ; (; ). static . Clear the stack of evaluation error messages. ; Definition at line 3542 of file RooAbsReal.cxx. ◆ copyCache(). void RooAbsReal::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value of another RooAbsArg to our cache. ; Warning: This function just copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, and RooRealVar.; Definition at line 2997 of file RooAbsReal.cxx. ◆ createChi2() [1/4]. RooAbsReal::createChi2 ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Create a \( \chi^2 \) variable from a histogra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:78078,clear,clearEvalErrorLog,78078,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['clear'],['clearEvalErrorLog']
Usability,"isable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4330 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 558 of file RooAbsReal.h. ◆ clearEvalErrorLog(). void RooAbsReal::clearEvalErrorLog ; (; ). static . Clear the stack of evaluation error messages. ; Definition at line 3622 of file RooAbsReal.cxx. ◆ copyCache(). void RooAbsReal::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value of another RooAbsArg to our cache. ; Warning: This function just copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, and RooRealVar.; Definition at line 3082 of file RooAbsReal.cxx. ◆ createChi2() [1/4]. RooAbsReal::createChi2 ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Create a \( \chi^2 \) variable from a histogra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:79346,clear,clearEvalErrorLog,79346,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['clear'],['clearEvalErrorLog']
Usability,"ise) ;  ; void setMonitoring (std::shared_ptr< Monitoring > ptrMonitoring);  prepared for monitoring ;  ; virtual void setProgressLimits (double minProgress=0, double maxProgress=100);  ; virtual void startTraining ();  ; size_t testRepetitions () const;  how often is the test data tested ;  ; bool useMultithreading () const;  is multithreading turned on? ;  . Public Attributes; std::vector< double > m_ams;  ; double m_cutValue;  ; std::string m_fileNameNetConfig;  ; std::string m_fileNameResult;  ; std::vector< double > m_input;  ; std::vector< double > m_output;  ; std::vector< Pattern > * m_pResultPatternContainer;  ; size_t m_scaleToNumEvents;  ; std::vector< double > m_significances;  ; double m_sumOfBkgWeights;  ; double m_sumOfSigWeights;  ; std::vector< double > m_targets;  ; std::vector< double > m_weights;  ;  Public Attributes inherited from TMVA::DNN::Settings; size_t count_dE;  ; size_t count_E;  ; size_t count_mb_dE;  ; size_t count_mb_E;  ; double fLearningRate;  ; MinimizerType fMinimizerType;  ; double fMomentum;  ; int fRepetitions;  ; size_t m_batchSize;  mini-batch size ;  ; size_t m_convergenceCount;  ; size_t m_convergenceSteps;  number of steps without improvement to consider the DNN to have converged ;  ; std::vector< double > m_dropOut;  ; double m_dropRepetitions;  ; double m_factorWeightDecay;  ; size_t m_maxConvergenceCount;  ; double m_maxProgress;  current limits for the progress bar ;  ; double m_minError;  ; double m_minProgress;  current limits for the progress bar ;  ; EnumRegularization m_regularization;  ; size_t m_testRepetitions;  ; Timer m_timer;  timer for monitoring ;  . Additional Inherited Members;  Protected Attributes inherited from TMVA::DNN::Settings; std::shared_ptr< Monitoring > fMonitoring;  ; bool m_useMultithreading;  . #include <TMVA/NeuralNet.h>. Inheritance diagram for TMVA::DNN::ClassificationSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:5912,progress bar,progress bar,5912,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,2,['progress bar'],['progress bar']
Usability,"iseActions(TClass *oldClass, Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1747; TGenCollectionProxy::fReadMemberWiseTObjArray * fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read)Definition TGenCollectionProxy.h:291; TGenCollectionProxy::DeleteItemvirtual void DeleteItem(Bool_t force, void *ptr) constCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:1350; TGenCollectionProxy::GetCollectionClassTClass * GetCollectionClass() const overrideReturn a pointer to the TClass representing the container.Definition TGenCollectionProxy.cxx:985; TGenCollectionProxy::fStagedStaged_t fStagedOptimization: Keep staged array once they were created.Definition TGenCollectionProxy.h:319; TGenCollectionProxy::fSizeMethod fSizeContainer accessors: size of container.Definition TGenCollectionProxy.h:302; TGenCollectionProxy::fClearMethod fClearMethod cache for container accessors: clear container.Definition TGenCollectionProxy.h:301; TGenCollectionProxy::fFeedFeedfunc_t fFeedContainer accessors: block feed.Definition TGenCollectionProxy.h:308; TGenCollectionProxy::GetFunctionCreateIteratorsCreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE) overrideSee typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena); begin_...Definition TGenCollectionProxy.cxx:1607; TGenCollectionProxy::fValDiffint fValDiffOffset between two consecutive value_types (memory layout).Definition TGenCollectionProxy.h:316; TGenCollectionProxy::ReadBuffervirtual void ReadBuffer(TBuffer &b, void *obj)Definition TGenCollectionProxy.cxx:1419; TGenCollectionProxy::fProxyKeptProxies_t fProxyKeptOptimization: Keep proxies once they were created.Definition TGenCollectionProxy.h:318; TGenCollectionProxy::SizeofUInt_t Sizeof() const overrideReturn the sizeof the collection object.Definition TGenCollectionProxy.cxx:1014; TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:85503,clear,clear,85503,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['clear'],['clear']
Usability,"ision of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial2.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial3.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial4.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  FITS_tutorial7.COpen a FITS file that contains a catalog of astronomical objects and dump some of its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:106841,simpl,simple,106841,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['simpl'],['simple']
Usability,"isionTree(); destructor. void SetParentTreeInNodes(TMVA::Node* n = __null); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. TMVA::DecisionTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262656); re-create a new tree (decision tree or search tree) from XML. UInt_t BuildTree(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node = __null); building the decision tree by recursively calling the splitting of; one (root-) node into two daughter nodes (returns the number of nodes). void FillTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:10564,clear,clear,10564,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,3,"['Clear', 'clear']","['ClearTree', 'clear']"
Usability,"isionTree(); destructor. void SetParentTreeInNodes(TMVA::Node* n = __null); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. TMVA::DecisionTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); re-create a new tree (decision tree or search tree) from XML. UInt_t BuildTree(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node = __null); building the decision tree by recursively calling the splitting of; one (root-) node into two daughter nodes (returns the number of nodes). void FillTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__DecisionTree.html:10572,clear,clear,10572,root/html604/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html,3,"['Clear', 'clear']","['ClearTree', 'clear']"
Usability,"ist of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; List of all members ; TGVProgressBar Class Reference. . Definition at line 122 of file TGProgressBar.h. Public Member Functions;  TGVProgressBar (const TGWindow *p, EBarType type, UInt_t h);  Simple constructor allow you to create either a standard progress bar, or a more fancy progress bar (fancy means: double sized border, white background and a bit wider to allow for text to be printed in the bar. ;  ;  TGVProgressBar (const TGWindow *p=nullptr, UInt_t w=kProgressBarTextWidth, UInt_t h=4, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Constructor. ;  ;  ~TGVProgressBar () override;  ; TGDimension GetDefaultSize () const override;  std::cout << fWidth << ""x"" << fHeight << std::endl; ;  ; TClass * IsA () const override;  ; void Percent (Bool_t) override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a vertical progress bar as a C++ statement(s) on output stream out. ;  ; void ShowPos (Bool_t) override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGProgressBar;  TGProgressBar (const TGWindow *p, UInt_t w, UInt_t h, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Create progress bar. ;  ;  ~TGProgressBar () override;  ; virtual void Format (const char *format=""%.2f"");  Set format for displaying a value. ;  ; Pixel_t GetBarColor () const;  ; EBarType GetBarType () const;  ; EFillType GetFillType () const;  ; FontStruct_t GetFontStruct () const;  ; TString GetFormat () const;  ; Float_t G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGVProgressBar.html:1244,progress bar,progress bar,1244,doc/master/classTGVProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGVProgressBar.html,1,['progress bar'],['progress bar']
Usability,"ist(int index) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; RooStats::SamplingDistribution*GetUpperLimitDistribution() const; doubleGetXValue(int index) const; doubleGetYError(int index) const; doubleGetYValue(int index) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; RooStats::HypoTestInverterResultHypoTestInverterResult(const char* name = 0); RooStats::HypoTestInverterResultHypoTestInverterResult(const char* name, const RooRealVar& scannedVariable, double cl); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooStats::SimpleInterval::IsInInterval(const RooArgSet&) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Double_tLowerLimit(); Double_tLowerLimitEstimatedError(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::SimpleInterval&RooStats::SimpleInterval::operator=(const RooStats::SimpleInterval&); virtual voidTObject::Paint(Option_t* option = """"); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestInverterResult.html:4612,Simpl,SimpleInterval,4612,root/html532/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestInverterResult.html,1,['Simpl'],['SimpleInterval']
Usability,"ist::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual voidDestroyed()SIGNAL ; Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQConnection.html:2160,Clear,Clear,2160,root/html602/TQConnection.html,https://root.cern,https://root.cern/root/html602/TQConnection.html,2,['Clear'],['Clear']
Usability,"ist< T > IL);  ; template<typename V , unsigned M, typename = std::enable_if<std::is_convertible<V, bool>::value>> ; RVecN operator[] (const RVecN< V, M > &conds) const;  ; reference operator[] (size_type idx);  ; const_reference operator[] (size_type idx) const;  ;  Public Member Functions inherited from ROOT::Detail::VecOps::RVecImpl< T >;  RVecImpl (const RVecImpl &)=delete;  ;  ~RVecImpl ();  ; template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> ; void append (in_iter in_start, in_iter in_end);  Add the specified range to the end of the SmallVector. ;  ; void append (size_type NumInputs, const T &Elt);  Append NumInputs copies of Elt to the end. ;  ; void append (std::initializer_list< T > IL);  ; template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> ; void assign (in_iter in_start, in_iter in_end);  ; void assign (size_type NumElts, const T &Elt);  ; void assign (std::initializer_list< T > IL);  ; void clear ();  ; template<typename... ArgTypes> ; reference emplace_back (ArgTypes &&...Args);  ; iterator erase (const_iterator CI);  ; iterator erase (const_iterator CS, const_iterator CE);  ; iterator insert (iterator I, const T &Elt);  ; template<typename ItTy , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<ItTy>::iterator_category, std::input_iterator_tag>::value>::type> ; iterator insert (iterator I, ItTy From, ItTy To);  ; iterator insert (iterator I, size_type NumToInsert, const T &Elt);  ; void insert (iterator I, std::initializer_list< T > IL);  ; iterator insert (iterator I, T &&Elt);  ; RVecImpl & operator= (const RVecImpl &RHS);  ; RVecImpl & operator= (RVecImpl &&RHS);  ; void pop_back_n (size_type NumItems);  ; T pop_back_val ();  ; void reserve (size_type N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVecN.html:4110,clear,clear,4110,doc/master/classROOT_1_1VecOps_1_1RVecN.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVecN.html,1,['clear'],['clear']
Usability,"ist_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPointSet3D::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEvePointSet.html:3366,Clear,ClearStamps,3366,root/html532/TEvePointSet.html,https://root.cern,https://root.cern/root/html532/TEvePointSet.html,4,['Clear'],['ClearStamps']
Usability,"ist_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrack.html:2837,Clear,ClearStamps,2837,root/html532/TEveTrack.html,https://root.cern,https://root.cern/root/html532/TEveTrack.html,1,['Clear'],['ClearStamps']
Usability,"ist_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTEveTrack::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrackProjected.html:2647,Clear,ClearStamps,2647,root/html532/TEveTrackProjected.html,https://root.cern,https://root.cern/root/html532/TEveTrackProjected.html,1,['Clear'],['ClearStamps']
Usability,"ist_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPointSet3D::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveLine.html:2710,Clear,ClearStamps,2710,root/html532/TEveLine.html,https://root.cern,https://root.cern/root/html532/TEveLine.html,6,['Clear'],['ClearStamps']
Usability,"istogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUnfoldSys.html:6108,Clear,Clear,6108,root/html532/TUnfoldSys.html,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html,1,['Clear'],['Clear']
Usability,"it package, which remains one of the fastest tools for neural networks studies.; 5.12.2 The MLP; The multilayer perceptron is a simple feed-forward network with the following structure showed on the left. It is made of neurons characterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; Such a structure is very useful because of two theorems:; 1- A linear combination of sigmoids can approximate any continuous function.; 2- Trained with output=1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X.; 5.12.3 Learning Methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for a synapse). This computation is called “back-propagation of the errors”. Six learning methods are implemented.; 5.12.3.1 Stochastic Minimization; This is the most trivial learning method. The Robbins-Monro stochastic approximation is applied to multilayer perceptrons. The weights are updated after each example according to the formula:; \[; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); \]; with:; \[; \Delta w_{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:231870,learn,learning,231870,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Learn', 'learn']","['Learning', 'learning']"
Usability,it tutorial macro #903 ;  rf903_numintcache.py;  ► roostats;  CreateExampleFile.C;  FourBinInstructional.C This example is a generalization of the on/off problem ;  HybridInstructional.C Example demonstrating usage of HybridCalcultor ;  HybridOriginalDemo.C Example on how to use the HybridCalculatorOriginal class ;  HybridStandardForm.C A hypothesis testing example based on number counting with background uncertainty ;  IntervalExamples.C Example showing confidence intervals with four techniques ;  JeffreysPriorDemo.C tutorial demonstrating and validates the RooJeffreysPrior class ;  ModelInspector.CRooStats Model Inspector ;  MultivariateGaussianTest.C Comparison of MCMC and PLC in a multi-variate gaussian problem ;  NuMuToNuE_Oscillation.cxx;  NuMuToNuE_Oscillation.h;  OneSidedFrequentistUpperLimitWithBands.C OneSidedFrequentistUpperLimitWithBands ;  rs101_limitexample.C 'Limit Example' RooStats tutorial macro #101 This tutorial shows an example of creating a simple model for a number counting experiment with uncertainty on both the background rate and signal efficiency ;  rs102_hypotestwithshapes.C rs102_hypotestwithshapes for RooStats project ;  rs301_splot.C SPlot tutorial ;  rs401c_FeldmanCousins.C Produces an interval on the mean signal in a number counting experiment with known background using the Feldman-Cousins technique ;  rs401d_FeldmanCousins.C 'Neutrino Oscillation Example from Feldman & Cousins' ;  rs601_HLFactoryexample.C 'High Level Factory Example' RooStats tutorial macro #601 ;  rs602_HLFactoryCombinationexample.C 'High Level Factory Example' RooStats tutorial macro #602 ;  rs603_HLFactoryElaborateExample.C 'High Level Factory Example' RooStats tutorial macro #602 ;  rs701_BayesianCalculator.C 'Bayesian Calculator' RooStats tutorial macro #701 ;  rs801_HypoTestInverterOriginal.C 'Hypothesis Test Inversion' RooStats tutorial macro #801 ;  rs_bernsteinCorrection.C 'Bernstein Correction' RooStats tutorial macro ;  rs_numberCountingCombination.C 'Numb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:159485,simpl,simple,159485,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"it).Definition TGMenu.cxx:1782; TGPopupMenu::DisableEntryvirtual void DisableEntry(Int_t id)Disable entry (disabled entries appear in a sunken relieve).Definition TGMenu.cxx:1724; TGPopupMenu::UnCheckEntryvirtual void UnCheckEntry(Int_t id)Uncheck menu entry (i.e. remove check mark).Definition TGMenu.cxx:1807; TGPopupMenu::Associatevirtual void Associate(const TGWindow *w)Definition TGMenu.h:206; TGPopupMenu::AddSeparatorvirtual void AddSeparator(TGMenuEntry *before=nullptr)Add a menu separator to the menu.Definition TGMenu.cxx:1060; TGPopupMenu::AddEntryvirtual void AddEntry(TGHotString *s, Int_t id, void *ud=nullptr, const TGPicture *p=nullptr, TGMenuEntry *before=nullptr)Add a menu entry.Definition TGMenu.cxx:990; TGProgressBar::SetPositionvoid SetPosition(Float_t pos)Set progress position between [min,max].Definition TGProgressBar.cxx:92; TGProgressBar::SetFillTypevoid SetFillType(EFillType type)Set fill type.Definition TGProgressBar.cxx:136; TGProgressBar::SetBarColorvirtual void SetBarColor(Pixel_t color)Set progress bar color.Definition TGProgressBar.cxx:156; TGProgressBar::kBlockFill@ kBlockFillDefinition TGProgressBar.h:23; TGSelectBoxThis class represent a specialized expression editor for TTVLVEntry 'true name' and 'alias' data memb...Definition TTVLVContainer.h:157; TGSelectBox::EditedEntryTTVLVEntry * EditedEntry()Definition TTVLVContainer.h:181; TGSelectBox::InsertTextvoid InsertText(const char *text)Insert text in text entry.Definition TTVLVContainer.cxx:825; TGSelectBox::GrabPointervoid GrabPointer()Just focus the cursor inside.Definition TTVLVContainer.cxx:755; TGSelectBox::SetLabelvoid SetLabel(const char *title)Set label of selection box.Definition TTVLVContainer.cxx:769; TGSelectBox::SetEntryvoid SetEntry(TTVLVEntry *entry)Connect one entry.Definition TTVLVContainer.cxx:814; TGSelectBox::GetInstancestatic TGSelectBox * GetInstance()Return the pointer to the instantiated singleton.Definition TTVLVContainer.cxx:747; TGStatusBarProvides a StatusBar w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:127437,progress bar,progress bar,127437,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,it;  GaussFunction.h;  MinimizerTypes.h;  testFitPerf.cxx;  ► genvector;  vectorOperation.cxx;  ► mandelbrot;  main.cpp;  main.h;  mandel.cpp;  mandel.h;  ► matrix;  main.cpp;  ► polarcoord;  main.cpp;  ► smatrix;  matrix_op_vec.h;  matrix_util.h;  testKalman.cxx;  testOperations.cxx;  TestTimer.h;  tsc.h;  ► include;  ► Vc;  ► avx;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  sorthelper.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  writemaskedvector.h;  ► common;  aliasingentryhelper.h;  bitscanintrinsics.h;  deinterleave.h;  exponential.h;  fix_clang_emmintrin.h;  iif.h;  interleavedmemory.h;  logarithm.h;  macros.h;  memory.h;  memorybase.h;  memoryfwd.h;  operand.h;  operators.h;  storage.h;  support.h;  trigonometric.h;  types.h;  undomacros.h;  vectortuple.h;  windows_fix_intrin.h;  ► internal;  namespace.h;  ► scalar;  helperimpl.h;  limits.h;  macros.h;  mask.h;  math.h;  types.h;  undomacros.h;  vector.h;  writemaskedvector.h;  ► sse;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  cpuid.h;  global.h;  support.h;  vector.h;  version.h;  ► src;  avx_sorthelper.cpp;  const.cpp;  cpuid.cpp;  support.cpp;  trigonometric.cpp;  ► tests;  arithmetics.cpp;  casts.cpp;  const.h;  convert-sincos-reference.cpp;  deinterleave.cpp;  expandandmerge.cpp;  gather.cpp;  implicit_type_conversion.cpp;  implicit_type_conversion_failures.cpp;  linkTest0.cpp;  linkTest1.cpp;  linkTestLib0.cpp;  linkTestLib1.cpp;  linkTestLib2.cpp;  linkTestLib3.cpp;  load.cpp;  mask.cpp;  math.cpp;  memory.cpp;  scalaraccess.cpp;  scatter.cpp;  sse_blend.cpp;  stlcontainer.cpp;  store.cpp;  supportfunctions.cpp;  swizzles.cpp;  ulp.h;  unittest.h;  utils.cpp;  vectormemoryhelper.h;  makeTest.py;  ► vdt;  ► include;  ► vdt;  asin.h;  atan.h;  atan2.h;  cos.h;  exp.h;  inv.h;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:58768,undo,undomacros,58768,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,2,['undo'],['undomacros']
Usability,"itance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of the same name on all members of the collection. For example, the list of graphics primitives are in a ROOT collection called TList. When the canvas is drawn, the Paint method is executed on the entire collection. Each member may be a different class, and if the Paint method is not implemented, TObject::Paint will be executed.; 15.1.3 Input/Output; The TObject::Write method is the interface to the ROOT I/O system. It streams the object into a buffer using the Streamer method. It supports cycle numbers and automatic schema evolution. See “Input/Output”.; 15.1.4 Paint/Draw; These graphics methods are defaults; their implementation in TObject does not use the graphics subsystem. The TObject::Draw method is simply a call to AppendPad. The Paint method is empty. The default is provided so that one can call Paint in a collection. The method GetDrawOption returns the draw option that was used when the object was drawn on the canvas. This is especially relevant with histograms and graphs.; 15.1.5 Clone/DrawClone; Two useful methods are Clone and DrawClone. The Clone method takes a snapshot of the object with the Streamer and creates a new object. The DrawClone method does the same thing and in addition draws the clone.; 15.1.6 Browse; This method is called if the object is browse-able and is to be displayed in the object browser. For example the TTree implementation of Browse, calls the Browse method for each branch. The TBranch::Browse method displays the name of each leaf. For the object’s Browse method to be called, the IsFolder() method must be overridden to return true. This does not mean it has to be a folder, it just means that it is browse-able.; 15.1.7 SavePrimitive; This method is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:807271,simpl,simply,807271,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"ite; kWriteDelete; };. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-12 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBenchmark.html:7132,resume,resume,7132,root/html534/TBenchmark.html,https://root.cern,https://root.cern/root/html534/TBenchmark.html,2,['resume'],['resume']
Usability,"iteFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAlphaColorSelected(ULong_t)SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidColorSelected(Pixel_t)SIGNAL ; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGColorDialog.html:2267,Clear,Clear,2267,root/html534/TGColorDialog.html,https://root.cern,https://root.cern/root/html534/TGColorDialog.html,3,['Clear'],['Clear']
Usability,"iterator to be incremented and an iterator that points to the end of the collection, respectively. ;  ;  Static Public Attributes inherited from TVirtualCollectionProxy; static const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to store iterator-specific information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedMapProxy.html:11411,clear,clear,11411,doc/master/classTEmulatedMapProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedMapProxy.html,1,['clear'],['clear']
Usability,"iterator, (*pattern_it).output ().at (0),; 861 (*pattern_it).weight ());; 862 ++output_iterator;; 863 }; 864 }; 865 }; 866 testError += testPatternError; /// batch.size ();; 867 }; 868 // testError /= testPattern.size ();; 869 }; 870 settings.endTestCycle ();; 871// testError /= weightSum;; 872 ; 873 settings.computeResult (*this, weights);; 874 ; 875 hasConverged = settings.hasConverged (testError);; 876 if (!hasConverged && !isWeightsForDrop); 877 {; 878 dropOutWeightFactor (weights, dropFractions, true); // inverse; 879 isWeightsForDrop = true;; 880 }; 881 }; 882 ++testCycleCount;; 883 ++dropOutChangeCount;; 884 ; 885 ; 886// settings.resetPlot (""errors"");; 887 settings.addPoint (""trainErrors"", cycleCount, trainError);; 888 settings.addPoint (""testErrors"", cycleCount, testError);; 889 settings.plot (""trainErrors"", ""C"", 1, kBlue);; 890 settings.plot (""testErrors"", ""C"", 1, kMagenta);; 891 ; 892 ; 893 // setup error plots and progress bar variables for JsMVA; 894 if (fInteractive){; 895 fInteractive->AddPoint(cycleCount, trainError, testError);; 896 if (*fExitFromTraining) break;; 897 *fIPyCurrentIter = 100*(double)settings.maxConvergenceCount () /(double)settings.convergenceSteps ();; 898 }; 899 ; 900 if (hasConverged); 901 break;; 902 ; 903 if ((int)cycleCount % 10 == 0) {; 904 ; 905 TString convText = TString::Format( ""(train/test/epo/conv/maxco): %.3g/%.3g/%d/%d/%d"",; 906 trainError,; 907 testError,; 908 (int)cycleCount,; 909 (int)settings.convergenceCount (),; 910 (int)settings.maxConvergenceCount ());; 911 double progress = 100*(double)settings.maxConvergenceCount () /(double)settings.convergenceSteps ();; 912 settings.cycle (progress, convText);; 913 }; 914 }; 915 while (true);; 916 settings.endTrainCycle (trainError);; 917 ; 918 TString convText = TString::Format( ""(train/test/epoch): %.4g/%.4g/%d"", trainError, testError, (int)cycleCount);; 919 double progress = 100*(double)settings.maxConvergenceCount() /(double)settings.convergenceSteps ();; 920 settings.cy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:27067,progress bar,progress bar,27067,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['progress bar'],['progress bar']
Usability,"ith Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » News Workshops. Here the list with ROOT workshops:. ROOT 2018 ; ROOT 2015 ; ROOT 2013 (slides); ROOT 2007 (slides); ROOT 2005 (slides); ROOT 2007; ROOT 2002 (slides); ROOT 2001 (slides); ROOT 2000 (slides); ROOT 1999 slides ; And PROOF workshops:; PROOF 2007 (slides). Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/workshops.html:2351,guid,guidelines,2351,d/workshops.html,https://root.cern,https://root.cern/d/workshops.html,1,['guid'],['guidelines']
Usability,"ith a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candledecay.C Candle Decay, illustrate a time development of a certain value ;  candlehisto.C Example showing how to combine the various candle plot options ;  candleplot.C Example of candle plot with 2-D histograms ;  candleplotoption.C Example showin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:121453,simpl,simple,121453,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,4,['simpl'],['simple']
Usability,"ith a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candleplot.C Example of candle plot with 2-D histograms ;  candleplotoption.C Example showing how to combine the various candle plot options ;  candleplotstack.C Example showing how a THStack with candle plot option ;  candleplotwhiskers.C Example of c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:120686,simpl,simple,120686,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"ith complicated, phase space; : dependent nonlinear correlations.; : ; : Please consult the Users Guide for the format of the formula string; : and the allowed parameter ranges:; : documentation/tmva/UsersGuide/TMVAUsersGuide.pdf; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : The FDA performance depends on the complexity and fidelity of the; : user-defined discriminator function. As a general rule, it should; : be able to reproduce the discrimination power of any linear; : discriminant analysis. To reach into the nonlinear domain, it is; : useful to inspect the correlation profiles of the input variables,; : and add quadratic and higher polynomial terms between variables as; : necessary. Comparison with more involved nonlinear classifiers can; : be used as a guide.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : Depending on the function used, the choice of ""FitMethod"" is; : crucial for getting valuable solutions with FDA. As a guideline it; : is recommended to start with ""FitMethod=MINUIT"". When more complex; : functions are used where MINUIT does not converge to reasonable; : results, the user should switch to non-gradient FitMethods such; : as GeneticAlgorithm (GA) or Monte Carlo (MC). It might prove to be; : useful to combine GA (or MC) with MINUIT by setting the option; : ""Converger=MINUIT"". GA (MC) will then set the starting parameters; : for MINUIT such that the basic quality of GA (MC) of finding global; : minima is combined with the efficacy of MINUIT of finding local; : minima.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; FitterBase : <GeneticFitter> Optimisation, please be patient ... (inaccurate progress timing for GA); : Elapsed time: 0.901 sec ; FDA_GA : Results for parameter fit using ""GA"" fitter:; : -----------------------; : Parameter: Fit result:; : -----------------------; : Par(0): 0.525294; : Par(1): 0; : Par(2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:39923,guid,guideline,39923,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['guid'],['guideline']
Usability,"ith less then 10 effective; number of events'; igood=2'There is a bin in the 2nd histogram with less then 10 effective; number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'. - chi2 - chisquare of the test; - ndf - number of degrees of freedom (important, when both histograms have the same; empty bins); - res - normalized residuals for further analysis. Double_t Chisquare(TF1* f1, Option_t* option = """") const; Compute and return the chisquare of this histogram with respect to a function; The chisquare is computed by weighting each histogram point by the bin error; By default the full range of the histogram is used.; Use option ""R"" for restricting the chisquare calculation to the given range of the function. void ClearUnderflowAndOverflow(); Remove all the content from the underflow and overflow bins, without changing the number of entries; After calling this method, every undeflow and overflow bins will have content 0.0; The Sumw2 is also cleared, since there is no more content in the bins. Double_t ComputeIntegral(Bool_t onlyPositive = false); Compute integral (cumulative sum of bins); The result stored in fIntegral is used by the GetRandom functions.; This function is automatically called by GetRandom when the fIntegral; array does not exist or when the number of entries in the histogram; has changed since the previous call to GetRandom.; The resulting integral is normalized to 1; If the routine is called with the onlyPositive flag set an error will; be produced in case of negative bin content and a NaN value returned. Double_t * GetIntegral(); Return a pointer to the array of bins integral.; if the pointer fIntegral is null, TH1::ComputeIntegral is called; The array dimension is the number of bins in the histograms; including underflow and overflow (fNCells); the last value integral[fNCells] is set to the number of entries of; the histogram. TH1 * GetCumulative(Bool_t forward = kTRUE, const char* suffix = ""_cumulative"") const; Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:60628,clear,cleared,60628,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,4,['clear'],['cleared']
Usability,"itialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent); virtual voidUpdateValueClass(const TClass* oldcl, TClass* newcl). private:. TGenCollectionProxy&operator=(const TGenCollectionProxy&); TGenCollectionProxy(). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tfCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tfConstructContainer accessors: block construct; map<string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tfDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tfFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tfFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tfFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tfFunctionDeleteIterator; TVirtualCollectionProxy::DeleteTwoIterators_tfFunctionDeleteTwoIterators; TVirtualCollectionProxy::Next_tfFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenCollectionProxy.html:4344,clear,clear,4344,root/html602/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html,4,['clear'],['clear']
Usability,iting nested parallelism through TTaskGroup ;  mt303_AsyncSimple.C Shows how to run items of work asynchronously with Async ;  mt304_AsyncNested.C Calculate Fibonacci numbers exploiting nested parallelism through Async ;  mt304_fillHistos.CFill histograms in parallel with automatic binning ;  mt305_TFuture.C Shows how to use the Future class of ROOT as a wrapper of std::future ;  mtbb001_fillHistos.C Fill histograms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:136305,simpl,simple,136305,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"ition BinData.h:56; ROOT::Fit::BinData::kNoError@ kNoErrorDefinition BinData.h:56; ROOT::Fit::BinData::kCoordError@ kCoordErrorDefinition BinData.h:56; ROOT::Fit::BinData::kAsymError@ kAsymErrorDefinition BinData.h:56; ROOT::Fit::BinData::kValueError@ kValueErrorDefinition BinData.h:56; ROOT::Fit::BinData::GetPointconst double * GetPoint(unsigned int ipoint, double &value, double &invError) constretrieve in a single call a pointer to the coordinate data, value and inverse error for the given fit...Definition BinData.h:439; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Fit::FitDataBase class for all the fit data types: Stores the coordinates and the DataOptions.Definition FitData.h:56; ROOT::Fit::FitData::fMaxPointsunsigned int fMaxPointsDefinition FitData.h:384; ROOT::Fit::FitData::fWrappedbool fWrappedDefinition FitData.h:376; ROOT::Fit::FitData::fDimunsigned int fDimDefinition FitData.h:386; ROOT::Fit::FitData::Coordsconst double * Coords(unsigned int ipoint) constreturn a pointer to the coordinates data for the given fit pointDefinition FitData.h:236; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; ValueDefinition functioncalls.h:15. mathmathcoreincFitBinData.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:31822,simpl,simple,31822,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['simpl'],['simple']
Usability,"ition TQCommand.cxx:588. Merged commands It possible to group several commands together so an end user can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad.h:308; TQCommand::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the list of merged commands.Definition TQCommand.cxx:360. Macro commands ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:3872,undo,undo,3872,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"ition at line 1186 of file TApplication.cxx. ◆ HandleException(). void TApplication::HandleException ; (; Int_t ; sig). virtual . Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in TSystem. ; Specific TApplication implementations may want something different here. ; Reimplemented in TRint, and TProofServ.; Definition at line 590 of file TApplication.cxx. ◆ HandleIdleTimer(). void TApplication::HandleIdleTimer ; (; ). virtual . Handle idle timeout. ; When this timer expires the registered idle command will be executed by this routine and a signal will be emitted. ; Definition at line 577 of file TApplication.cxx. ◆ HandleTermInput(). virtual Bool_t TApplication::HandleTermInput ; (; ). inlinevirtual . Reimplemented in TRint.; Definition at line 116 of file TApplication.h. ◆ Help(). void TApplication::Help ; (; const char * ; line). protectedvirtual . The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ; NoteYou can use "".?"" as the short version of "".help"" ; Parameters. [in]linecommand from the command line . Definition at line 1208 of file TApplication.cxx. ◆ Hide(). virtual void TApplication::Hide ; (; ). inlinevirtual . Definition at line 130 of file TApplication.h. ◆ Iconify(). virtual void TApplication::Iconify ; (; ). inlinevirtual . Definition at line 131 of file TApplication.h. ◆ Init(). virtual void TApplication::Init ; (; ). inlinevirtual . Definition at line 117 of file TApplication.h. ◆ InitializeGraphics(). void TApplication::InitializeGraphics ; (; Bool_t ; only_web = kFALSE). Initialize the graphics environment. ; IfParameters. only_webis specified, only web-related part of graphics is loaded . Definition at line 244 of file TApplication.cxx. ◆ InputFiles(). TObjArray * TApplication::InputFiles ; (; ); const. inline . Definition at line 146 of file TApplication.h. ◆ IsA(). TClass * TApplication::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:29034,guid,guide,29034,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['guid'],['guide']
Usability,"ition; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoConeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifing current parameters. void DoUndo(); Slot for undoing current operation. void DoRmin1(); Slot for Rmin1. void DoRmax1(); Slot for Rmax1. void DoRmin2(); Slot for Rmin2. void DoRmax2(); Slot for Rmax2. void DoDz(); Slot for Dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeEditor.html:21598,undo,undoing,21598,root/html534/TGeoConeEditor.html,https://root.cern,https://root.cern/root/html534/TGeoConeEditor.html,2,['undo'],['undoing']
Usability,"itive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree until it reaches an ancestor without a parent. To serialize the object data members it calls their Streamer. They in turn move up their own inheritance tree and so forth. The simple data members are written to the buffer directly. Eventually the buffer contains all simple data members of all the classes that make up this particular object. Data members that are references (as MyClass &fObj;) are never saved, it is always the responsibility of the object’s constructor to set them properly.; 11.3.1 Automatically Generated Streamers; A Streamerusually calls other Streamers: the Streamerof its parents and data members. This architecture depends on all classes having Streamers, because eventually they will be called. To ensure that a class has a Streamer, rootcling automatically creates one in the ClassDef macro that is defined in $ROOTSYS/include/Rtypes.h. ClassDef defines several methods for any class, and one of them is the Streamer. The automatically generated Streameris complete and can be used as long as no customization is needed.; The Event class is defined in $ROOTSYS/test/Event.h. Looking at the class definition, we find that it inherits from TObject. It is a simple example of a class with diverse data members.; class Event : public TObject {; private:; TDirect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:466856,simpl,simple,466856,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"itle to stringy,etc. TGraph2D(Int_t n); Graph2D constructor. The arrays fX, fY and fZ should be filled via; calls to SetPoint. TGraph2D(const char* filename, const char* format = ""%lg %lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. TGraph2D(const TGraph2D& ); Graph2D copy constructor. ~TGraph2D(); TGraph2D destructor. TGraph2D& operator=(const TGraph2D& ); Graph2D operator ""="". void Build(Int_t n); Creates the 2D graph basic data structure. void Clear(Option_t* option = """"); Free all memory allocated by this object. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the graph to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from point px,py to a graph. void Draw(Option_t* option = """"); Specific drawing options can be used to paint a TGraph2D:. ""TRI"" : The Delaunay triangles are drawn using filled area.; An hidden surface drawing technique is used. The surface is; painted with the current fill area color. The edges of each; triangles are painted with the current line color.; ""TRIW"" : The Delaunay triangles are drawn as wire frame; ""TRI1"" : The Delaunay triangles are painted with color levels. The edges; of each triangles are painted with the current line color.; ""TRI2"" : the Delaunay triangles are painted with color levels.; ""P"" : Draw a marker a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraph2D.html:19395,Clear,Clear,19395,root/html532/TGraph2D.html,https://root.cern,https://root.cern/root/html532/TGraph2D.html,1,['Clear'],['Clear']
Usability,"itle, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. void initializeMinimizer() const. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. MINIMIZER* minimizer(); { return _minimizer ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. Int_t numEval() const; { return _neval ; }. » Last changed: Tue Jun 2 15:33:08 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooProfileLL.html:40251,clear,clearAbsMin,40251,root/html604/RooProfileLL.html,https://root.cern,https://root.cern/root/html604/RooProfileLL.html,2,['clear'],['clearAbsMin']
Usability,"itlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THbookTree.html:3919,undo,undo,3919,root/html528/THbookTree.html,https://root.cern,https://root.cern/root/html528/THbookTree.html,10,['undo'],['undo']
Usability,"itor objects. ;  ; void MarkBad (TSocket *s, const char *reason=0);  Add slave with socket s to the bad slave list and remove if from the active list and from the two monitor objects. ;  ; Int_t ModifyWorkerLists (const char *ord, Bool_t add, Bool_t save);  Modify the worker active/inactive list by making the worker identified by the ordinal number 'ord' active (add == TRUE) or inactive (add == FALSE). ;  ; void NotifyLogMsg (const char *msg, const char *sfx=""\n"");  Notify locally 'msg' to the appropriate units (file, stdout, window) If defined, 'sfx' is added after 'msg' (typically a line-feed);. ;  ; void operator= (const TProof &);  ; void ParseConfigField (const char *config);  The config file field may contain special instructions which need to be parsed at the beginning, e.g. ;  ; Int_t Ping (ESlaves list);  Ping PROOF slaves. Returns the number of slaves that responded. ;  ; void PrintProgress (Long64_t total, Long64_t processed, Float_t procTime=-1., Long64_t bytesread=-1);  Print a progress bar on stderr. Used in batch mode. ;  ; Bool_t Prompt (const char *p);  Prompt the question 'p' requiring an answer y,Y,n,N Return kTRUE is the answer was y or Y, kFALSE in all other cases. ;  ; void RecvLogFile (TSocket *s, Int_t size);  Receive the log file of the slave with socket s. ;  ; void RedirectWorker (TSocket *s, TSlave *sl, Int_t output_size);  Redirect output of worker sl to some merger. ;  ; void ReleaseMonitor (TMonitor *mon);  Release the used monitor to be used, making sure to delete newly created monitors. ;  ; void ResetMergePrg ();  Reset the merge progress notificator. ;  ; void ResetMergers ();  ; Int_t RestoreActiveList ();  Restore saved list of active workers. ;  ; void SaveActiveList ();  Save current list of active workers. ;  ; Int_t SendCommand (const char *cmd, ESlaves list=kActive);  Send command to be executed on the PROOF master and/or slaves. ;  ; Int_t SendCurrentState (ESlaves list=kActive);  Transfer the current state of the master to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:51711,progress bar,progress bar,51711,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['progress bar'],['progress bar']
Usability,itor.cxx. ◆ CreateBinTab(). void TH1Editor::CreateBinTab ; (; ). protected . Create binning tab. ; Definition at line 340 of file TH1Editor.cxx. ◆ Dividers(). Int_t * TH1Editor::Dividers ; (; Int_t ; n). Return an array of dividers of n (without the trivial divider n). ; The number of dividers is saved in the first entry. ; Definition at line 2417 of file TH1Editor.cxx. ◆ DoAddB(). void TH1Editor::DoAddB ; (; Bool_t ; on). virtual . Slot connected to the bar Add check box. ; Definition at line 948 of file TH1Editor.cxx. ◆ DoAddBar(). void TH1Editor::DoAddBar ; (; Bool_t ; on). virtual . Slot connected to the bar Add check box. ; Definition at line 991 of file TH1Editor.cxx. ◆ DoAddMarker(). void TH1Editor::DoAddMarker ; (; Bool_t ; on). virtual . Slot connected to the show markers check box. ; Definition at line 902 of file TH1Editor.cxx. ◆ DoAddSimple(). void TH1Editor::DoAddSimple ; (; Bool_t ; on). virtual . Slot connected to fAddSimple check box for drawing a simple histogram without errors (== HIST draw option) in combination with some other draw options. ; It draws an additional line on the top of the bins. ; Definition at line 1092 of file TH1Editor.cxx. ◆ DoApply(). void TH1Editor::DoApply ; (; ). virtual . Slot connected to the Apply button of the Binning tab. ; Definition at line 2128 of file TH1Editor.cxx. ◆ DoAxisRange(). void TH1Editor::DoAxisRange ; (; ). virtual . Slot connected to the number entry fields containing the Max/Min value of the x-axis. ; Definition at line 1658 of file TH1Editor.cxx. ◆ DoBarOffset(). void TH1Editor::DoBarOffset ; (; ). virtual . Slot connected to the Bar Offset of the Bar Charts. ; Definition at line 1404 of file TH1Editor.cxx. ◆ DoBarWidth(). void TH1Editor::DoBarWidth ; (; ). virtual . Slot connected to the Bar Width of the Bar Charts. ; Definition at line 1394 of file TH1Editor.cxx. ◆ DoBinLabel(). void TH1Editor::DoBinLabel ; (; ). virtual . Slot connected to the Bin number entry of the Rebinning tab. ; Definition at ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:47339,simpl,simple,47339,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,1,['simpl'],['simple']
Usability,"its are set.; 1152/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 1153/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:40720,simpl,simple,40720,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['simpl'],['simple']
Usability,"its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is cleaned; upon destruction. Let's consider positioning now our wire in the middle of a gas chamber. We; need first to define the gas chamber :. TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);. Now we can put the wire inside :. chamber->AddNode(wire_co, 1);. If we inspect now the chamber volume in a browser, we will notice that it has; one daughter. Of course the gas has some container also, but let's keep it like; that for the sake of simplicity. The full prototype of AddNode() is :. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity). Since we did not supplied the third argument, the wire will be positioned with; an identity transformation inside the chamber. One will notice that the inner; radii of the wire and chamber are both zero - therefore, aren't the two volumes; overlapping ? The answer is no, the modeler is even relaying on the fact that; any daughter is fully contained by its mother. On the other hand, neither of; the nodes positioned inside a volume should overlap with each other. We will; see that there are allowed some exceptions to those rules. Overlapping volumes. Positioning volumes that does not overlap their neighbours nor extrude; their container is sometimes quite strong constraint. Some parts of the geometry; might overlap naturally, e.g. two crossing tubes. The modeller supports such; cases only if the overlapping",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:5867,simpl,simplicity,5867,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,18,['simpl'],['simplicity']
Usability,"its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is cleaned; upon destruction. Let's consider positioning now our wire in the middle of a gas chamber. We; need first to define the gas chamber :. TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);. Now we can put the wire inside :. chamber->AddNode(wire_co, 1);. If we inspect now the chamber volume in a browser, we will notice that it has; one daughter. Of course the gas has some container also, but let's keep it like; that for the sake of simplicity. The full prototype of AddNode() is :. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity). Since we did not supplied the third argument, the wire will be positioned with; an identity transformation inside the chamber. One will notice that the inner; radii of the wire and chamber are both zero - therefore, aren't the two volumes; overlapping ? The answer is no, the modeler is even relaying on the fact that; any daughter is fully contained by its mother. On the other hand, neither of; the nodes positioned inside a volume should overlap with each other. We will; see that there are allowed some exceptions to those rules. Overlapping volumes. Positioning volumes that does not overlap their neighbours nor extrude; their container is sometimes quite strong contrain. Some parts of the geometry; might overlap naturally, e.g. two crossing tubes. The modeller supports such; cases only if the overlapping n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:5847,simpl,simplicity,5847,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,12,['simpl'],['simplicity']
Usability,"its { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TBranchBrowsable.h>. Inheritance diagram for TMethodBrowsable:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~TMethodBrowsable(). TMethodBrowsable::~TMethodBrowsable ; (; ). inlineoverride . Definition at line 105 of file TBranchBrowsable.h. ◆ TMethodBrowsable(). TMethodBrowsable::TMethodBrowsable ; (; const TBranch * ; branch, . TMethod * ; m, . const TVirtualBranchBrowsable * ; parent = nullptr . ). protected . Constructor. ; Links a TBranchElement to a TMethod, allowing the TBrowser to browse simple methods.; The c'tor sets the name for a method ""Class::Method(params) const"" to ""Method(params)"", title to TMethod::GetPrototype ; Definition at line 409 of file TBranchBrowsable.cxx. Member Function Documentation. ◆ Class(). static TClass * TMethodBrowsable::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMethodBrowsable::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMethodBrowsable::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 128 of file TBranchBrowsable.h. ◆ DeclFileName(). static const char * TMethodBrowsable::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 128 of file TBranchBrowsable.h. ◆ GetBrowsableMethodsForClass(). void TMethodBrowsable::GetBrowsableMethodsForClass ; (; TClass * ; cl, . TList & ; li . ). staticprotected ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodBrowsable.html:16280,simpl,simple,16280,doc/master/classTMethodBrowsable.html,https://root.cern,https://root.cern/doc/master/classTMethodBrowsable.html,1,['simpl'],['simple']
Usability,"itsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TToggleGroup.html:7141,clear,clears,7141,root/html604/TToggleGroup.html,https://root.cern,https://root.cern/root/html604/TToggleGroup.html,2,['clear'],['clears']
Usability,"itsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TToggleGroup.html:7141,clear,clears,7141,root/html602/TToggleGroup.html,https://root.cern,https://root.cern/root/html602/TToggleGroup.html,2,['clear'],['clears']
Usability,"itted by Anonymous (not verified) on Thu, 07/23/2015 - 21:48 Permalink . Other Python bindings . I noticed that there are multiple other ways to call C++ code from Python, one of them being included in the Boost library. What would it do to the complexity (and dependencies) to use an interface that doesn't build on top of CINT/Reflex?. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Re: Other Python bindings . Hi Bram,; Thanks for your question. The main issue about the boost binding is that it is - as far as I understand - completely static and intrusive. PyROOT on the other hand is based on refection data, and it has features that e.g. the Boost binding doesn't offer (e.g. the mapping of concepts). Other bindings (e.g. SWIG-based ones) are difficult to maintain, not compatible with C++, and don't offer PyROOT's features either. So the cost is both on the implementation side and the feature side. Thus why not simply use PyROOT? :-); Note that we will soon have a PyROOT that builds on top of clang, as part of ROOT 6. I think Wim (the author of PyROOT) plans to port it to a version without ROOT, likely involving PyPy. So that might be exactly what you are looking for :-); Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Re: Other Python bindings . Hi Bram, Axel,; let me add to that (and point out that none of the mentioned tools are intrusive, btw.). The biggest problem with boost.python (with pyste; standalone it is a non-starter) and SWIG is that you need to run a separate tool to create and compile bindings. On top, these bindings are compiled against a specific version of Python, making for a distribution headache (just see the non-pickup of Python3 because of this problem). Compare: dictionaries are already available for all the most important classes in experiments, the EDM, because they are generated for I/O needs. They also do not depend on Python, and thus not on any specific version (onl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:6205,simpl,simply,6205,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simply']
Usability,"ity = kDefaultCapacity); Create an ordered collection. ~TOrdCollection(); Delete the collection. Objects are not deleted unless the TOrdCollection; is the owner (set via SetOwner()). void AddAt(TObject* obj, Int_t idx); Insert object at position idx in the collection. void AddFirst(TObject* obj); Insert object at beginning of collection. void AddLast(TObject* obj); Add object at the end of the collection. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the collection. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the collection. TObject * After(const TObject* obj) const; Return the object after object obj. Returns 0 if obj is last; in collection. TObject * At(Int_t idx) const; Returns the object at position idx. Returns 0 if idx is out of range. TObject * Before(const TObject* obj) const; Returns the object before object obj. Returns 0 if obj is first; in collection. void Clear(Option_t* option = """"); Remove all objects from the collection. Does not delete the objects; unless the TOrdCollection is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the collection AND delete all heap based objects. TObject * First() const; Return the first object in the collection. Returns 0 when collection; is empty. TObject ** GetObjectRef(const TObject* obj) const; return address of pointer obj. TObject * Last() const; Return the last object in the collection. Returns 0 when collection; is empty. Bool_t IllegalIndex(const char* method, Int_t idx) const; Return true when index out of bounds and print error. Int_t IndexOf(const TObject* obj) const; Return index of object in collection. Returns -1 when object not found.; Uses member IsEqual() to find object. void Init(Int_t capacity); Initialize ordered collection. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Return an ordered collection iterator. void MoveGapTo(Int_t newGapStart); Move gap to new p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TOrdCollection.html:10613,Clear,Clear,10613,root/html532/TOrdCollection.html,https://root.cern,https://root.cern/root/html532/TOrdCollection.html,4,['Clear'],['Clear']
Usability,"ity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  draw_subpads.cxx;  draw_th1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxx;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:165140,learn,learn,165140,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['learn'],['learn']
Usability,"ity() const; Returns true if links are visible, otherwise return false. TStructNode* GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activated when user press Undo button. Restore last top node pointer. void ScaleByChangedSlot(); Activated when user press radio button. » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gviz3d:$Id: TStructViewerGUI.h 30023 2009-09-02 17:57:16Z brun $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStructViewerGUI.html:28188,Clear,Clear,28188,root/html532/TStructViewerGUI.html,https://root.cern,https://root.cern/root/html532/TStructViewerGUI.html,4,"['Clear', 'Undo']","['Clear', 'Undo', 'UndoButton', 'UndoButtonSlot']"
Usability,"ity. The ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for Fisher discriminants is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, Fisher ; : discriminants often benefit from suitable transformations of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a Fisher discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; Fisher : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : m_jj: -0.051; : m_jjj: +0.192; : m_lv: +0.045; : m_jlv: +0.059; : m_bb: -0.211; : m_wbb: +0.549; : m_wwbb: -0.778; : (offset): +0.136; : -----------------------; : Elapsed time for training with 14000 events: 0.0105 sec ; Fisher : [dataset] : Evaluation of Fisher on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.0038 sec ; : <CreateMVAPdfs> Separation from histogram (PDF): 0.090 (0.000); : Dataset[dataset] : Evaluation of Fisher on training sample; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Fisher.weights.xml␛[0m; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:20156,simpl,simple,20156,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['simpl'],['simple']
Usability,"ity. The ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for Fisher discriminants is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, Fisher ; : discriminants often benefit from suitable transformations of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a Fisher discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; Fisher : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : m_jj: -0.051; : m_jjj: +0.192; : m_lv: +0.045; : m_jlv: +0.059; : m_bb: -0.211; : m_wbb: +0.549; : m_wwbb: -0.778; : (offset): +0.136; : -----------------------; : Elapsed time for training with 14000 events: 0.0116 sec ; Fisher : [dataset] : Evaluation of Fisher on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.00388 sec ; : <CreateMVAPdfs> Separation from histogram (PDF): 0.090 (0.000); : Dataset[dataset] : Evaluation of Fisher on training sample; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Fisher.weights.xml␛[0m;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:20093,simpl,simple,20093,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['simpl'],['simple']
Usability,"ium-r-normal ""Arial"" 0 5; *-* 5 : helvetica-medium-o-normal ""Arial"" 1 5; *-* 6 : helvetica-bold-r-normal ""Arial"" 0 8; *-* 7 : helvetica-bold-o-normal ""Arial"" 1 8; *-* 8 : courier-medium-r-normal ""Courier New"" 0 5; *-* 9 : courier-medium-o-normal ""Courier New"" 1 5; *-* 10 : courier-bold-r-normal ""Courier New"" 0 8; *-* 11 : courier-bold-o-normal ""Courier New"" 1 8; *-* 12 : symbol-medium-r-normal ""Symbol"" 0 6; *-* 13 : times-medium-r-normal ""Times New Roman"" 0 5; *-* 14 : ""Wingdings"" 0 5. void SetTextSize(Float_t textsize); Set current text size*-*-; *-* =====================. void UpdateWindow(Int_t mode); Update display.; mode : (1) update; (0) sync. Int_t WriteGIF(char* name). Writes the current active window into pixmap file.; The format is defined by the file name extension; like ""png"",""jpg"",""bmp"" . . .; If no extension is provided the ""png"" format is used by default. Returns 1 in case of success,; 0 otherwise; Note: this method may not produce the expected result been called; ---- from the ROOT prompt by simple reason:; The active window will be console window; rather the last selected ROOT canvas. void WritePixmap(Int_t wid, UInt_t w, UInt_t h, char* pxname); Write the pixmap wd in the bitmap file pxname in JPEG.; wd : Pixmap address; w,h : Width and height of the pixmap.; if w = h = -1 the size of the pimxap is equal the size the wd size; pxname : pixmap file name; The format is defined by the file name extension; like ""png"",""jpg"",""bmp"" . . .; If no or some unknown extension is provided then; the ""png"" format is used by default; --; Take in account the special ROOT filename syntax 26.12.2006 vf; ""gif+NN"" - an animated GIF file is produced, where NN is delay in 10ms units. Int_t LoadQt(const char* shareLibFileName); Make sure we load the GUI DLL from the gui thread. Int_t processQtEvents(Int_t maxtime = 300); Force processing the Qt events only without entering the ROOT event loop. void operator=(const TGQt& ). TGQt(). Bool_t IsHandleValid(Window_t id). » Author",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGQt.html:34011,simpl,simple,34011,root/html528/TGQt.html,https://root.cern,https://root.cern/root/html528/TGQt.html,5,['simpl'],['simple']
Usability,"ivatives implementation class using GSL ;  CGSLRootFinderBase class for GSL Root-Finding algorithms for one dimensional functions which do not use function derivatives ;  CGSLRootFinderDerivBase class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives ;  CGSLRootFSolverRoot-Finder implementation class using GSL ;  CGSLSimAnFuncGSLSimAnFunc class description ;  CGSLSimAnMinimizerGSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL ;  CGSLSimAnnealingGSLSimAnnealing class for performing a simulated annealing search of a multidimensional function ;  CGSLSimAnParamsStructure holding the simulated annealing parameters ;  CGSLVegasIntegrationWorkspaceWorkspace for VEGAS ;  CIBaseFunctionMultiDimDocumentation for the abstract class IBaseFunctionMultiDim ;  CIBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:36695,simpl,simple,36695,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['simpl'],['simple']
Usability,"ivatives implementation class using GSL ;  CGSLRootFinderBase class for GSL Root-Finding algorithms for one dimensional functions which do not use function derivatives ;  CGSLRootFinderDerivBase class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives ;  CGSLRootFSolverRoot-Finder implementation class using GSL ;  CGSLSimAnFuncGSLSimAnFunc class description ;  CGSLSimAnMinimizerGSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL ;  CGSLSimAnnealingGSLSimAnnealing class for performing a simulated annealing search of a multidimensional function ;  CGSLSimAnParamsStructure holding the simulated annealing parameters ;  CGSLVegasIntegrationWorkspaceWorkspace for VEGAS ;  CIBaseFunctionMultiDimDocumentation for the abstract class IBaseFunctionMultiDim ;  CIBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxillary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:32627,simpl,simple,32627,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['simpl'],['simple']
Usability,"ive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu item DrawClonePad.; Note that the original canvas may have subpads. void DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCanvas.html:38007,Clear,Cleared,38007,root/html532/TCanvas.html,https://root.cern,https://root.cern/root/html532/TCanvas.html,8,['Clear'],['Cleared']
Usability,"ive shapes supported by the package are basically the GEANT3 shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel planes. All basic primitives inherits from class TGeoBBox since the bounding box of a solid is essential for the tracking algorithms. They also implement the virtual methods defined in the virtual class TGeoShape (point and segment classification). User-defined primitives can be directly plugged into the modeler provided that they override these methods. Composite shapes will be soon supported by the modeler. In order to build a TGeoCompositeShape, one will have to define first the primitive components. The object that handle boolean operations among components is called TGeoBoolCombinator and it has to be constructed providing a string boolean expression between the components names. Example for building a simple geometry; ; void rootgeom(bool vis = true); {; // gStyle->SetCanvasPreferGL(true);; ; TGeoManager *geom = new TGeoManager(""simple1"", ""Simple geometry"");; ; //--- define some materials; TGeoMaterial *matVacuum = new TGeoMaterial(""Vacuum"", 0,0,0);; TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; // //--- define some media; TGeoMedium *Vacuum = new TGeoMedium(""Vacuum"",1, matVacuum);; TGeoMedium *Al = new TGeoMedium(""Root Material"",2, matAl);; ; //--- define the transformations; TGeoTranslation *tr1 = new TGeoTranslation(20., 0, 0.);; TGeoTranslation *tr2 = new TGeoTranslation(10., 0., 0.);; TGeoTranslation *tr3 = new TGeoTranslation(10., 20., 0.);; TGeoTranslation *tr4 = new TGeoTranslation(5., 10., 0.);; TGeoTranslation *tr5 = new TGeoTranslation(20., 0., 0.);; TGeoTranslation *tr6 = new TGeoTranslation(-5., 0., 0.);; TGeoTranslation *tr7 = new TGeoTranslation(7.5, 7.5, 0.);; TGeoRotation *rot1 = new TGeoRotation(""rot1"", 90., 0., 90., 270., 0., 0.);; TGeoCombiTrans *combi1 = new TGeoCombiTrans(7.5, -7.5, 0., rot1);; TGeoTranslation *tr8 = new TGeoTranslation(7.5, -5., 0.);; TGeoTranslation *tr9 = new TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:4977,simpl,simple,4977,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['simpl'],['simple']
Usability,"ive(const double* x, unsigned int icoord = 0) const; virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TPyMultiGradFunction(const TPyMultiGradFunction& src); TPyMultiGradFunction&operator=(const TPyMultiGradFunction&). Data Members; private:. PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyMultiGradFunction(PyObject* self = 0); Construct a TPyMultiGradFunction derived with <self> as the underlying. ~TPyMultiGradFunction(); Destructor. Only deref if still holding on to Py_None (circular otherwise). unsigned int NDim() const; Simply forward the call to python self. double DoEval(const double* x) const; Simply forward the call to python self. void Gradient(const double* x, double* grad) const; Simply forward the call to python self. void FdF(const double* x, double& f, double* df) const; Simply forward the call to python self. double DoDerivative(const double* x, unsigned int icoord) const; Simply forward the call to python self. ROOT::Math::IBaseFunctionMultiDim* Clone() const; Math::IMultiGenFunction implementation. { return new TPyMultiGenFunction( fPySelf ); }. TPyMultiGenFunction& operator=(const TPyMultiGradFunction& ); { return *this; }. TPyMultiGradFunction(PyObject* self = 0); ctor/dtor, and assignment. » Last changed: Thu Nov 3 20:22:00 2011 » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPyMultiGradFunction.html:1696,Simpl,Simply,1696,root/html532/TPyMultiGradFunction.html,https://root.cern,https://root.cern/root/html532/TPyMultiGradFunction.html,5,['Simpl'],['Simply']
Usability,"ivide(N,Xmin,Xmax,""X"");; Create a new volume by dividing an existing one (GEANT3 like).; Divides MOTHER into NDIV divisions called NAME along axis IAXIS starting at coordinate value START and having size STEP. The created volumes will have tracking media ID=NUMED (if NUMED=0 -> same media as MOTHER).; The behavior of the division operation can be triggered using OPTION (case insensitive):. Ndivide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NXdivide range starting with START in NDIV cells (GSDVN2 in G3); Sdivide all range with given STEP; NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SXsame as DVS, but from START position (GSDVS2, GSDVT2 in G3). Volume Assemblies; In general, geometry contains structures of positioned volumes that have to be grouped and handled together, for different possible reasons. One of these is that the structure has to be replicated in several parts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as ""overlapping"" (see also ""Overlapping Volumes""); Representing the container as a composite shape - the Boolean union of all components (see also ""Composite Shapes""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:50516,simpl,simply,50516,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simply']
Usability,"ividual file (each sample is simply a single file).; 376 /// In the multithreaded case, the idea is to accumulate the higher event entry value until; 377 /// the total number of events in a given file is reached.; 378 void registerNewSample(unsigned int /*slot*/, const ROOT::RDF::RSampleInfo &id); 379 {; 380 std::lock_guard<std::mutex> lock(fSampleNameToEventEntriesMutex);; 381 fSampleNameToEventEntries[id.AsString()] =; 382 std::max(id.EntryRange().second, fSampleNameToEventEntries[id.AsString()]);; 383 }; 384 ; 385 /// Thread-safe callback for RDataFrame.; 386 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the; 387 /// fPrintInterval). \param slot Ignored. \param value Ignored.; 388 template <typename T>; 389 void operator()(unsigned int /*slot*/, T &value); 390 {; 391 operator()(value);; 392 }; 393 // clang-format off; 394 /// Thread-safe callback for RDataFrame.; 395 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the fPrintInterval).; 396 /// \param value Ignored.; 397 // clang-format on; 398 template <typename T>; 399 void operator()(T & /*value*/); 400 {; 401 using namespace std::chrono;; 402 // ***************************************************; 403 // Warning: Here, everything needs to be thread safe:; 404 // ***************************************************; 405 fProcessedEvents += fIncrement;; 406 ; 407 // We only print every n seconds.; 408 if (duration_cast<seconds>(system_clock::now() - fLastPrintTime) < fPrintInterval) {; 409 return;; 410 }; 411 ; 412 // ***************************************************; 413 // Protected by lock from here:; 414 // ***************************************************; 415 if (!fPrintMutex.try_lock()); 416 return;; 417 std::lock_guard<std::mutex> lockGuard(fPrintMutex, std::adopt_lock);; 418 ; 419 std::size_t eventCount;; 420 seconds elapsedSeconds;; 421 std::tie(eventCount, elapsedSeconds) = RecordEvtCou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:18837,progress bar,progress bar,18837,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['progress bar'],['progress bar']
Usability,"ization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; TGeoManager::GetListOfNavigatorsTGeoNavigatorArray * GetListOfNavigators() constGet list of navigators for the calling thread.Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:66241,simpl,simple,66241,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"ize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual Bool_tROOT::v5::TFormula::CheckOperands(Int_t operation, Int_t& err); virtual Bool_tROOT::v5::TFormula::CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); voidROOT::v5::TFormula::ClearFormula(Option_t* option = """"); virtual voidROOT::v5::TFormula::Convert(UInt_t fromVersion); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tROOT::v5::TFormula::EvalParFast(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive0(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive1(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive2(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive3(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive4(const Double_t* x, const Double_t* params); Short_tROOT::v5::TFormula::GetAction(Int_t code) const; Short_tROOT::v5::TFormula::GetActionOptimized(Int_t code) const; Int_tROOT::v5::TFormula::GetActionParam(Int_t code) const; Int_tROOT::v5::TFormula::GetActionParamOptimized(Int_t code) const; Int_t*ROOT::v5::TFormula::GetOper() const; Int_t*ROOT::v5::TFormula::GetOperOptimized() const; virtual Bool_tROOT::v5::TFormula::IsString(Int_t oper) const; voidROOT::v5::TFormula::MakePrimitive(const char* expr, Int_t pos); voidTObject::MakeZombie(); Int_tROOT::v5::TFormula::PreCompile(); voidROOT::v5::TFormula::SetAction(Int_t code, Int_t value, Int_t param = 0); voidROOT::v5::TFormula::SetActionOptimized(Int_t code, Int_t value, Int_t param = 0); virtual Bool_tROOT::v5::TFormula::StringToNumber(Int_t code). Data Members; public:. Double_tfChisquareFunction fit chisquare; Double_tfMaximumMaximum value for plotting; Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__v5__TF1Data.html:10384,Clear,ClearFormula,10384,root/html604/ROOT__v5__TF1Data.html,https://root.cern,https://root.cern/root/html604/ROOT__v5__TF1Data.html,1,['Clear'],['ClearFormula']
Usability,"ize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual Bool_tTFormula::CheckOperands(Int_t operation, Int_t& err); virtual Bool_tTFormula::CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); voidTFormula::ClearFormula(Option_t* option = """"); virtual voidTFormula::Convert(UInt_t fromVersion); voidTF1::CreateFromFunctor(const char* name, Int_t npar); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tTFormula::EvalParFast(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive0(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive1(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive2(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive3(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive4(const Double_t* x, const Double_t* params); virtual Double_tFindMinMax(Double_t* x, bool findmax) const; Short_tTFormula::GetAction(Int_t code) const; Short_tTFormula::GetActionOptimized(Int_t code) const; Int_tTFormula::GetActionParam(Int_t code) const; Int_tTFormula::GetActionParamOptimized(Int_t code) const; virtual Double_tTF1::GetMinMaxNDim(Double_t* x, Bool_t findmax, Double_t epsilon = 0, Int_t maxiter = 0) const; Int_t*TFormula::GetOper() const; Int_t*TFormula::GetOperOptimized() const; virtual Bool_tTFormula::IsString(Int_t oper) const; voidTFormula::MakePrimitive(const char* expr, Int_t pos); voidTObject::MakeZombie(); Int_tTFormula::PreCompile(); voidTFormula::SetAction(Int_t code, Int_t value, Int_t param = 0); voidTFormula::SetActionOptimized(Int_t code, Int_t value, Int_t param = 0); virtual Bool_tTFormula::StringToNumber(Int_t code). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2.html:17796,Clear,ClearFormula,17796,root/html602/TF2.html,https://root.cern,https://root.cern/root/html602/TF2.html,2,['Clear'],['ClearFormula']
Usability,"ize Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2073 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2106 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2128 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2145 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2160 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:49499,learn,learning,49499,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"izeBins2D() specify a 2-dimensional group of bins. Note, the class TUnfoldDensity provides an automatic setup of complex; regularisation schemes. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regularize the slope given by two bins; RegularizeCurvature() regularize the curvature given by three bins; AddRegularisationCondition(); define an arbitrary regulatisation condition. Function Members (Methods); public:. TUnfold(const TUnfold&); TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); virtual~TUnfold(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDoUnfold(Double_t tau); Double_tDoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:8875,Clear,Clear,8875,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,1,['Clear'],['Clear']
Usability,"izerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; In the following we will give some brief description of the minimization packages. The packages all implement the ROOT::Math::Minimizer interface which can be use for finding the minimum of a multi-dimensional function. The interface is documented in the Mathematical Library Chapter.; In addition packages like Minuit or Minuit2 provide their own interfaces.; 5.9 MINUIT (Old TMInuit Version); This package was originally written in FORTRAN by Fred James and part of PACKLIB (patch D506). It has been converted to a C++ class by René Brun. The current implementation in C++ is a straightforward conversion of the original FORTRAN version. The main changes are:. The variables in the various Minuit labeled common blocks have been changed to the TMinuit class data members; The internal arrays with a maximum dimension depending on the maximum number of parameters are now data members’ arrays with a dynamic dimension such that one can fit very large problems by simply initializing the TMinuit constructor with the maximum number of parameters; The include file Minuit.h has been commented as much as possible using existing comments in the code or the printed documentation; The original Minuit subroutines are now member functions; Constructors and destructor have been added; Instead of passing the FCN function in the argument list, the addresses of this function is stored as pointer in the data members of the class. This is by far more elegant and flexible in an interactive environment. The member function SetFCN can be used to define this pointer; The ROOT static function Printf is provided to replace all format statements and to print on currently defined output file; The functions SetObjectFit/GetObjectFit can be used inside the FCN function to set/get a referenced object instead of using global variables; By default fGraphicsMode is true. When ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:214434,simpl,simply,214434,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"j, Option_t* opt); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidAddAfter(TObjLink*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddBefore(TObjLink*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSortedList.html:1595,Clear,Clear,1595,root/html602/TSortedList.html,https://root.cern,https://root.cern/root/html602/TSortedList.html,2,['Clear'],['Clear']
Usability,"j]) {; 5032 cle->Destructor(r[j]);; 5033 r[j] = 0;; 5034 }; 5035 }; 5036 }; 5037 ; 5038 if (etype == kBase) {; 5039 if (cle->Property() & kIsAbstract) {; 5040 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 5041 if (einfo) einfo->Destructor(eaddr, kTRUE);; 5042 } else {; 5043 cle->Destructor(eaddr, kTRUE);; 5044 }; 5045 }; 5046 ; 5047 if (etype == kObject || etype == kAny ||; 5048 etype == kTObject || etype == kTString || etype == kTNamed) {; 5049 // A data member is destroyed, but not deleted.; 5050 cle->Destructor(eaddr, kTRUE);; 5051 }; 5052 ; 5053 if (etype == kSTL) {; 5054 // A data member is destroyed, but not deleted.; 5055 TVirtualCollectionProxy *pr = cle->GetCollectionProxy();; 5056 if (!pr) {; 5057 if (strcmp(ele->GetName(),""This"")==0) {; 5058 // missing information, avoid infinite loop; 5059 // by doing nothing ....; 5060 } else {; 5061 cle->Destructor(eaddr, kTRUE);; 5062 }; 5063 } else {; 5064 if (ele->TestBit(TStreamerElement::kDoNotDelete)) {; 5065 TVirtualCollectionProxy::TPushPop env(cle->GetCollectionProxy(), eaddr); // used for both this 'clear' and the 'clear' inside destructor.; 5066 cle->GetCollectionProxy()->Clear(); // empty the collection without deleting the pointer; 5067 pr->Destructor(eaddr, kTRUE);; 5068 } else {; 5069 pr->Destructor(eaddr, kTRUE);; 5070 }; 5071 }; 5072 }; 5073 ; 5074 if (etype == kObject + kOffsetL || etype == kAny + kOffsetL ||; 5075 etype == kTObject + kOffsetL || etype == kTString + kOffsetL ||; 5076 etype == kTNamed + kOffsetL || etype == kSTL + kOffsetL) {; 5077 // For a data member which is an array of objects, we; 5078 // destroy the objects, but do not delete them.; 5079 Int_t len = ele->GetArrayLength();; 5080 Int_t size = cle->Size();; 5081 char* r = eaddr + (size * (len - 1));; 5082 for (Int_t j = len - 1; j >= 0; --j, r -= size) {; 5083 cle->Destructor(r, kTRUE);; 5084 }; 5085 }; 5086 } // iter over elements; 5087 ; 5088 if (!dtorOnly) {; 5089 delete[] p;; 5090 }; 5091}; 5092 ; 5093///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:201950,clear,clear,201950,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,2,['clear'],['clear']
Usability,"ject is created by the streamer during the disk-read operation. void SetRho(TFoamIntegrand* Rho); User may use this method to set (register) random number generator used by; the given instance of the FOAM event generator. Note that single r.n. generator; may serve several FOAM objects. void ResetRho(TFoamIntegrand* Rho); User may optionally reset the distribution using this method; Usually it is done when FOAM object is restored from the disk.; IMPORTANT: this method deletes existing distribution object registered in the FOAM object.; In particular such an object is created by the streamer diring the disk-read operation.; This method is used only in very special cases, because the distribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoam.html:20206,simpl,simple,20206,root/html528/TFoam.html,https://root.cern,https://root.cern/root/html528/TFoam.html,4,['simpl'],['simple']
Usability,"ject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); virtual Bool_tCancelStagingDataSet(const char* dataset); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; TDrawFeedback*TProof::CreateDrawFeedback(); voidTProof::DataSetStatus(const char* msg, Bool_t status, Int_t d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:2349,Clear,ClearInputData,2349,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,3,['Clear'],['ClearInputData']
Usability,"ject. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; virtual Bool_t Divide (const TH1 *h1);  Divide this histogram by h1. ;  ; virtual Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by the division of h1 by h2. ;  ; virtual Bool_t Divide (TF1 *f1, Double_t c1=1);  Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2), errors are also recalc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLTH3Composition.html:14619,clear,cleared,14619,doc/master/classTGLTH3Composition.html,https://root.cern,https://root.cern/doc/master/classTGLTH3Composition.html,15,['clear'],['cleared']
Usability,"ject. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; void Draw (Option_t *option="""") override;  Draw this histogram with options. ;  ; virtual TH1 * DrawCopy (Option_t *option="""", const char *name_postfix=""_copy"") const;  Copy this histogram and Draw in the current pad. ;  ; virtual TH1 * DrawNormalized (Option_t *option="""", Double_t norm=1) const;  Draw a normalized copy of this histogram. ;  ; virtual void DrawPanel ();  Display a panel with all histo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:12570,clear,cleared,12570,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,3,['clear'],['cleared']
Usability,"ject. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; virtual Bool_t Divide (const TH1 *h1);  Divide this histogram by h1. ;  ; virtual Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by the division of h1 by h2. ;  ; void Draw (Option_t *option="""") override;  Draw this histogram with options. ;  ; virtual TH1 * DrawCopy (Option_t *option="""", const char *name_postfix=""_copy"") const;  Copy this histogram and Draw in the current pad. ;  ; virtual TH1 * DrawNormalized (Option_t *option="""", Double_t norm=1) const;  Draw a normalized copy of this histogram. ;  ; virtual void DrawPanel ();  Display a panel with all histogram drawing options. ;  ; virtual void Eval (TF1 *f1, Option_t *option=""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:21063,clear,cleared,21063,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,2,['clear'],['cleared']
Usability,"ject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInInterval(const RooArgSet&) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Double_tLowerLimit(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::SimpleInterval&operator=(const RooStats::SimpleInterval& other); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetConfidenceLevel(Double_t); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__SimpleInterval.html:3964,Simpl,SimpleInterval,3964,root/html602/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html602/RooStats__SimpleInterval.html,2,['Simpl'],['SimpleInterval']
Usability,"ject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCLsCleanupThreshold(Double_t th); virtual voidSetConfidenceLevel(Double_t cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTestSize(Double_t size); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name = 0); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval& other, const char* name); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tUpperLimit(); Double_tUpperLimitEstimatedError(); voidUseCLs(bool on = true); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html:7271,Simpl,SimpleInterval,7271,root/html602/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html,2,['Simpl'],['SimpleInterval']
Usability,"ject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←. TQUndoManager. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:19366,undo,undo,19366,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,4,['undo'],['undo']
Usability,"ject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGeoShape*fLeftshape on the left branch; TGeoMatrix*fLeftMattransformation that applies to the left branch; Int_tfNpoints! number of points on the mesh; Double_t*fPoints! array of mesh points; TGeoShape*fRightshape on the right branch; TGeoMatrix*fRightMattransformation that applies to the right branch; vector<TGeoBoolNode::ThreadData_t*>fThreadData! Navigation data per thread; Int_tfThreadSize! Size for the navigation data array. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads); Create thread data for n threads max. void SetSelected(Int_t sel); Set the selected branch. TGeoBoolNode(); Default constructor. TGeoBoolNode(const char* expr1, const char* expr2); Constructor called by TGeoCompositeShape providing 2 subexpressions for the 2 branches. TGeoBoolNode(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing left and right shapes and matrices (in the Boolean operation). ~TGeoBoolNode(); Destructor.; --- deletion of components handled by TGeoManager class. Bool_t MakeBranch(const char* expr, Bool_t left); Expands the boolean expression either on left or right branch, creating; component elements (composite shapes and boolean nodes). Returns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. Bool_t ReplaceM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBoolNode.html:8700,Clear,ClearThreadData,8700,root/html602/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html602/TGeoBoolNode.html,2,['Clear'],['ClearThreadData']
Usability,"ject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tfRmax2outside radius at the high z limit; Float_tTTUBE::fRminellipse semi-axis in X inside; Float_tfRmin2inside radius at the high z limit; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCONE(); CONE shape default constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); CONE shape normal constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmax1, Float_t rmax2 = 0); CONE shape ""simplified"" constructor. ~TCONE(); CONE shape default destructor. void SetPoints(Double_t* points) const; Create CONE points. TCONE(). Float_t GetRmin2() const; {return fRmin2;}. Float_t GetRmax2() const; {return fRmax2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TCONE.html:10001,simpl,simplified,10001,root/html604/TCONE.html,https://root.cern,https://root.cern/root/html604/TCONE.html,2,['simpl'],['simplified']
Usability,"ject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tfRmax2outside radius at the high z limit; Float_tTTUBE::fRminellipse semi-axis in X inside; Float_tfRmin2inside radius at the high z limit; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCONE(); CONE shape default constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); CONE shape normal constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmax1, Float_t rmax2 = 0); CONE shape ""simplified"" constructor. ~TCONE(); CONE shape default destructor. void SetPoints(Double_t* points) const; Create CONE points. TCONE(). Float_t GetRmin2() const; {return fRmin2;}. Float_t GetRmax2() const; {return fRmax2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCONE.html:10001,simpl,simplified,10001,root/html602/TCONE.html,https://root.cern,https://root.cern/root/html602/TCONE.html,2,['simpl'],['simplified']
Usability,"ject::kZombie. protected:. TStringfFilenameEvents file name. private:. TRecorderState*fRecorderState! Current state of recorder. Class Charts. Inheritance Chart:. TObject. ←; TRecorder. Function documentation; TRecorder(); Creates initial INACTIVE state for the recorder. TRecorder(const char* filename, Option_t* option = ""READ""); Creates a recorder with filename to replay or to record,; depending on option (NEW or RECREATE will start recording,; READ will start replaying). ~TRecorder(); Destructor. void Browse(TBrowser* ); Browse the recorder from a ROOT file. This allows to replay a; session from the browser. void Start(const char* filename, Option_t* option = ""RECREATE"", Window_t* w = 0, Int_t winCount = 0); Starts recording events. void Stop(Bool_t guiCommand = kFALSE); Stopps recording events. Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays events from 'filename'. void Pause(); Pauses replaying. void Resume(); Resumes replaying. void ReplayStop(); Cancells replaying. void ListCmd(const char* filename); Prints out recorded commandline events. void ListGui(const char* filename); Prints out recorded GUI events. void ChangeState(TRecorderState* newstate, Bool_t deletePreviousState = kTRUE); Changes state from the current to the passed one (newstate); Deletes the old state if delPreviousState = KTRUE. void PrevCanvases(const char* filename, Option_t* option); Save previous canvases in a .root file. TRecorder(const TRecorder& ). TRecorder & operator=(const TRecorder& ). Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. TRecorder::ERecorderState GetState() const; Gets current state of recorder. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRecorder.html:9722,Resume,Resume,9722,root/html604/TRecorder.html,https://root.cern,https://root.cern/root/html604/TRecorder.html,2,['Resume'],"['Resume', 'Resumes']"
Usability,"ject::kZombie. protected:. TStringfFilenameEvents file name. private:. TRecorderState*fRecorderState! Current state of recorder. Class Charts. Inheritance Chart:. TObject. ←; TRecorder. Function documentation; TRecorder(); Creates initial INACTIVE state for the recorder. TRecorder(const char* filename, Option_t* option = ""READ""); Creates a recorder with filename to replay or to record,; depending on option (NEW or RECREATE will start recording,; READ will start replaying). ~TRecorder(); Destructor. void Browse(TBrowser* ); Browse the recorder from a ROOT file. This allows to replay a; session from the browser. void Start(const char* filename, Option_t* option = ""RECREATE"", Window_t* w = 0, Int_t winCount = 0); Starts recording events. void Stop(Bool_t guiCommand = kFALSE); Stopps recording events. Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays events from 'filename'. void Pause(); Pauses replaying. void Resume(); Resumes replaying. void ReplayStop(); Cancells replaying. void ListCmd(const char* filename); Prints out recorded commandline events. void ListGui(const char* filename); Prints out recorded GUI events. void ChangeState(TRecorderState* newstate, Bool_t deletePreviousState = kTRUE); Changes state from the current to the passed one (newstate); Deletes the old state if delPreviousState = KTRUE. void PrevCanvases(const char* filename, Option_t* option); Save previous canvases in a .root file. TRecorder(const TRecorder& ). TRecorder & operator=(const TRecorder& ). Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. TRecorder::ERecorderState GetState() const; Gets current state of recorder. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorder.html:9722,Resume,Resume,9722,root/html602/TRecorder.html,https://root.cern,https://root.cern/root/html602/TRecorder.html,2,['Resume'],"['Resume', 'Resumes']"
Usability,"ject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofProgressStatus&operator+=(const TProofProgressStatus& st); TProofProgressStatusoperator-(TProofProgressStatus& st); TProofProgressStatus&operator-=(const TProofProgressStatus& st); TProofProgressStatus&operator=(const TProofProgressStatus&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBytesRead(Long64_t bytesRead); voidSetCPUTime(Double_t procTime); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEntries(Long64_t entries); voidSetLastEntries(Long64_t entries); voidSetLastProcTime(Double_t procTime); voidSetLastUpdate(Double_t updtTime = 0); voidSetLearnTime(Double_t learnTime); static voidTObject::SetObjectStat(Bool_t stat); voidSetProcTime(Double_t procTime); voidSetReadCalls(Long64_t readCalls); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofProgressStatus.html:5136,learn,learnTime,5136,root/html530/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html530/TProofProgressStatus.html,3,['learn'],['learnTime']
Usability,"jectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; using LegacyIterator_t = TIteratorToSTLInterface< Storage_t >;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual bool canBeAdded (const RooAbsArg &arg, bool silent) const =0;  Determine whether it's possible to add a given RooAbsArg to the collection or not. ;  ; void clearStructureTags ();  ; void deleteList ();  Delete contents of the list. ;  ; void makeStructureTag ();  ; void makeTypedStructureTag ();  ; TNamed * structureTag ();  ; TNamed * typedStructureTag ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; template<class T > ; static void assert_is_no_temporary (T &&);  . Protected Attributes; bool _allRRV = true;  All contents are RRV. ;  ; Storage_t _list;  Actual object storage. ;  ; TString _name;  Our name. ;  ; bool _ownCont = false;  Flag to identify a list that owns its contents. ;  ; TNamed * _structureTag {nullptr};  ! Structure tag ;  ; TNamed * _typedStructureTag {nullptr};  ! Typed structure tag ;  . Private Types; using HashAssistedFind = RooFit::Detail::HashAssistedFind;  . Private Member Functions; void insert (RooAbsArg *);  Insert an element into the owned ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:24454,clear,clearStructureTags,24454,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,2,['clear'],['clearStructureTags']
Usability,"jects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » News Blog. ROOT::RWhy! ; ## Background. ROOT is implementing new interfaces following new interface styles. We follow [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md) where reasonable in our context. Most noticeably this means. - use of references as parameters instead... more . The status of reflection in C++ ; When the C++ committee met in Jacksonville two months ago, something big happened: the reflection study group, SG7, decided what the basic “language"" of reflected C++ should look like. What does that mean? Why do you care? Let me, the co-author of the only “blessed proposal"", explain:. Almost... more . ROOT::TSeq::GetSize() or ROOT::seq::size()? ; Hi,. It's time to resume this blog - on what the ROOT team is up to; what happens at the C++ meetings; and a bit of behind-the-scenes of cling and ROOT. We have started to develop towards ROOT 7 and [its new interfaces](http://indico.cern.ch/event/349459/session/1/contribution/3). We will have... more . ROOT6 and Backward Compatibility ; Hi everyone, dear Matt!. Matt Walker has posted an extensive review of ROOT and what he would hope the future of ROOT to be. Because I think many of his comments are good ones, and because I have heard some of them from several people in the past, I decided to give the answer to an audience that'... more . Main Histogram Changes in ROOT 6 ;  Here is a list of the main changes which have been applied to the histogram classes in ROOT 6. These changes affect the behaviour of the histogram classes and explain why for some cases the same code would give a different outcome than in ROOT 5. .  . Rebinning/Extension of axis... more . Rainbow ? ; The rainbow colormap is not the best choice to represent data using pseudo colors. This arti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog.html:2574,resume,resume,2574,d/blog.html,https://root.cern,https://root.cern/d/blog.html,1,['resume'],['resume']
Usability,"k () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >;  RooCacheManager (const RooCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooCacheManager (Int_t maxSize=2);  Constructor for simple caches without RooAbsArg payload. ;  ;  RooCacheManager (RooAbsArg *owner, Int_t maxSize=2);  Constructor for simple caches with RooAbsArg derived payload. ;  ;  ~RooCacheManager () override;  Destructor. ;  ; Int_t cacheSize () const;  Return size of cache. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIdx, const char *isetRangeName);  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Retrieve payload object indexed on nset,uset amd isetRangeName If sterileIdx is not null, it is set to the index of the sterile slot in cacse such a slot is recycled. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Getter function without integration set. ;  ; RooAbsCacheElement * getObjByIndex (Int_t index) const;  Retrieve payload object by slot index. ;  ; Int_t lastInd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:2624,simpl,simple,2624,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['simpl'],['simple']
Usability,"k existence of function pointers. TGenCollectionProxy * InitializeEx(Bool_t silent); Proxy initializer. TClass * GetCollectionClass() const; Return a pointer to the TClass representing the container. Int_t GetCollectionType() const; Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement() const; Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. void UpdateValueClass(const TClass* oldcl, TClass* newcl); Update the internal ValueClass when a TClass constructor need to; replace an emulated TClass by the real TClass. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void* At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the emulated collection. UInt_t Size() const; Return the current size of the container. void Resize(UInt_t n, Bool_t force_delete); Resize the container. void* Allocate(UInt_t n, Bool_t forceDelete); Allocate the needed space.; For associative collection, this returns a TStaging object that; need to be deleted manually __or__ returned by calling Commit(TStaging*). void Insert(const void* data, void* container, size_t size); Insert data into the container where data is a C-style array of the actual type contained in the collection; of the given size. For associative container (map, etc.), the data type is the pair<key,value>. void Commit(void* env); Commit the change. void PushProxy(void* objstart); Add an object. void PopProxy(); Remove the last object. void DeleteItem(Bool_t force, void* ptr) const; Call to delete/destruct individual item. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void ReadBuffer(TBuffer& b, void* obj). void Streamer(TBuffer& refBuffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenCollectionProxy.html:8278,Clear,Clear,8278,root/html602/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html,4,['Clear'],['Clear']
Usability,k searching function (class TSpectrum) ;  SearchHR3.C Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorit,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:154465,simpl,simple,154465,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['simpl'],['simple']
Usability,"kDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiVarGaussian.html:3333,clear,clearValueAndShapeDirty,3333,root/html532/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html532/RooMultiVarGaussian.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:2256,Clear,Clear,2256,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['Clear'],['Clear']
Usability,"kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:2187,Clear,Clear,2187,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,2,['Clear'],['Clear']
Usability,"kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:2015,Clear,Clear,2015,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,2,['Clear'],['Clear']
Usability,"kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinningCategory.html:1815,Clear,Clear,1815,root/html602/RooBinningCategory.html,https://root.cern,https://root.cern/root/html602/RooBinningCategory.html,8,['Clear'],['Clear']
Usability,"kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStringVar.html:1742,Clear,Clear,1742,root/html602/RooStringVar.html,https://root.cern,https://root.cern/root/html602/RooStringVar.html,2,['Clear'],['Clear']
Usability,"kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfDivIndexindex of first div. node; Double_tfEndending point; Int_tfNdivisionsnumber of divisions; Double_tfStartstarting point on divided axis; Double_tfStepdivision step length; vector<TGeoPatternFinder::ThreadData_t*>fThreadData! Vector of thread private transient data; Int_tfThreadSize! Size of the thread vector; TGeoVolume*fVolumevolume to which applies; static TGeoPatternFinder::EGeoPatternFlagskPatternReflected; static TGeoPatternFinder::EGeoPatternFlagskPatternSpacedOut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads); Create thread data for n threads max. TGeoPatternFinder(); Default constructor. TGeoPatternFinder(TGeoVolume* vol, Int_t ndiv); Default constructor. TGeoPatternFinder(const TGeoPatternFinder& ); copy constructor. TGeoPatternFinder& operator=(const TGeoPatternFinder& ); assignment operator. ~TGeoPatternFinder(); Destructor. Int_t GetCurrent(); Return current index. TGeoMatrix* GetMatrix(); Return current matrix. Int_t GetNext() const; Get index of next division. void SetNext(Int_t index); Set index of next division. TGeoNode * CdNext(); Make next node (if any) current. void SetRange(Double_t start, Double_t step, Int_t ndivisions); Set division range. Use this method only when dividing an assembly. ThreadData_t& GetThreadData() const. TGeoMatrix* CreateMatrix() const; methods. void cd(Int_t ); {}. TGeoNode * FindNode(Double_t* , const Double_t* = 0); {return 0;}. Int_t GetByteCount() const; {return 36;}. Int_t GetDivInde",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPatternFinder.html:8347,Clear,ClearThreadData,8347,root/html602/TGeoPatternFinder.html,https://root.cern,https://root.cern/root/html602/TGeoPatternFinder.html,2,['Clear'],['ClearThreadData']
Usability,"kRaw (the actual filling of tessellation) is split, as the X3D viewer requires two publication passes - one to establish the full tessellation capacity for all shapes, and another to actually add them. Splitting avoids having to do the expensive tessellation on the first pass. 9.13.4.4 Shape Specific TBuffer3D Derived Classes; Currently we provide the following shape specific classes, which the GL Viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres (GL Viewer only supports solid spheres at present - cut / hollow ones will be requested as tessellated objects by client.); TBuffer3DTube - basic tube with inner/outer radius and length.; TBuffer3DTubeSeg - angle tube segment.; TBuffer3DCutTube - angle tube segment with plane cut ends. See the above example from TGeoSphere::GetBuffer3D and also equivalent functions in TGeoTube, TGeoTubeSeg and TGeoCtub. Anyone is free to add new TBuffer3D classes, but it should be clear that one or more viewers will require updating to be able to take advantage of them. Hence we only provide classes which existing viewers can benefit from. The number of native shapes in GL Viewer will be expanded in the future.; 9.13.4.5 Master / Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference frames:. fLocalFrame: indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame).; fLocalMaster: is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame. If fLocalFrame is false, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using the TBuffer3D::SetLocalMasterIdentity() method.; 9.13.4.6 Bounding Boxes; You are not obliged to complete the kBoundingBox section, as any viewer requiring one internally (GL Viewer) will build it if you do not provide. However to do this the viewer will force you to p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:411360,clear,clear,411360,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['clear']
Usability,"k_tag = """"); Float_t*TAttBBox::AssertBBox(); Bool_tAssertCellIdCache() const; TEveRGBAPalette*AssertPalette(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; Bool_tCellInEtaPhiRng(TEveCaloData::CellData_t&) const; virtual voidCellSelectionChanged(); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTAttBBox::ComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCaloViz.html:2599,Clear,ClearProjectedList,2599,root/html532/TEveCaloViz.html,https://root.cern,https://root.cern/root/html532/TEveCaloViz.html,4,['Clear'],['ClearProjectedList']
Usability,"kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148; Our construction method is optimized to save memory, and differs a bit from the constraints above. In particular, the division axis is chosen as the one with the biggest spread, and the point to create the splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree; 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developed to simplify using it together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ...; ...; datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTree.html:4455,simpl,simplify,4455,doc/master/classTKDTree.html,https://root.cern,https://root.cern/doc/master/classTKDTree.html,1,['simpl'],['simplify']
Usability,"ke advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. OpenGL only supports solid spheres at present - cut/hollow ones will be requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the viewers require updating to be able to take advantage of them. The number of native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer requiring one internally (OpenGL) will build one for you if you do not provide. However to do this the viewer will force you to provide the raw tessellation, and the resulting box will be axis aligned with the overall scene, which is non-ideal for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(), for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference frames: fLocalFrame & fLocalMaster. fLocalFrame indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function. Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference frame.; Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:6536,simpl,simpler,6536,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['simpl'],['simpler']
Usability,"ke advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. OpenGL only supports solid spheres at present - cut/hollow ones will be requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the viewers require updating to be able to take advantage of them. The number of native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer requiring one internally (OpenGL) will build one for you if you do not provide. However to do this the viewer will force you to provide the raw tessellation, and the resulting box will be axis aligned with the overall scene, which is non-ideal for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(), for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference frames: fLocalFrame & fLocalMaster. fLocalFrame indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects. There are two cases of object addition:. Add this object as a single independent entity in the world reference frame.; Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer3D.html:4470,simpl,simpler,4470,doc/master/classTBuffer3D.html,https://root.cern,https://root.cern/doc/master/classTBuffer3D.html,1,['simpl'],['simpler']
Usability,"ke sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree.Definition TTree.cxx:7881; TTree::GetPlayerTVirtualTreePlayer * GetPlayer()Load the TTreePlayer (if not already done).Definition TTree.cxx:6305; TTree::MakeProxyvirtual Int_t MakeProxy(const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3)Generate a skeleton analysis class for this Tree using TBranchProxy.Definition TTree.cxx:6768; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::fTargetMemoryRatioFloat_t fTargetMemoryRatio! Ratio for memory usage in uncompressed buffers versus actual occupancy.Definition TTree.h:146; TTree::GetIndexValuesvirtual Double_t * GetIndexValues()Definition TTree.h:522; TTree::GetListOfAliasesvirtual TList * GetListOfAliases() constDefinition TTree.h:531; TTree::ReadStreamvirtual Long64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from an input stream.Definition TTree.cxx:7615; TTree::SetDebugvirtual void SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)Set the debug level and the debug range.Definition TTree.cxx:8928; TTree::fScanFieldInt_t fScanFieldNumber of runs before prompting in Scan.Definition TTree.h:92; TTree::GetWeightvirtual Double_t GetWeight() constDefinition TTree.h:584; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetFriendvirtual TTree * GetFriend(const char *) constReturn a pointer to the TTree friend whose name or alias is friendname.Definition TTree.cxx:5975; TTree::GetVarTTreeFormula * GetVar(Int_t i)Definition TTree.h:564; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return max",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:61696,simpl,simply,61696,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['simpl'],['simply']
Usability,"ke_shared<Browsable::RWrapper>(""root"", elem_root));; 118 ; 119 std::unique_ptr<Browsable::RHolder> rootfiles = std::make_unique<Browsable::TObjectHolder>(gROOT->GetListOfFiles(), kFALSE);; 120 auto elem_files = Browsable::RProvider::Browse(rootfiles);; 121 if (elem_files) {; 122 auto files = std::make_shared<Browsable::RWrapper>(""ROOT Files"", elem_files);; 123 files->SetExpandByDefault(true);; 124 comp->Add(files);; 125 // if there are any open files, make them visible by default; 126 if (elem_files->GetNumChilds() > 0); 127 seldir = {};; 128 }; 129 ; 130 SetTopElement(comp);; 131 ; 132 SetWorkingPath(seldir);; 133}; 134 ; 135/////////////////////////////////////////////////////////////////////; 136/// Reset all data correspondent to last request; 137 ; 138void RBrowserData::ResetLastRequestData(bool with_element); 139{; 140 fLastAllChilds = false;; 141 fLastSortedItems.clear();; 142 fLastSortMethod.clear();; 143 fLastItems.clear();; 144 if (with_element) {; 145 fLastPath.clear();; 146 fLastElement.reset();; 147 }; 148}; 149 ; 150/////////////////////////////////////////////////////////////////////////; 151/// Decompose path to elements; 152/// Returns array of names for each element in the path, first element either ""/"" or "".""; 153/// If returned array empty - it is error; 154 ; 155Browsable::RElementPath_t RBrowserData::DecomposePath(const std::string &strpath, bool relative_to_work_element); 156{; 157 Browsable::RElementPath_t arr;; 158 if (relative_to_work_element) arr = fWorkingPath;; 159 ; 160 if (strpath.empty()); 161 return arr;; 162 ; 163 auto arr2 = Browsable::RElement::ParsePath(strpath);; 164 arr.insert(arr.end(), arr2.begin(), arr2.end());; 165 return arr;; 166}; 167 ; 168/////////////////////////////////////////////////////////////////////////; 169/// Process browser request; 170 ; 171bool RBrowserData::ProcessBrowserRequest(const RBrowserRequest &request, RBrowserReply &reply); 172{; 173 auto path = fWorkingPath;; 174 path.insert(path.end(), request.pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:4646,clear,clear,4646,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['clear'],['clear']
Usability,keeps same size as canvas ; Definition at line 79 of file TRootCanvas.h. ◆ fButton. Int_t TRootCanvas::fButton. private . currently pressed button ; Definition at line 80 of file TRootCanvas.h. ◆ fCanvasContainer. TRootContainer* TRootCanvas::fCanvasContainer. private . container in canvas widget ; Definition at line 40 of file TRootCanvas.h. ◆ fCanvasID. Int_t TRootCanvas::fCanvasID. private . index in fWindows array of TGX11 ; Definition at line 78 of file TRootCanvas.h. ◆ fCanvasLayout. TGLayoutHints* TRootCanvas::fCanvasLayout. private . layout for canvas widget ; Definition at line 54 of file TRootCanvas.h. ◆ fCanvasWindow. TGCanvas* TRootCanvas::fCanvasWindow. private . canvas widget ; Definition at line 39 of file TRootCanvas.h. ◆ fDockLayout. TGLayoutHints* TRootCanvas::fDockLayout. private . layout hints for dockable frame widget ; Definition at line 72 of file TRootCanvas.h. ◆ fEditClearMenu. TGPopupMenu* TRootCanvas::fEditClearMenu. private . clear cascade submenu ; Definition at line 45 of file TRootCanvas.h. ◆ fEditMenu. TGPopupMenu* TRootCanvas::fEditMenu. private . edit menu ; Definition at line 44 of file TRootCanvas.h. ◆ fEditor. TVirtualPadEditor* TRootCanvas::fEditor. private . pointer to currently loaded pad editor ; Definition at line 76 of file TRootCanvas.h. ◆ fEditorFrame. TGCompositeFrame* TRootCanvas::fEditorFrame. private . side frame for current pad editor ; Definition at line 58 of file TRootCanvas.h. ◆ fEditorLayout. TGLayoutHints* TRootCanvas::fEditorLayout. private . layout for editor frame ; Definition at line 59 of file TRootCanvas.h. ◆ fEmbedded. Bool_t TRootCanvas::fEmbedded. private . true if embedded in any other frame (e.g. in the browser) ; Definition at line 77 of file TRootCanvas.h. ◆ fFileMenu. TGPopupMenu* TRootCanvas::fFileMenu. private . file menu ; Definition at line 42 of file TRootCanvas.h. ◆ fFileSaveMenu. TGPopupMenu* TRootCanvas::fFileSaveMenu. private . save cascade submenu ; Definition at line 43 of file TRootCanv,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootCanvas.html:55224,clear,clear,55224,doc/master/classTRootCanvas.html,https://root.cern,https://root.cern/doc/master/classTRootCanvas.html,1,['clear'],['clear']
Usability,"knots (see BuildCoeff) for more on this ;  CTSplinePolyBase class for TSpline knot ;  CTSplinePoly3Class for TSpline3 knot ;  CTSplinePoly5Class for TSpline5 knot ;  CTSPlot;  CTSQLClassColumnInfo;  CTSQLClassInfoContains information about tables specific to one class and version ;  CTSQLColumnData;  CTSQLColumnInfo;  CTSQLFileAccess an SQL db via the TFile interface ;  CTSQLiteResult;  CTSQLiteRow;  CTSQLiteServer;  CTSQLiteStatement;  CTSQLMonitoringWriter;  CTSQLObjectDataTSQLObjectData is used in TBufferSQL2 class in reading procedure ;  CTSQLObjectDataPoolXML object keeper class ;  CTSQLObjectInfoInfo (classname, version) about object in database ;  CTSQLResult;  CTSQLRow;  CTSQLServer;  CTSQLStatement;  CTSQLStructureThis is hierarchical structure, which is created when data is written by TBufferSQL2 ;  CTSQLTableData;  CTSQLTableInfo;  CTSSLSocket;  CTStatisticStatistical variable, defined by its mean and variance (RMS) ;  CTStatsFeedbackUtility class to display PROOF stats feedback histos during queries ;  CTStatusThis class holds the status of an ongoing operation and collects error messages ;  CTStdExceptionHandler;  CTStopwatchStopwatch class ;  CTStorageStorage manager ;  CTStreamerArtificial;  CTStreamerBase;  CTStreamerBasicPointer;  CTStreamerBasicType;  CTStreamerElement;  ►CTStreamerInfoDescribe Streamer information for one class version ;  CTCompInfo;  CTPointerCollectionAdapter;  CTStreamerLoop;  CTStreamerObject;  CTStreamerObjectAny;  CTStreamerObjectAnyPointer;  CTStreamerObjectPointer;  CTStreamerSTL;  CTStreamerSTLstring;  CTStreamerString;  ►CTStringBasic string class ;  CLongStr_t;  CRawStr_t;  CRep_t;  CShortStr_t;  CUStr_t;  CTStringLongATTENTION: this class is obsolete ;  CTStringTokenProvides iteration through tokens of a given string ;  CTStructNode;  CTStructNodeEditor;  CTStructNodeProperty;  CTStructViewer;  CTStructViewerGUI;  CTStyleTStyle objects may be created to define special styles ;  CTStyleDialog;  CTStyleManager;  CTStylePr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:206344,feedback,feedback,206344,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['feedback'],['feedback']
Usability,"known branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:132456,learn,learning,132456,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,4,['learn'],['learning']
Usability,"kspace; f form feed; n new line; r carriage return; s space; t tab; e ASCII ESC character (‘033’); DDD number formed of 1-3 octal digits; xDD number formed of 1-2 hex digits; ^C C = any letter. Control code. The class TRegexp can be used to create a regular expression from an input string. If wildcard is true then the input string contains a wildcard expression.; TRegexp(const char *re, Bool_t wildcard); Regular expression and wildcards can be easily used in methods like:; Ssiz_t Index(const TString& string,Ssiz_t* len,Ssiz_t i) const; The method finds the first occurrence of the regular expression in the string and returns its position.; 2.5 Conventions; In this paragraph, we will explain some of the conventions used in ROOT source and examples.; 2.5.1 Coding Conventions; From the first days of ROOT development, it was decided to use a set of coding conventions. This allows a consistency throughout the source code. Learning these will help you identify what type of information you are dealing with and enable you to understand the code better and quicker. Of course, you can use whatever convention you want but if you are going to submit some code for inclusion into the ROOT sources, you will need to use these.; These are the coding conventions:. Classes begin with T: TLine, TTree; Non-class types end with _t: Int_t; Data members begin with f: fTree; Member functions begin with a capital: Loop(); Constants begin with k: kInitialSize, kRed; Global variables begin with g: gEnv; Static data members begin with fg: fgTokenClient; Enumeration types begin with E: EColorLevel; Locals and parameters begin with a lower case: nbytes; Getters and setters begin with Get and Set: SetLast(), GetFirst(). 2.5.2 Machine Independent Types; Different machines may have different lengths for the same type. The most famous example is the int type. It may be 16 bits on some old machines and 32 bits on some newer ones. To ensure the size of your variables, use these pre defined types in ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:56892,Learn,Learning,56892,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Learn'],['Learning']
Usability,"l . Close the current gVirtualX pixmap. ; Implements TVirtualPadPainter.; Definition at line 333 of file TPadPainter.cxx. ◆ DrawBox(). void TPadPainter::DrawBox ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2, . EBoxMode ; mode . ). overridevirtual . Paint a simple box. ; Implements TVirtualPadPainter.; Definition at line 390 of file TPadPainter.cxx. ◆ DrawFillArea() [1/2]. void TPadPainter::DrawFillArea ; (; Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). overridevirtual . Paint filled area. ; Implements TVirtualPadPainter.; Definition at line 411 of file TPadPainter.cxx. ◆ DrawFillArea() [2/2]. void TPadPainter::DrawFillArea ; (; Int_t ; n, . const Float_t * ; x, . const Float_t * ; y . ). overridevirtual . Paint filled area. ; Implements TVirtualPadPainter.; Definition at line 425 of file TPadPainter.cxx. ◆ DrawLine(). void TPadPainter::DrawLine ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2 . ). overridevirtual . Paint a simple line. ; Implements TVirtualPadPainter.; Definition at line 360 of file TPadPainter.cxx. ◆ DrawLineNDC(). void TPadPainter::DrawLineNDC ; (; Double_t ; u1, . Double_t ; v1, . Double_t ; u2, . Double_t ; v2 . ). overridevirtual . Paint a simple line in normalized coordinates. ; Implements TVirtualPadPainter.; Definition at line 375 of file TPadPainter.cxx. ◆ DrawPixels(). void TPadPainter::DrawPixels ; (; const unsigned char * ; pixelData, . UInt_t ; width, . UInt_t ; height, . Int_t ; dstX, . Int_t ; dstY, . Bool_t ; enableAlphaBlending . ). overridevirtual . Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. ; Implements TVirtualPadPainter.; Definition at line 351 of file TPadPainter.cxx. ◆ DrawPolyLine() [1/2]. void TPadPainter::DrawPolyLine ; (; Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). overridevirtual . Paint Polyline. ; Implements TVirtualPadPainter.; Definition at line 438 of file TPadPainter.cxx. ◆ DrawPolyLine() [2/2]. void TPadPainter::DrawPolyLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPadPainter.html:8922,simpl,simple,8922,doc/master/classTPadPainter.html,https://root.cern,https://root.cern/doc/master/classTPadPainter.html,1,['simpl'],['simple']
Usability,"l == TMath::QuietNaN() ) { x = TMath::QuietNaN(); y = TMath::QuietNaN(); return;}; 1216 ; 1217 if (!rng) rng = gRandom;; 1218 Double_t r1 = rng->Rndm();; 1219 Int_t ibin = TMath::BinarySearch(nbins,fIntegral,(Double_t) r1);; 1220 Int_t biny = ibin/nbinsx;; 1221 Int_t binx = ibin - nbinsx*biny;; 1222 x = fXaxis.GetBinLowEdge(binx+1);; 1223 if (r1 > fIntegral[ibin]) x +=; 1224 fXaxis.GetBinWidth(binx+1)*(r1-fIntegral[ibin])/(fIntegral[ibin+1] - fIntegral[ibin]);; 1225 y = fYaxis.GetBinLowEdge(biny+1) + fYaxis.GetBinWidth(biny+1)*rng->Rndm();; 1226}; 1227 ; 1228 ; 1229////////////////////////////////////////////////////////////////////////////////; 1230/// Fill the array stats from the contents of this histogram; 1231/// The array stats must be correctly dimensioned in the calling program.; 1232/// ~~~ {.cpp}; 1233/// stats[0] = sumw; 1234/// stats[1] = sumw2; 1235/// stats[2] = sumwx; 1236/// stats[3] = sumwx2; 1237/// stats[4] = sumwy; 1238/// stats[5] = sumwy2; 1239/// stats[6] = sumwxy; 1240/// ~~~; 1241///; 1242/// If no axis-subranges are specified (via TAxis::SetRange), the array stats; 1243/// is simply a copy of the statistics quantities computed at filling time.; 1244/// If sub-ranges are specified, the function recomputes these quantities; 1245/// from the bin contents in the current axis ranges.; 1246///; 1247/// Note that the mean value/StdDev is computed using the bins in the currently; 1248/// defined ranges (see TAxis::SetRange). By default the ranges include; 1249/// all bins from 1 to nbins included, excluding underflows and overflows.; 1250/// To force the underflows and overflows in the computation, one must; 1251/// call the static function TH1::StatOverflows(kTRUE) before filling; 1252/// the histogram.; 1253 ; 1254void TH2::GetStats(Double_t *stats) const; 1255{; 1256 if (fBuffer) ((TH2*)this)->BufferEmpty();; 1257 ; 1258 if ((fTsumw == 0 && fEntries > 0) || fXaxis.TestBit(TAxis::kAxisRange) || fYaxis.TestBit(TAxis::kAxisRange)) {; 1259 std::fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:49997,simpl,simply,49997,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['simpl'],['simply']
Usability,"l Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGTable::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGTable::Expand(UInt_t nrows, UInt_t ncolumns); virtual voidTGTable::ExpandColumns(UInt_t ncolumns); virtual voidTGTable::ExpandRows(UInt_t nrows); virtual UInt_tTGTable::GetCHdrWidth() const; static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual UInt_tTGTable::GetRHdrHeight() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTGTable::Init(); voidTObject::MakeZombie(); virtual voidTGTable::ResizeTable(UInt_t nrows, UInt_t ncolumns); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGTable::SetInterface(TVirtualTableInterface* interface, UInt_t nrows = 50, UInt_t ncolumns = 20); virtual voidTGTable::Shrink(UInt_t nrows, UInt_t ncolumns); virtual voidTGTable::ShrinkColumns(UInt_t ncolumns); virtual voidTGTable::ShrinkRows(UInt_t nrows); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); virtual voidTGTable::UpdateHeaders(EHeaderType type); virtual voidTGTable::UpdateRangeFrame(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGSimpleTable.html:17499,Clear,ClearFlags,17499,root/html602/TGSimpleTable.html,https://root.cern,https://root.cern/root/html602/TGSimpleTable.html,4,['Clear'],['ClearFlags']
Usability,"l RooFitResult*chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:3619,clear,clearValueDirty,3619,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,2,['clear'],['clearValueDirty']
Usability,"l as for raw-data visualization.; Papers describing Eve (older ones still using the old name - Reve):. [EVE - Event Visualization Environment of the ROOT framework] (http://pos.sissa.it//archive/conferences/070/103/ACAT08_103.pdf) presented at ACAT 2008.; [Event Visualization Environment of the ALICE experiment] (http://indico.cern.ch/contributionDisplay.py?contribId=25&confId=13356) presented at ROOT Workshop 2007.; [Raw-data display and visual reconstruction validation in ALICE] (http://indico.cern.ch/contributionDisplay.py?contribId=442&sessionId=23&confId=3580) presented at CHEP 2007. Eve is built on top of ROOT's GUI, GL and GED infrastructure and delivers the following main features:. Base-classes for representation of visual objects that can be presented in list-tree views, object-editors and rendered via OpenGL (TEveElement and sub-classes).; Application manager class TEveManager for top-level management of elements, GUI components, geometries and events;; Classes for presentation of full TGeo geometries (TEveGeoNode and TEveGeoTopNode) as well as of simplifed geometries via extraction of shape-data (TEveGeoShape). CMS geometry. Classes for presentation of trajectories or tracks (TEveTrack, TEveTrackPropagator) and hits or clusters (TEvePointSet, TEvePointSetArray). A simulated ALICE pp@14TeV event in 3D. Base-classes for presentation of raw-data or digits (TEveDigitSet, TEveQuadSet and TEveBoxSet). A collection of objects can be assigned common signal-to-color mapping (TEveRGBAPelette) and surrounding frame (TEveFrameBox). Hexagonal and rectangular digits. Base-classes for 2D projections with dynamically controllable fish-eye magnification of the vertex region (TEveProjectionManager and TEveProjection). Tracks, points and geometries can be projected automatically. R-phi and Rho-z projections are currently supported. A r-phi projection with fish-eye transformation of a simulated ALICE pp@14TeV event. TriangleSet class for presentation of generic triangle mesh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TEve.html:1577,simpl,simplifed,1577,doc/master/group__TEve.html,https://root.cern,https://root.cern/doc/master/group__TEve.html,1,['simpl'],['simplifed']
Usability,l container. ; Definition at line 193 of file TGDockableFrame.cxx. Member Function Documentation. ◆ Class(). static TClass * TGUndockedFrame::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGUndockedFrame::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGUndockedFrame::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 78 of file TGDockableFrame.h. ◆ CloseWindow(). void TGUndockedFrame::CloseWindow ; (; ). overridevirtual . Close undocked frame (called via WM close button). ; Reimplemented from TGMainFrame.; Definition at line 213 of file TGDockableFrame.cxx. ◆ DeclFileName(). static const char * TGUndockedFrame::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file TGDockableFrame.h. ◆ FixSize(). void TGUndockedFrame::FixSize ; (; ). Fix the size of the undocked frame so it cannot be changed via the WM. ; Definition at line 203 of file TGDockableFrame.cxx. ◆ IsA(). TClass * TGUndockedFrame::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGTransientFrame.; Definition at line 78 of file TGDockableFrame.h. ◆ operator=(). TGUndockedFrame & TGUndockedFrame::operator= ; (; const TGUndockedFrame & ; ). privatedelete . ◆ Streamer(). void TGUndockedFrame::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGTransientFrame. ◆ StreamerNVirtual(). void TGUndockedFrame::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 78 of file TGDockableFrame.h. Member Data Documentation. ◆ fDockable. TGDockableFrame* TGUndockedFrame::fDockable. protected . orignal dockable frame ; Definition at line 69 of file TGDockableFrame.h. Libraries for TGUndockedFrame:. [legend]; The documentation for this class was generated from t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGUndockedFrame.html:37893,undo,undocked,37893,doc/master/classTGUndockedFrame.html,https://root.cern,https://root.cern/doc/master/classTGUndockedFrame.html,1,['undo'],['undocked']
Usability,"l each element of the matrix A and write the result into A. ;  ; static void ReconstructInput (TMatrixT< AReal > &compressedInput, TMatrixT< AReal > &reconstructedInput, TMatrixT< AReal > &fWeights);  ; static void SoftmaxAE (TMatrixT< AReal > &A);  ; static void SqrtElementWise (TMatrixT< AReal > &A);  Square root each element of the matrix A and write the result into A. ;  ; static void SquareElementWise (TMatrixT< AReal > &A);  Square each element of the matrix A and write the result into A. ;  ; static void SumColumns (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  Sum columns of (m x n) matrix A and write the results into the first m elements in A. ;  ; static void UpdateParams (TMatrixT< AReal > &x, TMatrixT< AReal > &tildeX, TMatrixT< AReal > &y, TMatrixT< AReal > &z, TMatrixT< AReal > &fVBiases, TMatrixT< AReal > &fHBiases, TMatrixT< AReal > &fWeights, TMatrixT< AReal > &VBiasError, TMatrixT< AReal > &HBiasError, AReal learningRate, size_t fBatchSize);  ; static void UpdateParamsLogReg (TMatrixT< AReal > &input, TMatrixT< AReal > &output, TMatrixT< AReal > &difference, TMatrixT< AReal > &p, TMatrixT< AReal > &fWeights, TMatrixT< AReal > &fBiases, AReal learningRate, size_t fBatchSize);  ; Forward Propagation; Low-level functions required for the forward propagation of activations through the network. . static void MultiplyTranspose (TMatrixT< Scalar_t > &output, const TMatrixT< Scalar_t > &input, const TMatrixT< Scalar_t > &weights);  Matrix-multiply input with the transpose of weights and write the results into output. ;  ; static void AddRowWise (TMatrixT< Scalar_t > &output, const TMatrixT< Scalar_t > &biases);  Add the vectors biases row-wise to the matrix output. ;  ; Backward Propagation; Low-level functions required for the forward propagation of activations through the network. . static void Backward (TMatrixT< Scalar_t > &activationGradientsBackward, TMatrixT< Scalar_t > &weightGradients, TMatrixT< Scalar_t > &biasGradients, TMatrixT< Scalar_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html:3679,learn,learningRate,3679,doc/master/classTMVA_1_1DNN_1_1TReference.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html,2,['learn'],['learningRate']
Usability,"l entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.; For examples of CloneTree, see tutorials:. copytree.C: A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1; copytree2.C: A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1 . Reimplemented in TNtuple.; Definition at line 3139 of file TTree.cxx. ◆ CopyAddresses(). void TTree::CopyAddresses ; (; TTree * ; tree, . bool ; undo = false . ). virtual . Set branch addresses of passed tree equal to ours. ; If undo is true, reset the branch addresses instead of copying them. This ensures 'separation' of a cloned tree from its original. ; Definition at line 3299 of file TTree.cxx. ◆ CopyEntries(). Long64_t TTree::CopyEntries ; (; TTree * ; tree, . Long64_t ; nentries = -1, . Option_t * ; option = """", . bool ; needCopyAddresses = false . ). virtual . Copy nentries from given tree to this tree. ; This routines assumes that the branches that intended to be copied are already connected. The typical case is that this tree was created using tree->CloneTree(0).; By default copy all entries.; Returns number of bytes copied to this tree.; If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contains a sorting order for the baskets in the output file.; There are currently 3 supported sorting order:. SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsBy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:106517,undo,undo,106517,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['undo'],['undo']
Usability,l functions which do not use function derivatives. More...;  ; class  GSLRootFinderDeriv;  Base class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives. More...;  ; class  GSLRootFSolver;  Root-Finder implementation class using GSL. More...;  ; class  GSLSimAnFunc;  GSLSimAnFunc class description. More...;  ; class  GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  GSLVegasIntegrationWorkspace;  workspace for VEGAS More...;  ; class  IBaseFunctionMultiDimTempl;  Documentation for the abstract class IBaseFunctionMultiDim. More...;  ; class  IBaseFunctionOneDim;  Interface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ). More...;  ; class  IBaseParam;  Documentation for the abstract class IBaseParam. More...;  ; class  IGradientFunctionMultiDimTempl;  Interface (abstract class) for multi-dimensional functions providing a gradient calculation. More...;  ; class  IGradientFunctionOneDim;  Interface (abstract class) for one-dimensional functions providing a gradient calculation. More...;  ; class  IGradientMultiDimTempl;  ; class  IMinimizer1D;  Interface class for numerical methods for one-dimensional minimization. More...;  ; class  IntegrandTransform;  Auxiliary inner class for mapping infinite and semi-infinite integrals. More...;  ; class  IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  IntegratorOneDim;  User Class for performing numerical integra,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:16463,simpl,simple,16463,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['simpl'],['simple']
Usability,"l list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:2982,clear,clearShapeDirty,2982,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,2,['clear'],['clearShapeDirty']
Usability,"l user and/or internal Minuit representation of the parameters and errors; transformation internal <-> external on demand; ;  CMnUserTransformationClass dealing with the transformation between user specified parameters (external) and internal parameters used for minimization ;  CMnVectorTransform;  CModularFunctionMinimizerBase common class providing the API for all the minimizer Various Minimize methods are provided varying on the type of FCN function passesd and on the objects used for the parameters ;  CMPIProcess;  CMPITerminate;  CNegativeG2LineSearchIn case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive ;  CNumerical2PGradientCalculatorClass performing the numerical gradient calculation ;  CParametricFunctionFunction which has parameters ;  CScanBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CScanMinimizerClass implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class ;  CSimplexBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CSimplexMinimizerClass implementing the required methods for a minimization using Simplex ;  CSimplexParametersClass describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process ;  CSimplexSeedGeneratorGenerate Simplex starting point (state) ;  CSinParameterTransformationClass for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one ;  CSqrtLowParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CSqrtUpParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CStackAllocatorStackAllocator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:69893,simpl,simplex,69893,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['simpl'],['simplex']
Usability,"l voidShowMembers(TMemberInspector& insp) const; virtual Bool_tStoreResult(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMySQLStatement(MYSQL_STMT* stmt, Bool_t errout = kTRUE); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. void*BeforeSet(const char* method, Int_t npar, Int_t sqltype, Bool_t sig = kTRUE, ULong_t size = 0); voidTSQLStatement::ClearError(); long doubleConvertToNumeric(Int_t npar); const char*ConvertToString(Int_t npar); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFreeBuffers(); Bool_tIsResultSetMode() const; Bool_tIsSetParsMode() const; voidTObject::MakeZombie(); voidSetBuffersNumber(Int_t n); voidTSQLStatement::SetError(Int_t code, const char* msg, const char* method = 0); Bool_tSetSQLParamType(Int_t npar, int sqltype, Bool_t sig, ULong_t sqlsize = 0). private:. TMySQLStatement&operator=(const TMySQLStatement&); TMySQLStatement(const TMySQLStatement&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMySQLStatement.html:8594,Clear,ClearError,8594,root/html602/TMySQLStatement.html,https://root.cern,https://root.cern/root/html602/TMySQLStatement.html,2,['Clear'],['ClearError']
Usability,"l voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; voidChanged(); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidCollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveScene.html:2509,Clear,ClearProjectedList,2509,root/html532/TEveScene.html,https://root.cern,https://root.cern/root/html532/TEveScene.html,4,['Clear'],['ClearProjectedList']
Usability,"l voidTGFrame::Activate(Bool_t); voidActivateButtons(Bool_t first, Bool_t previous, Bool_t next, Bool_t last); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); voidAppendTree(TTree* tree); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t*)MENU ; virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeViewer.html:8845,Clear,Clear,8845,root/html532/TTreeViewer.html,https://root.cern,https://root.cern/root/html532/TTreeViewer.html,4,['Clear'],['Clear']
Usability,"l voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTGPictureButton::CreateDisabledPicture(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGPictureButton::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGButton::EmitSignals(Bool_t wasUp); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGImageMap(const TGImageMap&); TGImageMap&operator=(const TGImageMap&). Data Members; public:. enum ENavMode { kNavRegions; kNavGrid; };; enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableK",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGImageMap.html:15870,Clear,ClearFlags,15870,root/html532/TGImageMap.html,https://root.cern,https://root.cern/root/html532/TGImageMap.html,2,['Clear'],['ClearFlags']
Usability,"l voidTGFrame::UnmapWindow(); virtual voidUpdateBackgroundStart(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual Bool_tItemLayout(); voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); virtual voidUpdateRegion(Int_t x, Int_t y, UInt_t w, UInt_t h). private:. TGView(const TGView&); TGView&operator=(const TGView&). Data Members; public:. enum { kNoHSB; kNoVSB; kHorizontal; kVertical; };; enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGView.html:16377,Clear,ClearFlags,16377,root/html532/TGView.html,https://root.cern,https://root.cern/root/html532/TGView.html,2,['Clear'],['ClearFlags']
Usability,"l voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; voidAttachList(TList* alist); virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofOutputList.html:1792,Clear,Clear,1792,root/html532/TProofOutputList.html,https://root.cern,https://root.cern/root/html532/TProofOutputList.html,2,['Clear'],['Clear']
Usability,"l voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelTrivial(); Default constructor for streamer. PDEFoamKernelTrivial(const TMVA::PDEFoamKernelTrivial& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Simple kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates). Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. virtual ~PDEFoamKernelTrivial(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__PDEFoamKernelTrivial.html:5910,Simpl,Simple,5910,root/html534/TMVA__PDEFoamKernelTrivial.html,https://root.cern,https://root.cern/root/html534/TMVA__PDEFoamKernelTrivial.html,1,['Simpl'],['Simple']
Usability,"l void InitImpl (RNTupleModel &model)=0;  ; RSealedPage SealPage (const RPage &page, const RColumnElementBase &element);  Helper for streaming a page. ;  ;  Protected Member Functions inherited from ROOT::Experimental::Internal::RPageStorage; void WaitForAllTasks ();  . Protected Attributes; std::unique_ptr< RNTupleCompressor > fCompressor;  Helper to zip pages and header/footer; includes a 16MB (kMAXZIPBUF) zip buffer. ;  ; std::unique_ptr< RNTupleWriteOptions > fOptions;  ;  Protected Attributes inherited from ROOT::Experimental::Internal::RPageStorage; Detail::RNTupleMetrics fMetrics;  ; std::string fNTupleName;  ; std::unique_ptr< RPageAllocator > fPageAllocator;  For the time being, we will use the heap allocator for all sources and sinks. This may change in the future. ;  ; RTaskScheduler * fTaskScheduler = nullptr;  . Private Attributes; bool fIsInitialized = false;  Flag if sink was initialized. ;  ; std::vector< Callback_t > fOnDatasetCommitCallbacks;  ; std::vector< unsigned char > fSealPageBuffer;  Used as destination buffer in the simple SealPage overload. ;  ; RWritePageMemoryManager fWritePageMemoryManager;  Used in ReservePage to maintain the page buffer budget. ;  . Additional Inherited Members;  Static Public Attributes inherited from ROOT::Experimental::Internal::RPageStorage; static constexpr std::size_t kNBytesPageChecksum = sizeof(std::uint64_t);  The page checksum is a 64bit xxhash3. ;  . #include <ROOT/RPageStorage.hxx>. Inheritance diagram for ROOT::Experimental::Internal::RPageSink:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Callback_t. using ROOT::Experimental::Internal::RPageSink::Callback_t = std::function<void(RPageSink &)>. Definition at line 258 of file RPageStorage.hxx. Constructor & Destructor Documentation. ◆ RPageSink() [1/3]. ROOT::Experimental::Internal::RPageSink::RPageSink ; (; std::string_view ; ntupleName, . const RNTupleWriteOptions & ; opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html:6662,simpl,simple,6662,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html,1,['simpl'],['simple']
Usability,"l ~TEveListTreeItem(); {}. Bool_t IsActive() const; { return fElement->GetSelectedLevel() != 0; }. void SetActive(Bool_t ); { NotSupported(""SetActive""); }. const char * GetText() const; { return fElement->GetElementName(); }. Int_t GetTextLength() const; { return strlen(fElement->GetElementName()); }. const char * GetTipText() const; { return fElement->GetElementTitle(); }. Int_t GetTipTextLength() const; { return strlen(fElement->GetElementTitle()); }. void SetText(const char* ); { NotSupported(""SetText""); }. void SetTipText(const char* ); { NotSupported(""SetTipText""); }. void SetUserData(void* , Bool_t = kFALSE); { NotSupported(""SetUserData""); }. void * GetUserData() const; { return fElement; }. const TGPicture* GetPicture() const; { return fElement->GetListTreeIcon(fOpen); }. const TGPicture* GetCheckBoxPicture() const; { return fElement->GetListTreeCheckBoxIcon(); }. void SetPictures(const TGPicture* , const TGPicture* ); { NotSupported(""SetUserData""); }. void SetCheckBoxPictures(const TGPicture* , const TGPicture* ); { NotSupported(""SetUserData""); }. void SetCheckBox(Bool_t = kTRUE); { NotSupported(""SetCheckBox""); }. Bool_t HasCheckBox() const; { return kTRUE; }. void CheckItem(Bool_t = kTRUE); { printf(""TEveListTreeItem::CheckItem - to be ignored ... all done via signal Checked().\n""); }. Bool_t IsChecked() const; { return fElement->GetRnrState(); }. Bool_t HasColor() const; Propagation of checked-state form children to parents. Not needed, ignore.; Item coloration (underline + minibox). { return fElement->HasMainColor(); }. Color_t GetColor() const; { return fElement->GetMainColor(); }. void SetColor(Color_t ); { NotSupported(""SetColor""); }. void ClearColor(); { NotSupported(""ClearColor""); }. » Last changed: root/eve:$Id: TEveBrowser.h 36955 2010-11-25 21:23:09Z matevz $ » Last generated: 2011-11-03 20:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveListTreeItem.html:6042,Clear,ClearColor,6042,root/html532/TEveListTreeItem.html,https://root.cern,https://root.cern/root/html532/TEveListTreeItem.html,2,['Clear'],['ClearColor']
Usability,"l! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static TEveElement::EDestructTEveElement::kAnnihilate; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"). virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveEventManager.html:21435,Clear,ClearNewEventCommands,21435,root/html604/TEveEventManager.html,https://root.cern,https://root.cern/root/html604/TEveEventManager.html,2,['Clear'],"['Clear', 'ClearNewEventCommands']"
Usability,"l! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static TEveElement::EDestructTEveElement::kAnnihilate; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"). virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveEventManager.html:21435,Clear,ClearNewEventCommands,21435,root/html602/TEveEventManager.html,https://root.cern,https://root.cern/root/html602/TEveEventManager.html,2,['Clear'],"['Clear', 'ClearNewEventCommands']"
Usability,"l*_funct; RooArgList*_initConstParamList; RooArgList*_initFloatParamList; ofstream*_logfile; double_maxFCN; int_nDim; int_numBadNLL; int_printEvalErrors; bool_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMinimizerFcn(RooAbsReal* funct, RooMinimizer* context, bool verbose = false); Reset the *largest* negative log-likelihood value we have seen so far. RooMinimizerFcn(const RooMinimizerFcn& other). ~RooMinimizerFcn(). ROOT::Math::IBaseFunctionMultiDim* Clone() const. Bool_t Synchronize(vector<ROOT::Fit::ParameterSettings>& parameters, Bool_t optConst, Bool_t verbose). Double_t GetPdfParamVal(Int_t index); Access PDF parameter value by ordinal index (needed by MINUIT). Double_t GetPdfParamErr(Int_t index); Access PDF parameter error by ordinal index (needed by MINUIT). void SetPdfParamErr(Int_t index, Double_t value); Modify PDF parameter error by ordinal index (needed by MINUIT). void ClearPdfParamAsymErr(Int_t index); Modify PDF parameter error by ordinal index (needed by MINUIT). void SetPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); Modify PDF parameter error by ordinal index (needed by MINUIT). void BackProp(const ROOT::Fit::FitResult& results); Transfer MINUIT fit results back into RooFit objects. Bool_t SetLogFile(const char* inLogfile); Change the file name for logging of a RooMinimizer of all MINUIT steppings; through the parameter space. If inLogfile is null, the current log file; is closed and logging is stopped. void ApplyCovarianceMatrix(TMatrixDSym& V); Apply results of given external covariance matrix. i.e. propagate its errors; to all RRV parameter representations and give this matrix instead of the; HESSE matrix at the next save() call. Bool_t SetPdfParamVal(const Int_t& index, const Double_t& value) const; RooRealVar* par = (RooRealVar*)_floatParamList->at(index);. void updateFloatVec(). double DoEval(const double* x) const. unsigned int NDim() const; { return _nDim; }. RooArgList* G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMinimizerFcn.html:3183,Clear,ClearPdfParamAsymErr,3183,root/html602/RooMinimizerFcn.html,https://root.cern,https://root.cern/root/html602/RooMinimizerFcn.html,2,['Clear'],['ClearPdfParamAsymErr']
Usability,"l, . Long64_t ; processed . ). Update progress bar and status labels. ; Definition at line 2745 of file TSessionViewer.cxx. ◆ ResetProgressDialog(). void TSessionQueryFrame::ResetProgressDialog ; (; const char * ; selec, . Int_t ; files, . Long64_t ; first, . Long64_t ; entries . ). Reset progress frame information fields. ; Definition at line 2905 of file TSessionViewer.cxx. ◆ Streamer(). void TSessionQueryFrame::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGCompositeFrame. ◆ StreamerNVirtual(). void TSessionQueryFrame::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 448 of file TSessionViewer.h. ◆ UpdateButtons(). void TSessionQueryFrame::UpdateButtons ; (; TQueryDescription * ; desc). Update buttons state for the current query status. ; Definition at line 3229 of file TSessionViewer.cxx. ◆ UpdateHistos(). void TSessionQueryFrame::UpdateHistos ; (; TList * ; objs). Update feedback histograms. ; Definition at line 2572 of file TSessionViewer.cxx. ◆ UpdateInfos(). void TSessionQueryFrame::UpdateInfos ; (; ). Update query information (header) text view. ; Definition at line 3337 of file TSessionViewer.cxx. Member Data Documentation. ◆ fBtnAbort. TGTextButton* TSessionQueryFrame::fBtnAbort. private . Definition at line 386 of file TSessionViewer.h. ◆ fBtnFinalize. TGTextButton* TSessionQueryFrame::fBtnFinalize. private . Definition at line 384 of file TSessionViewer.h. ◆ fBtnRetrieve. TGTextButton* TSessionQueryFrame::fBtnRetrieve. private . Definition at line 388 of file TSessionViewer.h. ◆ fBtnSave. TGTextButton* TSessionQueryFrame::fBtnSave. private . Definition at line 389 of file TSessionViewer.h. ◆ fBtnShowLog. TGTextButton* TSessionQueryFrame::fBtnShowLog. private . Definition at line 387 of file TSessionViewer.h. ◆ fBtnStop. TGTextButton* TSessionQueryFrame::fBtnStop. private . Definition at line 385 of file TSessionViewer.h. ◆ fBtnSubmit. TGTextButton* T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionQueryFrame.html:38258,feedback,feedback,38258,doc/master/classTSessionQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionQueryFrame.html,1,['feedback'],['feedback']
Usability,"l, TClass* newcl); voidWriteItems(int nElements, TBuffer& b). private:. TEmulatedCollectionProxy&operator=(const TEmulatedCollectionProxy&). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tTGenCollectionProxy::fCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tTGenCollectionProxy::fConstructContainer accessors: block construct; map<string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tTGenCollectionProxy::fDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*TGenCollectionProxy::fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tTGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::fFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::fFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::fFunctionDeleteI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedCollectionProxy.html:4896,clear,clear,4896,root/html602/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedCollectionProxy.html,4,['clear'],['clear']
Usability,"l,int> type = GetType(name);; 105 fUseDerivAlgo = type.first;; 106 fType = type.second;; 107}; 108 ; 109 ; 110int GSLMultiRootFinder::AddFunction(const ROOT::Math::IMultiGenFunction & func) {; 111 // add a new function in the vector; 112 ROOT::Math::IMultiGenFunction * f = func.Clone();; 113 if (!f) return 0;; 114 fFunctions.push_back(f);; 115 return fFunctions.size();; 116}; 117 ; 118void GSLMultiRootFinder::ClearFunctions() {; 119 // clear the function list; 120 for (unsigned int i = 0; i < fFunctions.size(); ++i) {; 121 if (fFunctions[i] != nullptr ) delete fFunctions[i];; 122 fFunctions[i] = nullptr;; 123 }; 124 fFunctions.clear();; 125}; 126 ; 127void GSLMultiRootFinder::Clear() {; 128 // clear the function list and the solver; 129 ClearFunctions();; 130 if (fSolver) Clear();; 131 fSolver = nullptr;; 132}; 133 ; 134 ; 135const double * GSLMultiRootFinder::X() const {; 136 // return x; 137 return (fSolver != nullptr) ? fSolver->X() : nullptr;; 138}; 139const double * GSLMultiRootFinder::Dx() const {; 140 // return x; 141 return (fSolver != nullptr) ? fSolver->Dx() : nullptr;; 142}; 143const double * GSLMultiRootFinder::FVal() const {; 144 // return x; 145 return (fSolver != nullptr) ? fSolver->FVal() : nullptr;; 146}; 147const char * GSLMultiRootFinder::Name() const {; 148 // get GSL name; 149 return (fSolver != nullptr) ? fSolver->Name().c_str() : """";; 150}; 151 ; 152// bool GSLMultiRootFinder::AddFunction( const ROOT::Math::IMultiGenFunction & func) {; 153// // clone and add function to the list; 154// // If using a derivative algorithm the function is checked if it implements; 155// // the gradient interface. If this is not the case the type is set to non-derivatibe algo; 156// ROOT::Math::IGenMultiFunction * f = func.Clone();; 157// if (f != 0) return false;; 158// if (fUseDerivAlgo) {; 159// bool gradFunc = (dynamic_cast<ROOT::Math::IMultiGradFunction *> (f) != 0 );; 160// if (!gradFunc) {; 161// MATH_ERROR_MSG(""GSLMultiRootFinder::AddFunction"",""Function do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html:4096,clear,clear,4096,doc/master/GSLMultiRootFinder_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html,2,['clear'],['clear']
Usability,"l->GetClassPointer()->CanSplit()); 2428 {; 2429 continue;; 2430 }; 2431 }; 2432 if (nextel->GetOffset() == TStreamerInfo::kMissing) {; 2433 // This element will be 'skipped', it's TBranchElement's fObject will null; 2434 // and thus can not be used to execute the artificial StreamerElements; 2435 continue;; 2436 }; 2437 if (nextel->IsA() != TStreamerArtificial::Class(); 2438 || nextel->GetType() == TStreamerInfo::kCacheDelete ) {; 2439 continue;; 2440 }; 2441 // NOTE: We should verify that the rule's source are 'before'; 2442 // or 'at' this branch.; 2443 // fprintf(stderr,""%s/%d[%zu] pushd %zu %s\n"",GetName(),fID,fIDs.size(),i,nextel->GetName());; 2444 fNewIDs.push_back(i);; 2445 fNewIDs.back().fElement = nextel;; 2446 fNewIDs.back().fInfo = fInfo;; 2447 }; 2448 } else if (elt && offset==TStreamerInfo::kMissing) {; 2449 // Still re-assign fID properly.; 2450 fNewIDs.clear();; 2451 size_t ndata = fInfo->GetNelement();; 2452 for (size_t i = 0; i < ndata; ++i) {; 2453 if (fInfo->GetElement(i) == elt) {; 2454 fID = i;; 2455 break;; 2456 }; 2457 }; 2458 } else {; 2459 // We have not even found the element .. this is strange :(; 2460 // fNewIDs.clear();; 2461 // fID = -3;; 2462 // SetBit(kDoNotProcess);; 2463 }; 2464 if (fOnfileObject==nullptr && (fType==31 || fType==41 || (0 <= fType && fType <=2) ) && fInfo->GetNelement(); 2465 && fInfo->GetElement(0)->GetType() == TStreamerInfo::kCacheNew); 2466 {; 2467 SetOnfileObject(fInfo);; 2468 }; 2469 }; 2470 if (fType == 3 || fType == 4 || (fType == 0 && fID == -2) || fType == 2) {; 2471 // Need to add the rule targeting transient members.; 2472 TStreamerInfo *localInfo = fInfo;; 2473 if (fType == 3 || fType == 4) {; 2474 // Don't we have real version information?; 2475 // Not unless there is a subbranch with a non-split element of the class.; 2476 // Search for the correct version.; 2477 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 2478 }; 2479 ; 2480 TString prefix(GetFullName());; 2481 if (fType == 2 && fID >= 0) {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:87723,clear,clear,87723,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['clear'],['clear']
Usability,l. RooStats::HypoTestInverterPlot. RooStats::HypoTestInverterResult. RooStats::HypoTestPlot. RooStats::HypoTestResult←. RooStats::HybridResult. RooStats::LikelihoodInterval. RooStats::LikelihoodIntervalPlot. RooStats::MCMCCalculator. RooStats::MCMCInterval. RooStats::MCMCIntervalPlot. RooStats::MarkovChain. RooStats::MaxLikelihoodEstimateTestStat. RooStats::MetropolisHastings. RooStats::MinNLLTestStat. RooStats::ModelConfig. RooStats::NeymanConstruction. RooStats::NumEventsTestStat. RooStats::PdfProposal. RooStats::PointSetInterval. RooStats::ProfileLikelihoodCalculator. RooStats::ProfileLikelihoodTestStat. RooStats::ProposalFunction←. RooStats::PdfProposal. RooStats::SequentialProposal. RooStats::UniformProposal. RooStats::ProposalHelper. RooStats::RatioOfProfiledLikelihoodsTestStat. RooStats::SPlot. RooStats::SamplingDistPlot←. RooStats::HypoTestPlot. RooStats::SamplingDistribution. RooStats::SamplingSummary. RooStats::SamplingSummaryLookup. RooStats::SequentialProposal. RooStats::SimpleInterval←. RooStats::HypoTestInverterResult. RooStats::SimpleLikelihoodRatioTestStat. RooStats::ToyMCImportanceSampler. RooStats::ToyMCPayload. RooStats::ToyMCSampler←. RooStats::ToyMCImportanceSampler. RooStats::ToyMCStudy. RooStats::UniformProposal. RooStats::UpperLimitMCSModule. RooStepFunction. RooStringVar. RooStudyManager. RooStudyPackage. RooSuperCategory. RooTFnBinding. RooTFnPdfBinding. RooTFoamBinding. RooTObjWrap. RooTable←. Roo1DTable. RooThreshEntry. RooThresholdCategory. RooTreeData. RooTreeDataStore. RooTruthModel. RooUnblindCPAsymVar. RooUnblindOffset. RooUnblindPrecision. RooUnblindUniform. RooUniform. RooUniformBinning. RooUnitTest. RooVectorDataStore. RooVectorDataStore::RealFullVector. RooVoigtian. RooWorkspace. RooWorkspace::CodeRepo. RooWorkspace::WSDir. RooXYChi2Var. TASImage. TASImagePlugin←. TASPluginGS. TASPaletteEditor. TASPluginGS. TAdvancedGraphicsDialog. TApplication←. PyROOT::TPyROOTApplication. TApplicationRemote. TApplicationServer. TGApplication. TP,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassHierarchy.html:27059,Simpl,SimpleInterval,27059,root/html534/ClassHierarchy.html,https://root.cern,https://root.cern/root/html534/ClassHierarchy.html,3,['Simpl'],['SimpleInterval']
Usability,"l; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of variables used in randomised trees;; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseSearchTreecut scan done with binary trees or simple event loop.; vector<Double_t>fVariableImportancethe relative importance of the different variables; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc.; static const Int_tfgRandomSeedset nonzero for debugging and zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTree(); default constructor using the GiniIndex as separation criterion,; no restrictions on minium number of events in a leave note or the; separation gain in the node splitting. DecisionTree(TMVA::SeparationBase* sepType, Float_t minSize, Int_t nCuts, TMVA::DataSetInfo* = __null, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); constructor specifying the separation type, the min number of; events in a no that is still subjected to furthe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:8350,simpl,simple,8350,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,4,['simpl'],['simple']
Usability,"l</A>.; 91 ; 92 ; 93@ingroup Integration; 94 ; 95*/; 96 ; 97 ; 98class IntegratorOneDim {; 99 ; 100public:; 101 ; 102 typedef IntegrationOneDim::Type Type; // for the enumerations defining the types; 103 ; 104 // constructors; 105 ; 106 ; 107 /**; 108 Constructor of one dimensional Integrator, default type is adaptive; 109 ; 110 @param type integration type (adaptive, non-adaptive, etc..); 111 @param absTol desired absolute Error; 112 @param relTol desired relative Error; 113 @param size maximum number of sub-intervals; 114 @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type); 115 ; 116 Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); 117 Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); 118 lower rules are indicated for singular functions while higher for smooth functions to get better accuracies; 119 ; 120 NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions; 121 */; 122 explicit; 123 IntegratorOneDim(IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = -1, double relTol = -1, unsigned int size = 0, unsigned int rule = 0) :; 124 fIntegrator(nullptr), fFunc(nullptr); 125 {; 126 fIntegrator = CreateIntegrator(type, absTol, relTol, size, rule);; 127 }; 128 ; 129 /**; 130 Constructor of one dimensional Integrator passing a function interface; 131 ; 132 @param f integration function (1D interface). It is copied inside; 133 @param type integration type (adaptive, non-adaptive, etc..); 134 @param absTol desired absolute tolerance. The algorithm will stop when either the absolute OR the relative tolerance are satisfied.; 135 @param relTol desired relative tolerance; 136 @param size maximum number of sub-intervals; 137 @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:4155,simpl,simple,4155,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,1,['simpl'],['simple']
Usability,"lFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 144 of file TGProgressBar.h. ◆ DoRedraw(). void TGVProgressBar::DoRedraw ; (; ). overrideprotectedvirtual . Draw vertical progress bar. ; Implements TGProgressBar.; Definition at line 359 of file TGProgressBar.cxx. ◆ GetDefaultSize(). TGDimension TGVProgressBar::GetDefaultSize ; (; ); const. inlineoverridevirtual . std::cout << fWidth << ""x"" << fHeight << std::endl; ; Reimplemented from TGFrame.; Definition at line 138 of file TGProgressBar.h. ◆ IsA(). TClass * TGVProgressBar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGProgressBar.; Definition at line 144 of file TGProgressBar.h. ◆ Percent(). void TGVProgressBar::Percent ; (; Bool_t ; ). inlineoverridevirtual . Reimplemented from TGProgressBar.; Definition at line 142 of file TGProgressBar.h. ◆ SavePrimitive(). void TGVProgressBar::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a vertical progress bar as a C++ statement(s) on output stream out. ; Reimplemented from TGProgressBar.; Definition at line 438 of file TGProgressBar.cxx. ◆ ShowPos(). void TGVProgressBar::ShowPos ; (; Bool_t ; ). inlineoverridevirtual . Reimplemented from TGProgressBar.; Definition at line 141 of file TGProgressBar.h. ◆ Streamer(). void TGVProgressBar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGProgressBar. ◆ StreamerNVirtual(). void TGVProgressBar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 144 of file TGProgressBar.h. Libraries for TGVProgressBar:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGProgressBar.h; gui/gui/src/TGProgressBar.cxx. TGVProgressBar. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGVProgressBar.html:33466,progress bar,progress bar,33466,doc/master/classTGVProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGVProgressBar.html,1,['progress bar'],['progress bar']
Usability,"lX(const char* name, const char* title); virtual~TVirtualX(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tAddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tAllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidChangeGC(GContext_t gc, GCValues_t* gval); virtual voidChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tCheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidClearWindow(); virtual voidClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseDisplay(); virtual voidClosePixmap(); virtual voidCloseWindow(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidCopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidCopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual Pixmap_tCreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height); virtual Cursor_tCreateCursor(ECursor cursor); virtual GC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualX.html:1657,Clear,Clear,1657,root/html532/TVirtualX.html,https://root.cern,https://root.cern/root/html532/TVirtualX.html,1,['Clear'],['Clear']
Usability,"lX. Font_t GetTextFont() const; Delegate to gVirtualX. Float_t GetTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPadPainter.html:5200,simpl,simple,5200,root/html528/TPadPainter.html,https://root.cern,https://root.cern/root/html528/TPadPainter.html,4,['simpl'],['simple']
Usability,"l_t JoinProcess(TList* workers); Not implemented: meaningful only in the remote player. Returns kFALSE. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(Bool_t savememvalues = kFALSE); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); Update automatic binning parameters for given object ""name"". TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet (may not be used in this class). void SetupFeedback(); Set up feedback (may not be used in this class). void StopFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:20905,feedback,feedback,20905,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,4,['feedback'],['feedback']
Usability,"l_t ShouldImport(TEveElement* el); Returns true if element el should be imported. Behaviour depends on the value of the fImportEmpty member:; false - el or any of its children must be projectable (default);; true - always import. void UpdateDependentElsAndScenes(TEveElement* root); Update dependent elements' bounding box and mark scenes; containing element root or its children as requiring a repaint. TEveElement* ImportElementsRecurse(TEveElement* el, TEveElement* parent); If el is TEveProjectable add projected instance else add plain; TEveElementList to parent. Call the same function on el's; children. Returns the projected replica of el. Can be 0, if el and none of; its children are projectable. TEveElement* ImportElements(TEveElement* el, TEveElement* ext_list = 0); Recursively import elements and apply projection to the newly; imported objects. If ext_list is not 0 the new element is also added to the list.; This simplifies construction of complex views where projected; elements are distributed into several scenes for optimization of; updates and rendering. Returns the projected replica of el. Can be 0, if el and none of; its children are projectable. TEveElement* SubImportElements(TEveElement* el, TEveElement* proj_parent); Recursively import elements and apply projection to the newly; imported objects. The proj_parent argument should be a projected replica of parent; of element 'el'. This allows to insert projected children of; a given element when they are added after the projection has; been already performed on the parent.; This is called from TEveElement::ProjectChild(). Returns the projected replica of el. Can be 0, if el and none of; its children are projectable. Int_t SubImportChildren(TEveElement* el, TEveElement* proj_parent); Recursively import childer elements of el and apply projection; to the newly imported objects. The proj_parent argument should be a projected replica of; element 'el'. This allows to insert projected children of; a given element ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveProjectionManager.html:22919,simpl,simplifies,22919,root/html528/TEveProjectionManager.html,https://root.cern,https://root.cern/root/html528/TEveProjectionManager.html,10,['simpl'],['simplifies']
Usability,"l_t back = GetDefaultFrameBackground()); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTGWindow::kEditDisableGrab; static TGWindow::EEditModeTGWindow::kEditDisableHeight; static TGWin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHScrollBar.html:15287,Clear,ClearFlags,15287,root/html602/TGHScrollBar.html,https://root.cern,https://root.cern/root/html602/TGHScrollBar.html,4,['Clear'],['ClearFlags']
Usability,"l_t back = GetDefaultFrameBackground()); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGScrollBar&operator=(const TGScrollBar&); TGScrollBar(const TGScrollBar&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTGWindow::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGScrollBar.html:15017,Clear,ClearFlags,15017,root/html602/TGScrollBar.html,https://root.cern,https://root.cern/root/html602/TGScrollBar.html,2,['Clear'],['ClearFlags']
Usability,"l_t shiftToZero = kFALSE, RooCurve::WingMode wmode = Extended, Int_t nEvalError = -1, Int_t doEEVal = kFALSE, Double_t eeVal = 0); RooCurve(const RooAbsReal& func, RooAbsRealLValue& x, Double_t xlo, Double_t xhi, Int_t xbins, Double_t scaleFactor = 1, const RooArgSet* normVars = 0, Double_t prec = 1e-3, Double_t resolution = 1e-3, Bool_t shiftToZero = kFALSE, RooCurve::WingMode wmode = Extended, Int_t nEvalError = -1, Int_t doEEVal = kFALSE, Double_t eeVal = 0, Bool_t showProgress = kFALSE); virtual~RooCurve(); voidTObject::AbstractMethod(const char* method) const; voidaddPoint(Double_t x, Double_t y); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGraph::Apply(TF1* f); Double_taverage(Double_t lo, Double_t hi) const; virtual voidTGraph::Browse(TBrowser* b); virtual Double_tTGraph::Chisquare(const TF1* f1) const; Double_tchiSquare(const RooHist& hist, int nFitParam) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tTGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareX(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareY(const TGraph* gr, Int_t left, Int_t right); virtual voidTGraph::ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidTNamed::Copy(TObject& named) const; TObject*RooPlotable::crossCast(); virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCurve.html:2219,Clear,Clear,2219,root/html532/RooCurve.html,https://root.cern,https://root.cern/root/html532/RooCurve.html,1,['Clear'],['Clear']
Usability,"l_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_thasChanged(Bool_t clearState); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooChangeTracker.html:15113,clear,clearState,15113,root/html530/RooChangeTracker.html,https://root.cern,https://root.cern/root/html530/RooChangeTracker.html,2,['clear'],['clearState']
Usability,"l_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_thasChanged(Bool_t clearState); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:14807,clear,clearState,14807,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,2,['clear'],['clearState']
Usability,"l_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*cacheUniqueSuffix() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidchangeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tcheckDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearShapeDirty() const; voidclearValueAndShapeDirty() const; voidclearValueDirty() const; TIterator*clientIterator() const; virtual TObject*clone(const char* newname = 0) const; virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsArg*cloneTree(const char* newname = 0) const; virtual Int_tCompare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tcrc32(const char* data); static UInt_tcrc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdependentOverlaps(const RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:2435,Clear,Clear,2435,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,1,['Clear'],['Clear']
Usability,"l_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddToRange(const char* rangeName, const char* stateNameList); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:2038,Clear,Clear,2038,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,1,['Clear'],['Clear']
Usability,"l_tMakeBranch(const char* expr, Bool_t left); voidTObject::MakeZombie(). private:. TGeoBoolNode&operator=(const TGeoBoolNode&). Data Members; public:. enum EGeoBoolType { kGeoUnion; kGeoIntersection; kGeoSubtraction; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGeoShape*fLeftshape on the left branch; TGeoMatrix*fLeftMattransformation that applies to the left branch; Int_tfNpoints! number of points on the mesh; Double_t*fPoints! array of mesh points; TGeoShape*fRightshape on the right branch; TGeoMatrix*fRightMattransformation that applies to the right branch; vector<ThreadData_t*>fThreadData! Navigation data per thread; Int_tfThreadSize! Size for the navigation data array. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads); Create thread data for n threads max. void SetSelected(Int_t sel); Set the selected branch. ~TGeoBoolNode(); Destructor.; --- deletion of components handled by TGeoManager class. Bool_t MakeBranch(const char* expr, Bool_t left); Expands the boolean expression either on left or right branch, creating; component elements (composite shapes and boolean nodes). Returns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. Bool_t ReplaceMatrix(TGeoMatrix* mat, TGeoMatrix* newmat); Replace one of the matrices. Does not work with TGeoIdentity. Returns true; if replacement was successful. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBoolNode.html:7954,Clear,ClearThreadData,7954,root/html534/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html534/TGeoBoolNode.html,1,['Clear'],['ClearThreadData']
Usability,"l_tMakeBranch(const char* expr, Bool_t left); voidTObject::MakeZombie(). private:. TGeoBoolNode&operator=(const TGeoBoolNode&). Data Members; public:. enum EGeoBoolType { kGeoUnion; kGeoIntersection; kGeoSubtraction; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGeoShape*fLeftshape on the left branch; TGeoMatrix*fLeftMattransformation that applies to the left branch; Int_tfNpoints! number of points on the mesh; Double_t*fPoints! array of mesh points; TGeoShape*fRightshape on the right branch; TGeoMatrix*fRightMattransformation that applies to the right branch; vector<ThreadData_t*>fThreadData! Navigation data per thread; Int_tfThreadSize! Size for the navigation data array. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void SetSelected(Int_t sel); Set the selected branch. ~TGeoBoolNode(); Destructor.; --- deletion of components handled by TGeoManager class. Bool_t MakeBranch(const char* expr, Bool_t left); Expands the boolean expression either on left or right branch, creating; component elements (composite shapes and boolean nodes). Returns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoints(Float_t* points) const; Fill buffer with shape vertices. void Sizeof3D() const; Register size of this 3D object. ThreadData_t& GetThreadData() const. TGeoBoolNode& operator=(const TGeoBoolNode& ). void ComputeBBox(Double_t& dx, Double_t& d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoBoolNode.html:7751,Clear,ClearThreadData,7751,root/html532/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html,1,['Clear'],['ClearThreadData']
Usability,"l_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidTGedSelect::DrawTriangle(GContext_t gc, Int_t x, Int_t y); virtual voidTGCheckButton::EmitSignals(Bool_t wasUp = kTRUE); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTGCheckButton::Init(); voidTObject::MakeZombie(); TGWindow&TGWindow::operator=(const TGWindow& tgw); voidTGCheckButton::PSetState(EButtonState state, Bool_t emit); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGedMarkerSelect.html:17176,Clear,ClearFlags,17176,root/html532/TGedMarkerSelect.html,https://root.cern,https://root.cern/root/html532/TGedMarkerSelect.html,4,['Clear'],['ClearFlags']
Usability,"l_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawTriangle(GContext_t gc, Int_t x, Int_t y); virtual voidTGCheckButton::EmitSignals(Bool_t wasUp = kTRUE); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTGCheckButton::Init(); voidTObject::MakeZombie(); voidTGCheckButton::PSetState(EButtonState state, Bool_t emit); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedSelect.html:17333,Clear,ClearFlags,17333,root/html602/TGedSelect.html,https://root.cern,https://root.cern/root/html602/TGedSelect.html,2,['Clear'],['ClearFlags']
Usability,"l_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawTriangle(GContext_t gc, Int_t x, Int_t y); virtual voidTGCheckButton::EmitSignals(Bool_t wasUp = kTRUE); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTGCheckButton::Init(); voidTObject::MakeZombie(); voidTGCheckButton::PSetState(EButtonState state, Bool_t emit); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGColorSelect&operator=(const TGColorSelect&); TGColorSelect(const TGColorSelect&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColorSelect.html:17454,Clear,ClearFlags,17454,root/html602/TGColorSelect.html,https://root.cern,https://root.cern/root/html602/TGColorSelect.html,2,['Clear'],['ClearFlags']
Usability,"lag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBoxEditor.html:21445,undo,undoing,21445,root/html534/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html534/TGeoBBoxEditor.html,2,['undo'],['undoing']
Usability,"lag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0); Create a PROOF player. TVirtualProofPlayer(); { ResetBit(TVirtualProofPlayer::kIsSubmerger); }. virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Bool_t JoinProcess(TList* workers). Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:14016,Clear,ClearInput,14016,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,1,['Clear'],['ClearInput']
Usability,"lag); virtual voidShowMembers(TMemberInspector& insp); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(const RooStats::SimpleLikelihoodRatioTestStat&); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. RooArgSet*fAltParameters; RooAbsPdf*fAltPdf; static Bool_tfAlwaysReuseNll; boolfFirstEval; RooNLLVar*fNllAlt! transient copy of the alt NLL; RooNLLVar*fNllNull! transient copy of the null NLL; RooArgSet*fNullParameters; RooAbsPdf*fNullPdf; Bool_tfReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleLikelihoodRatioTestStat(). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters). virtual ~SimpleLikelihoodRatioTestStat(). void SetAlwaysReuseNLL(Bool_t flag); { fAlwaysReuseNll = flag ; }. void SetReuseNLL(Bool_t flag); { fReuseNll = flag ; }. void SetNullParameters(const RooArgSet& nullParameters). void SetAltParameters(const RooArgSet& altParameters). bool ParamsAreEqual(). Double_t Evaluate(RooAbsData& data, RooArgSet& nullPOI). const TString GetVarName() const. » Author: Kyle Cranmer and Sven Kreiss June 2010 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: SimpleLikelihoodRatioTestStat.h 42339 2011-11-30 23:54:18Z moneta $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__SimpleLikelihoodRatioTestStat.html:2087,Simpl,SimpleLikelihoodRatioTestStat,2087,root/html532/RooStats__SimpleLikelihoodRatioTestStat.html,https://root.cern,https://root.cern/root/html532/RooStats__SimpleLikelihoodRatioTestStat.html,4,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,"lass More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. Mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:6552,simpl,simple,6552,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['simpl'],['simple']
Usability,"lass Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t > Class Template Reference. ; template<typename Architecture_t, typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >Adam Optimizer class. ; This class represents the Adam Optimizer. ; Definition at line 45 of file Adam.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdam (DeepNet_t &deepNet, Scalar_t learningRate=0.001, Scalar_t beta1=0.9, Scalar_t beta2=0.999, Scalar_t epsilon=1e-7);  Constructor. ;  ;  ~TAdam ()=default;  Destructor. ;  ; Scalar_t GetBeta1 () const;  Getters. ;  ; Scalar_t GetBeta2 () const;  ; Scalar_t GetEpsilon () const;  ; std::vector< std::vector< Matrix_t > > & GetFirstMomentBiases ();  ; std::vector< Matrix_t > & GetFirstMomentBiasesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetFirstMomentWeights ();  ; std::vector< Matrix_t > & GetFirstMomentWeightsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetSecondMomentBiases ();  ; std::vector< Matrix_t > & GetSecondMomentBiasesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetSecondMomentWeights ();  ; std::vector< Matrix_t > & GetSecondMomentWeightsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:1088,learn,learningRate,1088,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,1,['learn'],['learningRate']
Usability,"lass description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::BuildConfig. class RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__BuildConfig.html:1093,simpl,simple,1093,root/html526/RooSimWSTool__BuildConfig.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__BuildConfig.html,5,['simpl'],['simple']
Usability,"lass member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 // the online reference guide, we first check if the command starts correctly.; 1278 if ((!strippedCommand.BeginsWith("".help "")) && (!strippedCommand.BeginsWith("".? ""))) {; 1279 Error(""Help"", ""Unknown command!"");; 1280 return;; 1281 }; 1282 // We remove the command "".help"" or "".?"" from the TString.; 1283 if (strippedCommand.BeginsWith("".? "")) {; 1284 strippedCommand.Remove(0, 3);; 1285 } else {; 1286 strippedCommand.Remove(0, 5);; 1287 }; 1288 // We strip the command line after removing "".help"" or "".?"".; 1289 strippedCommand = strippedCommand.Strip(TString::kBoth);; 1290 ; 1291 if (strippedCommand == ""edit"") {; 1292 Printf(""\n ROOT terminal keyboard shortcuts (GNU-readline style)."");; 1293 #ifdef R__MACOSX; 1294 #define FOOTNOTE "" *""; 1295 Printf(""* Some of these commands might be intercepted by macOS predefined system shortcuts."");; 1296 // https://apple.stackexchange.com/questions/18043/how-can-i-make-ctrlright-left-arrow-stop-changing-desktops-in-lion; 1297 #else; 1298 #define FOOTNOTE """"; 1299 #endif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:50977,guid,guide,50977,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['guid'],['guide']
Usability,"lass provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactoryA factory for building PDFs and data for a number counting combination ;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspectorUtility class to plot conditional MLE of nuisance parameters vs ;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:7931,simpl,simple,7931,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['simpl'],['simple']
Usability,"lass()) {; 6283 unroll = Unroll(name, clParent, clOfBase, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6284 }; 6285 if (unroll < 0) {; 6286 // FIXME: We could not split because we are abstract, should we be doing this?; 6287 if (namelen) {; 6288 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6289 } else {; 6290 branchname.Form(""%s"", elem->GetFullName());; 6291 }; 6292 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, nullptr, basketsize, 0, btype);; 6293 branch->SetParentClass(clParent);; 6294 fBranches.Add(branch);; 6295 }; 6296 } else if (clOfBase->GetListOfRealData()->GetSize()) {; 6297 // -- Create a branch for a non-empty base class.; 6298 if (namelen) {; 6299 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6300 // Elide the base class name when creating the sub-branches.; 6301 // Note: The branch names for sub-branches of a base class branch; 6302 // do not represent the full class hierarchy because we do; 6303 // this, however it does keep the branch names for the; 6304 // inherited data members simple.; 6305 TBranchElement* branch = new TBranchElement(this, name, sinfo, elemID, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6306 // Then reset it to the proper name.; 6307 branch->SetName(branchname);; 6308 branch->SetTitle(branchname);; 6309 branch->SetParentClass(clParent);; 6310 fBranches.Add(branch);; 6311 } else {; 6312 branchname.Form(""%s"", elem->GetFullName());; 6313 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6314 branch->SetParentClass(clParent);; 6315 fBranches.Add(branch);; 6316 }; 6317 }; 6318 } else {; 6319 // -- This is a data member of cl.; 6320 if (namelen) {; 6321 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6322 } else {; 6323 branchname.Form(""%s"", elem->GetFullName());; 6324 }; 6325 if ((splitlevel > 1) && ((elem->IsA() =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:237208,simpl,simple,237208,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['simpl'],['simple']
Usability,"lass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C_struture only !!!. ~TTableDescriptor(); class destructor. Int_t AddAt(const void* c); Append one row pointed by ""c"" to the descriptor. void AddAt(const void* c, Int_t i); Add one row pointed by ""c"" to the ""i""-th row of the descriptor. void AddAt(TDataSet* dataset, Int_t idx = 0); Add one dataset to the descriptor.; There is no new implementation here.; One needs it to avoid the ""hidden method"" compilation warning. void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx); Add the descriptor element followed by its commentText; at the indx-th position of the descriptor (counted from zero). TString CreateLeafList() const; Create a list of leaf to be useful for TBranch::TBranch ctor. void Init(TClass* classPtr); Create a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C_structure only !!!. void LearnTable(const TTable* parentTable); to be documented. void LearnTable(TClass* classPtr). LearnTable() creates an array of the descriptors for elements of the row. It creates a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C-structure only !!!. This is to introduce an artificial restriction demanded by STAR database group. 1. the name may be 31 symbols at most; 2. the number the dimension is 3 at most. To lift this restriction one has to provide -DNORESTRICTIONS CPP symbol and; recompile code (and debug code NOW!). TTableDescriptor * MakeDescriptor(const char* structName). MakeDescriptor(const char *structName) - static method; structName - the name of the C structure; to create descriptor of; return a new instance of the TTableDescriptor or 0; if the ""structName is not present with the dictionary. TDataSet * MakeCommentField(Bool_t createFlag = kTRUE); Instantiate a comment dataset if any. Int_t UpdateOffsets(const TTableDescriptor* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableDescriptor.html:18467,Learn,LearnTable,18467,root/html602/TTableDescriptor.html,https://root.cern,https://root.cern/root/html602/TTableDescriptor.html,2,['Learn'],['LearnTable']
Usability,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Integration.html:4183,simpl,simple,4183,doc/master/group__Integration.html,https://root.cern,https://root.cern/doc/master/group__Integration.html,1,['simpl'],['simple']
Usability,"lasses, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree until it reaches an ancestor without a parent. To serialize the object data members it calls their Streamer. They in turn move up their own inheritance tree and so forth. The simple data members are written to the buffer directly. Eventually the buffer contains all simple data members of all the classes that make up this particular object. Data members that are references (as MyClass &fObj;) are never saved, it is always the responsibility of the object’s constructor to set them properly.; 11.3.1 Automatically Generated Streamers; A Streamerusually calls other Streamers: the Streamerof its parents and data members. This architecture depends on all classes having Streamers, because eventually they will be called. To ensure that a class has a Streamer, rootcling automatically creates one in the ClassDef macro that is defined in $ROOTSYS/include/Rtypes.h. ClassDef defines several methods for any class, and one of them is the Streamer. The automatically generated Streameris complete and can be used as long as no customization is needed.; The Event class is defined in $ROOTSYS/test/Event.h. Looking at the class definition, we find that it inherits from TObject. It is a simple example of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:466765,simpl,simple,466765,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"lassification.py;   TMVA Classification Example Using a Recurrent Neural Network ;  ;  TMVA_SOFIE_GNN.py;  ;  TMVA_SOFIE_GNN_Application.C;  ;  TMVA_SOFIE_GNN_Parser.py;  ;  TMVA_SOFIE_Inference.py;   This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ;  TMVA_SOFIE_Keras.C;   This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_Keras_HiggsModel.C;   This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ;  ;  TMVA_SOFIE_Models.py;   Example of inference with SOFIE using a set of models trained with Keras. ;  ;  TMVA_SOFIE_ONNX.C;   This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_PyTorch.C;   This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_RDataFrame.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model Then you need to run the macro TMVA_SOFIE_Keras_HiggsModel.C to generate the corresponding header file using SOFIE. ;  ;  TMVA_SOFIE_RDataFrame.py;   Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ;  ;  TMVA_SOFIE_RDataFrame_JIT.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras mode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:3495,simpl,simple,3495,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['simpl'],['simple']
Usability,"lassname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidTChain::CanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConnectProof(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidTChain::CreatePackets(); Int_tDebug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTChain::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofChain.html:3543,undo,undo,3543,root/html528/TProofChain.html,https://root.cern,https://root.cern/root/html528/TProofChain.html,10,['undo'],['undo']
Usability,"late(); virtual voidTEveElement::AnnihilateElements(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tCanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTriangleSet.html:2441,Clear,Clear,2441,root/html532/TEveTriangleSet.html,https://root.cern,https://root.cern/root/html532/TEveTriangleSet.html,4,['Clear'],['Clear']
Usability,"lateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TEveGValuatorBase&operator=(const TEveGValuatorBase&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGValuatorBase.html:15423,Clear,ClearFlags,15423,root/html532/TEveGValuatorBase.html,https://root.cern,https://root.cern/root/html532/TEveGValuatorBase.html,2,['Clear'],['ClearFlags']
Usability,"lateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGShutterItem(const TGShutterItem&); TGShutterItem&operator=(const TGShutterItem&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGShutterItem.html:15364,Clear,ClearFlags,15364,root/html532/TGShutterItem.html,https://root.cern,https://root.cern/root/html532/TGShutterItem.html,2,['Clear'],['ClearFlags']
Usability,"lateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEveElement::CSCTakeAnyParentAsMaster();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveElementList.html:2464,Clear,ClearStamps,2464,root/html532/TEveElementList.html,https://root.cern,https://root.cern/root/html532/TEveElementList.html,4,['Clear'],['ClearStamps']
Usability,"lateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConnect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveViewerList.html:2294,Clear,ClearStamps,2294,root/html532/TEveViewerList.html,https://root.cern,https://root.cern/root/html532/TEveViewerList.html,4,['Clear'],['ClearStamps']
Usability,"lateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEveElement::CSCTakeAnyParentAsMaste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrackList.html:2406,Clear,ClearStamps,2406,root/html532/TEveTrackList.html,https://root.cern,https://root.cern/root/html532/TEveTrackList.html,4,['Clear'],['ClearStamps']
Usability,"lateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEveElement::CSCTakeAny",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveElementListProjected.html:2353,Clear,ClearStamps,2353,root/html532/TEveElementListProjected.html,https://root.cern,https://root.cern/root/html532/TEveElementListProjected.html,12,['Clear'],['ClearStamps']
Usability,"lateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveTrackList::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEveElement::CSCTakeA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrackListProjected.html:2316,Clear,ClearStamps,2316,root/html532/TEveTrackListProjected.html,https://root.cern,https://root.cern/root/html532/TEveTrackListProjected.html,4,['Clear'],['ClearStamps']
Usability,"lateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidCloseCompound(); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCompound.html:2296,Clear,ClearStamps,2296,root/html532/TEveCompound.html,https://root.cern,https://root.cern/root/html532/TEveCompound.html,4,['Clear'],['ClearStamps']
Usability,"lateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTEveCompound::CloseCompound(); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCompoundProjected.html:2277,Clear,ClearStamps,2277,root/html532/TEveCompoundProjected.html,https://root.cern,https://root.cern/root/html532/TEveCompoundProjected.html,4,['Clear'],['ClearStamps']
Usability,"lated uncertainties of A, regularisation scheme and binning schemes ; Parameters. [in]hist_Amatrix that describes the migrations ; [in]histmapmapping of the histogram axes to the unfolding output ; [in]regmode(default=kRegModeSize) global regularisation mode ; [in]constraint(default=kEConstraintArea) type of constraint ; [in]densityMode(default=kDensityModeBinWidthAndUser) regularisation scale factors to construct the matrix L ; [in]outputBins(default=nullptr) binning scheme for truth (unfolding output) ; [in]inputBins(default=nullptr) binning scheme for measurement (unfolding input) ; [in]regularisationDistribution(default=nullptr) selectin of regularized distribution ; [in]regularisationAxisSteering(default=nullptr) detailed regularisation steeringfor selected distribution. The parameters hist_A, histmap, constraint are explained with the TUnfoldSys constructor. ; The parameters outputBins,inputBins set the binning schemes. If these arguments are zero, simple binning schemes are constructed which correspond to the axes of the histogram hist_A. ; The parameters regmode, densityMode, regularisationDistribution, regularisationAxisSteering together control how the initial matrix L of regularisation conditions is constructed. as explained in RegularizeDistribution(). ; Definition at line 220 of file TUnfoldDensity.cxx. ◆ ~TUnfoldDensity(). TUnfoldDensity::~TUnfoldDensity ; (; void ; ). override . Definition at line 170 of file TUnfoldDensity.cxx. Member Function Documentation. ◆ Class(). static TClass * TUnfoldDensity::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TUnfoldDensity::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TUnfoldDensity::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 205 of file TUnfoldDensity.h. ◆ DeclFileName(). static const char * TUnfoldDensity::DeclFileName ; (; ). inlinestatic . ReturnsName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:42650,simpl,simple,42650,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['simpl'],['simple']
Usability,"layCreation(). void TGeoVolume::ReplayCreation ; (; const TGeoVolume * ; other). Recreate the content of the other volume without pointer copying. ; Voxels are ignored and supposed to be created in a later step via Voxelize. ; Definition at line 1292 of file TGeoVolume.cxx. ◆ ResetTransparency(). void TGeoVolume::ResetTransparency ; (; Char_t ; transparency = -1). inline . Definition at line 383 of file TGeoVolume.h. ◆ SaveAs(). void TGeoVolume::SaveAs ; (; const char * ; filename = """", . Option_t * ; option = """" . ); const. overridevirtual . Save geometry having this as top volume as a C++ macro. ; Reimplemented from TObject.; Definition at line 1447 of file TGeoVolume.cxx. ◆ SavePrimitive(). void TGeoVolume::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Definition at line 1535 of file TGeoVolume.cxx. ◆ SelectVolume(). void TGeoVolume::SelectVolume ; (; Bool_t ; clear = kFALSE). Select this volume as matching an arbitrary criteria. ; The volume is added to a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need to be reset at the end by calling the method with CLEAR=true. This will also clear the list. ; Definition at line 2325 of file TGeoVolume.cxx. ◆ SetActiveDaughters(). void TGeoVolume::SetActiveDaughters ; (; Bool_t ; flag = kTRUE). inline . Definition at line 213 of file TGeoVolume.h. ◆ SetActivity(). void TGeoVolume::SetActivity ; (; Bool_t ; flag = kTRUE). inline . Definition at line 212 of file TGeoVolume.h. ◆ SetAdded(). void TGeoVolume::SetAdded ; (; ). inline . Definition at line 215 of file TGeoVolume.h. ◆ SetAsTopVolume(). void TGeoVolume::SetAsTopVolume ; (; ). Set this volume as the TOP one (the whole geometry starts from here) ; Definition at line 2051 of file TGeoVolume.cxx. ◆ SetAttVisibility(). void TGeoVolume::SetAttVisibility ; (; Bool_t ; vis). inline . Definition at line 233 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:63344,clear,clear,63344,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['clear'],['clear']
Usability,"ld));; 1077 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1078 if (theGraph->InheritsFrom(""TCutG"")) {; 1079 //make sure first and last point are the same; 1080 if (ipoint == 0) {; 1081 theX[theNpoints-1] = theX[0];; 1082 theY[theNpoints-1] = theY[0];; 1083 }; 1084 if (ipoint == theNpoints-1) {; 1085 theX[0] = theX[theNpoints-1];; 1086 theY[0] = theY[theNpoints-1];; 1087 }; 1088 }; 1089 }; 1090 badcase = kFALSE;; 1091 x.clear();; 1092 y.clear();; 1093 gPad->Modified(kTRUE);; 1094 gVirtualX->SetLineColor(-1);; 1095 }; 1096}; 1097 ; 1098 ; 1099////////////////////////////////////////////////////////////////////////////////; 1100 ; 1101char *TGraphPainter::GetObjectInfoHelper(TGraph * /*theGraph*/, Int_t /*px*/, Int_t /*py*/) const; 1102{; 1103 return (char*)"""";; 1104}; 1105 ; 1106 ; 1107////////////////////////////////////////////////////////////////////////////////; 1108/// Return the highlighted point for theGraph; 1109 ; 1110Int_t TGraphPainter::GetHighlightPoint(TGraph *theGraph) const; 1111{; 1112 if (theGraph == gHighlightGraph) return gHighlightPoint;; 1113 else return -1;; 1114}; 1115 ; 1116 ; 1117////////////////////////////////////////////////////////////////////////////////; 1118/// Set highlight (enable/disable) mode for theGraph; 1119 ; 1120void TGraphPainter::SetHighlight(TGraph *theGraph); 1121{; 1122 gHighlightPoint = -1; // must be -1; 1123 gHighlightGraph = nullptr;; 1124 if (theGraph->IsHighlight()) return;; 1125 ; 1126 // delete previous highlight marker; 1127 if (gHighlightMarker) gHighlightMarker.reset(nullptr);; 1128 // emit Highlighted() signal (user can check on disabled); 1129 if (gPad->GetCanvas()) gPad->GetCanvas()->Highlighted(gPad, theGraph, gHighlightPoint, -1);; 1130}; 1131 ; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Check on highlight point; 1135 ; 1136void TGraphPainter::HighlightPoint(TGraph *theGraph, Int_t hpoint, Int_t distance); 1137{; 1138 // call from Distanceto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:40105,clear,clear,40105,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"ldFirst(XMLNodePointer_t parent, XMLNodePointer_t child); Bool_tAddComment(XMLNodePointer_t parent, const char* comment); Bool_tAddDocComment(XMLDocPointer_t xmldoc, const char* comment); Bool_tAddDocRawLine(XMLDocPointer_t xmldoc, const char* line); Bool_tAddDocStyleSheet(XMLDocPointer_t xmldoc, const char* href, const char* type = ""text/css"", const char* title = 0, int alternate = -1, const char* media = 0, const char* charset = 0); Bool_tAddRawLine(XMLNodePointer_t parent, const char* line); Bool_tAddStyleSheet(XMLNodePointer_t parent, const char* href, const char* type = ""text/css"", const char* title = 0, int alternate = -1, const char* media = 0, const char* charset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); voidAssignDtd(XMLDocPointer_t xmldoc, const char* dtdname, const char* rootname); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanNode(XMLNodePointer_t xmlnode); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); XMLNodePointer_tDocGetRootElement(XMLDocPointer_t xmldoc); voidDocSetRootElement(XMLDocPointer_t xmldoc, XMLNodePointer_t xmlnode); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXMLEngine.html:1859,Clear,Clear,1859,root/html532/TXMLEngine.html,https://root.cern,https://root.cern/root/html532/TXMLEngine.html,1,['Clear'],['Clear']
Usability,"ldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; virtual void attachToTree (TTree &t, Int_t bufSize=32000)=0;  Overloadable function for derived classes to implement attachment as branch to a TTree. ;  ; virtual void attachToVStore (RooVectorDataStore &vstore)=0;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true)=0;  ; virtual void fillTreeBranch (TTree &t)=0;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual bool isValid () const;  WVE (08/21/01) Probably obsolete now. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:34459,clear,clearShapeDirty,34459,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,3,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"ldX2 = GetX2();; 155 oldY2 = GetY2();; 156 ndcsav = TestBit(kLineNDC);; 157 if (!opaque) {; 158 gVirtualX->SetLineColor(-1);; 159 TAttLine::Modify(); //Change line attributes only if necessary; 160 }; 161 ; 162 // No break !!!; 163 ; 164 case kMouseMotion:; 165 ; 166 if (TestBit(kLineNDC)) {; 167 px1 = gPad->UtoPixel(GetX1());; 168 py1 = gPad->VtoPixel(GetY1());; 169 px2 = gPad->UtoPixel(GetX2());; 170 py2 = gPad->VtoPixel(GetY2());; 171 } else {; 172 px1 = gPad->XtoAbsPixel(gPad->XtoPad(GetX1()));; 173 py1 = gPad->YtoAbsPixel(gPad->YtoPad(GetY1()));; 174 px2 = gPad->XtoAbsPixel(gPad->XtoPad(GetX2()));; 175 py2 = gPad->YtoAbsPixel(gPad->YtoPad(GetY2()));; 176 }; 177 p1 = p2 = pL = kFALSE;; 178 ; 179 d1 = abs(px1 - px) + abs(py1-py); //simply take sum of pixels differences; 180 if (d1 < kMaxDiff) { //*-*================>OK take point number 1; 181 px1old = px1; py1old = py1;; 182 p1 = kTRUE;; 183 gPad->SetCursor(kPointer);; 184 return;; 185 }; 186 d2 = abs(px2 - px) + abs(py2-py); //simply take sum of pixels differences; 187 if (d2 < kMaxDiff) { //*-*================>OK take point number 2; 188 px2old = px2; py2old = py2;; 189 p2 = kTRUE;; 190 gPad->SetCursor(kPointer);; 191 return;; 192 }; 193 ; 194 pL = kTRUE;; 195 pxold = px; pyold = py;; 196 gPad->SetCursor(kMove);; 197 ; 198 break;; 199 ; 200 case kArrowKeyRelease:; 201 case kButton1Motion:; 202 ; 203 if (p1) {; 204 if (!opaque) {; 205 gVirtualX->DrawLine(px1old, py1old, px2, py2);; 206 gVirtualX->DrawLine(px, py, px2, py2);; 207 } else {; 208 if (ndcsav) {; 209 SetNDC(kFALSE);; 210 SetX2(gPad->GetX1() + oldX2*(gPad->GetX2()-gPad->GetX1()));; 211 SetY2(gPad->GetY1() + oldY2*(gPad->GetY2()-gPad->GetY1()));; 212 }; 213 SetX1(gPad->AbsPixeltoX(px));; 214 SetY1(gPad->AbsPixeltoY(py));; 215 }; 216 px1old = px;; 217 py1old = py;; 218 }; 219 if (p2) {; 220 if (!opaque) {; 221 gVirtualX->DrawLine(px1, py1, px2old, py2old);; 222 gVirtualX->DrawLine(px1, py1, px, py);; 223 } else {; 224 if (ndcsav) {; 225 SetNDC(kFALSE);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLine_8cxx_source.html:5873,simpl,simply,5873,doc/master/TLine_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html,1,['simpl'],['simply']
Usability,"lding ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation Tutorials. ROOT offers a rich set of code examples that allow you to see ROOT's building blocks ""in action"", as part of more complex programs. They are separated in two categories: C++ or python scripts and Jupyter notebooks.; The tutorials are available for all major ROOT releases. These are the links for the latest git snapshot. All scripts are available also in the form of a ROOTBook which can be visualized in NBViewer or tried out interactively in SWAN. Just look for these badges:. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorials.html:2587,guid,guidelines,2587,d/tutorials.html,https://root.cern,https://root.cern/d/tutorials.html,1,['guid'],['guidelines']
Usability,"lding ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Using a Macro to Read a TTree. Why using a macro?; As real analyses don't fit into simple TTree::Draw() invocations, and as it is quite cumbersome to type the same lines again and again in the Root prompt, simply create macros for commonly used code. A macro is a file that is interpreted by ROOT.; Creating and Editing the Macro; Create a macro (e.g. AnalyzeTree.C) using your favorite text editor, e.g. with vi, emacs, wordpad, Eclipse, Visual Studio,... The macro should start with the proper #include statements and should contain the function declaration with the same name than the macro itself. As we know we're going to use TFile and TTree (at least), we can already include their headers TFile.h and TTree.h. Then come the function implementation.; Function Implementation; Lets start with something simple: calculate the sum of all event sizes. For this we need a new variable of type int. Create (declare) it at the beginning of the function, and don't forget to initialize it to 0. At the end, the code in AnalyzeTree.C should look like this:; #include ""TFile.h""; #include ""TTree.h"". void AnalyzeTree(); {; // Variables used to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:1998,simpl,simple,1998,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,2,['simpl'],"['simple', 'simply']"
Usability,"le = BIT(17);; 32 ; 33ClassImp(TStyle);; 34 ; 35/** \class TStyle; 36\ingroup Base; 37 \ingroup GraphicsAtt; 38 ; 39TStyle objects may be created to define special styles.; 40By default ROOT creates a default style that can be accessed via; 41the gStyle pointer.; 42 ; 43This class includes functions to set some of the following object attributes.; 44 - Canvas; 45 - Pad; 46 - Histogram axis; 47 - Lines; 48 - Fill areas; 49 - Text; 50 - Markers; 51 - Functions; 52 - Histogram Statistics and Titles; 53 ; 54All objects that can be drawn in a pad inherit from one or more attribute classes; 55like TAttLine, TAttFill, TAttText, TAttMarker. When the objects are created, their; 56default attributes are taken from the current style. The current style is an object; 57of the class[TStyle](https://root.cern/doc/master/classTStyle.html) and can be; 58referenced via the global variable `gStyle` (in TStyle.h).; 59 ; 60ROOT provides two styles called ""Default"" and ""Plain"". The ""Default""; 61style is created simply by:; 62 ; 63~~~ {.cpp}; 64 auto default = new TStyle(""Default"",""Default Style"");; 65~~~; 66 ; 67The `Plain` style can be used if you are working on a monochrome display or; 68if you want to get a ""conventional"" Postscript output. These are the instructions; 69in the ROOT constructor to create the `Plain` style.; 70 ; 71```; 72auto plain = new TStyle(""Plain"",""Plain Style (no colors/fill areas)"");; 73 ; 74 plain->SetCanvasBorderMode(0);; 75 plain->SetPadBorderMode(0);; 76 plain->SetPadColor(0);; 77 plain->SetCanvasColor(0);; 78 plain->SetTitleColor(0);; 79 plain->SetStatColor(0);; 80```; 81 ; 82You can set the current style with:; 83 ; 84```; 85gROOT->SetStyle(style_name);; 86```; 87 ; 88You can get a pointer to an existing style with:; 89 ; 90```; 91auto style = gROOT->GetStyle(style_name);; 92```; 93 ; 94You can create additional styles with:; 95 ; 96```; 97 TStyle *st1 = new TStyle(""st1"",""my style"");; 98 st1->Set....; 99 st1->cd(); this becomes now the current style gStyle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStyle_8cxx_source.html:2048,simpl,simply,2048,doc/master/TStyle_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html,1,['simpl'],['simply']
Usability,"le = df_available.Define(""twice"", ""col * 2""); 1629 ; 1630# Conversely, if we want to select the entries for which the column has missing; 1631# values, we do the following; 1632df_missingcol = df.FilterMissing(""col""); 1633# Following operations in the same branch of the computation graph clearly; 1634# cannot access that same column, since there would be no value to read; 1635df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); 1636\endcode; 1637 ; 1638\code{.cpp}; 1639ROOT::RDataFrame df{dataset};; 1640 ; 1641// Anytime an entry from ""col"" is missing, the entire entry will be filtered out; 1642auto df_available = df.FilterAvailable(""col"");; 1643auto df_twicecol = df_available.Define(""twice"", ""col * 2"");; 1644 ; 1645// Conversely, if we want to select the entries for which the column has missing; 1646// values, we do the following; 1647auto df_missingcol = df.FilterMissing(""col"");; 1648// Following operations in the same branch of the computation graph clearly; 1649// cannot access that same column, since there would be no value to read; 1650auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; 1651\endcode; 1652 ; 1653#### DefaultValueFor; 1654 ; 1655DefaultValueFor creates a node of the computation graph which just forwards the; 1656values of the columns necessary for other downstream nodes, when they are; 1657available. In case a value of the input column passed to this function is not; 1658available, the node will provide the default value passed to this function call; 1659instead. Example:; 1660 ; 1661\code{.py}; 1662df = ROOT.RDataFrame(dataset); 1663# Anytime an entry from ""col"" is missing, the value will be the default one; 1664default_value = ... # Some sensible default value here; 1665df = df.DefaultValueFor(""col"", default_value) ; 1666df = df.Define(""twice"", ""col * 2""); 1667\endcode; 1668 ; 1669\code{.cpp}; 1670ROOT::RDataFrame df{dataset};; 1671// Anytime an entry from ""col"" is missing, the value will be the defaul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:91847,clear,clearly,91847,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['clear'],['clearly']
Usability,"le > m_prevGradientsvector remembers the gradients of the previous stepDefinition NeuralNet.h:373; TMVA::DNN::Steepest::m_alphadouble m_alphainternal parameter (learningRate)Definition NeuralNet.h:371; TMVA::DNN::Steepest::m_localWeightsstd::vector< double > m_localWeightslocal weights for reuse in thread.Definition NeuralNet.h:375; TMVA::DNN::Steepest::operator()double operator()(Function &fitnessFunction, Weights &weights, PassThrough &passThrough)operator to call the steepest gradient descent algorithmDefinition NeuralNet.icc:271; TMVA::DNN::Steepest::SteepestSteepest(double learningRate=1e-4, double momentum=0.5, size_t repetitions=10)c'torDefinition NeuralNet.h:348; TMVA::IPythonInteractiveThis class is needed by JsMVA, and it's a helper class for tracking errors during the training in Jup...Definition MethodBase.h:94; TMVA::TimerTiming information for training and evaluation of MVA methods.Definition Timer.h:58; TMVA::Timer::DrawProgressBarvoid DrawProgressBar(Int_t, const TString &comment="""")draws progress bar in color or B&W caution:Definition Timer.cxx:202; TStringBasic string class.Definition TString.h:139; double; unsigned int; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA::DNN::sumOfSquaresdouble sumOfSquares(ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth itTruthEnd, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc itInvActFnc, double patternWeight); TMVA::DNN::uniformDoubledouble uniformDouble(double minValue, double maxValue)Definition NeuralNet.cxx:43; TMVA::DNN::forwardvoid forward(const LAYERDATA &prevLayerData, LAYERDATA &currLayerData)apply the weights (and functions) in forward direction of the DNNDefinition NeuralNet.icc:546; TMVA::DNN::applyFunctionsvoid applyFunctions(ItValue itValue, ItValue itValueEnd, ItFunction itFunction); TMVA::DNN::operator|ModeOutputValues operator|(ModeOutputValues lhs, ModeOutputValues rhs)Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:79682,progress bar,progress bar,79682,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['progress bar'],['progress bar']
Usability,"le RVec.hxx. ◆ append() [3/3]. template<typename T > . void ROOT::Detail::VecOps::RVecImpl< T >::append ; (; std::initializer_list< T > ; IL). inline . Definition at line 674 of file RVec.hxx. ◆ assign() [1/3]. template<typename T > . template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> . void ROOT::Detail::VecOps::RVecImpl< T >::assign ; (; in_iter ; in_start, . in_iter ; in_end . ). inline . Definition at line 692 of file RVec.hxx. ◆ assign() [2/3]. template<typename T > . void ROOT::Detail::VecOps::RVecImpl< T >::assign ; (; size_type ; NumElts, . const T & ; Elt . ). inline . Definition at line 680 of file RVec.hxx. ◆ assign() [3/3]. template<typename T > . void ROOT::Detail::VecOps::RVecImpl< T >::assign ; (; std::initializer_list< T > ; IL). inline . Definition at line 698 of file RVec.hxx. ◆ clear(). template<typename T > . void ROOT::Detail::VecOps::RVecImpl< T >::clear ; (; ). inline . Definition at line 586 of file RVec.hxx. ◆ emplace_back(). template<typename T > . template<typename... ArgTypes> . reference ROOT::Detail::VecOps::RVecImpl< T >::emplace_back ; (; ArgTypes &&... ; Args). inline . Definition at line 920 of file RVec.hxx. ◆ erase() [1/2]. template<typename T > . iterator ROOT::Detail::VecOps::RVecImpl< T >::erase ; (; const_iterator ; CI). inline . Definition at line 704 of file RVec.hxx. ◆ erase() [2/2]. template<typename T > . iterator ROOT::Detail::VecOps::RVecImpl< T >::erase ; (; const_iterator ; CS, . const_iterator ; CE . ). inline . Definition at line 721 of file RVec.hxx. ◆ insert() [1/5]. template<typename T > . iterator ROOT::Detail::VecOps::RVecImpl< T >::insert ; (; iterator ; I, . const T & ; Elt . ). inline . Definition at line 773 of file RVec.hxx. ◆ insert() [2/5]. template<typename T > . template<typename ItTy , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html:10645,clear,clear,10645,doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html,1,['clear'],['clear']
Usability,"le TToggleGroup.cxx. Member Function Documentation. ◆ Add(). Int_t TToggleGroup::Add ; (; TToggle * ; t, . Bool_t ; select = 1 . ). virtual . Add a new toggle. ; Definition at line 63 of file TToggleGroup.cxx. ◆ At(). virtual TToggle * TToggleGroup::At ; (; Int_t ; idx). inlinevirtual . Definition at line 41 of file TToggleGroup.h. ◆ Class(). static TClass * TToggleGroup::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TToggleGroup::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TToggleGroup::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 57 of file TToggleGroup.h. ◆ DeclFileName(). static const char * TToggleGroup::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 57 of file TToggleGroup.h. ◆ DeleteAll(). void TToggleGroup::DeleteAll ; (; ). virtual . Disposes of all objects and clears array. ; Definition at line 116 of file TToggleGroup.cxx. ◆ First(). virtual TToggle * TToggleGroup::First ; (; ). inlinevirtual . Definition at line 47 of file TToggleGroup.h. ◆ GetTogglesCount(). virtual Int_t TToggleGroup::GetTogglesCount ; (; ). inlinevirtual . Definition at line 40 of file TToggleGroup.h. ◆ IndexOf(). virtual Int_t TToggleGroup::IndexOf ; (; TToggle * ; t). inlinevirtual . Definition at line 50 of file TToggleGroup.h. ◆ InsertAt(). Int_t TToggleGroup::InsertAt ; (; TToggle * ; t, . Int_t ; pos, . Bool_t ; select = 1 . ). virtual . Add a new toggle at a specific position. ; Definition at line 77 of file TToggleGroup.cxx. ◆ IsA(). TClass * TToggleGroup::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 57 of file TToggleGroup.h. ◆ Last(). virtual TToggle * TToggleGroup::Last ; (; ). inlinevirtual . Definition at line 48 of file TToggleGroup.h. ◆ operator=(). TToggleGroup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTToggleGroup.html:13586,clear,clears,13586,doc/master/classTToggleGroup.html,https://root.cern,https://root.cern/doc/master/classTToggleGroup.html,1,['clear'],['clears']
Usability,"le TTree.h. ◆ Branch() [8/13]. template<typename T , std::size_t N> . TBranch * TTree::Branch ; (; const char * ; name, . std::array< T, N > * ; obj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Definition at line 405 of file TTree.h. ◆ Branch() [9/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T ** ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the array addobj being passed. ; NoteThis and the previous overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]addobjArray of the objects to be added. When calling Fill(), the current value of the type/object will be saved. ; [in]bufsizehe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 370 of file TTree.h. ◆ Branch() [10/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T * ; obj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the type of obj being passed. ; NoteThis and the next overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]objAddress of the object to be adde",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:81772,simpl,simple,81772,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simple']
Usability,"le error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad.h:308; TQCommand::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the list of merged commands.Definition TQCommand.cxx:360. Macro commands ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; void Add (TObject *obj) override;  ; void Add (TObject *obj, Option_t *opt) override;  Add command to the list of merged commands. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:4258,undo,undo,4258,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"le momentum = 0.5,; 350 size_t repetitions = 10); 351 : m_repetitions (repetitions); 352 , m_alpha (learningRate); 353 , m_beta (momentum); 354 {}; 355 ; 356 /*! \brief operator to call the steepest gradient descent algorithm; 357 *; 358 * entry point to start the minimization procedure; 359 *; 360 * \param fitnessFunction (templated) function which has to be provided. This function is minimized; 361 * \param weights (templated) a reference to a container of weights. The result of the minimization procedure; 362 * is returned via this reference (needs to support std::begin and std::end; 363 * \param passThrough (templated) object which can hold any data which the fitness function needs. This object; 364 * is not touched by the minimizer; This object is provided to the fitness function when; 365 * called; 366 */; 367 template <typename Function, typename Weights, typename PassThrough>; 368 double operator() (Function& fitnessFunction, Weights& weights, PassThrough& passThrough);; 369 ; 370 ; 371 double m_alpha; ///< internal parameter (learningRate); 372 double m_beta; ///< internal parameter (momentum); 373 std::vector<double> m_prevGradients; ///< vector remembers the gradients of the previous step; 374 ; 375 std::vector<double> m_localWeights; ///< local weights for reuse in thread.; 376 std::vector<double> m_localGradients; ///< local gradients for reuse in thread.; 377 };; 378 ; 379 ; 380 ; 381 ; 382 ; 383 ; 384 ; 385 ; 386 ; 387 ; 388 ; 389 ; 390 ; 391 ; 392 ; 393 ; 394 ; 395 ; 396 template <typename ItOutput, typename ItTruth, typename ItDelta, typename ItInvActFnc>; 397 double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth itTruthEnd, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc itInvActFnc, double patternWeight);; 398 ; 399 ; 400 ; 401 template <typename ItProbability, typename ItTruth, typename ItDelta, typename ItInvActFnc>; 402 double crossEntropy (ItProbability itProbabilityBegin, ItProbability itProbability",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:10153,learn,learningRate,10153,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['learn'],['learningRate']
Usability,"le show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  hlGraph1.CThis tutorial demonstrates how to use the highlight mode on graph ;  hlGraph2.CThis tutorial demonstrates how to use the highlight mode on graph ;  labels1.C Setting alphanumeric labels in a 1-d histogram ;  labels2.C Setting alphanumeric labels ;  motorcycle.C Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ;  multigraph.C Create and Draw a TMultiGraph ;  multigraphpalettecolor.C Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  multipalette.C Draw color plots using different color palettes ;  seism.C Strip chart example ;  splines_test.C Examples of use of the spline classes ;  surfaces.C Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:118948,simpl,simple,118948,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"le show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  labels1.C Setting alphanumeric labels in a 1-d histogram ;  labels2.C Setting alphanumeric labels ;  motorcycle.C Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ;  multigraph.C Create and Draw a TMultiGraph ;  multigraphpalettecolor.C Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  multipalette.C Draw color plots using different color palettes ;  seism.C Strip chart example ;  splines_test.C Examples of use of the spline classes ;  surfaces.C Draw 2-Dim functions ;  timeonaxis.C This macro illustrates the use of the time mode on the axis with different time intervals and time formats ;  timeonaxis2.C D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:115151,simpl,simple,115151,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['simpl'],['simple']
Usability,le* xlow = Coords( fNPoints-1 );; 630 ; 631 double binVolume = 1.0;; 632 for ( unsigned int j = 0; j < fDim; j++ ); 633 {; 634 binVolume *= ( xup[j] - xlow[j] );; 635 }; 636 ; 637 // store the minimum bin volume found as reference for future normalizations; 638 if ( fNPoints == 1 ); 639 fRefVolume = binVolume;; 640 else if ( binVolume < fRefVolume ); 641 fRefVolume = binVolume;; 642 }; 643 ; 644 ; 645 void BinData::InitDataVector (); 646 {; 647 fData.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 648 fDataPtr = fData.empty() ? nullptr : &fData.front();; 649 }; 650 ; 651 void BinData::InitializeErrors(); 652 {; 653 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 654 kAsymError == fErrorType || kNoError == fErrorType );; 655 ; 656 if ( fpTmpCoordErrorVector ); 657 {; 658 delete[] fpTmpCoordErrorVector;; 659 fpTmpCoordErrorVector = nullptr;; 660 }; 661 ; 662 if ( kNoError == fErrorType ); 663 {; 664 fCoordErrors.clear();; 665 fCoordErrorsPtr.clear();; 666 ; 667 fDataErrorHigh.clear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:20461,clear,clear,20461,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"le.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferSQL2(); destroy sql buffer. TSQLStructure* SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); Convert object of any class to sql structures; Return pointer on created TSQLStructure; TSQLStructure object will be owned by TBufferSQL2. void* SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL2.html:23684,simpl,simple,23684,root/html530/TBufferSQL2.html,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html,9,['simpl'],['simple']
Usability,"le.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hlHisto1.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hlHisto2.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hlHisto3.CThis tutorial demonstrates how the highlight mechanism can be used on a ntuple ;  hlHisto4.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  legendautoplaced.C The legend can be placed automatically in the current pad in an empty space found at painting time ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:127618,simpl,simple,127618,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"le::RProvider::Browse(rootfold);; 116 if (elem_root); 117 comp->Add(std::make_shared<Browsable::RWrapper>(""root"", elem_root));; 118 ; 119 std::unique_ptr<Browsable::RHolder> rootfiles = std::make_unique<Browsable::TObjectHolder>(gROOT->GetListOfFiles(), kFALSE);; 120 auto elem_files = Browsable::RProvider::Browse(rootfiles);; 121 if (elem_files) {; 122 auto files = std::make_shared<Browsable::RWrapper>(""ROOT Files"", elem_files);; 123 files->SetExpandByDefault(true);; 124 comp->Add(files);; 125 // if there are any open files, make them visible by default; 126 if (elem_files->GetNumChilds() > 0); 127 seldir = {};; 128 }; 129 ; 130 SetTopElement(comp);; 131 ; 132 SetWorkingPath(seldir);; 133}; 134 ; 135/////////////////////////////////////////////////////////////////////; 136/// Reset all data correspondent to last request; 137 ; 138void RBrowserData::ResetLastRequestData(bool with_element); 139{; 140 fLastAllChilds = false;; 141 fLastSortedItems.clear();; 142 fLastSortMethod.clear();; 143 fLastItems.clear();; 144 if (with_element) {; 145 fLastPath.clear();; 146 fLastElement.reset();; 147 }; 148}; 149 ; 150/////////////////////////////////////////////////////////////////////////; 151/// Decompose path to elements; 152/// Returns array of names for each element in the path, first element either ""/"" or "".""; 153/// If returned array empty - it is error; 154 ; 155Browsable::RElementPath_t RBrowserData::DecomposePath(const std::string &strpath, bool relative_to_work_element); 156{; 157 Browsable::RElementPath_t arr;; 158 if (relative_to_work_element) arr = fWorkingPath;; 159 ; 160 if (strpath.empty()); 161 return arr;; 162 ; 163 auto arr2 = Browsable::RElement::ParsePath(strpath);; 164 arr.insert(arr.end(), arr2.begin(), arr2.end());; 165 return arr;; 166}; 167 ; 168/////////////////////////////////////////////////////////////////////////; 169/// Process browser request; 170 ; 171bool RBrowserData::ProcessBrowserRequest(const RBrowserRequest &request, RBrowserReply &reply); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:4572,clear,clear,4572,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['clear'],['clear']
Usability,"le; n: the size of the array. Output:; index: the shuffled indexes. This method is used for stochastic training ; Definition at line 2139 of file TMultiLayerPerceptron.cxx. ◆ SteepestDir(). void TMultiLayerPerceptron::SteepestDir ; (; Double_t * ; dir). protected . Sets the search direction to steepest descent. ; Definition at line 2253 of file TMultiLayerPerceptron.cxx. ◆ Streamer(). void TMultiLayerPerceptron::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMultiLayerPerceptron::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 151 of file TMultiLayerPerceptron.h. ◆ Train(). void TMultiLayerPerceptron::Train ; (; Int_t ; nEpoch, . Option_t * ; option = ""text"", . Double_t ; minE = 0 . ). Train the network. ; nEpoch is the number of iterations. option can contain:; ""text"" (simple text output); ""graph"" (evoluting graphical training curves); ""update=X"" (step for the text/graph output update); ""+"" will skip the randomisation and start from the previous values.; ""current"" (draw in the current canvas); ""minErrorTrain"" (stop when NN error on the training sample gets below minE; ""minErrorTest"" (stop when NN error on the test sample gets below minE All combinations are available. . Definition at line 788 of file TMultiLayerPerceptron.cxx. Friends And Related Symbol Documentation. ◆ TMLPAnalyzer. friend class TMLPAnalyzer. friend . Definition at line 27 of file TMultiLayerPerceptron.h. Member Data Documentation. ◆ fCurrentTree. Int_t TMultiLayerPerceptron::fCurrentTree. private . ! index of the current tree in a chain ; Definition at line 124 of file TMultiLayerPerceptron.h. ◆ fCurrentTreeWeight. Double_t TMultiLayerPerceptron::fCurrentTreeWeight. private . ! weight of the current tree in a chain ; Definition at line 125 of file TMultiLayerPerceptron.h. ◆ fData. TTree* TMultiLayerPerceptron::fData. private . ! pointer to the tree used as da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:49324,simpl,simple,49324,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"le; static TTask*fgBeginTaskpointer to task initiator; static TTask*fgBreakPointpointer to current break point. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TTask. Function documentation; TTask(); Default constructor invoked when reading a TTask object from a file. TTask(const char* name, const char* title); Standard constructor. TTask& operator=(const TTask& tt); assignment operator (PLEASE DO NOT USE THIS IS WRONG). TTask(const TTask& task); Copy constructor. ~TTask(); Delete a task and its subtasks. void Abort(); Abort current tree of tasks.; After this call, the tree of tasks is ready to be executed again.; The application must take care of cleaning data structures created; by previous executions. void Browse(TBrowser* b); Browse the list of tasks.; It is recommended to add the top level task to the list of; ROOT browsables by:; gROOT->GetListOfBrowsables()->Add(myTopLevelTask). void CleanTasks(); Reset tasks state: breakpoints and execute flags; also invokes the Clear function of each task to clear all data; structures created by a previous execution of a task. void Clear(Option_t* option = """"); Recursively call the Clear function of this task and its subtasks.; The Clear function must be implemented for each derived class; to clear all data structures created by a previous execution of a task.; This function is automatically called by the CleanTasks function. void Continue(); Resume execution at the current break point. void Exec(Option_t* option); Dummy Execute.; This function must be redefined in the derived classes. void ExecuteTask(Option_t* option = ""0""); Execute main task and its subtasks.; When calling this function, the Exec function of the corresponding class; is invoked, then the list of its subtasks is executed calling recursively; all the subtasks, etc. The option parameter may be used to select different execution steps; within a task. This parameter is passed also to all the subtasks. void ExecuteTasks(Option_t* option); Execute all th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTask.html:10459,clear,clear,10459,root/html602/TTask.html,https://root.cern,https://root.cern/root/html602/TTask.html,6,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"le;  . Private Member Functions; TGeoPhysicalNode * FindNextBoundaryBVH (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ;  ; TGeoPhysicalNode * FindNextBoundaryLoop (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world in a trivial loop version (for debugging) ;  ; TGeoPhysicalNode * FindNextBoundaryOrig (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ;  ; TGeoPhysicalNode * FindNodeBVH (Double_t point[3]);  Finds physical node containing the point. ;  ; TGeoPhysicalNode * FindNodeLoop (Double_t point[3]);  Finds physical node containing the point using simple algorithm (for debugging) ;  ; TGeoPhysicalNode * FindNodeOrig (Double_t point[3]);  Finds physical node containing the point (original version based on TGeoVoxelFinder) ;  ; std::pair< double, double > GetBVHSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; std::pair< double, double > GetLoopSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; void InitSafetyVoxel (TGeoVoxelGridIndex const &);  Method to initialize the safety voxel at a specific 3D voxel (grid) index. ;  ; Double_t SafetyBVH (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ;  ; Double_t SafetyLoop (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (trivial loop ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:15381,simpl,simple,15381,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['simpl'],['simple']
Usability,"leBorder|kSunkenFrame);  Create progress bar. ;  ;  ~TGProgressBar () override;  ; virtual void Format (const char *format=""%.2f"");  Set format for displaying a value. ;  ; Pixel_t GetBarColor () const;  ; EBarType GetBarType () const;  ; EFillType GetFillType () const;  ; FontStruct_t GetFontStruct () const;  ; TString GetFormat () const;  ; Float_t GetMax () const;  ; Float_t GetMin () const;  ; GContext_t GetNormGC () const;  ; Float_t GetPosition () const;  ; Bool_t GetShowPos () const;  ; const char * GetValueFormat () const;  ; void Increment (Float_t inc);  Increment progress position. ;  ; TClass * IsA () const override;  ; virtual void Percent (Bool_t on);  ; virtual void Reset ();  Reset progress bar (i.e. set pos to 0). ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save progress bar parameters as a C++ statement(s) on output stream out. ;  ; void SetBarColor (const char *color=""blue"");  Set progress bar color. ;  ; virtual void SetBarColor (Pixel_t color);  Set progress bar color. ;  ; void SetBarType (EBarType type);  Set bar type. ;  ; void SetFillType (EFillType type);  Set fill type. ;  ; void SetForegroundColor (Pixel_t pixel) override;  Change text color drawing. ;  ; void SetMax (Float_t max);  ; void SetMin (Float_t min);  ; void SetPosition (Float_t pos);  Set progress position between [min,max]. ;  ; void SetRange (Float_t min, Float_t max);  Set min and max of progress bar. ;  ; virtual void ShowPos (Bool_t on);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t UsePercent () const;  ;  Public Member Functions inherited from TGFrame;  TGFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a TGFrame object. Options is an OR of the EFrameTypes. ;  ;  TGFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr);  Create a frame using an ext",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:2901,progress bar,progress bar,2901,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,2,['progress bar'],['progress bar']
Usability,"leDescriptor(); class destructor. Int_t AddAt(const void* c); Append one row pointed by ""c"" to the descriptor. void AddAt(const void* c, Int_t i); Add one row pointed by ""c"" to the ""i""-th row of the descriptor. void AddAt(TDataSet* dataset, Int_t idx = 0); Add one dataset to the descriptor.; There is no new implementation here.; One needs it to avoid the ""hidden method"" compilation warning. void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx); Add the descriptor element followed by its commentText; at the indx-th position of the descriptor (counted from zero). TString CreateLeafList() const; Create a list of leaf to be useful for TBranch::TBranch ctor. void Init(TClass* classPtr); Create a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C_structure only !!!. void LearnTable(const TTable* parentTable); to be documented. void LearnTable(TClass* classPtr). LearnTable() creates an array of the descriptors for elements of the row. It creates a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C-structure only !!!. This is to introduce an artificial restriction demanded by STAR database group. 1. the name may be 31 symbols at most; 2. the number the dimension is 3 at most. To lift this restriction one has to provide -DNORESTRICTIONS CPP symbol and; recompile code (and debug code NOW!). TTableDescriptor * MakeDescriptor(const char* structName). MakeDescriptor(const char *structName) - static method; structName - the name of the C structure; to create descriptor of; return a new instance of the TTableDescriptor or 0; if the ""structName is not present with the dictionary. TDataSet * MakeCommentField(Bool_t createFlag = kTRUE); Instantiate a comment dataset if any. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor); ""Schema evolution""; Method updates the offsets with a new ones from another descriptor. I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableDescriptor.html:18559,Learn,LearnTable,18559,root/html602/TTableDescriptor.html,https://root.cern,https://root.cern/root/html602/TTableDescriptor.html,2,['Learn'],['LearnTable']
Usability,"leList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUploadDataSetDlg.html:1731,Clear,Clear,1731,root/html532/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html,4,['Clear'],['Clear']
Usability,"le\(>\)&); 5.15.2 MnUserParameterState(const MnUserParameters&); 5.15.3 MnUserParameterState(const MnUserParameters&,; const MnUserCovariance&); 5.15.4 parameters(); 5.15.5 covariance(); 5.15.6 globalCC(); 5.15.7 MnUserParameterState::isValid() and; MnUserParameterState::hasCovariance(); 5.15.8 MnUserParameterState::fval(), MnUserParameterState::edm(),; MnUserParameterState::nfcn(). 5.16 MnPrint.h; 5.16.1 operator\(<<\)(std::ostream&, const FunctionMinimum&); 5.16.2 operator\(<<\)(std::ostream&, const MnUserParameters&); 5.16.3 operator\(<<\)(std::ostream&, const MnUserCovariance&); 5.16.4 operator\(<<\)(std::ostream&, const MnGlobalCorrelationCoeff&); 5.16.5 operator\(<<\)(std::ostream&, const MnUserParameterState&); 5.16.6 operator\(<<\)(std::ostream&, const MinosError&); 5.16.7 operator\(<<\)(std::ostream&, const ContoursErros&). 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.1.1 \(\mbox{MIGRAD}\); 6.1.2 \(\mbox{MINIMIZE}\); 6.1.3 \(\mbox{SCAN}\); 6.1.4 \(\mbox{SIMPLEX}\). 6.2 Floating point precision; 6.3 Parameter limits; 6.3.1 Getting the Right Minimum with Limits; 6.3.2 Getting the right parameter errors with limits. 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.5.1 Statistical interpretation; 6.5.2 The reliability of M error estimates. 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.1.1 GaussFunction.h; 7.1.2 GaussFcn.h; 7.1.3 GaussFcn.cpp. 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:4946,SIMPL,SIMPLEX,4946,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['SIMPL'],['SIMPLEX']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsAnaConvPdf.html:4315,clear,clearShapeDirty,4315,root/html602/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsAnaConvPdf.html,2,['clear'],['clearShapeDirty']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:3420,clear,clearShapeDirty,3420,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,12,['clear'],['clearShapeDirty']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDecay.html:2824,clear,clearShapeDirty,2824,root/html534/RooDecay.html,https://root.cern,https://root.cern/root/html534/RooDecay.html,6,['clear'],['clearShapeDirty']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPEffDecay.html:3126,clear,clearShapeDirty,3126,root/html534/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPEffDecay.html,24,['clear'],['clearShapeDirty']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBDecay.html:3024,clear,clearShapeDirty,3024,root/html534/RooBDecay.html,https://root.cern,https://root.cern/root/html534/RooBDecay.html,6,['clear'],['clearShapeDirty']
Usability,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgusBG.html:2848,clear,clearShapeDirty,2848,root/html534/RooArgusBG.html,https://root.cern,https://root.cern/root/html534/RooArgusBG.html,266,['clear'],['clearShapeDirty']
Usability,"leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:20987,simpl,simple,20987,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,8,['simpl'],['simple']
Usability,lear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704 fDataErrorHighPtr = nullptr;; 705 fDataErrorLow.clear();; 706 fDataErrorLowPtr = nullptr;; 707 }; 708 else if ( fErrorType == kAsymError ); 709 {; 710 fDataErrorHigh.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 711 fDataErrorHighPtr = fDataErrorHigh.empty() ? nullptr : &fDataErrorHigh.front();; 712 ; 713 fDataErrorLow.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 714 fDataErrorLowPtr = fDataErrorLow.empty() ? nullptr : &fDataErrorLow.front();; 715 ; 716 fDataError.clear();; 717 fDataErrorPtr = nullptr;; 718 }; 719 else; 720 {; 721 assert(false);; 722 }; 723 }; 724 ; 725 void BinData::InitBinEdge(); 726 {; 727 fBinEdge.resize( fDim );; 728 ; 729 for( unsigned int i=0; i<fDim; i++ ); 730 {; 731 fBinEdge[i].reserve(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 732 }; 733 ; 734 if ( fpTmpBinEdgeVector ); 735 {; 736 delete[] fpTmpBinEdgeVector;; 737 fpTmpBinEdgeVector = nullptr;; 738 }; 739 ; 740 fpTmpBinEdgeVector = new double[ fDim ];; 741 }; 742 ; 743 void BinData::UnWrap( ),MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:21466,clear,clear,21466,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"lectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGDockableFrame.html:21286,undo,undocking,21286,root/html534/TGDockableFrame.html,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html,2,['undo'],['undocking']
Usability,"lectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGDockableFrame.html:21186,undo,undocking,21186,root/html528/TGDockableFrame.html,https://root.cern,https://root.cern/root/html528/TGDockableFrame.html,4,['undo'],['undocking']
Usability,"lection.; 1494 // i.e. they contains the exact same type.; 1495 ; 1496 TVirtualCollectionProxy *oldProxy = oldClass->GetCollectionProxy();; 1497 TVirtualCollectionProxy *newProxy = newClass->GetCollectionProxy();; 1498 ; 1499 if (oldProxy->GetValueClass() == 0 && newProxy->GetValueClass() == 0; 1500 && (oldProxy->GetType() == kULong_t || oldProxy->GetType() == kULong64_t); 1501 && (newProxy->GetType() == kULong_t || newProxy->GetType() == kULong64_t )) {; 1502 // We have compatibles collections (they have the same content)!; 1503 return (oldClass->GetCollectionType() == newClass->GetCollectionType());; 1504 }; 1505 return kFALSE;; 1506 }; 1507 ; 1508 TClass *FindAlternate(TClass *context, const std::string &i_name, std::string& newName); 1509 {; 1510 // Return a class whose has the name as oldClass and can be found; 1511 // within the scope of the class 'context'.; 1512 ; 1513 // First strip any 'const ' prefix or trailing '*'.; 1514 std::string name(i_name);; 1515 newName.clear();; 1516 if (name.compare(0,6,""const "")==0) {; 1517 newName = ""const "";; 1518 name.erase(0,6);; 1519 }; 1520 std::string suffix;; 1521 UInt_t nstars = 0;; 1522 while(name[name.length()-nstars-1]=='*') {; 1523 ++nstars;; 1524 suffix.append(""*"");; 1525 }; 1526 if (nstars) {; 1527 name.erase(name.length()-nstars,nstars);; 1528 }; 1529 ; 1530 std::string alternate(context->GetName());; 1531 alternate.append(""::"");; 1532 alternate.append(name);; 1533 ; 1534 TClass *altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1535 if (altcl) {; 1536 newName.append(altcl->GetName());; 1537 newName.append(suffix);; 1538 return altcl;; 1539 }; 1540 ; 1541 size_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:58440,clear,clear,58440,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"lection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TQCommand*fCurrentthe latest executed command; TObjLink*fCursorcurrent position in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:18337,undo,undo,18337,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,4,['undo'],['undo']
Usability,lectionPtrIterators* TBranchElement::fPtrIterators. protected . ! holds the iterators when the branch is of fType==4 and it is a split collection of pointers. ; Definition at line 103 of file TBranchElement.h. ◆ fReadActionSequence. TStreamerInfoActions::TActionSequence* TBranchElement::fReadActionSequence. protected . ! Set of actions to be executed to extract the data from the basket. ; Definition at line 99 of file TBranchElement.h. ◆ fSTLtype. Int_t TBranchElement::fSTLtype. protected . ! STL container type ; Definition at line 81 of file TBranchElement.h. ◆ fStreamerType. Int_t TBranchElement::fStreamerType. protected . branch streamer type ; Definition at line 79 of file TBranchElement.h. ◆ fTargetClass. TClassRef TBranchElement::fTargetClass. protected . ! Reference to the target in-memory class ; Definition at line 91 of file TBranchElement.h. ◆ fType. Int_t TBranchElement::fType. protected . Branch type. ; Note on fType values:; -1 unsplit object with custom streamer at time of writing; 0 unsplit object with default streamer at time of writing OR simple data member of split object (fID==-1 for the former); 1 base class of a split object.; 2 class typed data member of a split object; 3 branch count of a split TClonesArray; 31 data member of the content of a split TClonesArray; 4 branch count of a split STL Collection.; 41 data member of the content of a split STL collection . Definition at line 67 of file TBranchElement.h. ◆ fWriteIterators. TVirtualCollectionIterators* TBranchElement::fWriteIterators. protected . ! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers. ; Definition at line 102 of file TBranchElement.h. Libraries for TBranchElement:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TBranchElement.h; tree/tree/src/TBranchElement.cxx. TBranchElement. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:18 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:83907,simpl,simple,83907,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['simpl'],['simple']
Usability,"lector::SlaveBegin(TTree*); virtual voidTSelector::SlaveTerminate(); virtual UInt_tTSelectorDraw::SplitNames(const TString& varexp, vector<TString>& names); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTakeAction(); virtual voidTSelectorDraw::TakeEstimate(); virtual voidTSelectorDraw::Terminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual intTSelector::Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSelectorDraw::ClearFormula(); virtual Bool_tTSelectorDraw::CompileVariables(const char* varexp = """", const char* selection = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTSelectorDraw::InitArrays(Int_t newsize); voidTObject::MakeZombie(). private:. TEvePointSelector(const TEvePointSelector&); TEvePointSelector&operator=(const TEvePointSelector&). Data Members; public:. enum TSelectorDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTSelectorDraw::fAction! Action type; Bool_tTSelectorDraw::fCleanElisttrue if original Tree elist must be saved; TEvePointSelectorConsumer*fConsumer; Long64_tTSelectorDraw::fCurrentSubEntryCurrent subentry when fSelectMultiple is true. Used to fill TEntryListArray; Int_tTSelect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEvePointSelector.html:7881,Clear,ClearFormula,7881,root/html532/TEvePointSelector.html,https://root.cern,https://root.cern/root/html532/TEvePointSelector.html,1,['Clear'],['ClearFormula']
Usability,led by unuran ;  CUnuranDistrMultiFree functions for multidimensional functions needed bby UNURAN ;  CUnuranRngUnuranRng class for interface ROOT random generators to Unuran ;  CUserGroup_t;  CVariableSelectionRule;  CVectorMemoryHelper;  CVecTrackD;  CVecTVecDouble;  CVecVecDouble;  CWindowAttributes_t;  CWrapperRooPdf;  C<X11Drawable>;  C<X11Window>;  CXColor_tDescription of a X11 color ;  CXHandleErr_t;  CXHandleIn_t;  ►CXMLReader;  CAttributes;  CXPClientArchiveRequest;  CXPClientInterruptRequest;  CXPClientLoginRequest;  CXPClientProofRequest;  CXPClientReadbufRequest;  CXPClientRequest;  CXPClientSendRcvRequest;  CXpdAdminCpCmd;  CXpdClientSessions;  CXpdEnv;  CXpdGroupEff_t;  CXpdGroupGlobal_t;  CXpdManagerCron_t;  CXpdMsg;  CXpdObject;  CXpdObjectQ;  CXpdSrvMgrCreateCnt;  CXpdSrvMgrCreateGuard;  CXrdClientCacheInterval;  ►CXrdClientConn;  CSessionIDInfo;  ►CXrdClientConnectionMgr;  CCndVarInfo;  CXrdClientID;  CXrdClientInputBuffer;  CXrdClientLogConnection;  CXrdClientMessage;  CXrdClientPhyConnection;  CXrdClientPhyConnLocker;  CXrdClientReadCache;  CXrdClientReadCacheItem;  CXrdClientSock;  CXrdClientSockConnectParms;  ►CXrdPoll;  CPipeData;  CXrdProofConn;  CXrdProofdAdmin;  CXrdProofdAux;  CXrdProofdClient;  CXrdProofdClientMgr;  CXrdProofdConfig;  CXrdProofdDirective;  CXrdProofdDSInfo;  CXrdProofdFile;  CXrdProofdManager;  CXrdProofdMultiStr;  CXrdProofdMultiStrToken;  CXrdProofdNetMgr;  CXrdProofdPInfo;  CXrdProofdPipe;  CXrdProofdPriority;  CXrdProofdPriorityMgr;  CXrdProofdProofServ;  CXrdProofdProofServMgr;  CXrdProofdProtocol;  CXrdProofdResponse;  CXrdProofdSandbox;  CXrdProofdSessionEntry;  CXrdProofGI;  CXrdProofGroup;  CXrdProofGroupMember;  CXrdProofGroupMgr;  CXrdProofPhyConn;  CXrdProofQuery;  CXrdProofSched;  CXrdProofSessionInfo;  CXrdProofUI;  CXrdProofWorker;  CXrdROOT;  CXrdROOTMgr;  CXrdSrvBuffer;  CXrdSysPriv;  CXrdSysPrivGuard;  CXShapeEvent. ROOT 6.06/09 - Reference Guide Generated on Sun Dec 10 2017 22:29:05 using Doxygen 1.8.9. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:168601,Guid,Guide,168601,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['Guid'],['Guide']
Usability,"led for the first time; 162(`TH1::Draw`), it creates a `THistPainter` object and saves a; 163pointer to this ""painter"" as a data member of the histogram. The; 164`THistPainter` class specializes in the drawing of histograms. It is; 165separated from the histogram so that one can have histograms without the; 166graphics overhead, for example in a batch program. Each histogram having its own; 167painter (rather than a central singleton painter painting all histograms), allows; 168two histograms to be drawn in two threads without overwriting the painter's; 169values.; 170 ; 171When a displayed histogram is filled again, there is no need to call the; 172`Draw()` method again; the image will be refreshed the next time the; 173pad will be updated.; 174 ; 175A pad is updated after one of these three actions:; 176 ; 1771. a carriage control on the ROOT command line,; 1782. a click inside the pad,; 1793. a call to `TPad::Update`.; 180 ; 181 ; 182By default a call to `TH1::Draw()` clears the pad of all objects; 183before drawing the new image of the histogram. One can use the `SAME`; 184option to leave the previous display intact and superimpose the new histogram.; 185The same histogram can be drawn with different graphics options in different; 186pads.; 187 ; 188When a displayed histogram is deleted, its image is automatically removed; 189from the pad.; 190 ; 191To create a copy of the histogram when drawing it, one can use; 192`TH1::DrawClone()`. This will clone the histogram and allow to change; 193and delete the original one without affecting the clone.; 194 ; 195 ; 196\anchor HP01; 197### Histograms' plotting options; 198 ; 199 ; 200Most options can be concatenated with or without spaces or commas, for example:; 201 ; 202 h->Draw(""E1 SAME"");; 203 ; 204The options are not case sensitive:; 205 ; 206 h->Draw(""e1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:7078,clear,clears,7078,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clears']
Usability,"led with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:4065,learn,learning,4065,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"led(Bool_t on)SIGNAL ; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGButton::EmitSignals(Bool_t wasUp); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidInit(); voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGTextButton(const TGTextButton&); TGTextButton&operator=(const TGTextButton&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustClean",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextButton.html:19113,Clear,ClearFlags,19113,root/html532/TGTextButton.html,https://root.cern,https://root.cern/root/html532/TGTextButton.html,2,['Clear'],['ClearFlags']
Usability,"ledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; 2855/// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; 2856/// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; 2857/// - kMatch (0) : perfect match; 2858/// - kMatchConversion (1) : match with (I/O) conversion; 2859/// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; 2860/// - kMakeClass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool isptr); 2869{; 2870 if (GetMakeClass()) {; 2871 // If we are in MakeClass mode so we do not really use classes.; 2872 return kMakeClass;; 2873 }; 2874 ; 2875 // Let's determine what we need!; 2876 TClass* expectedClass = nullptr;; 2877 EDataType expectedType = kOther_t;; 2878 if (0 != branch->GetExpectedType(expectedClass,expectedType) ) {; 2879 // Something went wrong, the warning message has already been issued.; 2880 return kInternalError;; 2881 }; 2882 bool isBranchElement = branch->InheritsFrom( TBranchElement::Class() );; 2883 if (expectedClass && datatype == kOther_t && ptrClass == nullptr) {; 2884 if (isBranchElement) {; 2885 TBranchElement* bEl = (TBranchElement*)branch;; 2886 bEl->SetTargetClass( expectedClass->GetName() );; 288",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:113097,usab,usable,113097,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['usab'],['usable']
Usability,"legant replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin J. 2; H(J) = sum Y E(J) = sum Y; l(J) = sum l L(J) = sum l; h(J) = H(J)/L(J) s(J) = sqrt(E(J)/L(J)- h(J)**2); e(J) = s(J)/sqrt(L(J)). In the special case where s(J) is zero (eg, case of 1 entry only in one bin); e(J) is computed from the average of the s(J) for all bins if the static function; TProfile::Approximate has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile histogram with its graphics output; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }. /*. */. Function Members (Methods); public:. TProfile(); TProfile(const TProfile& profile); TProfile(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Double_t ylow, Double_t yup, Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile.html:1374,simpl,simple,1374,root/html528/TProfile.html,https://root.cern,https://root.cern/root/html528/TProfile.html,4,['simpl'],['simple']
Usability,"legant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; 48 instead of using global variables.; 49 ; 50 ; 51## Basic concepts of MINUIT; 52 ; 53The [MINUIT](https://root.cern/download/minuit.pdf); 54package acts on a multiparameter Fortran function to which one; 55must give the generic name <TT>FCN</TT>. In the ROOT implementation,; 56the function <TT>FCN</TT> is defined via the MINUIT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit fitting function as being H1FitChisquare; 63or H1FitLikelihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, while; 82the external value \f$P_{\mathrm{ext}}\f$ can take on values only between the lower; 83limit \f$a\f$ and the upper limit \f$b\f$.; 84Since the transformat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:2700,simpl,simple,2700,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['simpl'],['simple']
Usability,"legation object; 237 TString fSenderClass; //class name of delegation object; 238 ; 239 void *GetSender() override { return fSender; }; 240 const char *GetSenderClassName() const override { return fSenderClass.Data(); }; 241 ; 242private:; 243 TQObjSender(const TQObjSender&) = delete;; 244 TQObjSender& operator=(const TQObjSender&) = delete;; 245 ; 246public:; 247 TQObjSender() : TQObject(), fSender(nullptr), fSenderClass() { }; 248 virtual ~TQObjSender() { Disconnect(); }; 249 ; 250 virtual void SetSender(void *sender) { fSender = sender; }; 251 void SetSenderClassName(const char *sclass = """") { fSenderClass = sclass; }; 252 ; 253 ClassDefOverride(TQObjSender,0) //Used to ""delegate"" TQObject functionality; 254 //to interpreted classes, see also RQ_OBJECT.h; 255};; 256 ; 257 ; 258 ; 259// Global function which simplifies making connections in interpreted; 260// ROOT session; 261//; 262// ConnectCINT - connects to interpreter(CINT) command; 263 ; 264extern Bool_t ConnectCINT(TQObject *sender, const char *signal,; 265 const char *slot);; 266 ; 267#ifdef G__DICTIONARY; 268// This include makes it possible to have a single connection; 269// from all objects of the same class but is only needed in; 270// the dictionary.; 271#include ""TQClass.h""; 272#endif; 273 ; 274 ; 275//---- ClassImpQ macro ----------------------------------------------; 276//; 277// This macro used to correspond to the ClassImp macro and should be used; 278// for classes derived from TQObject instead of the ClassImp macro.; 279// This macro makes it possible to have a single connection from; 280// all objects of the same class.; 281// *** It is now obsolete ***; 282 ; 283#define ClassImpQ(name) \; 284 ClassImp(name); 285 ; 286#endif; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; ClassDefOverride#define ClassDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8h_source.html:9271,simpl,simplifies,9271,doc/master/TQObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8h_source.html,1,['simpl'],['simplifies']
Usability,"lel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoMoreParallel(Int_t nWorkersToAdd); Add nWorkersToAdd workers to current list of workers. This function is; works on the master only, and only when an analysis is ongoing. A message; is sent back to the client when we go ""more"" parallel.; Returns -1 on error, number of total (not added!) workers on success. Int_t GoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Go in parallel mode with at most ""nodes"" slaves. Since the fSlaves; list is sorted by slave performace the active list will contain first; the most performant nodes. Returns the number of active slaves.; If random is TRUE, and nodes is less than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the data directory in the sandbox.; This is the place where files produced by the client queries are kept. void ClearData(UInt_t what = kUnregistered, const char* dsname = 0); Remove files for the data directory.; The option 'what' can take the values:; kPurge remove all files and directories under '~/data'; kUnregistered remove only files not in registered datasets (default); kDataset remove files belonging to dataset 'dsname'; User is prompt for confirmation, unless kForceClear is ORed with the option. Bool_t Prompt(const char* p); Prompt the question 'p' requiring an answer y,Y,n,N; Return kTRUE is the answer was y or Y, kFALSE in all other cases. void ClearDataProgress(Int_t r, Int_t t); Progress bar for clear data. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:68837,Clear,ClearData,68837,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['Clear'],['ClearData']
Usability,"lement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual Bool_tTEveWindow::CanMakeNewSlots() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidTEveWindow::ClearEveFrame(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); static TEveWindowSlot*TEveWindow::CreateDefaultWindowSlot(); static TEveWindowSlot*TEveWindow::CreateWindowInTab(TGTab* tab, TEveWindow* eve_parent = 0); static TEveWindowSlot*TEveWindow::CreateWindowMainFrame(TEveWindow* eve_parent = 0); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveEle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveViewer.html:2906,Clear,ClearStamps,2906,root/html532/TEveViewer.html,https://root.cern,https://root.cern/root/html532/TEveViewer.html,12,['Clear'],['ClearStamps']
Usability,"lement> Randomize(float alpha, float beta, Double_t& seed); Randomize matrix element values. void TMatrixTBase<Element> Streamer(TBuffer& ); Stream an object of class TMatrixTBase<Element>. template<class Element> Element TMatrixTBase<Element> SetTol(float tol). Element * GetElements(). Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fNcols+fColLwb-1; }. Int_t GetNcols() const; { return fNcols; }. Int_t GetNoElements() const; { return fNelems; }. Element GetTol() const; { return fTol; }. const Element * GetMatrixArray() const. Element * GetMatrixArray(). const Int_t * GetRowIndexArray() const. Int_t * GetRowIndexArray(). const Int_t * GetColIndexArray() const. Int_t * GetColIndexArray(). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data). TMatrixTBase<Element> & SetColIndexArray(Int_t* data). void Clear(Option_t* option = """"). void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. TMatrixTBase<Element> & GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). TMatrixTBase<Element> & ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1). Double_t Determinant() const; { AbstractMethod(""Determinant()""); return 0.; }. void Determinant(Double_t& d1, Double_t& d2) const; { AbstractMethod(""Determinant()""); d1 = 0.; d2 = 0.; }. Element NormInf() const; { return RowNorm(); }. Element Norm1() const; { return ColNorm(); }. Element operator()(Int_t rown, Int_t coln) const. Element & operator()(Int_t rown, Int_t coln). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-30 15:19;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTBase_float_.html:21832,Clear,Clear,21832,root/html602/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTBase_float_.html,1,['Clear'],['Clear']
Usability,"lementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Double_t& retDouble); Execute the method for the specified object and argument values. void Execute(vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodCall.html:10321,usab,usable,10321,root/html528/TMethodCall.html,https://root.cern,https://root.cern/root/html528/TMethodCall.html,6,['usab'],['usable']
Usability,"lename, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); virtual~TParallelMergingFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTDirectory::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TObject*TDirectoryFile::CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTFile::Copy(TObject&) const; virtual voidTMemFile::CopyTo(TBuffer& tobuf) const; virtual Long64_tTMemFile::CopyTo(void* to, Long64_t maxsize) const; virtual Bool_tTFile::Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); static Bool_tTFile::Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); virtual TKey*TFile::CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); virtual TKey*TFile::CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParallelMergingFile.html:1795,Clear,Clear,1795,root/html532/TParallelMergingFile.html,https://root.cern,https://root.cern/root/html532/TParallelMergingFile.html,2,['Clear'],['Clear']
Usability,"length n.; 1739/// Note that this function returns the sigma(standard deviation) and; 1740/// not the root mean square of the array.; 1741 ; 1742template <typename T>; 1743Double_t TMVA::Tools::RMS(Long64_t n, const T *a, const Double_t *w); 1744{; 1745 ; 1746 if (w) {; 1747 return TMVA::Tools::RMS(a, a+n, w);; 1748 } else {; 1749 return TMath::RMS(a, a+n);; 1750 }; 1751}; 1752 ; 1753////////////////////////////////////////////////////////////////////////////////; 1754/// get the cumulative distribution of a histogram; 1755 ; 1756TH1* TMVA::Tools::GetCumulativeDist( TH1* h); 1757{; 1758 TH1* cumulativeDist= (TH1*) h->Clone(TString::Format(""%sCumul"",h->GetTitle()));; 1759 //cumulativeDist->Smooth(5); // with this, I get less beautiful ROC curves, hence out!; 1760 ; 1761 Float_t partialSum = 0;; 1762 Float_t inverseSum = 0.;; 1763 ; 1764 Float_t val;; 1765 for (Int_t ibinEnd=1, ibin=cumulativeDist->GetNbinsX(); ibin >=ibinEnd ; ibin--){; 1766 val = cumulativeDist->GetBinContent(ibin);; 1767 if (val>0) inverseSum += val;; 1768 }; 1769 inverseSum = 1/inverseSum; // as I learned multiplications are much faster than division, and later I need one per bin. Well, not that it would really matter here I guess :); 1770 ; 1771 for (Int_t ibinEnd=1, ibin=cumulativeDist->GetNbinsX(); ibin >=ibinEnd ; ibin--){; 1772 val = cumulativeDist->GetBinContent(ibin);; 1773 if (val>0) partialSum += val;; 1774 cumulativeDist->SetBinContent(ibin,partialSum*inverseSum);; 1775 }; 1776 return cumulativeDist;; 1777}; 1778 ; 1779void TMVA::Tools::ReadAttr(void *node, const char *attrname, float &value); 1780{; 1781 // read attribute from xml; 1782 const char *val = xmlengine().GetAttr(node, attrname);; 1783 if (val == nullptr) {; 1784 const char *nodename = xmlengine().GetNodeName(node);; 1785 Log() << kFATAL << ""Trying to read non-existing attribute '"" << attrname << ""' from xml node '"" << nodename << ""'""; 1786 << Endl;; 1787 } else; 1788 value = atof(val);; 1789}; 1790 ; 1791void TMVA::Tools::Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:62293,learn,learned,62293,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['learn'],['learned']
Usability,"lete [] integral;; 3570}; 3571 ; 3572////////////////////////////////////////////////////////////////////////////////; 3573/// Fill histogram following distribution in histogram h.; 3574///; 3575/// @param h : Histogram pointer used for sampling random number; 3576/// @param ntimes : number of times the histogram is filled; 3577/// @param rng : (optional) Random number generator used for sampling; 3578///; 3579/// The distribution contained in the histogram h (TH1) is integrated; 3580/// over the channel contents for the bin range of this histogram.; 3581/// It is normalized to 1.; 3582///; 3583/// Getting one random number implies:; 3584/// - Generating a random number between 0 and 1 (say r1); 3585/// - Look in which bin in the normalized integral r1 corresponds to; 3586/// - Fill histogram channel ntimes random numbers are generated; 3587///; 3588/// SPECIAL CASE when the target histogram has the same binning as the source.; 3589/// in this case we simply use a poisson distribution where; 3590/// the mean value per bin = bincontent/integral.; 3591 ; 3592void TH1::FillRandom(TH1 *h, Int_t ntimes, TRandom * rng); 3593{; 3594 if (!h) { Error(""FillRandom"", ""Null histogram""); return; }; 3595 if (fDimension != h->GetDimension()) {; 3596 Error(""FillRandom"", ""Histograms with different dimensions""); return;; 3597 }; 3598 if (std::isnan(h->ComputeIntegral(true))) {; 3599 Error(""FillRandom"", ""Histograms contains negative bins, does not represent probabilities"");; 3600 return;; 3601 }; 3602 ; 3603 //in case the target histogram has the same binning and ntimes much greater; 3604 //than the number of bins we can use a fast method; 3605 Int_t first = fXaxis.GetFirst();; 3606 Int_t last = fXaxis.GetLast();; 3607 Int_t nbins = last-first+1;; 3608 if (ntimes > 10*nbins) {; 3609 auto inconsistency = CheckConsistency(this,h);; 3610 if (inconsistency != kFullyConsistent) return; // do nothing; 3611 Double_t sumw = h->Integral(first,last);; 3612 if (sumw == 0) return;; 3613 Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:142960,simpl,simply,142960,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['simpl'],['simply']
Usability,"letteEditor ; (; ). overridevirtual . Start palette editor. ; Reimplemented from TAttImage.; Definition at line 2252 of file TASImage.cxx. ◆ Streamer(). void TASImage::Streamer ; (; TBuffer & ; b). overridevirtual . Streamer for ROOT I/O. ; Reimplemented from TObject.; Definition at line 6175 of file TASImage.cxx. ◆ StreamerNVirtual(). void TASImage::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 211 of file TASImage.h. ◆ Tile(). void TASImage::Tile ; (; UInt_t ; width, . UInt_t ; height . ). overridevirtual . Tile the original image. ; Reimplemented from TImage.; Definition at line 1987 of file TASImage.cxx. ◆ TypeFromMagicNumber(). const char * TASImage::TypeFromMagicNumber ; (; const char * ; file). private . Guess the file type from the first byte of file. ; Definition at line 402 of file TASImage.cxx. ◆ UnZoom(). void TASImage::UnZoom ; (; ). overridevirtual . Un-zoom the image to original size. ; UnZoom() - performs undo for Zoom,Crop,Scale actions ; Reimplemented from TImage.; Definition at line 2049 of file TASImage.cxx. ◆ Vectorize(). Double_t * TASImage::Vectorize ; (; UInt_t ; max_colors = 256, . UInt_t ; dither = 4, . Int_t ; opaque_threshold = 1 . ). overridevirtual . Reduce color-depth of an image and fills vector of ""scientific data"" [0...1]. ; Colors are reduced by allocating color cells to most used colors first, and then approximating other colors with those allocated.; Parameters. [in]max_colors- maximum size of the colormap. ; [in]dither- number of bits to strip off the color data ( 0...7 ) ; [in]opaque_threshold- alpha channel threshold at which pixel should be treated as opaque . Reimplemented from TImage.; Definition at line 2832 of file TASImage.cxx. ◆ WriteImage(). void TASImage::WriteImage ; (; const char * ; file, . EImageFileTypes ; type = TImage::kUnknown . ). overridevirtual . Write image to specified file. ; If there is no file extension or if the file extension is unknown, the type argument",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:77895,undo,undo,77895,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['undo'],['undo']
Usability,"lexible Object; Oriented implementation has been chosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:3510,Learn,Learning,3510,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,3,['Learn'],['Learning']
Usability,"liases can be used in composing others;; input/output event lists easy to handle;; menu with histogram drawing options;; user commands may be executed within the viewer and the current command can be echoed;; current 'Draw' event loop is reflected by a progress bar and may be interrupted by the user;; all widgets have self-explaining tool tips and/or context menus;; expressions/leaves can be dragged to a 'scan box' and scanned by double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. a menu bar with entries : File, Edit, Run, Options and Help;; a toolbar in the upper part where you can issue user commands, change the drawing option and the histogram name, three check buttons Hist, Rec and Scan.HIST toggles histogram drawing mode, REC enables recording of the last command issued and SCAN enables redirecting of TTree::Scan command in an ASCII file (see -Scanning expressions-);; a button bar in the lower part with : buttons DRAW/STOP that issue histogram drawing and stop the current command respectively, two text widgets where input and output event lists can be specified, a message box and a RESET button on the right that clear edited expression content (see Editing...); a tree-type list on the main left panel where you can select among trees or branches. The tree/branch will be detailed in the right panel. Mapped trees are provided with context menus, activated by right-clicking;; a view-type list on the right panel. The first column contain X, Y and Z expression items, an optional cut and ten optional editable expressions. Expressions and leaf-type items can be dragged or deleted. A right click on the list-box or item activates context menus. Opening a new tree and saving a session :; To open a new tree in the viewer use <File/Open tree file> menu The content of the file (keys) will be listed. Use <SetTreeName> function from the context menu of the right panel, entering a tree name among those listed.; To save",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeViewer.html:2299,clear,clear,2299,doc/master/classTTreeViewer.html,https://root.cern,https://root.cern/doc/master/classTTreeViewer.html,1,['clear'],['clear']
Usability,lic Member Functions |; Static Public Member Functions |; Private Member Functions |; Static Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TGuiBldDragManager Class ReferenceGUI » GUI Builder. ; Drag and drop manager used by the ROOT GUI Builder. ; Definition at line 58 of file TGuiBldDragManager.h. Public Member Functions;  TGuiBldDragManager ();  ;  ~TGuiBldDragManager () override;  Destructor. ;  ; void ChangeBackgroundColor (TGCanvas *);  Change background color via context menu. ;  ; void ChangeBackgroundColor (TGComboBox *);  Change background color for list box entries. ;  ; void ChangeBackgroundColor (TGCompositeFrame *);  Change background color via context menu for this frame and all subframes. ;  ; void ChangeBackgroundColor (TGFrame *);  Change background color via context menu. ;  ; void ChangeBackgroundColor (TGListBox *);  Set background color for list box entries. ;  ; void ChangeBarColor (TGProgressBar *);  Set progress bar color via TGColorDialog. ;  ; void ChangeImage (TGIcon *);  Invoke file dialog to assign a new image. ;  ; void ChangePicture (TGPictureButton *);  Invoke file dialog to assign a new picture. ;  ; void ChangeProperties (TGLabel *);  Edit properties via font selection dialog. ;  ; void ChangeProperties (TGTextButton *);  Edit properties via font selection dialog. ;  ; void ChangeTextColor (TGGroupFrame *);  Change text color via color selection dialog. ;  ; void ChangeTextColor (TGLabel *);  Change text color via color selection dialog. ;  ; void ChangeTextColor (TGProgressBar *);  Change text color which displays position. ;  ; void ChangeTextColor (TGTextButton *);  Change text color via color selection dialog. ;  ; void ChangeTextColor (TGTextEntry *);  Set text color. ;  ; void ChangeTextFont (TGGroupFrame *);  Change text font via font selection dialog. ;  ; void ChangeTextFont (TGTextEntry *);  Change text font via font selection dialog. ;  ; void DoClassMenu (I,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGuiBldDragManager.html:1158,progress bar,progress bar,1158,doc/master/classTGuiBldDragManager.html,https://root.cern,https://root.cern/doc/master/classTGuiBldDragManager.html,1,['progress bar'],['progress bar']
Usability,"lid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooResolutionModel.html:4627,clear,clearValueDirty,4627,root/html602/RooResolutionModel.html,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html,2,['clear'],['clearValueDirty']
Usability,"lightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TGGC*TGContainer::fgLineGC; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. Cursor_tfCursorcurrent cursor; Cursor_tfDefaultCursordefault cursor; TList*fExpressionListlist of user defined expression widgets; TGListView*fListViewassociated list view; TTreeViewer*fViewerpointer to tree viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVLVContainer(const TGWindow* p, UInt_t w, UInt_t h, UInt_t options = kSunkenFrame); TGLVContainer constructor. ~TTVLVContainer(); TGLVContainer destructor. const char* Cut(); return the cut entry. TTVLVEntry * ExpressionItem(Int_t index); return the expression item at specific position. TList* ExpressionList(); return the list of user-defined expressions. const char* Ex(); return the expression on X. const char* Ey(); return the expression on Y. const char* Ez(); return the expression on Z. const char* ScanList(); return the cut entry. Bool_t HandleButton(Event_t* event); Handle mouse button event in container. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. void EmptyAll(); Clear all names and aliases for expression type items. void RemoveNonStatic(); remove all non-static items from the list view, except expressions. void SelectItem(const char* name); select an item. void AddThisItem(TTVLVEntry* item); { AddFrame(item, fItemLayout); item->SetColumns(fCpos, fJmode); }. TTreeViewer * GetViewer(); {return fViewer;}. void SetListView(TGListView* lv); {fListView = lv;}. void SetViewer(TTreeViewer* viewer); {fViewer = viewer;}. » Last changed: root/treeviewer:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTVLVContainer.html:26195,Clear,Clear,26195,root/html534/TTVLVContainer.html,https://root.cern,https://root.cern/root/html534/TTVLVContainer.html,1,['Clear'],['Clear']
Usability,"like this should appear:. Figure 2: Example of TBrowser at start-up time; On the left, in the ""ROOT Files"" folder, you can find the ROOT file you have opened and our EventTree. If you see EventTree;1 and EventTree: they are identical. The first one is the tree on disk, the second the one in memory. Click your way through the tree.; Draw the ""fPosZ"" values from the browser. You should obtain a result looking like this:. Figure 3: Distribution of ""fPosZ"" values; This graph is called a histogram: it counts occurrences, combining neighboring values into ""bins"". In this case we have 100 equally sized bins (the ""steps""), ranging from x=-74 to x=102. You can tell that there were about 500 particles with a fPosZ value around -11. Histograms are a very common way to visualize data, e.g. in high energy physics.; Now close the browser, quit and restart ROOT (to make sure everybody starts from the same point).; . ‹ Meet a TTree; up; Using TTree::Draw() to access a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tbrowser.html:3639,guid,guidelines,3639,d/accessing-ttree-tbrowser.html,https://root.cern,https://root.cern/d/accessing-ttree-tbrowser.html,1,['guid'],['guidelines']
Usability,"limit the amount of data processed. ;  ;  df006_ranges.py;   Use Range to limit the amount of data processed. ;  ;  df007_snapshot.C;   Write ROOT data with RDataFrame. ;  ;  df007_snapshot.py;   Write ROOT data with RDataFrame. ;  ;  df008_createDataSetFromScratch.C;   Create data from scratch with RDataFrame. ;  ;  df008_createDataSetFromScratch.py;   Create data from scratch with RDataFrame. ;  ;  df009_FromScratchVSTTree.C;   Compare creation of a ROOT dataset with RDataFrame and TTree. ;  ;  df010_trivialDataSource.C;   Use the ""trivial data source"", an example data source implementation. ;  ;  df010_trivialDataSource.py;   Use the ""trivial data source"", an example data source implementation. ;  ;  df012_DefinesAndFiltersAsStrings.C;   Use just-in-time-compiled Filters and Defines for quick prototyping. ;  ;  df012_DefinesAndFiltersAsStrings.py;   Use just-in-time-compiled Filters and Defines for quick prototyping. ;  ;  df013_InspectAnalysis.C;   Use callbacks to update a plot and a progress bar during the event loop. ;  ;  df014_CSVDataSource.C;   Process a CSV file with RDataFrame and the CSV data source. ;  ;  df014_CSVDataSource.py;   Process a CSV file with RDataFrame and the CSV data source. ;  ;  df015_LazyDataSource.C;   Use the lazy RDataFrame data source to concatenate computation graphs. ;  ;  df016_vecOps.C;   Process collections in RDataFrame with the help of RVec. ;  ;  df016_vecOps.py;   Process collections in RDataFrame with the help of RVec. ;  ;  df017_vecOpsHEP.C;   Use RVecs to plot the transverse momentum of selected particles. ;  ;  df017_vecOpsHEP.py;   Use RVecs to plot the transverse momentum of selected particles. ;  ;  df018_customActions.C;   Implement a custom action to fill THns. ;  ;  df019_Cache.C;   Cache a processed RDataFrame in memory for further usage. ;  ;  df019_Cache.py;   Cache a processed RDataFrame in memory for further usage. ;  ;  df020_helpers.C;   Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:2067,progress bar,progress bar,2067,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,1,['progress bar'],['progress bar']
Usability,"line 1571 of file RooFactoryWSTool.cxx. ◆ autoClassNamePostFix(). const char * RooFactoryWSTool::autoClassNamePostFix ; (; ); const. inline . Definition at line 155 of file RooFactoryWSTool.h. ◆ checkIndex(). void RooFactoryWSTool::checkIndex ; (; UInt_t ; index). staticprotected . Definition at line 1516 of file RooFactoryWSTool.cxx. ◆ checkSyntax(). bool RooFactoryWSTool::checkSyntax ; (; const char * ; arg). protected . Perform basic syntax on given factory expression. ; If function returns true syntax errors are found. ; Definition at line 1481 of file RooFactoryWSTool.cxx. ◆ Class(). static TClass * RooFactoryWSTool::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooFactoryWSTool::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooFactoryWSTool::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 199 of file RooFactoryWSTool.h. ◆ clearError(). void RooFactoryWSTool::clearError ; (; ). inlineprotected . Associated workspace. ; Definition at line 192 of file RooFactoryWSTool.h. ◆ createArg(). RooAbsArg * RooFactoryWSTool::createArg ; (; const char * ; className, . const char * ; objName, . const char * ; varList . ). Low-level factory interface for creating a RooAbsPdf of a given class with a given list of input variables The variable list varList should be of the form ""a,b,c"" where the interpretation of the argument is dependent on the pdf. ; Set and List arguments can be passed by substituting a single argument with the form (a,b,c), i.e. one can set varList to ""x,(a0,a1,a2)"" to pass a RooAbsReal and a RooArgSet as arguments. ; Definition at line 280 of file RooFactoryWSTool.cxx. ◆ createCategory(). RooCategory * RooFactoryWSTool::createCategory ; (; const char * ; name, . const char * ; stateNameList = nullptr . ). Low-level factory interface for creating a RooCategory with a given list of state names. ; The State ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:30143,clear,clearError,30143,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['clear'],['clearError']
Usability,"line 650 of file TUnfoldSys.cxx. ◆ DeclFileName(). static const char * TUnfoldSys::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 146 of file TUnfoldSys.h. ◆ DoBackgroundSubtraction(). void TUnfoldSys::DoBackgroundSubtraction ; (; void ; ). protected . perform background subtraction ; This prepares the data members for the base class TUnfold, such that the background is properly taken into account. ; Definition at line 377 of file TUnfoldSys.cxx. ◆ GetBackground(). void TUnfoldSys::GetBackground ; (; TH1 * ; bgrHist, . const char * ; bgrSource = nullptr, . const Int_t * ; binMap = nullptr, . Int_t ; includeError = 3, . Bool_t ; clearHist = kTRUE . ); const. get background into a histogram ; Parameters. [in,out]bgrHisttarget histogram, content and errors will be altered ; [in]bgrSource(default=nullptr) name of backgrond source or zero to add all sources of background ; [in]binMap(default=nullptr) remap histogram bins ; [in]includeError(default=3) include uncorrelated(1), correlated (2) or both (3) sources of uncertainty in the histogram errors ; [in]clearHist(default=true) reset histogram before adding up the specified background sources. the array binMap is explained with the method GetOutput(). The flag clearHist may be used to add background from several sources in successive calls to GetBackground(). ; Definition at line 565 of file TUnfoldSys.cxx. ◆ GetBgrSources(). TSortedList * TUnfoldSys::GetBgrSources ; (; void ; ); const. Get a new list of all background sources. ; The user is responsible for deleting the list get list of name of background sources ; Definition at line 1528 of file TUnfoldSys.cxx. ◆ GetChi2Sys(). Double_t TUnfoldSys::GetChi2Sys ; (; void ; ). calculate total chi**2 including all systematic errors ; Definition at line 1366 of file TUnfoldSys.cxx. ◆ GetDeltaSysBackgroundScale(). Bool_t TUnfoldSys::GetDeltaSysBackgroundScale ; (; TH1 * ; hist_delta, . const char * ; source, . c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:34290,clear,clearHist,34290,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearHist']
Usability,"line 926 of file RooTreeDataStore.cxx. ◆ reduce(). std::unique_ptr< RooAbsDataStore > RooTreeDataStore::reduce ; (; RooStringView ; name, . RooStringView ; title, . const RooArgSet & ; vars, . const RooFormulaVar * ; cutVar, . const char * ; cutRange, . std::size_t ; nStart, . std::size_t ; nStop . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 179 of file RooTreeDataStore.cxx. ◆ reset(). void RooTreeDataStore::reset ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 935 of file RooTreeDataStore.cxx. ◆ Reset(). void RooTreeDataStore::Reset ; (; Option_t * ; option = nullptr). Interface function to TTree::Reset. ; Definition at line 1104 of file RooTreeDataStore.cxx. ◆ resetBuffers(). void RooTreeDataStore::resetBuffers ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 1058 of file RooTreeDataStore.cxx. ◆ resetCache(). void RooTreeDataStore::resetCache ; (; ). overridevirtual . Remove tree with values of cached observables and clear list of cached observables. ; Implements RooAbsDataStore.; Definition at line 1018 of file RooTreeDataStore.cxx. ◆ restoreAlternateBuffers(). void RooTreeDataStore::restoreAlternateBuffers ; (; ). Definition at line 1069 of file RooTreeDataStore.cxx. ◆ row(). const RooArgSet & RooTreeDataStore::row ; (; ). inline . Definition at line 139 of file RooTreeDataStore.h. ◆ setArgStatus(). void RooTreeDataStore::setArgStatus ; (; const RooArgSet & ; set, . bool ; active . ). overridevirtual . Activate or deactivate the branch status of the TTree branch associated with the given set of dataset observables. ; Implements RooAbsDataStore.; Definition at line 999 of file RooTreeDataStore.cxx. ◆ setBranchBufferSize(). void RooTreeDataStore::setBranchBufferSize ; (; Int_t ; size). inlineprivate . Definition at line 152 of file RooTreeDataStore.h. ◆ setExternalWeightArray(). void RooTreeDataStore::setExternalWeightArray ; (; const double * ; arrayWgt, . const double * ; arrayWgtErrLo, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:36174,clear,clear,36174,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['clear'],['clear']
Usability,"lineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 63 of file RooPoisson.h. ◆ protectNegativeMean(). void RooPoisson::protectNegativeMean ; (; bool ; flag = true). inline . Switch on or off protection against negative means. ; Definition at line 40 of file RooPoisson.h. ◆ setNoRounding(). void RooPoisson::setNoRounding ; (; bool ; flag = true). inline . Switch off/on rounding of x to the nearest integer. ; Definition at line 36 of file RooPoisson.h. ◆ Streamer(). void RooPoisson::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooPoisson::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 63 of file RooPoisson.h. ◆ translate(). void RooPoisson::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 67 of file RooPoisson.cxx. Member Data Documentation. ◆ _noRounding. bool RooPoisson::_noRounding. protected . Definition at line 56 of file RooPoisson.h. ◆ _protectNegative. bool RooPoisson::_protectNegative {true}. protected . Definition at line 57 of file RooPoisson.h. ◆ mean. RooRealProxy RooPoisson::mean. protected . Definition at line 55 of file RooPoisson.h. ◆ x. RooRealProxy RooPoisson::x. protected . Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPoisson.html:79535,simpl,simple,79535,doc/master/classRooPoisson.html,https://root.cern,https://root.cern/doc/master/classRooPoisson.html,1,['simpl'],['simple']
Usability,"lineprivate . Definition at line 3151 of file RInterface.hxx. ◆ DefinePerSample() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename RetType_t = typename TTraits::CallableTraits<F>::ret_type> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::DefinePerSample ; (; std::string_view ; name, . F ; expression . ). inline . Define a new column that is updated when the input sample changes. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionA C++ callable that computes the new value of the defined column. . Returnsthe first node of the computation graph for which the new quantity is defined.; The signature of the callable passed as second argument should be T(unsigned int slot, const ROOT::RDF::RSampleInfo &id) where:; T is the type of the defined column; slot is a number in the range [0, nThreads) that is different for each processing thread. This can simplify the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; id is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is being processed (see the class docs for more information). DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being processed or to inject a callback into the event loop that is only called when the processing of a new sample starts rather than at every entry.; The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often. Example usage:; ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; df.DefinePerSample(""weightbysample"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; ROOT::RDF::RInterface::DefinePerSampleRInterface< Proxied, DS_t > DefinePerSample(std::string_view name, F expression)Define a new column that is updated when the input sample changes.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:54315,simpl,simplify,54315,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['simpl'],['simplify']
Usability,"ling::GetEnum"", ""DeclContext not found for %s .\n"", name);; 4854 }; 4855 }; 4856 } else {; 4857 // If it is a global enum.; 4858 // Could trigger deserialization of decls.; 4859 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 4860 possibleEnum = cling::utils::Lookup::Tag(&fInterpreter->getSema(), name);; 4861 }; 4862 if (possibleEnum && (possibleEnum != (clang::Decl*)-1); 4863 && isa<clang::EnumDecl>(possibleEnum)) {; 4864 return possibleEnum;; 4865 }; 4866 return nullptr;; 4867}; 4868 ; 4869////////////////////////////////////////////////////////////////////////////////; 4870/// Return pointer to cling DeclId for a global value; 4871 ; 4872TInterpreter::DeclId_t TCling::GetDeclId( const llvm::GlobalValue *gv ) const; 4873{; 4874 if (!gv) return nullptr;; 4875 ; 4876 llvm::StringRef mangled_name = gv->getName();; 4877 ; 4878 int err = 0;; 4879 char* demangled_name_c = TClassEdit::DemangleName(mangled_name.str().c_str(), err);; 4880 if (err) {; 4881 if (err == -2) {; 4882 // It might simply be an unmangled global name.; 4883 DeclId_t d;; 4884 TClingClassInfo gcl(GetInterpreterImpl());; 4885 d = gcl.GetDataMember(mangled_name.str().c_str());; 4886 return d;; 4887 }; 4888 return nullptr;; 4889 }; 4890 ; 4891 std::string scopename(demangled_name_c);; 4892 free(demangled_name_c);; 4893 ; 4894 //; 4895 // Separate out the class or namespace part of the; 4896 // function name.; 4897 //; 4898 std::string dataname;; 4899 ; 4900 if (!strncmp(scopename.c_str(), ""typeinfo for "", sizeof(""typeinfo for "")-1)) {; 4901 scopename.erase(0, sizeof(""typeinfo for "")-1);; 4902 } else if (!strncmp(scopename.c_str(), ""vtable for "", sizeof(""vtable for "")-1)) {; 4903 scopename.erase(0, sizeof(""vtable for "")-1);; 4904 } else {; 4905 // See if it is a function; 4906 std::string::size_type pos = scopename.rfind('(');; 4907 if (pos != std::string::npos) {; 4908 return nullptr;; 4909 }; 4910 // Separate the scope and member name; 4911 pos = scopename.rfind(':');; 4912 if (pos ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:190138,simpl,simply,190138,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['simpl'],['simply']
Usability,list specific TList derivation; TProofPerfAnalysis Set of tools to analyse the performance tree; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interface; TProofServLite PROOF-Lite Server Application Interface; TProofSuperMaster PROOF control class for making submasters; TProofVectorContainer<TProofDrawListOfGraphs::Point3D_t> Class describing a vector container; TProofVectorContainer<TProofDrawListOfPolyMarkers3D::Point4D_t> Class describing a vector container; TProtoClass Persistent TClass; TProtoClass::TProtoRealData Persistent version of TRealData; TPyArg Python morphing argument type; TPyDispatcher Python dispatcher class; TPyMultiGenFunction Python for Math::IMultiGenFunction equivalent; TPyMultiGradFunction Python for Math::IMultiGradFunction equivalent; TPyReturn Python morphing return object; TPySelector Python equivalent base class for PROOF; TPythia8 Interface class of Pythia8; TPythia8Decayer Particle Decayer using Pythia8; TPython Access to the python interpreter; TQApplication creates ROOT environment with the Qt windowing system; TQCanvasImp ABC describing Qt GUI independent main window; TQCanvasMenu interface to Qt based context sensitive popup menus; TQClass Class with connections; TQCommand encapsulates the information for undo/redo a single action.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:118649,undo,undo,118649,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,['undo'],['undo']
Usability,"lit; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; if splitlevel=0, the object is serialized in the branch buffer. ==> Case C. TBranch *branch = tree->Branch(branchname,clonesarray, bufsize, splitlevel); clonesarray is the address of a pointer to a TClonesArray.; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with only one branch). /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:4350,simpl,simple,4350,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['simpl'],['simple']
Usability,"litlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode. ; Reimplemented in TTreeSQL.; Definition at line 2074 of file TTree.cxx. ◆ BranchRef(). TBranch * TTree::BranchRef ; (; ). virtual . Build the optional branch supporting the TRefTable. ; This branch wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:93532,simpl,simply,93532,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simply']
Usability,"lity of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:3068,Clear,Clear,3068,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['Clear'],['Clear']
Usability,"ll be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. Returns the header, which is the title that appears at the top; of the legend.; ; . void InsertEntry(const char* objectName = """", const char* label = """", Option_t* option = ""lpf""). Add a new entry before the entry a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLegend.html:17155,Clear,Clear,17155,root/html532/TLegend.html,https://root.cern,https://root.cern/root/html532/TLegend.html,4,['Clear'],['Clear']
Usability,"ll(), the current value of the type/object will be saved. ; [in]bufsizeThe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:83892,simpl,simple,83892,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simple']
Usability,"ll.cxx;  draw.cxx;  draw_subpads.cxx;  draw_th1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxx;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:165788,simpl,simple,165788,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['simpl'],['simple']
Usability,llTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool TTreeCache::fIsLearning {true}. protected . ! true if cache is in learning mode ; Definition at line 54 of file TTreeCache.h. ◆ fIsManual. bool TTreeCache::fIsManual {false}. protected . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCach,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:54227,learn,learning,54227,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"llptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Types; typedef std::map< TEveElement *, Set_t >::iterator SelMap_i;  ; typedef std::map< TEveElement *, Set_t > SelMap_t;  ;  Protected Types inherited from TEveElement; enum  ECompoundSelectionColorBits { ;   kCSCBImplySelectAllChildren = (1ULL << ( 0 )); , kCSCBTakeAnyParentAsMaster = (1ULL << ( 1 )); , kCSCBApplyMainColorToAllChildren = (1ULL << ( 2 )); , kCSCBApplyMainColorToMatchingChildren = (1ULL << ( 3 )); , ;   kCSCBApplyMainTransparencyToAllChildren = (1ULL << ( 4 )); , kCSCBApplyMainTransparencyToMatchingChildren = (1ULL << ( 5 )). };  ; enum  EDestruct { kNone; , kStandard; , kAnnihilate; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; void DoElementSelect (SelMap_i entry);  Select element indicated by the entry and fill its implied-selected set. ;  ; void DoElementUnselect (SelMap_i entry);  Deselect element indicated by the entry and clear its implied-selected set. ;  ; void RecheckImpliedSet (SelMap_i smi);  Recalculate implied-selected state for given selection entry. ;  ;  Protected Member Functions inherited from TEveElement; virtual void AnnihilateRecursively ();  Protected member function called from TEveElement::Annihilate(). ;  ; virtual void PreDeleteElement ();  Externally assigned and controlled user data. ;  ; virtual void RemoveElementsInternal ();  Remove all elements. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; Bool_t fActive;  ; ImplySelect_foo fDecImpSelElement;  ; SelMap_t fImpliedSelected;  ; ImplySelect_foo fIncImpSelElement;  ; Bool_t fIsM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveSelection.html:35936,clear,clear,35936,doc/master/classTEveSelection.html,https://root.cern,https://root.cern/doc/master/classTEveSelection.html,1,['clear'],['clear']
Usability,load . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome ROOT 6 Analysis Workshop. Abstract; This tutorial will guide you through an example analysis with ROOT 6. It shows the recommended practices for analyzing data stored in ROOT TTrees - the most common format for High Energy Physics data.; It requires ROOT 6 as it uses several of its features.; . 0. Setting up ROOT ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/root-6-analysis-workshop-1.html:1914,guid,guide,1914,d/root-6-analysis-workshop-1.html,https://root.cern,https://root.cern/d/root-6-analysis-workshop-1.html,2,['guid'],['guide']
Usability,"locked(); Bool_tTQObject::AreSignalsBlocked() const; TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveSelection.html:2538,Clear,ClearProjectedList,2538,root/html532/TEveSelection.html,https://root.cern,https://root.cern/root/html532/TEveSelection.html,8,['Clear'],['ClearProjectedList']
Usability,"lockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 36592 2010-11-11 10:43:17Z ganis $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerSuperMaster.html:17172,feedback,feedback,17172,root/html528/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofPlayerSuperMaster.html,2,['feedback'],['feedback']
Usability,"lockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 39442 2011-05-27 09:13:25Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerSuperMaster.html:17440,feedback,feedback,17440,root/html530/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html530/TProofPlayerSuperMaster.html,2,['feedback'],['feedback']
Usability,"lockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 40186 2011-07-11 12:00:50Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerSuperMaster.html:17456,feedback,feedback,17456,root/html532/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html532/TProofPlayerSuperMaster.html,4,['feedback'],['feedback']
Usability,"lon () const;  ; Scalar_t GetMomentum () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ; Scalar_t GetRho () const;  ; std::vector< std::vector< Matrix_t > > & GetWeightUpdates ();  ; std::vector< Matrix_t > & GetWeightUpdatesAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; std::vector< std::vector< Matrix_t > > fBiasUpdates;  The accumulation of the past Biases for performing updates. ;  ; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; Scalar_t fMomentum;  The momentum used for training. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The sum of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The sum of the square of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:2432,learn,learningRate,2432,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['learn'],['learningRate']
Usability,"look like this:; ... // open the file; TFile *f = TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");; if (f == 0) {; // if we cannot open the file, print an error message and return immediatly; printf(""Error: cannot open http://root.cern/files/introtutorials/eventdata.root!\n"");; return;; }. // Create tyhe tree reader and its data containers; TTreeReader myReader(""EventTree"", f);. ... Getting the data out of the TTree; Fine, we have access to our tree. But now we need to get a handle on the data it stores, as shown below:; ... TTreeReaderValue<Int_t> eventSize(myReader, ""fEventSize"");. ... Loading TTree's Data; For the analysis example we need to access the events' size, which is accessible through the TTreeReaderValue eventSize. But the TTreeReader first needs to get told about which TTree entry to access. For that call TTreeReader::Next() in a loop. It will return false once it has reached the end of the TTree.; In the same loop, compute the total size of all events (simply add the current event size to the total size); ... // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Get the data from the current TTree entry by getting; // the value from the connected reader (eventSize):; totalSize += *eventSize;; }. Accessing the Analysis Result; At the end of the loop, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; ... Int_t sizeInMB = totalSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. Running the Macro; To run this macro, simply type .x AnalyzeTree.C and ROOT will execute it. If it finds an error it might be wise to quit ROOT (.q) and try again!; If, for any reason, you don't manage to get it working, yo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:4466,simpl,simply,4466,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['simpl'],['simply']
Usability,"lor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord, Bool_t xoySelectable, Bool_t xozSelectable, Bool_t yozSelectable); TGLPlotPainter's ctor. TGLPlotPainter(TGL5DDataSet* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLPlotPainter's ctor. TGLPlotPainter(TGLPlotCamera* camera); TGLPlotPainter's ctor. void Paint(); Draw lego/surf/whatever you can. void PrintPlot() const; Generate PS using gl2ps. Bool_t PlotSelected(Int_t px, Int_t py); Read color buffer content to find selected object. void SetPadColor(const TColor* color); Used in a pad. void SetFrameColor(const TColor* frameColor); Set plot's back box color. void InvalidateSelection(); Selection must be updated. const TColor * GetPadColor() const; Get pad color. void MoveSection(Int_t px, Int_t py); Create dynamic profile using selected plane. void DrawSections() const; Draw sections (if any). void ClearBuffers() const. // Clear buffer.; Float_t rgb[3] = {1.f, 1.f, 1.f};; if (const TColor *color = GetPadColor()); color->GetRGB(rgb[0], rgb[1], rgb[2]);; glClearColor(rgb[0], rgb[1], rgb[2], 1.);; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);. void DrawPaletteAxis() const; Draw. Palette. Axis. void SaveModelviewMatrix() const. void SaveProjectionMatrix() const. void RestoreModelviewMatrix() const. void RestoreProjectionMatrix() const. TGLPlotPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord, Bool_t xoySelectable, Bool_t xozSelectable, Bool_t yozSelectable); TGLPlotPainter(TH1 *hist, TGLPlotCamera *camera, TGLPlotCoordinates *coord, Int_t context,; Bool_t xoySelectable, Bool_t xozSelectable, Bool_t yozSelectable);; TGLPlotPainter(TGLPlotCamera *camera, Int_t context);. TGLPlotPainter(TGLPlotCamera* camera). const TGLPlotBox& RefBackBox() const; { return fBackBox; }. void SetPhysicalShapeColor(const Float_t* rgba). void InitGL() const. void DeInitGL() const. void DrawP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPlotPainter.html:4326,Clear,ClearBuffers,4326,root/html602/TGLPlotPainter.html,https://root.cern,https://root.cern/root/html602/TGLPlotPainter.html,2,['Clear'],['ClearBuffers']
Usability,"lor; Style_tTAttFill::fFillStylefill area style; TGeoPatternFinder*TGeoVolume::fFinderfinder object for divisions; UInt_tTGeoAtt::fGeoAttoption flags; TGeoManager*TGeoVolume::fGeoManager! pointer to TGeoManager owning this volume; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TGeoMedium*TGeoVolume::fMediumtracking medium; TStringTNamed::fNameobject identifier; TObjArray*TGeoVolume::fNodesarray of nodes inside this volume; Int_tTGeoVolume::fNtotaltotal number of physical nodes; Int_tTGeoVolume::fNumbervolume serial number in the list of volumes; TStringTGeoVolume::fOption! option - if any; TGeoShape*TGeoVolume::fShapeshape; vector<ThreadData_t*>fThreadData! Thread specific data vector; Int_tfThreadSize! Thread vector size; TStringTNamed::fTitleobject title; TGeoVoxelFinder*TGeoVolume::fVoxelsfinder object for bounding boxes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. Int_t GetCurrentNodeIndex() const. Int_t GetNextNodeIndex() const. void SetCurrentNodeIndex(Int_t index). void SetNextNodeIndex(Int_t index). TGeoVolumeAssembly(); Default constructor. TGeoVolumeAssembly(const char* name); Constructor. Just the name has to be provided. Assemblies does not have their own; shape or medium. ~TGeoVolumeAssembly(); Destructor. The assembly is owner of its ""shape"". void AddNode(const TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); Add a component to the assembly. void AddNodeOverlap(const TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option); Add an overlapping node - not allowed for assemblies. TGeoVolume * CloneVolume() const; Clone this volume.; build a volume with same name, shape and medium. TGeoVolume * Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Division makes no sense for assemblies. TGeoVolume * Divid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoVolumeAssembly.html:23507,Clear,ClearThreadData,23507,root/html532/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html532/TGeoVolumeAssembly.html,1,['Clear'],['ClearThreadData']
Usability,"lorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualX::BeginModalSessionFor(Window_t window); virtual voidTGX11::Bell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidTGX11::ChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidTGX11::ChangeGC(GContext_t gc, GCValues_t* gval); virtual voidTGX11::ChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidTGX11::ChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidTGX11::ChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tTGX11::CheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGX11::ClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGX11::ClearWindow(); virtual voidTGX11::ClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTGX11::CloseDisplay(); virtual voidTGX11::ClosePixmap(); virtual voidTGX11::CloseWindow(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGX11::ConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidTGX11::ConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTGX11::CopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidTGX11::CopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidTGX11::CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual Pixmap_tTGX11::CreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height); virtual Cursor_tTGX11::CreateCursor(ECursor cursor); virtual GContext_tTGX11::CreateGC(Drawable_t id, GCValues_t* gval); virtual Drawable_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11TTF.html:1970,Clear,ClearWindow,1970,root/html534/TGX11TTF.html,https://root.cern,https://root.cern/root/html534/TGX11TTF.html,3,['Clear'],['ClearWindow']
Usability,"lot a PDF in disjunct ranges, and get normalisation right. ;  ; file  rf212_plottingInRanges_blinding.py;   Plot a PDF in disjunct ranges, and get normalisation right. ;  ; file  rf301_composition.C;   Multidimensional models: multi-dimensional pdfs through composition e.g. ;  ; file  rf301_composition.py;   Multidimensional models: multi-dimensional pdfs through composition, e.g. ;  ; file  rf302_utilfuncs.C;   Multidimensional models: utility functions classes available for use in tailoring of composite (multidimensional) pdfs ;  ; file  rf302_utilfuncs.py;   Multidimensional models: utility functions classes available for use in tailoring of composite (multidimensional) pdfs ;  ; file  rf303_conditional.C;   Multidimensional models: use of tailored pdf as conditional pdfs.s ;  ; file  rf303_conditional.py;   'MULTIDIMENSIONAL MODELS' RooFit tutorial macro #303 Use of tailored p.d.f as conditional p.d.fs.s ;  ; file  rf304_uncorrprod.C;   Multidimensional models: simple uncorrelated multi-dimensional pdfs ;  ; file  rf304_uncorrprod.py;   Multidimensional models: simple uncorrelated multi-dimensional pdfs ;  ; file  rf305_condcorrprod.C;   Multidimensional models: multi-dimensional pdfs with conditional pdfs in product ;  ; file  rf305_condcorrprod.py;   Multidimensional models: multi-dimensional pdfs with conditional pdfs in product ;  ; file  rf306_condpereventerrors.C;   Multidimensional models: conditional pdf with per-event errors ;  ; file  rf306_condpereventerrors.py;   Multidimensional models: complete example with use of conditional pdf with per-event errors ;  ; file  rf307_fullpereventerrors.C;   Multidimensional models: full pdf with per-event errors ;  ; file  rf307_fullpereventerrors.py;   Multidimensional models: usage of full pdf with per-event errors ;  ; file  rf308_normintegration2d.C;   Multidimensional models: normalization and integration of pdfs, construction of cumulative distribution functions from pdfs in two dimensions ;  ; file  rf308_no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:6969,simpl,simple,6969,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['simpl'],['simple']
Usability,"lovAccurate. ROOT::Math::VavilovAccurateCdf. ROOT::Math::VavilovAccuratePdf. ROOT::Math::VavilovAccurateQuantile. ROOT::Math::VavilovFast. ROOT::Math::VirtualIntegratorMultiDim←. ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::GSLMCIntegrator. ROOT::Math::VirtualIntegratorOneDim←. ROOT::Math::GSLIntegrator. ROOT::Math::GaussIntegrator; ←. ROOT::Math::GaussLegendreIntegrator. ROOT::Math::WrappedMultiTF1. ROOT::Math::WrappedTF1. ROOT::Minuit2::CombinedMinimizer. ROOT::Minuit2::FCNBase←. ROOT::Minuit2::FCNGradientBase; ←. TFcnAdapter. ROOT::Minuit2::FumiliFCNBase. ROOT::Minuit2::FCNGradientBase←. TFcnAdapter. ROOT::Minuit2::FumiliFCNBase. ROOT::Minuit2::FumiliMinimizer. ROOT::Minuit2::Minuit2Minimizer. ROOT::Minuit2::MnFumiliMinimize. ROOT::Minuit2::MnMigrad. ROOT::Minuit2::MnMinimize. ROOT::Minuit2::MnScan. ROOT::Minuit2::MnSimplex. ROOT::Minuit2::ModularFunctionMinimizer←. ROOT::Minuit2::CombinedMinimizer. ROOT::Minuit2::FumiliMinimizer. ROOT::Minuit2::ScanMinimizer. ROOT::Minuit2::SimplexMinimizer. ROOT::Minuit2::VariableMetricMinimizer. ROOT::Minuit2::ScanMinimizer. ROOT::Minuit2::SimplexMinimizer. ROOT::Minuit2::VariableMetricMinimizer. ROOT::TArrayProxy<ROOT::TArrayType<Long64_t,0> >. ROOT::TArrayProxy<ROOT::TArrayType<ULong64_t,0> >. ROOT::TArrayProxy<ROOT::TArrayType<bool,0> >. ROOT::TArrayProxy<ROOT::TArrayType<char,0> >. ROOT::TArrayProxy<ROOT::TArrayType<double,0> >. ROOT::TArrayProxy<ROOT::TArrayType<float,0> >. ROOT::TArrayProxy<ROOT::TArrayType<int,0> >. ROOT::TArrayProxy<ROOT::TArrayType<long,0> >. ROOT::TArrayProxy<ROOT::TArrayType<short,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned char,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned int,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned long,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned short,0> >. ROOT::TBranchProxyClassDescriptor. ROOT::TBranchProxyDescriptor. ROOT::TClaArrayProxy<ROOT::TArrayType<Long64_t,0> >. ROOT::TClaArrayProxy<ROOT::TArrayType<ULong64_t,0> >. ROOT::TClaArrayProxy<R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassHierarchy.html:4930,Simpl,SimplexMinimizer,4930,root/html534/ClassHierarchy.html,https://root.cern,https://root.cern/root/html534/ClassHierarchy.html,1,['Simpl'],['SimplexMinimizer']
Usability,"lper-cols). |; 106| Filter() | Filter rows based on user-defined conditions. |; 107| FilterAvailable() | Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. |; 108| FilterMissing() | Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. |; 109| Range() | Filter rows based on entry number (single-thread only). |; 110| Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; 111| RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; 112| RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; 113| Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |; 114 ; 115 ; 116### Actions; 117Actions aggregate data into a result. Each one is described in more detail in the reference guide.; 118 ; 119In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; 120 ; 121Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; 122produce many different results in one event loop. Instant actions trigger the event loop instantly.; 123 ; 124 ; 125| **Lazy action** | **Description** |; 126|------------------|-----------------|; 127| Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; 128| Book() | Book execution of a custom action using a user-defined helper object. |; 129| Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; 130| Count() | Return the number of events processed. Useful e.g. to get a quick count of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:7142,guid,guide,7142,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['guid'],['guide']
Usability,"lrecord->AddText(""fSeekKey: Pointer to object on file"");; lrecord->AddText(""fSeekPdir: Pointer to directory on file"");; lrecord->AddText(""fClassName: class name of the object"");; lrecord->AddText(""fName: name of the object"");; lrecord->AddText(""fTitle: title of the object"");; ; c1->Update();; c1->Print(""file.png"");; }; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextAnglevirtual void SetTextAngle(Float_t tangle=0)Set the text angle.Definition TAttText.h:43; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLabel.cxx:88; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::AddLinevirtual TLine * AddLine(Double_t x1=0, Double_t y1=0, Double_t x2=0, Double_t y2=0)Add a new graphics line to this pavetext.Definition TPaveText.cxx:177; TPaveText::Drawvoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/file_8C.html:5260,simpl,simple,5260,doc/master/file_8C.html,https://root.cern,https://root.cern/doc/master/file_8C.html,1,['simpl'],['simple']
Usability,"ls with default value should be shown.; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfUIDoubleRepRepresent UI parts with real values.; Double_tfUIcUI representation calculated as: d = fUIf*i + fUIc; Double_tfUIfUI representation calculated as: d = fUIf*i + fUIc; Color_tfUnderColorUnderflow color; UChar_tfUnderRGBA[4]; Int_tfUnderflowAction; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TEveRGBAPalette*fgDefaultPalette. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveRGBAPalette(); Constructor. TEveRGBAPalette(Int_t min, Int_t max, Bool_t interp = kTRUE, Bool_t showdef = kTRUE, Bool_t fixcolrng = kFALSE); Constructor. ~TEveRGBAPalette(); Destructor. void SetupColor(Int_t val, UChar_t* pix) const; Set RGBA color 'pixel' for signal-value 'val'. void SetupColorArray() const; Construct internal color array that maps signal value to RGBA color. void ClearColorArray(); Clear internal color array. void SetLimits(Int_t low, Int_t high); Set low/high limits on signal value. Current min/max values are; clamped into the new limits. void SetLimitsScaleMinMax(Int_t low, Int_t high); Set low/high limits and rescale current min/max values. void SetMin(Int_t min); Set current min value. void SetMax(Int_t max); Set current max value. void SetMinMax(Int_t min, Int_t max); Set current min/max values. void SetUIDoubleRep(Bool_t b, Double_t f = 1, Double_t c = 0); Set flag determining whether GUI editor and overlays should show limits; and axis values as real values with mapping from integer value i to real; value d as: d = f*i + fc. void SetInterpolate(Bool_t b); Set interpolation flag. This determines how colors from ROOT's; palette are mapped into RGBA values for given signal. void SetFixColorRange(Bool_t v); Set flag specifying how the palette is mapped to signal values:; true - LowLimit -> HighLimit; false - MinValue -> MaxValue. void SetDefaultColor(Color_t ci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveRGBAPalette.html:12725,Clear,ClearColorArray,12725,root/html534/TEveRGBAPalette.html,https://root.cern,https://root.cern/root/html534/TEveRGBAPalette.html,6,['Clear'],"['Clear', 'ClearColorArray']"
Usability,"ls. Detailed Description; Write and read STL vectors in a tree. . ; #include <vector>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TCanvas.h""; #include ""TFrame.h""; #include ""TH1F.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; #include ""TSystem.h""; ; void write(); {; ; TFile *f = TFile::Open(""hvector.root"",""RECREATE"");; ; if (!f) { return; }; ; // Create one histograms; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; hpx->SetFillColor(48);; ; std::vector<float> vpx;; std::vector<float> vpy;; std::vector<float> vpz;; std::vector<float> vrand;; ; // Create a TTree; TTree *t = new TTree(""tvec"",""Tree with vectors"");; t->Branch(""vpx"",&vpx);; t->Branch(""vpy"",&vpy);; t->Branch(""vpz"",&vpz);; t->Branch(""vrand"",&vrand);; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; gRandom->SetSeed();; const Int_t kUPDATE = 1000;; for (Int_t i = 0; i < 25000; i++) {; Int_t npx = (Int_t)(gRandom->Rndm(1)*15);; ; vpx.clear();; vpy.clear();; vpz.clear();; vrand.clear();; ; for (Int_t j = 0; j < npx; ++j) {; ; Float_t px,py,pz;; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ; hpx->Fill(px);; ; vpx.emplace_back(px);; vpy.emplace_back(py);; vpz.emplace_back(pz);; vrand.emplace_back(random);; ; }; if (i && (i%kUPDATE) == 0) {; if (i == kUPDATE) hpx->Draw();; c1->Modified();; c1->Update();; if (gSystem->ProcessEvents()); break;; }; t->Fill();; }; f->Write();; ; delete f;; }; ; ; void read(); {; ; TFile *f = TFile::Open(""hvector.root"",""READ"");; ; if (!f) { return; }; ; TTree *t; f->GetObject(""tvec"",t);; ; std::vector<float> *vpx = nullptr;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; const Int_t kUPDATE = 1000;; ; TBranch *bvpx = nullptr;; t->SetBranchAddress(""vpx"",&vpx,&bvpx);; ; ; // Create one histograms; TH1F *h = new TH1F(""h"",""This is the px distribution"",100,-4,4);; h->SetFillColor(48);; ; for (Int_t i = 0; i < ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hvector_8C.html:1171,clear,clear,1171,doc/master/hvector_8C.html,https://root.cern,https://root.cern/doc/master/hvector_8C.html,1,['clear'],['clear']
Usability,"ls. Returns the previous block status. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void SetupFeedback () override;  Setup feedback. ;  ; void StopFeedback () override;  Stop feedback. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ; void MergeOutput (Bool_t savememvalues=kFALSE) override;  Merge output (may not be used in this class). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSlave.html:18903,feedback,feedback,18903,doc/master/classTProofPlayerSlave.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSlave.html,1,['feedback'],['feedback']
Usability,"ls::TNormalizedCtxt &normCtxt); 8742{; 8743 const clang::TypeDecl* td = llvm::dyn_cast<clang::TypeDecl>(decl->getDeclContext());; 8744 if (!td) return;; 8745 ; 8746 clang::QualType qualType(td->getTypeForDecl(),0);; 8747 ROOT::TMetaUtils::GetNormalizedName(name, qualType, interp, normCtxt);; 8748 unsigned int level = 0;; 8749 for(size_t cursor = name.length()-1; cursor != 0; --cursor) {; 8750 if (name[cursor] == '>') ++level;; 8751 else if (name[cursor] == '<' && level) --level;; 8752 else if (level == 0 && name[cursor] == ':') {; 8753 name.erase(0,cursor+1);; 8754 break;; 8755 }; 8756 }; 8757}; 8758 ; 8759////////////////////////////////////////////////////////////////////////////////; 8760 ; 8761void TCling::GetFunctionName(const clang::Decl *decl, std::string &output) const; 8762{; 8763 output.clear();; 8764 ; 8765 const auto *FD = llvm::dyn_cast<clang::FunctionDecl>(decl);; 8766 if (const auto *USD = llvm::dyn_cast<clang::UsingShadowDecl>(decl)) {; 8767 FD = llvm::dyn_cast<clang::FunctionDecl>(USD->getTargetDecl());; 8768 }; 8769 if (!FD) {; 8770 Error(""GetFunctionName"", ""NULL Decl!"");; 8771 return;; 8772 }; 8773 ; 8774 // For using-decls, show ""Derived"", not ""Base"", i.e. use the; 8775 // name of the decl context of the UsingShadowDecl (aka `decl`); 8776 // not the name of FD's decl context.; 8777 if (llvm::isa<clang::CXXConstructorDecl>(FD)); 8778 {; 8779 ConstructorName(output, decl, *fInterpreter, *fNormalizedCtxt);; 8780 ; 8781 } else if (llvm::isa<clang::CXXDestructorDecl>(decl)); 8782 {; 8783 ConstructorName(output, decl, *fInterpreter, *fNormalizedCtxt);; 8784 output.insert(output.begin(), '~');; 8785 } else {; 8786 llvm::raw_string_ostream stream(output);; 8787 auto printPolicy = decl->getASTContext().getPrintingPolicy();; 8788 // Don't trigger fopen of the source file to count lines:; 8789 printPolicy.AnonymousTagLocations = false;; 8790 FD->getNameForDiagnostic(stream, printPolicy, /*Qualified=*/false);; 8791 }; 8792}; 8793 ; 8794//////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:341066,clear,clear,341066,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['clear'],['clear']
Usability,"lse, unless you can highlight selected object in pad. void PushTopLevelSelectable(TObject* top); Does nothing, unless you implement your own picking.; When complex object containing sub-objects (which can be picked); is painted in a pad, this ""top-level"" object is pushed into; the selectables stack. void PushSelectableObject(TObject* obj); Does nothing, unless you implement your own picking.; ""Complete"" object, or part of complex object, which; can be picked. void PopTopLevelSelectable(); Does nothing, unless you implement your own picking.; Remove top level selectable and all its' children. void * GetSender(); { return this; }. TVirtualPad(). void AbsCoordinates(Bool_t set). Double_t AbsPixeltoX(Int_t px). Double_t AbsPixeltoY(Int_t py). void AddExec(const char* name, const char* command). TLegend * BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67000000000000004, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"). TVirtualPad* cd(Int_t subpadnumber = 0). void Clear(Option_t* option = """"). void Close(Option_t* option = """"). void CopyPixmap(). void CopyPixmaps(). void DeleteExec(const char* name). void Divide(Int_t nx = 1, Int_t ny = 1, Float_t xmargin = 0.01, Float_t ymargin = 0.01, Int_t color = 0). void Draw(Option_t* option = """"). void DrawClassObject(const TObject* obj, Option_t* option = """"). TH1F * DrawFrame(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char* title = """"). void ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis). Short_t GetBorderMode() const. Short_t GetBorderSize() const. Int_t GetCanvasID() const. TCanvasImp * GetCanvasImp() const. TCanvas * GetCanvas() const. TVirtualPad * GetVirtCanvas() const. Int_t GetEvent() const. Int_t GetEventX() const. Int_t GetEventY() const. TFrame * GetFrame(). Color_t GetHighLightColor() const. Int_t GetNumber() const. void GetRange(Double_t& x1, Double_t& y1, Double_t& x2, Double_t& y2). void GetRangeAxis(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPad.html:23976,Clear,Clear,23976,root/html602/TVirtualPad.html,https://root.cern,https://root.cern/root/html602/TVirtualPad.html,2,['Clear'],['Clear']
Usability,"lso minimizer type; 121 // algorithm is after "" / ""; 122 const std::string & minname = result.MinimizerType();; 123 size_t pos = minname.find("" / "");; 124 if (pos != std::string::npos) {; 125 std::string minimType = minname.substr(0,pos);; 126 std::string algoType = minname.substr(pos+3,minname.length() );; 127 SetMinimizer(minimType.c_str(), algoType.c_str() );; 128 }; 129 else {; 130 SetMinimizer(minname.c_str());; 131 }; 132}; 133 ; 134 ; 135void FitConfig::SetParamsSettings(unsigned int npar, const double *params, const double * vstep ) {; 136 // initialize FitConfig from given parameter values and step sizes; 137 // if npar different than existing one - clear old one and create new ones; 138 if (params == nullptr) {; 139 fSettings = std::vector<ParameterSettings>(npar);; 140 return;; 141 }; 142 // if a vector of parameters is given and parameters are not existing or are of different size; 143 bool createNew = false;; 144 if (npar != fSettings.size() ) {; 145 fSettings.clear();; 146 fSettings.reserve(npar);; 147 createNew = true;; 148 }; 149 unsigned int i = 0;; 150 const double * end = params+npar;; 151 for (const double * ipar = params; ipar != end; ++ipar) {; 152 double val = *ipar;; 153 double step = 0;; 154 if (vstep == nullptr) {; 155 step = 0.3*std::fabs(val); // step size is 30% of par value; 156 //double step = 2.0*std::fabs(val); // step size is 30% of par value; 157 if (val == 0) step = 0.3;; 158 }; 159 else; 160 step = vstep[i];; 161 ; 162 if (createNew); 163 fSettings.push_back( ParameterSettings(""Par_"" + ROOT::Math::Util::ToString(i), val, step ) );; 164 else {; 165 fSettings[i].SetValue(val);; 166 fSettings[i].SetStepSize(step);; 167 }; 168 ; 169 i++;; 170 }; 171}; 172 ; 173ROOT::Math::Minimizer * FitConfig::CreateMinimizer() {; 174 // create minimizer according to the chosen configuration using the; 175 // plug-in manager; 176 ; 177 // in case of empty string usesd default values; 178 if (fMinimizerOpts.MinimizerType().empty()); 179 fMinimizerOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8cxx_source.html:4544,clear,clear,4544,doc/master/FitConfig_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html,1,['clear'],['clear']
Usability,"lso possible with indexed friend trees (see below).; To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame with the main tree:; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");; ; RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above, or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree).; NoteA common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original one: rows will be mismatched.; Indexed friend trees provide a way to perform simple joins of multiple trees over a common column. When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the ""index"" columns have a value identical to the one in the main one. For example, in Python:; main_tree = ...; aux_tree = ...; ; # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""); ; mainTree.AddFriend(aux_tree); ; df = ROOT.RDataFrame(mainTree); RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats.; RDataFrame calls into concrete RDataSource implementations to retrieve information abou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:71327,simpl,simple,71327,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simple']
Usability,"lt and Minuit2Minimizer::Hesse for the hesseResult.; If other minimizers are used see their specific documentation for the status code returned.; For example in the case of Fumili, for the status returned see TFumili::Minimize. Excluding points. Use TF1::RejectPoint inside your fitting function to exclude points; within a certain range from the fit. Example:; Double_t fline(Double_t *x, Double_t *par); {; if (x[0] > 2.5 && x[0] < 3.5) {; TF1::RejectPoint();; return 0;; }; return par[0] + par[1]*x[0];; }. void exclude() {; TF1 *f1 = new TF1(""f1"", ""[0] +[1]*x +gaus(2)"", 0, 5);; f1->SetParameters(6, -1,5, 3, 0.2);; TH1F *h = new TH1F(""h"", ""background + signal"", 100, 0, 5);; h->FillRandom(""f1"", 2000);; TF1 *fline = new TF1(""fline"", fline, 0, 5, 2);; fline->SetParameters(2, -1);; h->Fit(""fline"", ""l"");; }. Warning when using the option ""0"". When selecting the option ""0"", the fitted function is added to; the list of functions of the histogram, but it is not drawn.; You can undo what you disabled in the following way:; h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; h.Draw(); function is not drawn; const Int_t kNotDraw = 1<<9;; h.GetFunction(""myFunction"")->ResetBit(kNotDraw);; h.Draw(); // function is visible again. Access to the Minimizer information during fitting. This function calls, the ROOT::Fit::FitObject function implemented in HFitImpl.cxx; which uses the ROOT::Fit::Fitter class. The Fitter class creates the objective fuction; (e.g. chi2 or likelihood) and uses an implementation of the Minimizer interface for minimizing; the function.; The default minimizer is Minuit (class TMinuitMinimizer which calls TMinuit).; The default can be set in the resource file in etc/system.rootrc. For example; Root.Fitter: Minuit2; A different fitter can also be set via ROOT::Math::MinimizerOptions::SetDefaultMinimizer; (or TVirtualFitter::SetDefaultFitter).; For example ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");; will set the usdage of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:80299,undo,undo,80299,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,10,['undo'],['undo']
Usability,"lt; At the end of the loop, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; ... Int_t sizeInMB = totalSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. Running the Macro; To run this macro, simply type .x AnalyzeTree.C and ROOT will execute it. If it finds an error it might be wise to quit ROOT (.q) and try again!; If, for any reason, you don't manage to get it working, you can download a working macro file here: CountEvents.C; Here again, if you are using ROOT via ssh, you have to download the file with wget from your remote directory:; wget http://root-mirror.github.io/training/intro/CountEvents.C; . ‹ TTree and Its Data; up; Histogramming ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:6319,guid,guidelines,6319,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['guid'],['guidelines']
Usability,"ltSelectedBackground; static TList*TEveCompositeFrame::fgFrameList; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static const TStringTEveCompositeFrame::fgkEmptyFrameName; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveCompositeFrameInMainFrame(TGCompositeFrame* parent, TEveWindow* eve_parent, TGMainFrame* mf); Constructor. ~TEveCompositeFrameInMainFrame(); Destructor. void WindowNameChanged(const TString& name); Update widgets using window's name or title. void Destroy(); Virtual function called from eve side when the frame should be; destroyed. This means we expect that fEveWindow is null. We simply call CloseWindow() on the main-frame which will in; turn generate the ""CloseWindow()"" signal.; This is then handled in MainFrameClosed(). void SetOriginalSlotAndContainer(TEveWindow* slot, TEveWindow* container); Set the container where to return the contained window on destruction. void SomeWindowClosed(TEveWindow* w); Slot called when a window is closed ... we check that this was; not our original container. void MainFrameClosed(); Slot for main-frame's ""CloseWindow()"" signal.; If an eve window is still present, it will be put into:; - original-container, if it is set;; - into window-managers default-container. TEveCompositeFrame& operator=(const TEveCompositeFrameInMainFrame& ). TEveCompositeFrameInMainFrame(const TEveCompositeFrameInMainFrame& ). TEveWindow* GetOriginalSlot() const; { return fOriginalSlot; }. TEveWindow* GetOriginalContainer() const; { return fOriginalContainer; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCompositeFrameInMainFrame.html:21772,simpl,simply,21772,root/html602/TEveCompositeFrameInMainFrame.html,https://root.cern,https://root.cern/root/html602/TEveCompositeFrameInMainFrame.html,4,['simpl'],['simply']
Usability,"lude instead of ROOTINCDIR ROOT-7537. Interpreter. Fix redirection ROOT-7053; Take the language and target options from the PCH ROOT-7478 ROOT-6966; Properly recover from a template instantiation failure when looking up a class in the interpreter ROOT-7462; Do not clear pending instantiations upon unloading; fixes missing symbols due to missing function bodies ROOT-7586; Speed up significantly cling’s findType and remove its memory cost in most cases.; Make sure object declared on the interpreter stack are deleted at the end of the process ROOT-7673; Resolve issues with error recovery when the transaction includes template instantiation.; Fix handling of argument that negative integers in TClingCallFunc ROOT-7684. I/O. Fix memory leak in handling of I/O customization rules ROOT-7683; Set CheckSum of StreamerInfo of user classes that have a collection proxy. Tree. Fix ROOT-6885 which affects very large TChain with friend trees.; Fix ROOT-7423 which can stop the TTreeCache from stopping the learning phase when asynchronous prefetching is enabled. TTreeReader. Fix reading of data members of type BasicType[42]; Fix support for large file ROOT-7652. Geom. Fix missing OCC header file for the version ROOT-7536. Bugs. [ROOT-6419] - ROOT-6.00.01 fails to build with geocad support due to conficting function definition; [ROOT-6966] - MacOS 10.9 build cannot run on 10.10; [ROOT-7342] - Conflicting definitions of Printf function; [ROOT-7402] - Fix the inconsistency in ROOT_LINKER_LIBRARY() macro between 5 and 6 versions; [ROOT-7423] - Activating prefetching makes TTree iteration slower when reading through HTTP; [ROOT-7475] - TTreeReader is retrieving the containers properly, but when used in a for loop, the elements get somehow “overridden”; [ROOT-7478] - Generating PCH fails with CXX flags with spaces; [ROOT-7491] - TLatex display issues with root 6.04; [ROOT-7509] - Build Failure on FreeBSD 10.1; [ROOT-7515] - C++14 needs GCC 5.1; [ROOT-7536] - Missing include file; [ROOT-753",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:29960,learn,learning,29960,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['learn'],['learning']
Usability,"lue when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:134469,learn,learning,134469,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['learn'],['learning']
Usability,"lue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:4296,clear,clearValueAndShapeDirty,4296,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"lue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:3396,clear,clearValueAndShapeDirty,3396,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"lue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:2997,clear,clearValueAndShapeDirty,2997,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,8,['clear'],['clearValueAndShapeDirty']
Usability,"lue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignmemt, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interessting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLegend.html:2592,simpl,simply,2592,root/html534/TLegend.html,https://root.cern,https://root.cern/root/html534/TLegend.html,4,['simpl'],['simply']
Usability,"lue. void SetParameter(const char* par, Int_t value); Set an input list parameter. void SetParameter(const char* par, Long_t value); Set an input list parameter. void SetParameter(const char* par, Long64_t value); Set an input list parameter. void SetParameter(const char* par, Double_t value); Set an input list parameter. TObject * GetParameter(const char* par) const; Get specified parameter. A parameter set via SetParameter() is either; a TParameter or a TNamed or 0 in case par is not defined. void DeleteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; Default is remote. Socket is needed in case a slave player ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:74687,feedback,feedback,74687,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,18,"['Clear', 'feedback']","['Clear', 'ClearFeedback', 'feedback']"
Usability,"lue=true) const;  Add a subfield to the provided entry. ;  ; void EnsureNotBare () const;  Throws an RException if fDefaultEntry is nullptr. ;  ; void EnsureNotFrozen () const;  Throws an RException if fFrozen is true. ;  ; void EnsureValidFieldName (std::string_view fieldName);  Checks that user-provided field names are valid in the context of this NTuple model. ;  ; RFieldBase * FindField (std::string_view fieldName) const;  The field name can be a top-level field or a nested field. Returns nullptr if the field is not in the model. ;  . Private Attributes; std::unique_ptr< REntry > fDefaultEntry;  Contains field values corresponding to the created top-level fields, as well as registered subfields. ;  ; std::string fDescription;  Free text set by the user. ;  ; std::unordered_set< std::string > fFieldNames;  Keeps track of which field names are taken, including projected field names. ;  ; std::unique_ptr< RFieldZero > fFieldZero;  Hierarchy of fields consisting of simple types and collections (sub trees) ;  ; bool fIsFrozen = false;  Changed by Freeze() / Unfreeze() and by the RUpdater. ;  ; std::uint64_t fModelId = 0;  Every model has a unique ID to distinguish it from other models. ;  ; std::unique_ptr< Internal::RProjectedFields > fProjectedFields;  The set of projected top-level fields. ;  ; std::unordered_set< std::string > fRegisteredSubfields;  Keeps track of which subfields have been registered to be included in entries belonging to this model. ;  ; std::uint64_t fSchemaId = 0;  Models have a separate schema ID to remember that the clone of a frozen model still has the same schema. ;  . Friends; RFieldZero & Internal::GetFieldZeroOfModel (RNTupleModel &);  ; Internal::RProjectedFields & Internal::GetProjectedFieldsOfModel (RNTupleModel &);  . #include <ROOT/RNTupleModel.hxx>; Member Typedef Documentation. ◆ FieldMappingFunc_t. using ROOT::Experimental::RNTupleModel::FieldMappingFunc_t = std::function<std::string(const std::string &)>. User provided function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html:5495,simpl,simple,5495,doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,1,['simpl'],['simple']
Usability,"lues; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassName(ostream& os) const; Print class name of fit result. void printArgs(ostream& os) const; Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFitResult.html:14716,simpl,simple,14716,root/html526/RooFitResult.html,https://root.cern,https://root.cern/root/html526/RooFitResult.html,3,['simpl'],['simple']
Usability,"lume.cxx. ◆ ResetTransparency(). void TGeoVolume::ResetTransparency ; (; Char_t ; transparency = -1). inline . Definition at line 383 of file TGeoVolume.h. ◆ SaveAs(). void TGeoVolume::SaveAs ; (; const char * ; filename = """", . Option_t * ; option = """" . ); const. overridevirtual . Save geometry having this as top volume as a C++ macro. ; Reimplemented from TObject.; Definition at line 1447 of file TGeoVolume.cxx. ◆ SavePrimitive(). void TGeoVolume::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Definition at line 1535 of file TGeoVolume.cxx. ◆ SelectVolume(). void TGeoVolume::SelectVolume ; (; Bool_t ; clear = kFALSE). Select this volume as matching an arbitrary criteria. ; The volume is added to a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need to be reset at the end by calling the method with CLEAR=true. This will also clear the list. ; Definition at line 2325 of file TGeoVolume.cxx. ◆ SetActiveDaughters(). void TGeoVolume::SetActiveDaughters ; (; Bool_t ; flag = kTRUE). inline . Definition at line 213 of file TGeoVolume.h. ◆ SetActivity(). void TGeoVolume::SetActivity ; (; Bool_t ; flag = kTRUE). inline . Definition at line 212 of file TGeoVolume.h. ◆ SetAdded(). void TGeoVolume::SetAdded ; (; ). inline . Definition at line 215 of file TGeoVolume.h. ◆ SetAsTopVolume(). void TGeoVolume::SetAsTopVolume ; (; ). Set this volume as the TOP one (the whole geometry starts from here) ; Definition at line 2051 of file TGeoVolume.cxx. ◆ SetAttVisibility(). void TGeoVolume::SetAttVisibility ; (; Bool_t ; vis). inline . Definition at line 233 of file TGeoVolume.h. ◆ SetCurrentPoint(). void TGeoVolume::SetCurrentPoint ; (; Double_t ; x, . Double_t ; y, . Double_t ; z . ). Set the current tracking point. ; Definition at line 2059 of file TGeoVolume.cxx. ◆ SetCylVoxels(). void TGeoVolume::SetCylVoxels ; (; Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:63595,clear,clear,63595,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['clear'],['clear']
Usability,"lumn_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Definition at line 2806 of file OptionParser.h. ◆ printUsage() [3/5]. template<typename Function , typename Stream > . void ROOT::option::printUsage ; (; Function * ; prn, . Stream * ; stream, . const Descriptor ; usage[], . int ; width = 80, . int ; last_column_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Definition at line 2830 of file OptionParser.h. ◆ printUsage() [4/5]. template<typename OStream > . void ROOT::option::printUsage ; (; OStream & ; prn, . const Descriptor ; usage[], . int ; width = 80, . int ; last_column_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Outputs a nicely formatted usage string with support for multi-column formatting and line-wrapping. ; printUsage() takes the help texts of a Descriptor[] array and formats them into a usage message, wrapping lines to achieve the desired output width.; Table formatting:; Aside from plain strings which are simply line-wrapped, the usage may contain tables. Tables are used to align elements in the output.; // Without a table. The explanatory texts are not aligned.; -c, --create |Creates something.; -k, --kill |Destroys something.; ; // With table formatting. The explanatory texts are aligned.; -c, --create |Creates something.; -k, --kill |Destroys something.; c#define c(i)Definition RSha256.hxx:101; Table formatting removes the need to pad help texts manually with spaces to achieve alignment. To create a table, simply insert \t (tab) characters to separate the cells within a row.; const option::Descriptor usage[] = {; {..., ""-c, --create \tCreates something."" },; {..., ""-k, --kill \tDestroys something."" }, ...; Note that you must include the minimum amount of space desired between cells yourself. Table formatting will insert further spaces as needed to achieve alignment.; You can insert line breaks within cells by using \v (vertical tab).; const option::Descriptor usage[] = {; {..., ""-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1option.html:6468,simpl,simply,6468,doc/master/namespaceROOT_1_1option.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1option.html,1,['simpl'],['simply']
Usability,"lumn_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Definition at line 2806 of file OptionParser.h. ◆ printUsage() [3/5]. template<typename Function , typename Stream > . void ROOT::option::printUsage ; (; Function * ; prn, . Stream * ; stream, . const Descriptor ; usage[], . int ; width = 80, . int ; last_column_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Definition at line 2830 of file OptionParser.h. ◆ printUsage() [4/5]. template<typename OStream > . void ROOT::option::printUsage ; (; OStream & ; prn, . const Descriptor ; usage[], . int ; width = 80, . int ; last_column_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Outputs a nicely formatted usage string with support for multi-column formatting and line-wrapping. ; printUsage() takes the help texts of a Descriptor[] array and formats them into a usage message, wrapping lines to achieve the desired output width.; Table formatting:; Aside from plain strings which are simply line-wrapped, the usage may contain tables. Tables are used to align elements in the output.; // Without a table. The explanatory texts are not aligned.; -c, --create |Creates something.; -k, --kill |Destroys something.; ; // With table formatting. The explanatory texts are aligned.; -c, --create |Creates something.; -k, --kill |Destroys something.; c#define c(i)Definition RSha256.hxx:101; createvirtual RooAbsTestStatistic * create(const char *name, const char *title, RooAbsReal &real, RooAbsData &data, const RooArgSet &projDeps, Configuration const &cfg)=0; Table formatting removes the need to pad help texts manually with spaces to achieve alignment. To create a table, simply insert \t (tab) characters to separate the cells within a row.; const option::Descriptor usage[] = {; {..., ""-c, --create \tCreates something."" },; {..., ""-k, --kill \tDestroys something."" }, ...; Note that you must include the minimum amount of space desired between cells yourself. Table formatting wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1option.html:6467,simpl,simply,6467,doc/v632/namespaceROOT_1_1option.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1option.html,1,['simpl'],['simply']
Usability,"lution operator PDF. convVar : convolution variable (on which both pdf and resmodel should depend); pdf : input 'physics' pdf; resmodel : input 'resultion' pdf. output is pdf(x) (X) resmodel(x) = Int [ pdf(x') resmodel (x-x') ] dx'. RooNumConvPdf(const RooNumConvPdf& other, const char* name = 0); Copy constructor. ~RooNumConvPdf(); Destructor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:43376,intuit,intuitively,43376,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,11,['intuit'],['intuitively']
Usability,"lution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSize ( spread ) by this factor; (if ofSteps == successSteps nothing is changed, if ofSteps < successSteps, the spread; is divided by the factor). using this function one can increase the stepSize of the mutation when we have; good success (to pass fast through the easy phase-space) and reduce the stepSize; if we are in a difficult ""territory"" of the phase-space. Bool_t HasConverged(Int_t steps = 10, Double_t ratio = 0.1); gives back true if the last ""steps"" steps have lead to an improvement of the; ""fitness"" of the ""individuals"" of at least ""improvement"". this gives a simple measure of if the fitness of the individuals is; converging and no major improvement is to be expected soon. GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0). GeneticPopulation& GetGeneticPopulation(); { return fPopulation; }. Double_t GetSpread() const; { return fSpread; }. void SetSpread(Double_t s); { fSpread = s; }. void SetMakeCopies(Bool_t s); { fMakeCopies = s; }. Bool_t GetMakeCopies(); { return fMakeCopies; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticAlgorithm.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__GeneticAlgorithm.html:5154,simpl,simple,5154,root/html532/TMVA__GeneticAlgorithm.html,https://root.cern,https://root.cern/root/html532/TMVA__GeneticAlgorithm.html,2,['simpl'],['simple']
Usability,"lutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussModel.html:3302,clear,clearShapeDirty,3302,root/html532/RooGaussModel.html,https://root.cern,https://root.cern/root/html532/RooGaussModel.html,6,['clear'],['clearShapeDirty']
Usability,"lutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussModel.html:3302,clear,clearShapeDirty,3302,root/html528/RooGaussModel.html,https://root.cern,https://root.cern/root/html528/RooGaussModel.html,3,['clear'],['clearShapeDirty']
Usability,"lutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGaussModel.html:3302,clear,clearShapeDirty,3302,root/html530/RooGaussModel.html,https://root.cern,https://root.cern/root/html530/RooGaussModel.html,3,['clear'],['clearShapeDirty']
Usability,"lvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:437074,learn,learning,437074,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['learn'],['learning']
Usability,"lways visible, having a scroll bar when the displayed area is not enough to show all items. The choices may be mutually exclusive (a list box with single selection) or not mutually exclusive (a list box with multiple selection). The proper usage of the list boxes is for selecting values, or objects, or setting attributes. You have to create them to display 4 to 8 choices at one time (3 is a required minimum in case of lack of screen space). The list should contain not more than 40 items accessible by scrolling view (vertical scroll bar). If more are required, you should provide a method for using search criteria or scoping the options. The best list boxes use is for textual data or choices. They should be wide enough to display fully all items. When it is not possible, break the long items with ellipsis and provide tool tip that displays the full item text.; The list box widget is represented by TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry classes. Currently entries are simple text strings (TGTextLBEntry). A TGListBox looks a lot like a TGCanvas. It has a TGViewPort containing a TGLBContainer which contains the entries and it also has a vertical scrollbar which becomes visible if there are more items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service classes of the list box. Here is a sample code showing how to create a list box with ten entries:; // list box widget containing 10 entries; int fFirstEntry = 0, fLastEntry = 10;; char tmp[20];; TGListBox *fListBox = new TGListBox(parent, 90);; for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; We create the list box widget passing the parent window pointer and giving an ID number. Next we add entries with specified string and ID to the list box. Before adding the list box to its parent ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1200044,simpl,simple,1200044,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"ly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; virtual value_type evaluate () const =0;  Evaluate the category state and return. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:36240,clear,clearTypes,36240,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['clear'],['clearTypes']
Usability,"ly a group of logically connected widgets: radio buttons, related check boxes, two or more functionally related controls. It is a composite frame with a border and a title. The title explains the purpose of the group and should be a noun or noun phrase. Here is an example taken from guitest.C:; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; The second line sets the title position on the left. You can change it to be centered or right aligned if you use TGGroupFrame::kCenter or TGGroupFrame::kRight as a parameter. Be conservative in the use of borders because of the potential for clutter. Do not place them around single entry fields, single combo boxes, list boxes and groups of command buttons. The design of these widgets provides them with a border. The picture above provides kind of borders to avoid.; 25.6 Layout Management; The layout process is an integral part of any GUI. When you create a simple message window, laying out its few buttons and text widgets is quite simple. However, this process becomes increasingly difficult if you have to implement large GUI’s with many widgets that should behave properly when the GUI is resized or uses a different font type or size. Layout management is the process of determining the size and position of every widget in a container.; A layout manager is an object that performs layout management for the widgets within a container. You already know that when adding a component (child widget) to a container (parent widget) you can provide alignment hints (or rely on the default ones). These hints are used by the layout manager to correctly position the widgets in the container. The TGLayoutManager is an abstract class providing the basic layout functionality. The layout classes hierarchy. The base “container” class is TGCmpositeFrame. You can easily change the layout manager using the SetLayoutManager(TGLayoutManager *l) method. Setting the proper layout manager for each",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1157535,simpl,simple,1157535,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['simpl'],['simple']
Usability,"ly discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. Bool_t IgnoreSizeForOfInterest() const; Return true if size of this shape should be ignored when determining if; the object should be drawn. In this base-class we simply return state of; static flag fgIgnoreSizeForCameraInterest. Several sub-classes override this virtual function. Bool_t GetIgnoreSizeForCameraInterest(); Get state of static fgIgnoreSizeForCameraInterest flag.; When this is true all objects, also very small, will be drawn by GL. void SetIgnoreSizeForCameraInterest(Bool_t isfci); Set state of static fgIgnoreSizeForCameraInterest flag. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLogicalShape.html:7805,simpl,simply,7805,root/html534/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html534/TGLLogicalShape.html,2,['simpl'],['simply']
Usability,"ly discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. Bool_t IgnoreSizeForOfInterest() const; Return true if size of this shape should be ignored when determining if; the object should be drawn. In this base-class we simply return state of; static flag fgIgnoreSizeForCameraInterest. Several sub-classes override this virtual function. Bool_t GetIgnoreSizeForCameraInterest(); Get state of static fgIgnoreSizeForCameraInterest flag.; When this is true all objects, also very small, will be drawn by GL. void SetIgnoreSizeForCameraInterest(Bool_t isfci); Set state of static fgIgnoreSizeForCameraInterest flag. TGLLogicalShape(const TGLLogicalShape& ). TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLLogicalShape.html:8256,simpl,simply,8256,root/html602/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html,4,['simpl'],['simply']
Usability,"ly discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* GetFirstPhysical() const; { return fFirstPhysical; }. TObject* ID() const; { return fExternalObj; }. TObject* GetExternal() const; { return fExternalObj; }. TGLScene* GetScene() const; { return fScene; }. void UpdateBoundingBox(); {}. UInt_t DLOffset(Short_t ) const; { return 0; }. ELODAxes SupportedLODAxes() const; { return kLODAxesNone; }. void DirectDraw(TGLRnrCtx& rnrCtx) const. Bool_t IgnoreSizeForOfInterest() const; { return kFALSE; }. Bool_t KeepDuringSmartRefresh() const; Override in sub-classes that do direct object rendering (e.g. TGLObject).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLogicalShape.html:7640,simpl,simply,7640,root/html528/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html,4,['simpl'],['simply']
Usability,"ly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Camel2); // Set 2-dim distribution, included below; FoamX->SetPseRan(PseRan); // Set random number generator; FoamX->Initialize(); // Initialize simulator, takes a few seconds...; // From now on FoamX is ready to generate events according to Camel2(x,y); for(Long_t loop=0; loop<100000; loop++){; FoamX->MakeEvent(); // generate MC event; FoamX->GetMCvect( MCvect); // get generated vector (x,y); Double_t x=MCvect[0];; Double_t y=MCvect[1];; if(loop<10) cout<<""(x,y) = ( ""<< x <<"", ""<< y <",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFoam.html:1472,Simpl,Simple,1472,root/html532/TFoam.html,https://root.cern,https://root.cern/root/html532/TFoam.html,2,['Simpl'],['Simple']
Usability,"ly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Camel2); // Set 2-dim distribution, included below; FoamX->SetPseRan(PseRan); // Set random number generator; FoamX->Initialize(); // Initialize simulator, takes a few seconds...; // From now on FoamX is ready to generate events according to Camel2(x,y); for(Long_t loop=0; loop<100000; loop++){; FoamX->MakeEvent(); // generate MC event; FoamX->GetMCvect( MCvect); // get generated vector (x,y); Double_t x=MCvect[0];; Double_t y=MCvect[1];; if(loop<10) std::cout<<""(x,y) = ( ""<< x <<"", ""<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFoam.html:1472,Simpl,Simple,1472,root/html602/TFoam.html,https://root.cern,https://root.cern/root/html602/TFoam.html,2,['Simpl'],['Simple']
Usability,"ly small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. Function Members (Methods); public:. ~THnT<unsigned long long>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnT_ULong64_t_.html:2038,Clear,Clear,2038,root/html534/THnT_ULong64_t_.html,https://root.cern,https://root.cern/root/html534/THnT_ULong64_t_.html,1,['Clear'],['Clear']
Usability,"ly thread-safe and asynchronous interfaces. More robust interfaces; Compile-time type safety by default; Decomposition into layers: logical layer, primitives layer, storage layer; Separation of data model and live data; Self-contained I/O code to support creation of a standalone I/O library. Concepts; At the logical layer, the user defines a data model using the RNTupleModel class. The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree. The data model can contain (nested) collections, e.g., a type can be std::vector<std::vector<float>>.; Each serializable type is represented by a field, concretely by a templated version of RField, e.g. RField<double>. A field can generate or adopt an associated value, which represents a memory location storing a value of the given C++ type. These distinguished memory locations are the destinations and sources for the deserialization and serialization.; The (de-)serialization is a mapping from the C++ type to the more simple column type system. A column contains an arbitrary number of fixed-sized elements of a well-defined set of types: integers and floats of different bit sizes. A C++ type may be mapped to multiple columns. For instance, an std::vector<float> maps to two columns, an offset column indicating the size of the vector per entry, and a payload column with the float data.; Columns are partitioned into pages (roughly: TTree baskets) of a few kB – a few tens of kB each. The physical layer (only) needs to provide the means to store and retrieve pages. The physical layer is decoupled from the high-level C++ logic. The physical layer implements an abstract page storage interface, so that dedicated implementations for key-value stores and other storage systems are conceivable. At this point, the only provided backend stores the pages in ROOT files.; RNTuples are further grouped into clusters, which are, like TTree clusters, self-contained blocks of consecutive entries. Clus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html:2271,simpl,simple,2271,doc/master/md_tree_2ntuple_2v7_2doc_2README.html,https://root.cern,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html,1,['simpl'],['simple']
Usability,"ly, TProfile, TProfile2D, and TProfile3D.; Definition at line 2840 of file TH1.cxx. ◆ DoFillN(). void TH1::DoFillN ; (; Int_t ; ntimes, . const Double_t * ; x, . const Double_t * ; w, . Int_t ; stride = 1 . ). protectedvirtual . Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ; Definition at line 3473 of file TH1.cxx. ◆ DoIntegral(). Double_t TH1::DoIntegral ; (; Int_t ; ix1, . Int_t ; ix2, . Int_t ; iy1, . Int_t ; iy2, . Int_t ; iz1, . Int_t ; iz2, . Double_t & ; err, . Option_t * ; opt, . Bool_t ; doerr = kFALSE . ); const. protectedvirtual . Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ; Definition at line 7977 of file TH1.cxx. ◆ Draw(). void TH1::Draw ; (; Option_t * ; option = """"). overridevirtual . Draw this histogram with options. ; Histograms are drawn via the THistPainter class. Each histogram has a pointer to its own painter (to be usable in a multithreaded program). The same histogram can be drawn with different options in different pads. When a histogram drawn in a pad is deleted, the histogram is automatically removed from the pad or pads where it was drawn. If a histogram is drawn in a pad, then filled again, the new status of the histogram will be automatically shown in the pad next time the pad is updated. One does not need to redraw the histogram. To draw the current version of a histogram in a pad, one can use h->DrawCopy(); This makes a clone of the histogram. Once the clone is drawn, the original histogram may be modified or deleted without affecting the aspect of the clone. By default, TH1::Draw clears the current pad.; One can use TH1::SetMaximum and TH1::SetMinimum to force a particular value for the maximum or the minimum scale on the plot.; TH1::UseCurrentStyle can be used to change all histogram graphics attributes to correspond to the current selected style. This function must be called",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:108625,usab,usable,108625,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['usab'],['usable']
Usability,"l _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooArgSet _emptySet;  Supports named argument constructor. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions;  RooChi2Var (const char *name, const char *title, RooAbsReal &func, RooDataHist &data, const RooArgSet &projDeps, FuncMode funcMode, RooAbsTestStatistic::Configuration const &cfg, RooDataHist::ErrorType etype);  . Additional Inherited Members;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:66127,clear,clearEvalErrorLog,66127,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['clear'],['clearEvalErrorLog']
Usability,"m ""col"" is missing, the entire entry will be filtered out; df_available = df.FilterAvailable(""col""); df_available = df_available.Define(""twice"", ""col * 2""); ; # Conversely, if we want to select the entries for which the column has missing; # values, we do the following; df_missingcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); ROOT::RDataFrame df{dataset};; ; // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");; ; // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; DefaultValueFor; DefaultValueFor creates a node of the computation graph which just forwards the values of the columns necessary for other downstream nodes, when they are available. In case a value of the input column passed to this function is not available, the node will provide the default value passed to this function call instead. Example:; df = ROOT.RDataFrame(dataset); # Anytime an entry from ""col"" is missing, the value will be the default one; default_value = ... # Some sensible default value here; df = df.DefaultValueFor(""col"", default_value) ; df = df.Define(""twice"", ""col * 2""); ROOT::RDataFrame df{dataset};; // Anytime an entry from ""col"" is missing, the value will be the default one; constexpr auto default_value = ... // Some sensible default value here; auto df_default = df.DefaultValueFor(""col"", default_value);; auto df_col = df",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:83729,clear,clearly,83729,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['clear'],['clearly']
Usability,"m &other, const char *name=nullptr);  Copy constructor. ;  ; TObject * clone (const char *newname) const override;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; TClass * IsA () const override;  ; const RooArgList & list ();  ; bool setData (RooAbsData &data, bool cloneData=true) override;  Replace the variables in this RooConstraintSum with the global observables in the dataset if they match by name. ;  ; bool setData (RooAbsData const &data, bool cloneData=true);  Replace the variables in this RooConstraintSum with the global observables in the dataset if they match by name. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstraintSum.html:2129,simpl,simple,2129,doc/master/classRooConstraintSum.html,https://root.cern,https://root.cern/doc/master/classRooConstraintSum.html,1,['simpl'],['simple']
Usability,"m any other branch. Now, assume that Px and Py are data members of the event, and we would like to compute Px2 + Py2 for every event and histogram the result.; If we had saved the million events without a TTree we would have to:. read each event in its entirety into memory; extract the Px and Py from the event; compute the sum of the squares; fill a histogram. We would have to do that a million times! This is very time consuming, and we really do not need to read the entire event, every time. All we need are two little data members (Px and Py). On the other hand, if we use a tree with one branch containing Px and another branch containing Py, we can read all values of Px and Py by only reading the Px and Py branches. This makes the use of the TTree very attractive.; 12.2 A Simple TTree; This script builds a TTree from an ASCII file containing statistics about the staff at CERN. This script, cernbuild.C and its input file cernstaff.dat are in $ROOTSYS/tutorials/tree.; {; // Simplified version of cernbuild.C.; // This macro to read data from an ascii file and; // create a root file with a TTree. Int_t Category;; UInt_t Flag;; Int_t Age;; Int_t Service;; Int_t Children;; Int_t Grade;; Int_t Step;; Int_t Hrweek;; Int_t Cost;; Char_t Division[4];; Char_t Nation[3];. FILE *fp = fopen(""cernstaff.dat"",""r"");. TFile *hfile = hfile = TFile::Open(""cernstaff.root"",""RECREATE"");. TTree *tree = new TTree(""T"",""CERN 1988 staff data"");; tree->Branch(""Category"",&Category,""Category/I"");; tree->Branch(""Flag"",&Flag,""Flag/i"");; tree->Branch(""Age"",&Age,""Age/I"");; tree->Branch(""Service"",&Service,""Service/I"");; tree->Branch(""Children"",&Children,""Children/I"");; tree->Branch(""Grade"",&Grade,""Grade/I"");; tree->Branch(""Step"",&Step,""Step/I"");; tree->Branch(""Hrweek"",&Hrweek,""Hrweek/I"");; tree->Branch(""Cost"",&Cost,""Cost/I"");; tree->Branch(""Division"",Division,""Division/C"");; tree->Branch(""Nation"",Nation,""Nation/C"");; char line[80];; while (fgets(line,80,fp)) {; sscanf(&line[0],""%d %d %d %d %d %d %d %d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:522093,Simpl,Simplified,522093,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simplified']
Usability,m color to operations. ; Definition at line 178 of file TWebPainting.cxx. ◆ AddFillAttr(). void TWebPainting::AddFillAttr ; (; const TAttFill & ; attr). Store fill attributes If attributes were not changed - ignore operation. ; Definition at line 131 of file TWebPainting.cxx. ◆ AddLineAttr(). void TWebPainting::AddLineAttr ; (; const TAttLine & ; attr). Store line attributes If attributes were not changed - ignore operation. ; Definition at line 113 of file TWebPainting.cxx. ◆ AddMarkerAttr(). void TWebPainting::AddMarkerAttr ; (; const TAttMarker & ; attr). Store marker attributes If attributes were not changed - ignore operation. ; Definition at line 161 of file TWebPainting.cxx. ◆ AddOper(). void TWebPainting::AddOper ; (; const std::string & ; oper). Add next custom operator to painting Operations are separated by semicolons Following operations are supported: t - text h - text coded into simple hex r - rectangle b - rectangular fill region l - polyline f - poly fill region m - poly marker z - line attributes y - fill attributes x - marker attributes o - text attributes After operation code optional arguments can be append like length of operation or coded text Each operation may use data from binary float buffer. ; Definition at line 53 of file TWebPainting.cxx. ◆ AddTextAttr(). void TWebPainting::AddTextAttr ; (; const TAttText & ; attr). Store text attributes If attributes were not changed - ignore operation. ; Definition at line 147 of file TWebPainting.cxx. ◆ Class(). static TClass * TWebPainting::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TWebPainting::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TWebPainting::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 59 of file TWebPainting.h. ◆ DeclFileName(). static const char * TWebPainting::DeclFileName ; (; ). inlinestatic . ReturnsName of the file contain,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebPainting.html:13081,simpl,simple,13081,doc/master/classTWebPainting.html,https://root.cern,https://root.cern/doc/master/classTWebPainting.html,1,['simpl'],['simple']
Usability,"m fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:15890,learn,learning,15890,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"m for TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 47 of file Optimizer.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 48 of file Optimizer.h. Constructor & Destructor Documentation. ◆ VOptimizer(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::VOptimizer ; (; Scalar_t ; learningRate, . DeepNet_t & ; deepNet . ). Constructor. ; Definition at line 94 of file Optimizer.h. ◆ ~VOptimizer(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . virtual TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::~VOptimizer ; (; ). virtualdefault . Virtual Destructor. . Member Function Documentation. ◆ GetGlobalStep(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . size_t TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::GetGlobalStep ; (; ); const. inline . Definition at line 81 of file Optimizer.h. ◆ GetLayerAt(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Layer_t * TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html:3121,learn,learningRate,3121,doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,1,['learn'],['learningRate']
Usability,"m specified with the TUnfold constructor). The indexes of binMap correspond to the truth bins (including underflow and overflow) of the response matrix. The element binMap[i] specifies the histogram number in output where the corresponding truth bin will be stored. It is possible to specify the same output bin number for multiple indexes, in which case these bins are added. Set binMap[i]=-1 to ignore an unfolded truth bin. The uncertainties are calculated from the corresponding parts of the covariance matrix, properly taking care of added truth bins. ; If the pointer binMap is zero, the bins are mapped one-to-one. Truth bin zero (underflow) is stored in the output underflow, truth bin 1 is stored in bin number 1, etc. ; Definition at line 3289 of file TUnfold.cxx. ◆ GetOutputBinName(). TString TUnfold::GetOutputBinName ; (; Int_t ; iBinX); const. protectedvirtual . Get bin name of an outpt bin. ; Parameters. [in]iBinXbin number. Return value: name of the bin ; For TUnfold and TUnfoldSys, this function simply returns the bin number as a string. This function really only makes sense in the context of TUnfoldDensity, where binnig schemes are implemented using the class TUnfoldBinning, and non-trivial bin names are returned. ; Reimplemented in TUnfoldDensity.; Definition at line 1667 of file TUnfold.cxx. ◆ GetProbabilityMatrix(). void TUnfold::GetProbabilityMatrix ; (; TH2 * ; A, . EHistMap ; histmap . ); const. get matrix of probabilities ; Parameters. [out]Atwo-dimensional histogram to store the probabilities (normalized response matrix). The bin contents are overwritten for those bins where A is nonzero ; [in]histmapspecify axis along which the truth bins are oriented . Definition at line 3010 of file TUnfold.cxx. ◆ GetRhoAvg(). Double_t TUnfold::GetRhoAvg ; (; void ; ); const. inline . get average global correlation determined in recent unfolding ; Definition at line 327 of file TUnfold.h. ◆ GetRhoI(). Double_t TUnfold::GetRhoI ; (; TH1 * ; rhoi, . const Int_t * ; bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:41950,simpl,simply,41950,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['simpl'],['simply']
Usability,"m with options.Definition TH1.cxx:3066; TLegend::TLegendTLegend()Default constructor.Definition TLegend.cxx:200; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11. TLegend inherits from TAttText therefore changing any text attributes (text alignment, font, color...) on a legend will changed the text attributes on each line.; In particular it can be interesting to change the text alignement that way. In order to have a base-line vertical alignment instead of a centered one simply do: legend->SetTextAlign(13);; or legend->SetTextAlign(11);; The default value of some TLegend attributes can be changed using gStyle. The default settings are: SetLegendBorderSize(1);; SetLegendFillColor(0);; SetLegendFont(42);; SetLegendTextSize(0.);; The global attributes change the default values for the next created legends.; Text attributes can be also changed individually on each legend entry: TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TLegendEntryStorage class for one entry of a TLegend.Definition TLegendEntry.h:25; leglegDefinition legend1.C:34; Note that the TPad class has a method to build automatically a legend for all objects in the pad. It is called TPad::BuildLegend().; Each item in the legend is added using the AddEntry method. This method defines the object to be added (by reference or name), the label associated to this o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLegend.html:5114,simpl,simply,5114,doc/master/classTLegend.html,https://root.cern,https://root.cern/doc/master/classTLegend.html,1,['simpl'],['simply']
Usability,"m, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:18143,Clear,Clear,18143,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['Clear'],['Clear']
Usability,"m->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:3016,undo,undo,3016,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,8,"['Undo', 'undo']","['Undo', 'undo']"
Usability,"m->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::Appen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:3015,undo,undo,3015,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,8,"['Undo', 'undo']","['Undo', 'undo']"
Usability,"m->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:3040,undo,undo,3040,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,6,"['Undo', 'undo']","['Undo', 'undo']"
Usability,"m->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:3039,undo,undo,3039,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,6,"['Undo', 'undo']","['Undo', 'undo']"
Usability,"m; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TTreeCache * GetReadCache(TFile* file, Bool_t create = kFALSE); Find and return the TTreeCache registered with the file and which may; contain branches for us. If create is true and there is no cache:; Create a new cache according to the autocache setting and return it. TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:103853,Clear,Clear,103853,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['Clear'],['Clear']
Usability,"mPIDs][fAllocSize] array of Parent IDs; TObjArray*fParentsarray of Parent objects (eg TTree branch) holding the referenced objects; vector<std::string>fProcessGUIDsUUIDs of TProcessIDs used in fParentIDs; Int_tfSizedummy for backward compatibility; UInt_tfUID!Current uid (set by TRef::GetObject); TProcessID*fUIDContext!TProcessID the current uid is referring to; static TRefTable*fgRefTablePointer to current TRefTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. void Clear(Option_t* = """"); Clear all entries in the table. Int_t Expand(Int_t pid, Int_t newsize); Expand fParentIDs to newsize for ProcessID pid. Int_t ExpandForIID(Int_t iid, Int_t newsize); Expand fParentIDs to newsize for internel ProcessID index iid. void ExpandPIDs(Int_t numpids); Expand the arrays of managed PIDs. void FillBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::FillLeaves. Int_t FindPIDGUID(const char* guid) const; Get fProcessGUIDs' index of the TProcessID with GUID guid. TObject * GetParent(Int_t uid, TProcessID* context = 0) const; Return object corresponding to uid. Int_t GetInternalIdxForPID(TProcessID* procid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. Int_t GetInternalIdxForPID(Int_t pid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. TRefTable * GetRefTable(); Static f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRefTable.html:8759,Clear,Clear,8759,root/html532/TRefTable.html,https://root.cern,https://root.cern/root/html532/TRefTable.html,4,['Clear'],['Clear']
Usability,"m_{\rm ES}}\) , \(\Delta E\) and \({\cal F}\). The variable which is not incorporated in \(y\) is used as the control variable \(x\) . The six distributions of the three variables are assumed to be the ones depicted in Fig. 1. Figure 1 ; Distributions of the three discriminating variables available to perform the Likelihood fit: \({m_{\rm ES}}\) , \(\Delta E\) , \({\cal F}\) . Among the three variables, two are used to perform the fit while one is kept out of the fit to serve the purpose of a control variable. The three distributions on the top (resp. bottom) of the figure correspond to the signal (resp. background). The unit of the vertical axis is chosen such that it indicates the number of entries per bin, if one slices the histograms in 25 bins.; A data sample being built through a Monte Carlo simulation based on the distributions shown in Fig. 1, one obtains the three distributions of Fig. 2. Whereas the distribution of \(\Delta E\) clearly indicates the presence of the signal, the distribution of \({m_{\rm ES}}\) and \({\cal F}\) are less obviously populated by signal. Figure 2 ; Distributions of the three discriminating variables for signal plus background. The three distributions are the ones obtained from a data sample obtained through a Monte Carlo simulation based on the distributions shown in Fig. 1. The data sample consists of 500 signal events and 5000 background events.; Choosing \(\Delta E\) and \({\cal F}\) as discriminating variables to determine \(N_1\) and \(N_2\) through a maximum Likelihood fit, one builds, for the control variable \({m_{\rm ES}}\) which is unknown to the fit, the two \(\hbox {$_s$}{\cal P}lots\) for signal and background shown in Fig. 3. One observes that the \(\hbox{$_s$}{\cal P}lot\) for signal reproduces correctly the PDF even where the latter vanishes, although the error bars remain sizeable. This results from the almost complete cancellation between positive and negative weights: the sum of weights is close to zero while t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSPlot.html:8050,clear,clearly,8050,doc/master/classTSPlot.html,https://root.cern,https://root.cern/doc/master/classTSPlot.html,1,['clear'],['clearly']
Usability,"maining time (per file being processed). It is recorded and printed in the terminal every m events and every ; 1521n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. ; 1522 ; 1523ProgressBar is added after creating the dataframe object (df):; 1524~~~{.cpp}; 1525ROOT::RDataFrame df(""tree"", ""file.root"");; 1526ROOT::RDF::Experimental::AddProgressBar(df);; 1527~~~; 1528 ; 1529Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; 1530For example, it can be called at any computational node, such as Filter or Define, not only the head node,; 1531with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ; 1532section for appropriate usage in Python): ; 1533~~~{.cpp}; 1534ROOT::RDataFrame df(""tree"", ""file.root"");; 1535auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; 1536ROOT::RDF::Experimental::AddProgressBar(df_1);; 1537~~~; 1538Examples of implemented progress bars can be seen by running [Higgs to Four Lepton tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html) and [Dimuon tutorial](https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html). ; 1539 ; 1540*/; 1541// clang-format on; 1542 ; 1543namespace ROOT {; 1544 ; 1545using ROOT::RDF::ColumnNames_t;; 1546using ColumnNamesPtr_t = std::shared_ptr<const ColumnNames_t>;; 1547 ; 1548////////////////////////////////////////////////////////////////////////////; 1549/// \brief Build the dataframe.; 1550/// \param[in] treeName Name of the tree contained in the directory; 1551/// \param[in] dirPtr TDirectory where the tree is stored, e.g. a TFile.; 1552/// \param[in] defaultColumns Collection of default columns.; 1553///; 1554/// The default columns are looked at in case no column is specified in the; 1555/// booking of actions or transformations.; 1556/// \see ROOT::RDF::RInterface for the documentation of the methods available.; 1557RDataF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:86840,progress bar,progress bars,86840,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['progress bar'],['progress bars']
Usability,"maining time (per file being processed). It is recorded and printed in the terminal every m events and every ; 1561n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. ; 1562 ; 1563ProgressBar is added after creating the dataframe object (df):; 1564~~~{.cpp}; 1565ROOT::RDataFrame df(""tree"", ""file.root"");; 1566ROOT::RDF::Experimental::AddProgressBar(df);; 1567~~~; 1568 ; 1569Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; 1570For example, it can be called at any computational node, such as Filter or Define, not only the head node,; 1571with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ; 1572section for appropriate usage in Python): ; 1573~~~{.cpp}; 1574ROOT::RDataFrame df(""tree"", ""file.root"");; 1575auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; 1576ROOT::RDF::Experimental::AddProgressBar(df_1);; 1577~~~; 1578Examples of implemented progress bars can be seen by running [Higgs to Four Lepton tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html) and [Dimuon tutorial](https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html). ; 1579 ; 1580\anchor missing-values; 1581### Working with missing values in the dataset; 1582 ; 1583In certain situations a dataset might be missing one or more values at one or; 1584more of its entries. For example:; 1585 ; 1586- If the dataset is composed of multiple files and one or more files is; 1587 missing one or more columns required by the analysis.; 1588- When joining different datasets horizontally according to some index value; 1589 (e.g. the event number), if the index does not find a match in one or more; 1590 other datasets for a certain entry.; 1591 ; 1592For example, suppose that column ""y"" does not have a value for entry 42:; 1593 ; 1594\code{.unparsed}; 1595+-------+---+---+; 1596| Entry | x | y |; 1597+-------+---+---+; 1598| 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:88520,progress bar,progress bars,88520,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['progress bar'],['progress bars']
Usability,"malize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitely, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMultiLayerPerceptron.html:7442,Learn,Learning,7442,root/html532/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html532/TMultiLayerPerceptron.html,1,['Learn'],['Learning']
Usability,"malized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. One can also call TF1::GetRandom to get a random variate from a function. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in histogram h*-*-*-*. The distribution contained in the histogram h (TH1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. SPECIAL CASE when the target histogram has the same binning as the source.; in this case we simply use a poisson distribution where; the mean value per bin = bincontent/integral. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. Int_t FindBin(Double_t x, Double_t y = 0, Double_t z = 0); Return Global bin number corresponding to x,y,z. 2-D and 3-D histograms are represented with a one dimensional; structure. This function tries to rebin the axis if the given point; belongs to an under-/overflow bin.; This has the advantage that all existing functions, such as; GetBinContent, GetBinError, GetBinFunction work for all dimensions.; See also TH1::GetBin, TAxis::FindBin and TAxis::FindFixBin; -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; Return Global bin number corresponding to x,y,z. 2-D and 3-D histograms are represented with a one dimensional; structure. This function DOES not try to rebin the axis if the given; point belongs to an under-/overflow bin.; This has the advantage that all existing fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:68908,simpl,simply,68908,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['simpl'],['simply']
Usability,"mand * ; c). virtual . Compress command. ; Compression is analogous to arithmetic ""addition operation"".; Note:; The compressed command will be deleted.; Execution Compress method invokes Redo action with new redo arguments inherited from compressed command. More complicated commands might want to override this function. ; Definition at line 402 of file TQCommand.cxx. ◆ DeclFileName(). static const char * TQCommand::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 98 of file TQCommand.h. ◆ Delete(). void TQCommand::Delete ; (; Option_t * ; opt = """"). overridevirtual . If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ; If ""opt"" is zero - delete all merged commands. ; Reimplemented from TList.; Definition at line 285 of file TQCommand.cxx. ◆ GetCommand(). TQCommand * TQCommand::GetCommand ; (; ). static . Return a command which is doing redo/undo action. ; This static method allows to set undo parameters dynamically, i.e. during execution of Redo function.; Example: For redo actions like TGTextEdit::DelChar() it is not possible to know ahead what character will be deleted. To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)), one needs to call TQCommand::SetUndoArgs(1, character) from inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);; TQCommand::GetCommandstatic TQCommand * GetCommand()Return a command which is doing redo/undo action.Definition TQCommand.cxx:276. Definition at line 276 of file TQCommand.cxx. ◆ GetName(). const char * TQCommand::GetName ; (; ); const. overridevirtual . Returns the command name. ; Default name is ""ClassName::RedoName(args)"" If list of merged commands is not empty the name is ""ClassName::RedoName(args):cname1:cname2 ..."" ; Reimplemented from TCollection.; Definition at line 670 of file TQCommand.cxx. ◆ GetNRargs(). Int_t TQCommand::GetNRargs ; (; ); const. Returns a number of re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:36650,undo,undo,36650,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"mand. ; Definition at line 736 of file TQCommand.cxx. ◆ GetStatus(). Int_t TQCommand::GetStatus ; (; ); const. Returns a number of sequential undo or redo operations. ; Definition at line 792 of file TQCommand.cxx. ◆ GetTitle(). const char * TQCommand::GetTitle ; (; ); const. overridevirtual . Returns command description. ; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"" ; Reimplemented from TObject.; Definition at line 713 of file TQCommand.cxx. ◆ GetUndo(). TQConnection * TQCommand::GetUndo ; (; ); const. inline . Definition at line 76 of file TQCommand.h. ◆ GetUndoArgs(). Long_t * TQCommand::GetUndoArgs ; (; ); const. Returns a pointer to array of undo arguments. ; Definition at line 760 of file TQCommand.cxx. ◆ GetUndoName(). const char * TQCommand::GetUndoName ; (; ); const. Returns the name of undo command. ; Definition at line 744 of file TQCommand.cxx. ◆ Init(). void TQCommand::Init ; (; const char * ; cl, . void * ; object, . const char * ; redo, . const char * ; undo . ). protectedvirtual . Common protected method used in several constructors. ; Definition at line 120 of file TQCommand.cxx. ◆ IsA(). TClass * TQCommand::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 98 of file TQCommand.h. ◆ IsEqual(). Bool_t TQCommand::IsEqual ; (; const TObject * ; obj); const. overridevirtual . Equal comparison. ; The commands are equal if they are applied to the same object and have the same Redo/Undo actions; More complicated commands might want to override this function. ; Reimplemented from TObject.; Definition at line 418 of file TQCommand.cxx. ◆ IsExecuting(). Bool_t TQCommand::IsExecuting ; (; ); const. Returns kTRUE if command execution is in progress. ; Definition at line 824 of file TQCommand.cxx. ◆ IsMacro(). Bool_t TQCommand::IsMacro ; (; ); const. Returns kTRUE if neither redo nor undo action specified. ; Definition at line 8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:39389,undo,undo,39389,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; static THnSparse*CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:5498,Clear,Clear,5498,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,1,['Clear'],['Clear']
Usability,"mation for undo/redo a single action.; TQConnection Internal class used in the object communication mechanism; TQMimeTypes Pool of mime type objects; TQObjSender Used to ""delegate"" TQObject functionality; TQObject Base class for object communication mechanism; TQRootApplication creates Qt environment interface with the ROOT windowing system; TQRootCanvas interface to Qt eventloop to handle user input; TQRootDialog prompt for the arguments of an object's member function; TQRootGuiFactory Qt ROOT Gui factory; TQUndoManager recorder of operations for undo and redo; TQpDataBase Qp Base Data class; TQpDataDens Qp Data class for Dens formulation; TQpDataSparse Qp Data class for Sparse formulation; TQpLinSolverBase Qp linear solver base class; TQpLinSolverDens Qp linear solver class for Dens formulation; TQpLinSolverSparse Qp linear solver class for Sparse formulation; TQpProbBase Qp problem formulation base class; TQpProbDens Qp dens problem formulation class; TQpProbSparse Qp sparse problem formulation class; TQpResidual Qp Residual class; TQpSolverBase Qp Solver class; TQpVar Qp Variables class; TQtApplication Instantiate the Qt system within ROOT environment; TQtBrush create QBrush object based on the ROOT ""fill"" attributes; TQtClientFilter Map Qt and ROOT event; TQtClientWidget QFrame implementation backing ROOT TGWindow objects; TQtMarker Convert ROOT TMarker objects on to QPointArray; TQtPadFont < Create Qt QFont object based on ROOT TAttText attributes; TQtRootGuiFactory Factory for Qt-based ROOT GUI components; TQtRootSlot ; TQtTimer QTimer to awake the ROOT event loop from Qt event loop; TQtWidget QWidget to back ROOT TCanvas (Can be used with Qt designer); TQuaternion a quaternion class; TQueryDescription Query description; TQueryResult Class describing a query; TQueryResultManager PROOF query result manager; TROOT Top level (or root) structure for all classes; TRWLock Reader/writer lock; TRadialGradient Radial gradient fill.; TRandom Simple Random number genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:119192,undo,undo,119192,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,['undo'],['undo']
Usability,"mation in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non ROOT applications. Currently writing and reading XML files is limited to ROOT applications. It is our intention to develop a simple reader independent of the ROOT libraries that could be used as an example for real applications.; The XML format should be used only for small data volumes, typically histogram files, pictures, geometries, calibrations. The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism exploiting the ROOT/Cling dictionary. Any class having a dictionary can be saved in XML format. This first implementation does not support subdirectories or trees.; The shared library libRXML.so may be loaded dynamically via gSystem->Load(""libRXML""). This library is also automatically loaded by the plug-in manager as soon a XML file is created. To create an XTM file, simply specify a filename with an .xml extension when calling TFile::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how objects can be saved in ROOT files. In case you want to store large quantities of same-class objects, ROOT has designed the TTree and TNtuple classes specifica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:518616,simpl,simply,518616,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"max = 0); intFindClosestPointIndex(double target, int mode = 0, double xtarget = 0); doubleGetExpectedLimit(double nsig, bool lower, const char* opt = """") const; doubleGetGraphX(const TGraph& g, double y0, bool lowSearch = true) const; doubleGetGraphX(const TGraph& g, double y0, bool lowSearch, double& xmin, double& xmax) const; RooStats::SamplingDistribution*GetLimitDistribution(bool lower) const. Data Members; public:. Double_tRooStats::SimpleInterval::fConfidenceLevelconfidence level; Double_tRooStats::SimpleInterval::fLowerLimitlower interval limit; RooArgSetRooStats::SimpleInterval::fParametersset containing the parameter of interest; Double_tRooStats::SimpleInterval::fUpperLimitupper interval limit; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static RooStats::HypoTestInverterResult::InterpolOption_tkLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooStats::HypoTestInverterResult::InterpolOption_tkSpline; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. doublefCLsCleanupThreshold; TListfExpPValueslist of expected sampling distribution for each point; boolfFittedLowerLimit; boolfFittedUpperLimit; RooStats::HypoTestInverterResult::InterpolOption_tfInterpolOptioninterpolatation option (linear or spline); boolfInterpolateLowerLimit; boolfInterpolateUpperLimit; boolfIsTwoSidedtwo sided scan (look for lower/upper limit); doublefLowerLimitError; TStringTNamed::fNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html:8968,Simpl,SimpleInterval,8968,root/html602/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html,8,['Simpl'],['SimpleInterval']
Usability,"max] for the first and [ymin,ymax] for the second coordinate; 167 */; 168 void AddRange(double xmin, double xmax, double ymin, double ymax ) { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }; 169 /**; 170 add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; 171 [zmin,zmax] for the third coordinate; 172 */; 173 void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax ) {; 174 AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); AddRange(2,zmin,zmax); }; 175 ; 176 /**; 177 set a range [xmin,xmax] for the new coordinate icoord; 178 If more range exists for other coordinates, delete the existing one and use it the new one; 179 Use Add range if want to keep the union of the existing ranges; 180 */; 181 void SetRange(unsigned int icoord , double xmin, double xmax );; 182 ; 183 /**; 184 set a range [xmin,xmax] for the first coordinate icoord; 185 */; 186 void SetRange(double xmin, double xmax ) { SetRange(0,xmin,xmax); }; 187 /**; 188 set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate; 189 */; 190 void SetRange(double xmin, double xmax, double ymin, double ymax ) { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }; 191 /**; 192 set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; 193 [zmin,zmax] for the third coordinate; 194 */; 195 void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax ) {; 196 SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); SetRange(2,zmin,zmax); }; 197 ; 198 /**; 199 clear all ranges in one coordinate (is now -inf, +inf); 200 */; 201 void Clear (unsigned int icoord = 0 );; 202 ; 203 /**; 204 check if a point is inside the range for the given coordinate; 205 */; 206 bool IsInside(double x, unsigned int icoord = 0) const;; 207 ; 208 /**; 209 check if a multi-dimpoint is inside the range; 210 */; 211 bool IsInside(const double *x) const {; 212 bool ret = true;; 213 for (unsigned int idim = 0; idim < fRanges.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataRange_8h_source.html:6994,clear,clear,6994,doc/master/DataRange_8h_source.html,https://root.cern,https://root.cern/doc/master/DataRange_8h_source.html,1,['clear'],['clear']
Usability,"maxdiff=0 (default), the first cell with content=c is returned. Double_t GetCorrelationFactor(Int_t axis1 = 1, Int_t axis2 = 2) const; -*-*-*Return correlation factor between axis1 and axis2; *-* ====================================================. Double_t GetCovariance(Int_t axis1 = 1, Int_t axis2 = 2) const; -*-*-*Return covariance between axis1 and axis2; *-* ====================================================. void GetRandom2(Double_t& x, Double_t& y); return 2 random numbers along axis x and y distributed according; the cellcontents of a 2-dim histogram; return a NaN if the histogram has a bin with negative content. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2; stats[6] = sumwxy. If no axis-subranges are specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If sub-ranges are specified, the function recomputes these quantities; from the bin contents in the current axis ranges. Note that the mean value/RMS is computed using the bins in the currently; defined ranges (see TAxis::SetRange). By default the ranges include; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. Double_t Integral(Option_t* option = """") const; Return integral of bin contents. Only bins in the bins range are considered.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Option_t* option = """") const; Return integral",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2.html:40034,simpl,simply,40034,root/html534/TH2.html,https://root.cern,https://root.cern/root/html534/TH2.html,2,['simpl'],['simply']
Usability,"mber Functions |; List of all members ; TProofPlayerLite Class ReferencePROOF » PROOF kernel Libraries. ; Version of TProofPlayerRemote merges the functionality needed by clients and masters. ; It is used in optmized local sessions. ; Definition at line 28 of file TProofPlayerLite.h. Public Member Functions;  TProofPlayerLite (TProof *proof=0);  ;  ~TProofPlayerLite () override;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize a query. ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; TClass * IsA () const override;  ; Long64_t Process (TDSet *set, const char *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Process specified TDSet on PROOF. ;  ; Long64_t Process (TDSet *set, TSelector *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Process specified TDSet on PROOF. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayerRemote;  TProofPlayerRemote (TProof *proof=0);  ;  ~TProofPlayerRemote () override;  Destructor. ;  ; void AddOutput (TList *out) override;  Incorporate the content of the received output list 'out' into the final output list fOutput. ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate the received object 'obj' into the output list fOutput. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (support for TChain::Draw()). ;  ; void Feedback (TList *objs) override;  Feedback signal. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:1234,feedback,feedback,1234,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['feedback'],['feedback']
Usability,"mber function virtual void Myclass::Func0() which then can be overridden in a derived class of Myclass. (See example TMhs3).; Class Myclass may also provide a method to stop the running thread:; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; Example TMhs3: Class TThreadframe (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to four threaded methods. Class TMhs3 (TMhs3.h, TMhs3.cxx) inherits from this base class, showing the mhs3 example 8.1 (mhs3.h, mhs3.cxx)within a class. The Makefile of this example builds the shared libraries libTThreadframe.so and libTMhs3.so. These are either loaded or executed by the ROOT script TMhs3demo.C, or are linked against an executable: TMhs3run.cxx.; 23.3.1 Known Problems; Parts of the ROOT framework, like the interpreter, are not yet thread-safe. Therefore, you should use this package with caution. If you restrict your threads to distinct and `simple’ duties, you will able to benefit from their use. The TThread class is available on all platforms, which provide a POSIX compliant thread implementation. On Linux, Xavier Leroy’s Linux Threads implementation is widely used, but the TThread implementation should be usable on all platforms that provide pthread.; Linux Xlib on SMP machines is not yet thread-safe. This may cause crashes during threaded graphics operations; this problem is independent of ROOT.; Object instantiation: there is no implicit locking mechanism for memory allocation and global ROOT lists. The user has to explicitly protect their code when using them.; 23.4 The Signals of ROOT; The list of default signals handled by ROOT is:; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; The signals kSigFloatingException, kSigSegmentationViolation, kSigIllegalInstruction, and kSigBus cause the printing of the *** Break *** messag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1117115,simpl,simple,1117115,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"mber function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. Bool_t CheckOperands(Int_t operation, Int_t& err); Check whether the operand at 'oper-1' is compatible with the operation; at 'oper'. Bool_t CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); Check whether the operands at 'leftoper' and 'oper-1' are compatible with; the operation at 'oper'. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void Clear(Option_t* option = """"); Resets the objects. Resets the object to its state before compilation. void ClearFormula(Option_t* option = """"); Resets the objects. Resets the object to its state before compilation. Int_t Compile(const char* expression = """"); Compile expression already stored in fTitle. Loop on all subexpressions of formula stored in fTitle. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. /*; ; */. void Copy(TObject& formula) const; Copy this formula. char * DefinedString(Int_t code);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:19902,Clear,Clear,19902,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,3,['Clear'],['Clear']
Usability,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:25920,learn,learning,25920,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['learn'],['learning']
Usability,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:26544,learn,learning,26544,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,4,['learn'],['learning']
Usability,"mberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); ~TGNumberEntryField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGTextEntry::AppendText(const char* text); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); voidTGTextEntry::Backspace(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGTextEntry::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; voidTGTextEntry::CursorLeft(Bool_t mark = kFALSE, Int_t steps = 1); virtual voidTGTextEntry::CursorOutDown()SIGNAL ; virtual voidTGTextEntry::CursorOutLeft()SIGNAL ; virtual voidTGTextEntry::CursorOutRight()SIGNAL ; virtual voidTGTextEntry::CursorOutUp()SIGNAL ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGNumberEntryField.html:4160,Clear,Clear,4160,root/html532/TGNumberEntryField.html,https://root.cern,https://root.cern/root/html532/TGNumberEntryField.html,2,['Clear'],['Clear']
Usability,"mber_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:23260,undo,undo,23260,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,10,['undo'],['undo']
Usability,"mbers ; TPadPainter Class ReferenceGraphics » 2D Graphics » Graphics pad. ; Implement TVirtualPadPainter which abstracts painting operations. ; Definition at line 26 of file TPadPainter.h. Public Member Functions;  TPadPainter ();  Empty ctor. We need it only because of explicit copy ctor. ;  ; void ClearDrawable () override;  Clear the current gVirtualX window. ;  ; void CopyDrawable (Int_t device, Int_t px, Int_t py) override;  Copy a gVirtualX pixmap. ;  ; Int_t CreateDrawable (UInt_t w, UInt_t h) override;  Create a gVirtualX Pixmap. ;  ; void DestroyDrawable (Int_t device) override;  Close the current gVirtualX pixmap. ;  ; void DrawBox (Double_t x1, Double_t y1, Double_t x2, Double_t y2, EBoxMode mode) override;  Paint a simple box. ;  ; void DrawFillArea (Int_t n, const Double_t *x, const Double_t *y) override;  Paint filled area. ;  ; void DrawFillArea (Int_t n, const Float_t *x, const Float_t *y) override;  Paint filled area. ;  ; void DrawLine (Double_t x1, Double_t y1, Double_t x2, Double_t y2) override;  Paint a simple line. ;  ; void DrawLineNDC (Double_t u1, Double_t v1, Double_t u2, Double_t v2) override;  Paint a simple line in normalized coordinates. ;  ; void DrawPixels (const unsigned char *pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending) override;  Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. ;  ; void DrawPolyLine (Int_t n, const Double_t *x, const Double_t *y) override;  Paint Polyline. ;  ; void DrawPolyLine (Int_t n, const Float_t *x, const Float_t *y) override;  Paint polyline. ;  ; void DrawPolyLineNDC (Int_t n, const Double_t *u, const Double_t *v) override;  Paint polyline in normalized coordinates. ;  ; void DrawPolyMarker (Int_t n, const Double_t *x, const Double_t *y) override;  Paint polymarker. ;  ; void DrawPolyMarker (Int_t n, const Float_t *x, const Float_t *y) override;  Paint polymarker. ;  ; void DrawText (Double_t x, Double_t y, const char *text, ETextMode mode) override; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPadPainter.html:1284,simpl,simple,1284,doc/master/classTPadPainter.html,https://root.cern,https://root.cern/doc/master/classTPadPainter.html,1,['simpl'],['simple']
Usability,"mbined viewer/scene clip (set in scene::update); Short_tTGLSceneInfo::fLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tTGLSceneInfo::fLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tTGLSceneInfo::fLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tTGLSceneInfo::fLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tTGLSceneInfo::fOLLineWOptional override of scene outline line-width; TGLSceneBase*TGLSceneInfo::fScene; UInt_tTGLSceneInfo::fSceneStampScene's time-stamp on last update.; Short_tTGLSceneInfo::fStyleOptional override of scene style; TGLBoundingBoxTGLSceneInfo::fTransformedBBox; Bool_tTGLSceneInfo::fUpdateTimeoutedSet if update was interrupted.; Bool_tTGLSceneInfo::fViewCheckViewer side check if render is necessary.; TGLViewerBase*TGLSceneInfo::fViewer; Float_tTGLSceneInfo::fWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t CmpDrawElements(const TGLScene::DrawElement_t& de1, const TGLScene::DrawElement_t& de2). void ClearDrawElementVec(TGLScene::DrawElementVec_t& vec, Int_t maxSize). void ClearDrawElementPtrVec(TGLScene::DrawElementPtrVec_t& vec, Int_t maxSize). TSceneInfo(TGLViewerBase* view = 0, TGLScene* scene = 0). virtual ~TSceneInfo(). void ClearAfterRebuild(). void ClearAfterUpdate(). void Lodify(TGLRnrCtx& ctx). void PreDraw(). void PostDraw(). void ResetDrawStats(). void UpdateDrawStats(const TGLPhysicalShape& shape, Short_t lod). void DumpDrawStats(). » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScene.h 32334 2010-02-12 11:52:13Z matevz $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLScene__TSceneInfo.html:6011,Clear,ClearDrawElementVec,6011,root/html532/TGLScene__TSceneInfo.html,https://root.cern,https://root.cern/root/html532/TGLScene__TSceneInfo.html,4,['Clear'],"['ClearAfterRebuild', 'ClearAfterUpdate', 'ClearDrawElementPtrVec', 'ClearDrawElementVec']"
Usability,"mdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvolution.html:5646,clear,clearValueDirty,5646,root/html530/RooNumConvolution.html,https://root.cern,https://root.cern/root/html530/RooNumConvolution.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t binnedL = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:4325,clear,clearValueDirty,4325,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,6,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:4280,clear,clearValueDirty,4280,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,6,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:4352,clear,clearValueDirty,4352,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,30,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:4261,clear,clearValueDirty,4261,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:4216,clear,clearValueDirty,4216,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsHiddenReal.html:3720,clear,clearValueDirty,3720,root/html532/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html532/RooAbsHiddenReal.html,3,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:4288,clear,clearValueDirty,4288,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefficients(); virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStepFunction.html:3986,clear,clearValueDirty,3986,root/html532/RooStepFunction.html,https://root.cern,https://root.cern/root/html532/RooStepFunction.html,2,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefficients(); virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStepFunction.html:4145,clear,clearValueDirty,4145,root/html534/RooStepFunction.html,https://root.cern,https://root.cern/root/html534/RooStepFunction.html,6,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitRange = kFALSE, Bool_t binnedL = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:4934,clear,clearValueDirty,4934,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,6,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet&, const char*, const char*, Int_t, RooFit::MPSplit, Bool_t, Bool_t, Bool_t); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::create",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:4540,clear,clearValueDirty,4540,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,6,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:5466,clear,clearValueDirty,5466,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,6,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& adata, const RooArgSet& projDeps, const char* = 0, const char* = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t = kFALSE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:4307,clear,clearValueDirty,4307,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,6,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNLLVar.html:4761,clear,clearValueDirty,4761,root/html532/RooNLLVar.html,https://root.cern,https://root.cern/root/html532/RooNLLVar.html,2,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet&, const char*, const char*, Int_t, Bool_t, Bool_t, Bool_t); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:4381,clear,clearValueDirty,4381,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,2,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChi2Var.html:5259,clear,clearValueDirty,5259,root/html532/RooChi2Var.html,https://root.cern,https://root.cern/root/html532/RooChi2Var.html,1,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& adata, const RooArgSet& projDeps, const char* = 0, const char* = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataWeightedAverage.html:4124,clear,clearValueDirty,4124,root/html532/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html532/RooDataWeightedAverage.html,2,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; RooArgListcomponents(); virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:3645,clear,clearValueDirty,3645,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,6,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; RooArgSetcomponents(); virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProduct.html:3591,clear,clearValueDirty,3591,root/html532/RooProduct.html,https://root.cern,https://root.cern/root/html532/RooProduct.html,2,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo1DMomentMorphFunction.html:3618,clear,clearValueDirty,3618,root/html532/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo1DMomentMorphFunction.html,72,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:3738,clear,clearValueDirty,3738,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,354,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:3667,clear,clearValueDirty,3667,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,13,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; voidcopyCacheFast(const RooRealVar& other, Bool_t setValDirty = kTRUE); static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealVar.html:4007,clear,clearValueDirty,4007,root/html534/RooRealVar.html,https://root.cern,https://root.cern/root/html534/RooRealVar.html,6,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; voidcopyCacheFast(const RooRealVar& other, Bool_t setValDirty = kTRUE); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealVar.html:3943,clear,clearValueDirty,3943,root/html532/RooRealVar.html,https://root.cern,https://root.cern/root/html532/RooRealVar.html,2,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:4599,clear,clearValueDirty,4599,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,6,['clear'],['clearValueDirty']
Usability,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealMPFE.html:4495,clear,clearValueDirty,4495,root/html532/RooRealMPFE.html,https://root.cern,https://root.cern/root/html532/RooRealMPFE.html,2,['clear'],['clearValueDirty']
Usability,"me (Int_t hour, Int_t min, Int_t sec, Bool_t emit=kTRUE);  Set the numeric value (time format). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TextChanged (const char *text=nullptr) override;  Text has changed message. ;  ;  Public Member Functions inherited from TGTextEntry;  TGTextEntry (const TGWindow *p, TGTextBuffer *text, Int_t id=-1, GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t option=kSunkenFrame|kDoubleBorder, Pixel_t back=GetWhitePixel());  Create a text entry widget. ;  ;  TGTextEntry (const TGWindow *parent=nullptr, const char *text=nullptr, Int_t id=-1);  Simple text entry constructor. ;  ;  TGTextEntry (const TString &contents, const TGWindow *parent, Int_t id=-1);  Simple test entry constructor. ;  ;  ~TGTextEntry () override;  Delete a text entry widget. ;  ; virtual void AppendText (const char *text);  Appends text to the end of text entry, clears the selection and moves the cursor to the end of the line. ;  ; void Backspace ();  Deletes the character on the left side of the text cursor and moves the cursor one position to the left. ;  ; void Clear (Option_t *option="""") override;  Clears up the text entry. ;  ; void CursorLeft (Bool_t mark=kFALSE, Int_t steps=1);  Moves the cursor leftwards one or more characters. ;  ; virtual void CursorOutDown ();  This signal is emitted when cursor is going out of bottom side. ;  ; virtual void CursorOutLeft ();  This signal is emitted when cursor is going out of left side. ;  ; virtual void CursorOutRight ();  This signal is emitted when cursor is going out of right side. ;  ; virtual void CursorOutUp ();  This signal is emitted when cursor is going out of upper side. ;  ; void CursorRight (Bool_t mark=kFALSE, Int_t steps=1);  Moves the cursor rightwards one or more characters. ;  ; void CursorWordBackward (Bool_t mark=kFALSE);  Moves the cursor one word to the left. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntryField.html:4403,clear,clears,4403,doc/master/classTGNumberEntryField.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntryField.html,1,['clear'],['clears']
Usability,"me (TGFrame *f, TGLayoutHints *hints) override;  Add frame to dockable frame container. Frame and hints are NOT adopted. ;  ; void DockContainer (Int_t del=kTRUE);  Dock container back to TGDockableFrame. ;  ; virtual void Docked ();  ; Bool_t EnableHide () const;  ; void EnableHide (Bool_t onoff);  Enable hiding. ;  ; Bool_t EnableUndock () const;  ; void EnableUndock (Bool_t onoff);  Enable undocking. ;  ; TGCompositeFrame * GetContainer () const;  ; TGUndockedFrame * GetUndocked () const;  ; void HideContainer ();  Hide dock container. ;  ; TClass * IsA () const override;  ; Bool_t IsFixedSize () const;  ; Bool_t IsHidden () const;  ; Bool_t IsUndocked () const;  ; Bool_t ProcessMessage (Longptr_t, Longptr_t, Longptr_t) override;  Process dockable frame messages. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a dockable frame widget as a C++ statement(s) on output stream out. ;  ; void SetFixedSize (Bool_t fixed);  ; void SetWindowName (const char *name) override;  Set window name so it appear as title of the undock window. ;  ; void ShowContainer ();  Show dock container. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UndockContainer ();  Undock container. ;  ; virtual void Undocked ();  ;  Public Member Functions inherited from TGCompositeFrame;  TGCompositeFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a composite frame. ;  ;  TGCompositeFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr);  Create a frame using an externally created window. ;  ;  ~TGCompositeFrame () override;  Delete a composite frame. ;  ; void ChangeOptions (UInt_t options) override;  Change composite frame options. Options is an OR of the EFrameTypes. ;  ; virtual void ChangeSubframesBackground (Pixel_t back);  Change background color for this frame and all subfr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDockableFrame.html:2067,undo,undock,2067,doc/master/classTGDockableFrame.html,https://root.cern,https://root.cern/doc/master/classTGDockableFrame.html,1,['undo'],['undock']
Usability,"me + _total"" and ""name + _passed"" respectively. ; Reimplemented from TNamed.; Definition at line 3547 of file TEfficiency.cxx. ◆ SetPassedEvents(). Bool_t TEfficiency::SetPassedEvents ; (; Int_t ; bin, . Int_t ; events . ). Sets the number of passed events in the given global bin. ; returns ""true"" if the number of passed events has been updated otherwise ""false"" ist returned; Note: - requires: 0 <= events <= fTotalHistogram->GetBinContent(bin) ; Definition at line 3566 of file TEfficiency.cxx. ◆ SetPassedHistogram(). Bool_t TEfficiency::SetPassedHistogram ; (; const TH1 & ; rPassed, . Option_t * ; opt . ). Sets the histogram containing the passed events. ; The given histogram is cloned and stored internally as histogram containing the passed events. The given histogram has to be consistent with the current fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)). The method returns whether the fPassedHistogram has been replaced (true) or not (false).; Note: The list of associated functions fFunctions is cleared.; Option:; ""f"": force the replacement without checking the consistency This can lead to inconsistent histograms and useless results or unexpected behaviour. But sometimes it might be the only way to change the histograms. If you use this option, you should ensure that the fTotalHistogram is replaced by a consistent one (with respect to rPassed) as well. . Definition at line 3597 of file TEfficiency.cxx. ◆ SetPosteriorAverage(). void TEfficiency::SetPosteriorAverage ; (; Bool_t ; on = true). inline . Definition at line 143 of file TEfficiency.h. ◆ SetPosteriorMode(). void TEfficiency::SetPosteriorMode ; (; Bool_t ; on = true). inline . Definition at line 142 of file TEfficiency.h. ◆ SetShortestInterval(). void TEfficiency::SetShortestInterval ; (; Bool_t ; on = true). inline . Definition at line 144 of file TEfficiency.h. ◆ SetStatisticOption(). void TEfficiency::SetStatisticOption ; (; EStatOption ; option). Sets the statistic option which affects the cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:109022,clear,cleared,109022,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,1,['clear'],['cleared']
Usability,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd2Editor.html:21251,undo,undoing,21251,root/html528/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html528/TGeoTrd2Editor.html,1,['undo'],['undoing']
Usability,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrd2Editor.html:21351,undo,undoing,21351,root/html530/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html530/TGeoTrd2Editor.html,1,['undo'],['undoing']
Usability,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrd2Editor.html:21351,undo,undoing,21351,root/html532/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html532/TGeoTrd2Editor.html,2,['undo'],['undoing']
Usability,"me(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); virtual~TGDockableFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* hints); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGDockableFrame.html:1775,Clear,Clear,1775,root/html532/TGDockableFrame.html,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html,2,['Clear'],['Clear']
Usability,"me) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussModel.html:3266,clear,clearEvalErrorLog,3266,root/html532/RooGaussModel.html,https://root.cern,https://root.cern/root/html532/RooGaussModel.html,6,['clear'],['clearEvalErrorLog']
Usability,"me) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussModel.html:3266,clear,clearEvalErrorLog,3266,root/html528/RooGaussModel.html,https://root.cern,https://root.cern/root/html528/RooGaussModel.html,3,['clear'],['clearEvalErrorLog']
Usability,"me) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGaussModel.html:3266,clear,clearEvalErrorLog,3266,root/html530/RooGaussModel.html,https://root.cern,https://root.cern/root/html530/RooGaussModel.html,3,['clear'],['clearEvalErrorLog']
Usability,"me) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment(const char *title) {; 2677 const char *left = strstr(title,""["");; 2678 if (left) {; 2679 const char *right = strstr(left,""]"");; 2680 if (right) {; 2681 ++left;; 2682 fComment.Append(left,right-left);; 2683 }; 2684 }; 2685 }; 2686 void Clear() {; 2687 fName.Clear();; 2688 fClassName.Clear();; 2689 fComment.Clear();; 2690 }; 2691 /* Hide this not yet used implementation to suppress warnings message; 2692 from icc 11; 2693 Bool_t operator==(const TMemberInfo &other) {; 2694 return fName==other.fName; 2695 && fClassName == other.fClassName; 2696 && fComment == other.fComment;; 2697 }; 2698 */; 2699 Bool_t operator!=(const TMemberInfo &other) {; 2700 if (fName != other.fName) return kTRUE;; 2701 if (fDataType < TStreamerInfo::kObject) {; 2702 // For simple type, let compare the data type; 2703 if (fDataType != other.fDataType) {; 2704 if ( (fDataType == 4 && other.fDataType == 16); 2705 || (fDataType == 16 && other.fDataType == 4) ) {; 2706 // long and 'long long' have the same file format; 2707 } else if ( (fDataType == 14 && other.fDataType == 17); 2708 || (fDataType == 17 && other.fDataType == 14) ) {; 2709 // unsigned long and 'unsigned long long' have the same file format; 2710 } else if ( (fDataType == 3 && other.fDataType == 6); 2711 ||(fDataType == 6 && other.fDataType == 3) ){; 2712 // Int_t and kCounter. As the switch from Int_t (3) to; 2713 // kCounter (6) might be triggered by a derived class using; 2714 // the field as an array size, the class itself has no; 2715 // control on what the field type really use.; 2716 } else {; 2717 return kTRUE;; 2718 }; 2719 }; 2720 } else if (fClassName != other.fClassName) {; 2721 if ( (fClassName == ""long"" && (other.fClassName == ""long long"" || other.fClassName == ""Long64_t""))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:107395,simpl,simple,107395,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['simpl'],['simple']
Usability,"me); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::Release(); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolume::SetAdded(); voidTGeoVolume::SetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidTGeoVolume::SetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentNodeIndex(Int_t index); voidTGeoVolume::SetCurrentPoint(Double_t x, Double_t y, Double_t z); voidTGeoVolume::SetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoVolume::SetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTGeoVolume::SetFinder(TGeoPatternFinder* finder); voidTGeoVolume::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeAssembly.html:27507,clear,clear,27507,root/html534/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeAssembly.html,6,['clear'],['clear']
Usability,"me); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::Release(); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolume::SetAdded(); voidTGeoVolume::SetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidTGeoVolume::SetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoVolume::SetCurrentPoint(Double_t x, Double_t y, Double_t z); voidTGeoVolume::SetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoVolume::SetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTGeoVolume::SetFinder(TGeoPatternFinder* finder); voidTGeoVolume::SetFWExtension(TGeoExtension* ext); vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeMulti.html:27556,clear,clear,27556,root/html534/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeMulti.html,6,['clear'],['clear']
Usability,"me, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:1995,clear,clearValueAndShapeDirty,1995,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,4,['clear'],['clearValueAndShapeDirty']
Usability,"me, Long_t address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, const char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidTChain::CanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConnectProof(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidTChain::CreatePackets(); Int_tDebug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTChain::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofChain.html:3189,Clear,Clear,3189,root/html534/TProofChain.html,https://root.cern,https://root.cern/root/html534/TProofChain.html,1,['Clear'],['Clear']
Usability,"me, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidRooAbsDataStore::dump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeDataStore.html:2489,Clear,Clear,2489,root/html534/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html,1,['Clear'],['Clear']
Usability,"me.; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments:; if either clname or obj is NULL that means that redo/undo is function; to specify default arguments for redo/undo method/function '=' must precede to argument value. Example: TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case undo parameter can be omitted.; Example: TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. Definition at line 168 of file TQCommand.cxx. ◆ TQCommand() [2/3]. TQCommand::TQCommand ; (; TObject * ; obj, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments: to specify default arguments for redo/undo method/function '=' must precede to argument value.; Example: TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case ""undo"" can parameter be omitted.; Example: TQCommand(gPad, ""SetFillStyle(Style_t)"");. Definition at line 199 of file TQCommand.cxx. ◆ TQCommand() [3/3]. TQCommand::TQCommand ; (; const TQCommand & ; com). Copy constructor. ; Definition at line 209 of file TQCommand.cxx. ◆ ~TQCommand(). TQCommand::~TQCommand ; (; ). virtual . dtor. ; Definition at line 249 of file TQCommand.cxx. Member Function Documentation. ◆ Add() [1/2]. void TQCommand::Add ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 91 of file TQCommand.h. ◆ Add() [2/2]. void TQCommand::Add ; (; TObject * ; obj, . Option_t * ; opt . ). overridevirtual . Add command to the list of merged commands. ; Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command . Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:33051,undo,undo,33051,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"me.c_str());; 5793 i->SetClass(nullptr);; 5794 i->GetElements()->Delete();; 5795 TStreamerElement *fel = R__CreateEmulatedElement(""first"", firstname, 0, silent);; 5796 Int_t size = 0;; 5797 if (fel) {; 5798 i->GetElements()->Add( fel );; 5799 ; 5800 size = fel->GetSize();; 5801 Int_t sp = sizeof(void *);; 5802 //align the non-basic data types (required on alpha and IRIX!!); 5803 if (size%sp != 0) size = size - size%sp + sp;; 5804 } else {; 5805 delete i;; 5806 return 0;; 5807 }; 5808 if (hint_pair_offset); 5809 size = hint_pair_offset;; 5810 TStreamerElement *second = R__CreateEmulatedElement(""second"", secondname, size, silent);; 5811 if (second) {; 5812 i->GetElements()->Add( second );; 5813 } else {; 5814 delete i;; 5815 return 0;; 5816 }; 5817 Int_t oldlevel = gErrorIgnoreLevel;; 5818 // Hide the warning about the missing pair dictionary.; 5819 gErrorIgnoreLevel = kError;; 5820 i->BuildCheck(nullptr, kFALSE); // Skipping the loading part (it would leads to infinite recursion on this very routine); 5821 gErrorIgnoreLevel = oldlevel;; 5822 // In the state emulated, BuildOld would recalculate the offset and undo the offset update.; 5823 // Note: we should consider adding a new state just for this (the hints indicates that we are mapping a compiled class but; 5824 // then we would have to investigate all use of the state with <= and >= condition to make sure they are still appropriate).; 5825 if (hint_pair_size) {; 5826 i->GetClass()->SetClassSize(hint_pair_size);; 5827 i->GetClass()->fIsSyntheticPair = kTRUE;; 5828 }; 5829 ; 5830 i->BuildOld();; 5831 ; 5832 if (hint_pair_size); 5833 i->GetClass()->SetClassSize(hint_pair_size);; 5834 return i;; 5835}; 5836 ; 5837TVirtualStreamerInfo *TStreamerInfo::GenerateInfoForPair(const std::string &pairclassname, bool silent, size_t hint_pair_offset, size_t hint_pair_size); 5838{; 5839 const static int pairlen = strlen(""pair<"");; 5840 if (pairclassname.compare(0, pairlen, ""pair<"") != 0) {; 5841 if (!silent); 5842 Error(""GenerateI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:233532,undo,undo,233532,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['undo'],['undo']
Usability,"me::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGUndockedFrame(const TGWindow* p = 0, TGDockableFrame* dockable = 0); Create the undocked (transient) frame. ~TGUndockedFrame(); Delete undocked frame. Puts back dockable frame in its original container. void FixSize(); Fix the size of the undocked frame so it cannot be changed via the WM. void CloseWindow(); Close undocked frame (called via WM close button). TGUndockedFrame(const TGUndockedFrame& ). TGUndockedFrame& operator=(const TGUndockedFrame& ). » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-04-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGUndockedFrame.html:22334,undo,undocked,22334,root/html534/TGUndockedFrame.html,https://root.cern,https://root.cern/root/html534/TGUndockedFrame.html,8,['undo'],['undocked']
Usability,"me::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TSessionOutputFrame. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h). TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionOutputFrame.html:19805,feedback,feedback,19805,root/html602/TSessionOutputFrame.html,https://root.cern,https://root.cern/root/html602/TSessionOutputFrame.html,4,['feedback'],['feedback']
Usability,"me::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDockableFrame.html:21826,Undo,UndockContainer,21826,root/html602/TGDockableFrame.html,https://root.cern,https://root.cern/root/html602/TGDockableFrame.html,4,['Undo'],"['Undock', 'UndockContainer']"
Usability,"me_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSplitFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0); Default constructor. ~TGSplitFrame(); Destructor. Make cleanup. void AddFrame(TGFrame* f, TGLayoutHints* l = 0); Add a frame in the split frame using layout hints l. void RemoveFrame(TGFrame* f); Add a frame in the split frame using layout hints l. void Cleanup(); Recursively cleanup child frames. TGSplitFrame * GetTopFrame(); Return the top level split frame. void Close(); Close (unmap and remove from the list of frames) the frame contained in; this split frame. void CloseAndCollapse(); Close (unmap, remove from the list of frames and destroy) the frame; contained in this split frame. Then unsplit the parent frame. void Docked(TGFrame* frame); Emit Undocked() signal. void ExtractFrame(); Extract the frame contained in this split frame an reparent it in a; transient frame. Keep a pointer on the transient frame to be able to; swallow the child frame back to this. Bool_t HandleConfigureNotify(Event_t* ); Handles resize events for this frame.; This is needed to keep as much as possible the sizes ratio between; all subframes. void HSplit(UInt_t h = 0); Horizontally split the frame. void VSplit(UInt_t w = 0); Vertically split the frame. void MapToSPlitTool(TGSplitFrame* top); Map this split frame in the small overview tooltip. void OnSplitterClicked(Event_t* event); Handle mouse click events on the splitter. void SplitHor(); Horizontally split the frame, and if it contains a child frame, ask; the user where to keep it (top or bottom). This is the method used; via the context menu. void SplitHorizontal(const char* side = ""top""); Horizontally split the frame, and if it contains a child frame, ask; the user where to keep it (top o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGSplitFrame.html:20624,Undo,Undocked,20624,root/html532/TGSplitFrame.html,https://root.cern,https://root.cern/root/html532/TGSplitFrame.html,2,['Undo'],['Undocked']
Usability,"mechanism can be used on an histogram. ;  ;  hlHisto3.C;  This tutorial demonstrates how the highlight mechanism can be used on a ntuple. ;  ;  hlHisto4.C;  This tutorial demonstrates how the highlight mechanism can be used on an histogram. ;  ;  hstack.C;   Example of stacked histograms: class THStack. ;  ;  hstackpads.C;   Drawing stack histograms on subpads. ;  ;  hsum.C;   Histograms filled and drawn in a loop. ;  ;  hsumTimer.C;   Demo of Timers. ;  ;  legendautoplaced.C;   The legend can be placed automatically in the current pad in an empty space found at painting time. ;  ;  logscales.C;   Draw parametric functions with log scales. ;  ;  movepalette.C;   When an histogram is drawn with the option COLZ, a palette is automatically drawn vertically on the right side of the plot. ;  ;  multicolor.C;   Use a THStack to show a 2-D hist with cells with different colors. ;  ;  NormalizeHistogram.C;   Normalizing a Histogram ;  ;  ratioplot1.C;   Example creating a simple ratio plot of two histograms using the pois division option. ;  ;  ratioplot1.py;   Example creating a simple ratio plot of two histograms using the pois division option. ;  ;  ratioplot2.C;   Example of a fit residual plot. ;  ;  ratioplot2.py;   Example of a fit residual plot. ;  ;  ratioplot3.C;   Example which shows how you can get the graph of the lower plot and set the y axis range for it. ;  ;  ratioplot3.py;   Example which shows how you can get the graph of the lower plot and set the y axis range for it. ;  ;  ratioplot4.C;   Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ;  ;  ratioplot4.py;   Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ;  ;  ratioplot5.C;   Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ;  ;  ratioplot5.py;   Example that shows how you can set the colors of the confidence interval bands by us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:3512,simpl,simple,3512,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,1,['simpl'],['simple']
Usability,"members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::MultiBuildConfig. class RooSimWSTool::MultiBuildConfig: public RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__MultiBuildConfig.html:1139,simpl,simple,1139,root/html534/RooSimWSTool__MultiBuildConfig.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__MultiBuildConfig.html,6,['simpl'],['simple']
Usability,"memory costly logical shapes, and retaining/discarding the physical placements as required. The viewer may decide to force the client to rebuild (republish) the scene (via a TPad repaint at present), and thus collect these objects if the internal viewer state changes. It does this presently by forcing a repaint on the attached TPad object - hence the reason for putting all publishing to the viewer in the attached pad objects Paint() method. We will likely remove this requirement in the future, indicating the rebuild request via a normal ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; bool; unsigned int; If you use the first (simple) case a viewer using logical/physical pairs SetSectionsValid(TBuffer3D::kBoundingBox); will generate IDs for each physical object internally. In the second you can specify a unique identifier from the client, which allows the viewer to be more efficient. It can now cache both logical and physical objects, and only discard physical objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of descendents. Both AddObject() methods have an addChildren parameter. The viewer will complete this (if passed) indicating if children (contained within the one just sent) are worth adding. Recycling TBuffer3D; Once add AddObject() has been called, the contents are copied to the viewer internally. You are free to destroy this object, or recycle it for the next object if suitable. ; Definition at line 17 of file TBuffer3D.h. Public",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer3D.html:8443,simpl,simple,8443,doc/master/classTBuffer3D.html,https://root.cern,https://root.cern/doc/master/classTBuffer3D.html,1,['simpl'],['simple']
Usability,"memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * If the objects are added using the placement new then the Clear ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClonesArray.html:3313,Clear,Clear,3313,root/html604/TClonesArray.html,https://root.cern,https://root.cern/root/html604/TClonesArray.html,1,['Clear'],['Clear']
Usability,"memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:3313,Clear,Clear,3313,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,3,['Clear'],['Clear']
Usability,"ment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:53130,simpl,simple,53130,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"ment* parent); virtual voidTEveElement::AddParent(TEveElement* re); virtual voidAddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveSceneInfo.html:1917,Clear,Clear,1917,root/html532/TEveSceneInfo.html,https://root.cern,https://root.cern/root/html532/TEveSceneInfo.html,4,['Clear'],['Clear']
Usability,"ment. ;  ; Bool_t GetDestroyOnZeroRefCnt () const;  Returns state of flag determining if the element will be destroyed when reference count reaches zero. ;  ; virtual TObject * GetEditorObject (const TEveException &eh) const;  ; virtual TString GetHighlightTooltip ();  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual const TGPicture * GetListTreeIcon (Bool_t open=kFALSE);  Returns pointer to first listtreeicon. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; virtual Bool_t HandleElementPaste (TEveElement *el);  React to element being pasted or dnd-ed. ;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveGeoNode.html:10507,feedback,feedback,10507,doc/master/classTEveGeoNode.html,https://root.cern,https://root.cern/doc/master/classTEveGeoNode.html,2,['feedback'],['feedback']
Usability,"mentation; ~TEveWindow(); Destructor. void PreDeleteElement(); Called before the element is deleted, thus offering the last chance; to detach from acquired resources and from the framework itself.; Here the request is just passed to TEveManager.; If you override it, make sure to call base-class version. void PreUndock(); Virtual function called before a window is undocked. void PostDock(); Virtual function called after a window is docked. void NameTitleChanged(); Name or title of the window changed - propagate to frames.; Virtual from TEveElement. void PopulateEmptyFrame(TEveCompositeFrame* ef); Populate given frame-slot - intended for initial population; of a new slot or low-level window-swapping.; No layout or window-mapping is done. void SwapWindow(TEveWindow* w); Swap frames with the given window. void SwapWindowWithCurrent(); Swap frames with the current window. void UndockWindow(); Undock the window - put it into a dedicated main-frame. void UndockWindowDestroySlot(); Undock the window - put it into a dedicated main-frame.; The old window slot is destroyed. void ReplaceWindow(TEveWindow* w); Replace this window with the passed one.; Eve parentship is properly handled.; This will most likely lead to the destruction of this window.; Layout is called on the frame. void DestroyWindow(); Destroy eve-window - replace it with an empty frame-slot. void DestroyWindowAndSlot(); Destroy eve-window and its frame-slot. void ClearEveFrame(); Clears eve-frame associated with this window.; This is used in special case when the window is embedded in a foreign; GUI container and gets deleted from this side.; In particular, this happens when TRootBrowser closes a tab. void SetShowTitleBar(Bool_t x); Set display state of the title-bar.; This is forwarded to eve-frame. Bool_t IsCurrent() const; Returns true if this window is the current one. void MakeCurrent(); Make this window current. void SetCurrent(Bool_t curr); Set current state of this eve-window.; Protected method - called ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveWindow.html:22109,Undo,UndockWindowDestroySlot,22109,root/html532/TEveWindow.html,https://root.cern,https://root.cern/root/html532/TEveWindow.html,4,['Undo'],"['Undock', 'UndockWindowDestroySlot']"
Usability,"mented from TGFrame.; Reimplemented in TGVProgressBar.; Definition at line 90 of file TGProgressBar.h. ◆ Percent(). virtual void TGProgressBar::Percent ; (; Bool_t ; on). inlinevirtual . Reimplemented in TGVProgressBar.; Definition at line 78 of file TGProgressBar.h. ◆ Reset(). void TGProgressBar::Reset ; (; ). virtual . Reset progress bar (i.e. set pos to 0). ; Definition at line 126 of file TGProgressBar.cxx. ◆ SavePrimitive(). void TGProgressBar::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save progress bar parameters as a C++ statement(s) on output stream out. ; Reimplemented from TGFrame.; Reimplemented in TGVProgressBar.; Definition at line 396 of file TGProgressBar.cxx. ◆ SetBarColor() [1/2]. void TGProgressBar::SetBarColor ; (; const char * ; color = ""blue""). Set progress bar color. ; Definition at line 166 of file TGProgressBar.cxx. ◆ SetBarColor() [2/2]. void TGProgressBar::SetBarColor ; (; Pixel_t ; color). virtual . Set progress bar color. ; Definition at line 156 of file TGProgressBar.cxx. ◆ SetBarType(). void TGProgressBar::SetBarType ; (; EBarType ; type). Set bar type. ; Definition at line 146 of file TGProgressBar.cxx. ◆ SetFillType(). void TGProgressBar::SetFillType ; (; EFillType ; type). Set fill type. ; Definition at line 136 of file TGProgressBar.cxx. ◆ SetForegroundColor(). void TGProgressBar::SetForegroundColor ; (; Pixel_t ; pixel). overridevirtual . Change text color drawing. ; Reimplemented from TGFrame.; Definition at line 207 of file TGProgressBar.cxx. ◆ SetMax(). void TGProgressBar::SetMax ; (; Float_t ; max). inline . Definition at line 82 of file TGProgressBar.h. ◆ SetMin(). void TGProgressBar::SetMin ; (; Float_t ; min). inline . Definition at line 81 of file TGProgressBar.h. ◆ SetPosition(). void TGProgressBar::SetPosition ; (; Float_t ; pos). Set progress position between [min,max]. ; Definition at line 92 of file TGProgressBar.cxx. ◆ SetRange(). void TGProgressBar::SetRange ; (; Float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGProgressBar.html:35210,progress bar,progress bar,35210,doc/master/classTGProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGProgressBar.html,1,['progress bar'],['progress bar']
Usability,"mented in TGVProgressBar.; Definition at line 79 of file TGProgressBar.h. ◆ Streamer(). void TGProgressBar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGFrame.; Reimplemented in TGVProgressBar. ◆ StreamerNVirtual(). void TGProgressBar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 90 of file TGProgressBar.h. ◆ UsePercent(). Bool_t TGProgressBar::UsePercent ; (; ); const. inline . Definition at line 68 of file TGProgressBar.h. Member Data Documentation. ◆ fBarColorGC. TGGC TGProgressBar::fBarColorGC. protected . progress bar drawing context ; Definition at line 39 of file TGProgressBar.h. ◆ fBarType. EBarType TGProgressBar::fBarType. protected . OPTION={GetMethod=""GetBarType"";SetMethod=""SetBarType"";Items=(kStandard=""Standard"",kFancy=""Fancy"")} ; Definition at line 34 of file TGProgressBar.h. ◆ fBarWidth. Int_t TGProgressBar::fBarWidth. protected . progress bar width ; Definition at line 32 of file TGProgressBar.h. ◆ fDrawBar. Bool_t TGProgressBar::fDrawBar. protected . if true draw only bar in DoRedraw() ; Definition at line 38 of file TGProgressBar.h. ◆ fFillType. EFillType TGProgressBar::fFillType. protected . OPTION={GetMethod=""GetFillType"";SetMethod=""SetFillType"";Items=(kSolidFill=Solid"",kBlockFill=""Block"")} ; Definition at line 33 of file TGProgressBar.h. ◆ fFontStruct. FontStruct_t TGProgressBar::fFontStruct. protected . font used to draw position text ; Definition at line 41 of file TGProgressBar.h. ◆ fFormat. TString TGProgressBar::fFormat. protected . format used to show position not in percent ; Definition at line 35 of file TGProgressBar.h. ◆ fgDefaultFont. const TGFont * TGProgressBar::fgDefaultFont = nullptr. staticprotected . Definition at line 45 of file TGProgressBar.h. ◆ fgDefaultGC. TGGC * TGProgressBar::fgDefaultGC = nullptr. staticprotected . Definition at line 46 of file TGProgressBar.h. ◆ fMax. Float_t TGProgressBar::fMax. protected . log",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGProgressBar.html:37391,progress bar,progress bar,37391,doc/master/classTGProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGProgressBar.html,1,['progress bar'],['progress bar']
Usability,"ments the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines the analytical integral translation for the class. ;  ; TObject * clone (const char *newname) const override;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; TClass * IsA () const override;  ; void selectNormalizationRange (const char *rangeName=nullptr, bool force=false) override;  Interface function to force use of a given normalization range to interpret function value. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChebychev.html:2105,simpl,simple,2105,doc/master/classRooChebychev.html,https://root.cern,https://root.cern/doc/master/classRooChebychev.html,1,['simpl'],['simple']
Usability,"ments(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveElementList.html:2417,Clear,ClearProjectedList,2417,root/html532/TEveElementList.html,https://root.cern,https://root.cern/root/html532/TEveElementList.html,4,['Clear'],['ClearProjectedList']
Usability,"ments(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConnect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveViewerList.html:2247,Clear,ClearProjectedList,2247,root/html532/TEveViewerList.html,https://root.cern,https://root.cern/root/html532/TEveViewerList.html,4,['Clear'],['ClearProjectedList']
Usability,"ments(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrackList.html:2359,Clear,ClearProjectedList,2359,root/html532/TEveTrackList.html,https://root.cern,https://root.cern/root/html532/TEveTrackList.html,4,['Clear'],['ClearProjectedList']
Usability,"ments(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveElementListProjected.html:2306,Clear,ClearProjectedList,2306,root/html532/TEveElementListProjected.html,https://root.cern,https://root.cern/root/html532/TEveElementListProjected.html,12,['Clear'],['ClearProjectedList']
Usability,"ments(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveTrackList::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrackListProjected.html:2269,Clear,ClearProjectedList,2269,root/html532/TEveTrackListProjected.html,https://root.cern,https://root.cern/root/html532/TEveTrackListProjected.html,4,['Clear'],['ClearProjectedList']
Usability,"ments(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidCloseCompound(); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCompound.html:2249,Clear,ClearProjectedList,2249,root/html532/TEveCompound.html,https://root.cern,https://root.cern/root/html532/TEveCompound.html,4,['Clear'],['ClearProjectedList']
Usability,"ments(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTEveCompound::CloseCompound(); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCompoundProjected.html:2230,Clear,ClearProjectedList,2230,root/html532/TEveCompoundProjected.html,https://root.cern,https://root.cern/root/html532/TEveCompoundProjected.html,4,['Clear'],['ClearProjectedList']
Usability,"mepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetM2() const; Double_tGetMean() const; Double_tGetMeanErr() const; Long64_tGetN() const; virtual const char*GetName() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStatistic.html:696,Clear,Clear,696,root/html604/TStatistic.html,https://root.cern,https://root.cern/root/html604/TStatistic.html,1,['Clear'],['Clear']
Usability,"mepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » BINDINGS; » PYROOT; » TPyMultiGenFunction. class TPyMultiGenFunction: public ROOT::Math::IBaseFunctionMultiDim. Python wrapper for Fit functions. Function Members (Methods); public:. TPyMultiGenFunction(PyObject* self = 0); virtual~TPyMultiGenFunction(); static TClass*Class(); virtual ROOT::Math::IBaseFunctionMultiDim*Clone() const; virtual doubleDoEval(const double* x) const; virtual TClass*IsA() const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TPyMultiGenFunction(const TPyMultiGenFunction& src); TPyMultiGenFunction&operator=(const TPyMultiGenFunction&). Data Members; private:. PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyMultiGenFunction(PyObject* self = 0); Construct a TPyMultiGenFunction derived with <self> as the underlying. ~TPyMultiGenFunction(); Destructor. Only deref if still holding on to Py_None (circular otherwise). unsigned int NDim() const; Simply forward the call to python self. double DoEval(const double* x) const; Simply forward the call to python self. TPyMultiGenFunction(PyObject* self = 0); ctor/dtor, and assignment. ROOT::Math::IBaseFunctionMultiDim* Clone() const; Math::IMultiGenFunction implementation. { return new TPyMultiGenFunction( fPySelf ); }. TPyMultiGenFunction& operator=(const TPyMultiGenFunction& ); { return *this; }. » Last changed: Sat Mar 14 16:47:58 2015 » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPyMultiGenFunction.html:1408,Simpl,Simply,1408,root/html534/TPyMultiGenFunction.html,https://root.cern,https://root.cern/root/html534/TPyMultiGenFunction.html,2,['Simpl'],['Simply']
Usability,"mepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualViewer3D. class TVirtualViewer3D: public TObject. TVirtualViewer3D. Abstract 3D shapes viewer. The concrete implementations are:. TViewerX3D : X3d viewer; TGLViewer : OpenGL viewer. ; 3D Viewer Infrastructure Overview; The 3D Viewer infrastructure consists of:. TVirtualViewer3D interface: An abstract handle to the viewer, allowing; client to test preferences, add objects, control the viewer via scripting; (to be added) etc.; TBuffer3D class hierarchy: Used to describe 3D objects; (""shapes""); - filled /added by negotiation with viewer via TVirtualViewer3D. Together these allow clients to publish objects to any one of the 3D viewers; (currently OpenGL/x3d,TPad), free of viewer specific drawing code. They allow; our simple x3d viewer, and considerably more sophisticated OpenGL one to both; work with both geometry libraries (g3d and geom) efficiently.; Publishing to a viewer consists of the following steps:. Create / obtain viewer handle; Begin scene on viewer; Fill mandatory parts of TBuffer3D describing object; Add to viewer; Fill optional parts of TBuffer3D if requested by viewer, and add again; ... repeat 3/4/5; as required; End scene on viewer. Creating / Obtaining Viewer; Create/obtain the viewer handle via local/global pad - the viewer is always; bound to a TPad object at present [This may be removed as a restriction in; the future] . You should perform the publishing to the viewer described below; in the Paint() method of the object you attach to the pad (via Draw()); TVirtualViewer3D * v = gPad->GetViewer3D(""xxxx"");; "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or; Pad ""pad"" (default). The viewer is created via the plugin manager,; attached to pad, and the interface returned.; Begin / End Scene; Objects must be added to viewer between BeginScene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:982,simpl,simple,982,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['simpl'],['simple']
Usability,"merNVirtual_b). protected:. TGText(const TGText&); voidInit(); voidLongestLine(); TGText&operator=(const TGText&); Bool_tSetCurrentRow(Long_t row). Data Members; protected:. Long_tfColCountnumber of columns in current line; TGTextLine*fCurrentcurrent line; Long_tfCurrentRowcurrent row number; TStringfFilenamename of opened file ("""" if open buffer); TGTextLine*fFirstfirst line of text; Bool_tfIsSavedfalse if text needs to be saved; Long_tfLongestLinelength of longest line; Long_tfRowCountnumber of rows. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGText(const TGText& ); copy constructor. TGText& operator=(const TGText& ); assignment operator. void Init(); Common initialization method. TGText(); Create default (empty) text buffer. TGText(TGText* text); Create text buffer and initialize with other text buffer. TGText(const char* string); Create text buffer and initialize with single line string. ~TGText(); Destroy text buffer. void Clear(); Clear text buffer. Bool_t Load(const char* fn, Long_t startpos = 0, Long_t length = -1); Load text from file fn. Startpos is the begin from where to; load the file and length is the number of characters to read; from the file. Bool_t LoadBuffer(const char* txtbuf); Load a 0 terminated buffer. Lines will be split at '\n'. Bool_t Save(const char* fn); Save text buffer to file fn. Bool_t Append(const char* fn); Append buffer to file fn. Bool_t DelChar(TGLongPosition pos); Delete character at specified position pos. Bool_t InsChar(TGLongPosition pos, char c); Insert character c at the specified position pos. char GetChar(TGLongPosition pos); Get character a position pos. If charcater not valid return -1. Bool_t DelText(TGLongPosition start, TGLongPosition end); Delete text between start and end positions. Returns false in; case of failure (start and end not being within bounds). Bool_t InsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); Insert src ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGText.html:2946,Clear,Clear,2946,root/html534/TGText.html,https://root.cern,https://root.cern/root/html534/TGText.html,2,['Clear'],['Clear']
Usability,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMath.html:33612,Simpl,Simple,33612,root/html532/TMath.html,https://root.cern,https://root.cern/root/html532/TMath.html,4,['Simpl'],['Simple']
Usability,"meters(const Double_t *params)Definition TF1.h:677; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveStatsThe histogram statistics painter class.Definition TPaveStats.h:18; TPaveStats::SetOptStatvoid SetOptStat(Int_t stat=1)Set the stat option.Definition TPaveStats.cxx:30",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxy_8C.html:13563,simpl,simple,13563,doc/master/h1analysisProxy_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisProxy_8C.html,1,['simpl'],['simple']
Usability,"method returns the shifts of the unfolding result induced by varying the identified systematic source by one sigma. ; the array binMap is explained with the method GetOutput(). ; Definition at line 1027 of file TUnfoldSys.cxx. ◆ GetDeltaSysTau(). Bool_t TUnfoldSys::GetDeltaSysTau ; (; TH1 * ; hist_delta, . const Int_t * ; binMap = nullptr . ). correlated one-sigma shifts from shifting tau ; Parameters. [out]hist_deltahistogram to store shifts ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins. returns true if the background source was found. ; This method returns the shifts of the unfolding result induced by varying the normalisation of the identified background by one sigma. ; the array binMap is explained with the method GetOutput(). ; Definition at line 1086 of file TUnfoldSys.cxx. ◆ GetEmatrixFromVyy(). void TUnfoldSys::GetEmatrixFromVyy ; (; const TMatrixDSparse * ; vyy, . TH2 * ; ematrix, . const Int_t * ; binMap, . Bool_t ; clearEmat . ). protected . propagate an error matrix on the input vector to the unfolding result ; Parameters. [in]vyyinput error matrix ; [in,out]ematrixhistogram to be updated ; [in]binMapmapping of histogram bins ; [in]clearEmatif set, clear histogram before adding this covariance contribution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:37159,clear,clearEmat,37159,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void setExpectedData(Bool_t ); {}. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Sat Sep 5 17:28:33 2015 » Last generated: 2015-09-05 17:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsGenContext.html:12108,clear,clear,12108,root/html604/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html604/RooAbsGenContext.html,2,['clear'],['clear']
Usability,"metry MDI Geometry; TGMdiHorizontalWinResizer Horizontal Window Resizer; TGMdiMainFrame MDI main frame; TGMdiMenuBar MDI menu bar; TGMdiTitleBar MDI Title Bar; TGMdiTitleIcon MDI Title Icon; TGMdiVerticalWinResizer Vertical Window Resizer; TGMdiWinResizer Window Resizer; TGMenuBar Menu bar class; TGMenuEntry Menu entry class; TGMenuTitle Menu title class; TGMimeTypes Pool of mime type objects; TGMsgBox A message dialog box; TGNumberEntry Entry field widget for several numeric formats; TGNumberEntryField A text entry field used by a TGNumberEntry; TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider wid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:86599,Progress bar,Progress bar,86599,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,['Progress bar'],['Progress bar']
Usability,"mi-interactive work with large amounts of data. They ended up re-implementing a full Totem analysis in a declarative fashion using RDataFrame and distributing their calculations over a big Spark cluster with PyRDF.; Check it out on CDS! . 30-01-2019 ; More tests, more benchmarks! ; ROOT relies on testing, including performance testing - and we need to improve both.; . 30-01-2019 ; Better argument parsing ; Use a C++ command line argument library for defining and parsing ROOT's options.; . 30-01-2019 ; Transform GNU-makefile tests to CMake ; ROOT's test suite has several crucial tests that still try on GNU-Makefile. We need to integrate them with CMake.; . 11-07-2018 ; RDataFrame session at CHEP 2018 ; Join the CHEP 2018 BOF to discuss bout the Future of ROOT Based Analysis: sign up here and visit the indico agenda.; Too much data? Too many cores? TTree analysis is tedious? Come and enjoy an intro plus discussion of RDataFrame, ROOT's current-generation way of writing super-efficient analyses! It moves all the intricacies into ROOT's responsibility, leaving you simply with a declarative formulation of the filters and computations that make up your analysis.; . 17-01-2018 ; ROOT Users' Workshop 2018 ; The ROOT team would like to invite you to the 11th ROOT Users' Workshop. This time we meet in Sarajevo, the capital of Bosnia and Herzegovina -; a buzzing melting pot of cultures since centuries.; The workshop features four days of presentations and discussions on everything ROOT:; what works for you, what doesn't and how ROOT evolves to address future challenges.; ROOT is changing; this is your chance to influence what happens and to interact with all its developers!; Our way of saying ""thank you for participating"" is to make sure that you have a great time in a unique location! . 03-08-2017 ; The ROOT Docker container (alpha version) ; Do you like Docker? Would you like to use ROOT? We provide an alpha version of the ROOT Docker container!; . 08-03-2017 ; Development r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/news.html:3254,simpl,simply,3254,d/news.html,https://root.cern,https://root.cern/d/news.html,1,['simpl'],['simply']
Usability,"mid : internal model id (really, you should not use this method at all); sde : efficiency estimate's standard deviation; sdb : background estimate's standard deviation; tau : ratio parameter (read TRolke.cxx for details); b : background expectation value (considered known); m : number of MC events generated. void SetModelParameters(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m). x : number of observed events in the experiment; y : number of observed events in background region; z : number of MC events observed; bm : estimate of the background; em : estimate of the efficiency; e : true efficiency (considered known); mid : internal model id; sde : efficiency estimate's standard deviation; sdb : background estimate's standard deviation; tau : ratio parameter (read TRolke.cxx for details); b : background expectation value (considered known); m : number of MC events generated. void SetModelParameters(); Clear internal model. Double_t ComputeInterval(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m). ComputeInterval, the internals.; x : number of observed events in the experiment; y : number of observed events in background region; z : number of MC events observed; bm : estimate of the background; em : estimate of the efficiency; e : true efficiency (considered known); mid : internal model id (really, you should not use this method at all); sde : efficiency estimate's standard deviation; sdb : background estimate's standard deviation; tau : ratio parameter (read TRolke.cxx for details); b : background expectation value (considered known); m : number of MC events generated. Double_t Interval(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m). Internal helper function 'Interval'. x : number of observed events i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRolke.html:20054,Clear,Clear,20054,root/html532/TRolke.html,https://root.cern,https://root.cern/root/html532/TRolke.html,4,['Clear'],['Clear']
Usability,"min = gPad->GetUxmin();; 432 xmax = gPad->GetUxmax();; 433 ymin = gPad->GetUymin();; 434 ymax = gPad->GetUymax();; 435 dx = xmax-xmin;; 436 dy = ymax-ymin;; 437 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 438 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 439 ; 440 // Range() could change the size of the pad pixmap and therefore should; 441 // be called before the other paint routines; 442 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 443 ymin - dyr*gPad->GetBottomMargin(),; 444 xmax + dxr*gPad->GetRightMargin(),; 445 ymax + dyr*gPad->GetTopMargin());; 446 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 447 ; 448 if (!x.empty() && !y.empty()) {; 449 if (middle) {; 450 for(i=0;i<np;i++) {; 451 fX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 452 fY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 453 }; 454 } else {; 455 fX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 456 fY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 457 }; 458 x.clear();; 459 y.clear();; 460 }; 461 gPad->Modified(kTRUE);; 462 gVirtualX->SetLineColor(-1);; 463 }; 464}; 465 ; 466////////////////////////////////////////////////////////////////////////////////; 467/// List this polyline with its attributes.; 468/// The option string is ignored.; 469 ; 470void TPolyLine::ls(Option_t *) const; 471{; 472 TROOT::IndentLevel();; 473 printf(""TPolyLine N=%d\n"",fN);; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// Merge polylines in the collection in this polyline; 478 ; 479Int_t TPolyLine::Merge(TCollection *li); 480{; 481 if (!li) return 0;; 482 TIter next(li);; 483 ; 484 //first loop to count the number of entries; 485 TPolyLine *pl;; 486 Int_t npoints = 0;; 487 while ((pl = (TPolyLine*)next())) {; 488 if (!pl->InheritsFrom(TPolyLine::Class())) {; 489 Error(""Add"",""Attempt to add object of class: %s to a %s"",pl->ClassName(),this->ClassName());; 490 return -1;; 491 }; 492 npoints += pl->Size();; 493 }; 494 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPolyLine_8cxx_source.html:14924,clear,clear,14924,doc/master/TPolyLine_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html,1,['clear'],['clear']
Usability,"min, double xmax, double ymin, double ymax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. void GetInfRange(double& x1, double& x2); get the full range (-inf, +inf). » Author: L. Moneta Wed Aug 30 11:05:02 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__DataRange.html:6080,clear,clear,6080,root/html602/ROOT__Fit__DataRange.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__DataRange.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"min, double xmax, double ymin, double ymax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. void GetInfRange(double& x1, double& x2); get the full range (-inf, +inf). » Author: L. Moneta Wed Aug 30 11:05:02 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__DataRange.html:6080,clear,clear,6080,root/html534/ROOT__Fit__DataRange.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataRange.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"min, double xmax, double ymin, double ymax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. void GetInfRange(double& x1, double& x2); get the full range (-inf, +inf). » Author: L. Moneta Wed Aug 30 11:05:02 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__DataRange.html:6080,clear,clear,6080,root/html604/ROOT__Fit__DataRange.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__DataRange.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"mitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. Long64_t Merge(TCollection* , TFileMerg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQCommand.html:19634,undo,undo,19634,root/html530/TQCommand.html,https://root.cern,https://root.cern/root/html530/TQCommand.html,9,['undo'],['undo']
Usability,"mitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:19461,undo,undo,19461,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,1,['undo'],['undo']
Usability,"mization of the output should be done; with THtml's interfaces - TDocOutput should not be used nor re-implemented; directly. TDocOutput generates the index tables:; * classes (THtml invokes TClassDocOutput for each),; * inheritance hierarchy,; * types and typedefs,; * libraries,; * the product index, and; * the module index (including the links to per-module documentation).; It invokes AT&T's GraphViz tool (dot) if available; charts benefit a lot; from it. TDocOutput also writes all pages' header and footer, which can be customized; by calling THtml::SetHeader(), THtml::SetFooter(). Function Members (Methods); public:. virtual~TDocOutput(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustSourcePath(TString& line, const char* relpath = ""../""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConvert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tCopyHtmlFile(const char* sourceName, const char* destName = """"); virtual voidCreateClassIndex(); virtual voidCreateClassTypeDefs(); virtual voidCreateHierarchy(); virtual voidCreateModuleIndex(); virtual voidCreateProductIndex(); virtual voidCreateTypeIndex(); virtual voidDecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidDecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::Dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDocOutput.html:1362,Clear,Clear,1362,root/html602/TDocOutput.html,https://root.cern,https://root.cern/root/html602/TDocOutput.html,2,['Clear'],['Clear']
Usability,"mizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are set separately when calling Fitter::CalculateMinosErrors(); 211 ; 212 // globalCC; 213 fGlobalCC.reserve(npar);; 214 for (unsigned int i = 0; i < npar; ++i) {; 215 double globcc = min->GlobalCC(i);; 216 if (globcc < 0) break; // it is not supported by that minimizer; 217 fGlobalCC.push_back(globcc);; 218 }; 219 ; 220 }; 221 ; 222}; 223 ; 224bool FitResult::Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls) {; 225 // update fit result with new status from minimizer; 226 // ncalls if it is not zero is used instead of value from minimizer; 227 ; 228 fMinimizer = min;; 229 ; 230 // in case minimizer changes; 231 fMinimTy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:6924,clear,clear,6924,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['clear'],['clear']
Usability,"mizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDim; intfErrorCode; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char * type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const Minuit2Minimizer &); usually copying is non trivial, so we make this unaccessible. Copy constructor. void Clear(); clear resources (parameters) for consecutives minimizations. void SetFunction(const ROOT::Math::IMultiGenFunction & func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction & func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableVal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html:5489,clear,clear,5489,root/html526/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html,1,['clear'],['clear']
Usability,"mmand.h. ◆ Compress(). void TQCommand::Compress ; (; TQCommand * ; c). virtual . Compress command. ; Compression is analogous to arithmetic ""addition operation"".; Note:; The compressed command will be deleted.; Execution Compress method invokes Redo action with new redo arguments inherited from compressed command. More complicated commands might want to override this function. ; Definition at line 402 of file TQCommand.cxx. ◆ DeclFileName(). static const char * TQCommand::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 98 of file TQCommand.h. ◆ Delete(). void TQCommand::Delete ; (; Option_t * ; opt = """"). overridevirtual . If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ; If ""opt"" is zero - delete all merged commands. ; Reimplemented from TList.; Definition at line 285 of file TQCommand.cxx. ◆ GetCommand(). TQCommand * TQCommand::GetCommand ; (; ). static . Return a command which is doing redo/undo action. ; This static method allows to set undo parameters dynamically, i.e. during execution of Redo function.; Example: For redo actions like TGTextEdit::DelChar() it is not possible to know ahead what character will be deleted. To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)), one needs to call TQCommand::SetUndoArgs(1, character) from inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);; TQCommand::GetCommandstatic TQCommand * GetCommand()Return a command which is doing redo/undo action.Definition TQCommand.cxx:276. Definition at line 276 of file TQCommand.cxx. ◆ GetName(). const char * TQCommand::GetName ; (; ); const. overridevirtual . Returns the command name. ; Default name is ""ClassName::RedoName(args)"" If list of merged commands is not empty the name is ""ClassName::RedoName(args):cname1:cname2 ..."" ; Reimplemented from TCollection.; Definition at line 670 of file TQCommand.cxx. ◆ GetNRargs(). Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:36602,undo,undo,36602,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"mmands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Returns the name of redo command. ;  ; Int_t GetStatus () const;  Returns a number of sequential undo or redo operations. ;  ; const char * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo parameters. ;  ; virtual void SetName (const char *name);  Sets name of the command. ;  ; virtual void SetRedoArgs (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:3495,undo,undo,3495,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"mn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTreeDataStore.html:17033,clear,clear,17033,root/html528/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html528/RooTreeDataStore.html,2,['clear'],['clear']
Usability,"mn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree(); { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). void setBranchBufferSize(Int_t size); TTree Branch buffer size contro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:16959,clear,clear,16959,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,1,['clear'],['clear']
Usability,"modified/protected for the case; when a TProfile is projected (ProjectionX). The previous algorithm; generated a N^2 problem when projecting a TProfile with a large number of; bins (eg 100000).; - in version 3.05/06, a new static function TProfile::Approximate; is introduced to enable or disable (default) the approximation. Ideas for improvements of this algorithm are welcome. No suggestions; received since our call for advice to roottalk in Jul 2002.; see for instance: http://root.cern.ch/root/roottalk/roottalk02/2916.html. Option_t * GetErrorOption() const; -*Return option to compute profile errors; *-* =======================================. void GetStats(Double_t* stats) const; fill the array stats from the contents of this profile; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. void LabelsDeflate(Option_t* axis = ""X""); Reduce the number of bins for this axis to the number of bins having a label. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the x axis,; compu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile.html:39627,simpl,simply,39627,root/html602/TProfile.html,https://root.cern,https://root.cern/root/html602/TProfile.html,4,['simpl'],['simply']
Usability,"modulo color component, cmy smooth alorithm,; cmy modulo color component, cie smooth alorithm,; cie modulo color component, yiq smooth alorithm,; yiq modulo color component, hsv smooth alorithm,; hsv modulo color component, it does not apply for simple display modes; algorithm group. void SetColorIncrements(Double_t r, Double_t g, Double_t b); Sets color increments between two color levels for r, g, b components:; -r, g, b - color increments between two color levels. void SetLightPosition(Int_t x, Int_t y, Int_t z); Sets position of fictive light source in 3D space:; -x, y, z. void SetShading(Int_t shading, Int_t shadow); Sets on/off shading and shadow switches:; -shading - determines whether the picture will shaded, smoothed (no shading, shading), for rainbowed display modes only; -shadow - determines whether shadow will be drawn, for rainbowed display modes with shading according to light. void SetBezier(Int_t bezier); Sets on/off Bezier smoothing:; -bezier - determines Bezier interpolation (applies only for simple; display modes group for grid, x_lines, y_lines display modes). void SetContourWidth(Int_t width); Sets width between horizontal slices:; -width - width between contours, applies only for contours display mode. void SetLightHeightWeight(Double_t weight); Sets weight between shading according to fictive light source and according to channels counts:; -weight - weight between shading according to fictive light source and according to channels counts, applies only for kPicture2ModeGroupLightHeight modes group. void SetChanMarks(Int_t enable, Int_t color, Int_t width, Int_t height, Int_t style); Sets enables/disables drawing of channel marks and sets their attributes:; -enable - decides whether the channel marks are shown or not; -color - color of channel marks; -width - width of channel marks in pixels; -height - height of channel marks in pixels; -style - style of channel marks (dot, cross, star, rectangle, X, diamond, triangle). void SetChanGrid(Int_t en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Painter.html:30348,simpl,simple,30348,root/html528/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Painter.html,10,['simpl'],['simple']
Usability,"more than one adequate generator. If you use Visual Studio, “NMake Makefiles” is a generator you can use for building with NMake. By default, CMake chooses the most specific generator supported by your development environment. If you want an alternative generator, you must tell this to CMake with the -G option.; Options and variables; Variables customize how the build will be generated. Options are boolean variables, with possible values ON/OFF. Options and variables are defined on the CMake command line like this:; $ cmake -DVARIABLE=value path/to/source. You can set a variable after the initial CMake invocation to change its value. You can also undefine a variable:; $ cmake -UVARIABLE path/to/source. Variables are stored in the CMake cache. This is a file named CMakeCache.txt stored at the root of your build directory that is generated by cmake. Editing it yourself is not recommended.; Variables are listed in the CMake cache with the variable name and type separated by a colon. You can also specify the variable and type on the CMake command line:; $ cmake -DVARIABLE:TYPE=value path/to/source. Variables in the CMake cache are 'remembered', so you do not need to type them if you execute cmake command again. It is recommended to delete the file CMakeCache.txt to start from a clean configuration. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:23827,guid,guidelines,23827,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['guid'],['guidelines']
Usability,"moryPlot::DoPlot ; (; ). Draw the plot from the logs. ; Definition at line 192 of file TProofProgressMemoryPlot.cxx. ◆ DoWorkerPlot(). TGraph * TProofProgressMemoryPlot::DoWorkerPlot ; (; TProofLogElem * ; ple). protected . Make a memory consumption graph for a worker. ; Definition at line 553 of file TProofProgressMemoryPlot.cxx. ◆ ParseLine(). Int_t TProofProgressMemoryPlot::ParseLine ; (; TString ; l, . Long64_t & ; v, . Long64_t & ; r, . Long64_t & ; e . ). protected . Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the number of events 'e'. ; The line is assumed to be in the form ""... Memory 130868 virtual 31540 ... event 5550"" The fields are only filled if >= 0 . Return 0 on success, -1 if any of the values could not be filled (the output fields are not touched in such a case). ; Definition at line 507 of file TProofProgressMemoryPlot.cxx. ◆ Select(). void TProofProgressMemoryPlot::Select ; (; Int_t ; id). actions of select all/clear all button ; Definition at line 644 of file TProofProgressMemoryPlot.cxx. Member Data Documentation. ◆ fAllWorkers. TGSplitButton* TProofProgressMemoryPlot::fAllWorkers. protected . Definition at line 34 of file TProofProgressMemoryPlot.h. ◆ fAPlot. TMultiGraph* TProofProgressMemoryPlot::fAPlot. protected . Definition at line 40 of file TProofProgressMemoryPlot.h. ◆ fDialog. TProofProgressDialog* TProofProgressMemoryPlot::fDialog. protected . Definition at line 31 of file TProofProgressMemoryPlot.h. ◆ fFullLogs. Bool_t TProofProgressMemoryPlot::fFullLogs. protected . Definition at line 41 of file TProofProgressMemoryPlot.h. ◆ fMasterPlot. TRootEmbeddedCanvas* TProofProgressMemoryPlot::fMasterPlot. protected . Definition at line 36 of file TProofProgressMemoryPlot.h. ◆ fMPlot. TMultiGraph* TProofProgressMemoryPlot::fMPlot. protected . Definition at line 39 of file TProofProgressMemoryPlot.h. ◆ fPlot. TGTextButton* TProofProgressMemoryPlot::fPlot. protected . Definition at line 33 of file TProofProgressMemo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressMemoryPlot.html:39684,clear,clear,39684,doc/master/classTProofProgressMemoryPlot.html,https://root.cern,https://root.cern/doc/master/classTProofProgressMemoryPlot.html,1,['clear'],['clear']
Usability,"mous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_t_debug; TFile*_refFile; list<pair<RooPlot*,string> >_regPlots; list<pair<RooFitResult*,string> >_regResults; list<pair<TH1*,string> >_regTH; list<pair<RooTable*,string> >_regTables; list<pair<Double_t,string> >_regValues; list<pair<RooWorkspace*,string> >_regWS; Int_t_verb; Bool_t_write; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static TDirectory*gMemDir. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnitTest(const char* name, TFile* refFile, Bool_t writeRef, Int_t verbose). ~RooUnitTest(). void regPlot(RooPlot* frame, const char* refName). void regResult(RooFitResult* r, const char* refName). void regValue(Double_t value, const char* refName). void regTable(RooTable* t, const char* refName). void regWS(RooWorkspace* ws, const char* refName). void regTH(TH1* h, const char* refName). RooWorkspace* getWS(const char* refName). Bool_t areTHidentical(TH1* htest, TH1* href). Bool_t runCompTests(). void setSilentMode(). void clearSilentMode(). Bool_t runTest(). void setMemDir(TDirectory* memDir); Set gMemDir to memDir. RooUnitTest(const char* name, TFile* refFile, Bool_t writeRef, Int_t verbose). void setDebug(Bool_t flag); { _debug = flag ; }. Bool_t isTestAvailable(); { return kTRUE ; }. Bool_t testCode(). Double_t htol(); { return 5e-4 ; }. Double_t ctol(); { return 2e-3 ; }. Double_t fptol(); { return 1e-3 ; }. Double_t fctol(); { return 1e-3 ; }. Double_t vtol(); { return 1e-3 ; }. » Last changed: Tue Jun 2 15:36:32 2015 » Last generated: 2015-06-02 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooUnitTest.html:8275,clear,clearSilentMode,8275,root/html604/RooUnitTest.html,https://root.cern,https://root.cern/root/html604/RooUnitTest.html,2,['clear'],['clearSilentMode']
Usability,"mous)TObject::kZombie. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Int_tfNvertnumber of vertices of the 2D polygon (at least 3); Int_tfNznumber of z planes (at least two); Double_tTGeoBBox::fOrigin[3]box origin; Double_t*fScale[fNz] array of scale factors (for each Z); UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; vector<TGeoXtru::ThreadData_t*>fThreadData! Navigation data per thread; Int_tfThreadSize! size of thread-specific array; TStringTNamed::fTitleobject title; Double_t*fX[fNvert] X positions for polygon vertices; Double_t*fX0[fNz] array of X offsets (for each Z); Double_t*fY[fNvert] Y positions for polygon vertices; Double_t*fY0[fNz] array of Y offsets (for each Z); Double_t*fZ[fNz] array of Z planes positions; Double_tfZcurrentcurrent Z position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads); Create thread data for n threads max. void SetIz(Int_t iz); Set current z-plane. void SetSeg(Int_t iseg); Set current segment. TGeoXtru(); dummy ctor. TGeoXtru(Int_t nz); Default constructor. TGeoXtru(Double_t* param); Default constructor in GEANT3 style; param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to clos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoXtru.html:16886,Clear,ClearThreadData,16886,root/html602/TGeoXtru.html,https://root.cern,https://root.cern/root/html602/TGeoXtru.html,2,['Clear'],['ClearThreadData']
Usability,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBenchmark.html:7593,resume,resume,7593,root/html604/TBenchmark.html,https://root.cern,https://root.cern/root/html604/TBenchmark.html,2,['resume'],['resume']
Usability,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 14:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBenchmark.html:7593,resume,resume,7593,root/html602/TBenchmark.html,https://root.cern,https://root.cern/root/html602/TBenchmark.html,2,['resume'],['resume']
Usability,"mplate<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetWidth ; (; size_t ; width). inline . Definition at line 223 of file GeneralLayer.h. ◆ Update(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::Update ; (; const Scalar_t ; learningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; name, . const Matrix_t & ; matrix . ). Definition at line 521 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:26007,learn,learning,26007,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learning']
Usability,"mple to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMultiDimFit.html:26643,Clear,Clear,26643,root/html532/TMultiDimFit.html,https://root.cern,https://root.cern/root/html532/TMultiDimFit.html,8,['Clear'],['Clear']
Usability,"mple: TAxis_ver8 or TList_raw5 Second kind of tables appears, when some of class members can not be converted to normalized form or when class has custom streamer. For instance, for TH1 class two tables are required: TH1_ver4 and TH1_raw4 Most of members are stored in TH1_ver4 table column-wise, and only member: Double_t* fBuffer; //[fBufferSize] can not be represented as column while size of array is not fixed. Therefore, fBuffer will be written as list of values in TH1_raw4 table. All objects, stored in the DB, will be registered in table ""ObjectsTable"". In this there are following columns: . Name Description . ""key:id"" key identifier to which belong object . ""obj:id"" object identifier . ""Class"" object class name . ""Version"" object class version . Data in each ""ObjectsTable"" row uniquely identify, in which table and which column object is stored.; In normal situation all class data should be sorted column-wise. Up to now following member are supported:; Basic data types. Here is everything clear. Column SQL type will be as much as possible close to the original type of value.; Fixed array of basic data types. In this case n columns like fArr[0], fArr[1] and so on will be created. If there is multidimensional array, names will be fArr2[1][2][1] and so on; Parent class. In this case version of parent class is stored and data of parent class will be stored with the same obj:id in correspondent table. There is a special case, when parent store nothing (this is for instance TQObject). In that case just -1 is written to avoid any extra checks if table exist or not.; Object as data member. In that case object is saved in normal way to data base and column will contain id of this object.; Pointer on object. Same as before. In case if object was already stored, just its id will be placed in the column. For NULL pointer 0 is used.; TString. Now column with limited width like VARCAHR(255) in MySQL is used. Later this will be improved to support maximum possible strings; Anyt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:1716,clear,clear,1716,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['clear'],['clear']
Usability,"mplicated, especially if there are (cyclical) reference back to the owning object ; Definition at line 47 of file RooObjCacheManager.cxx. ◆ RooObjCacheManager() [2/2]. RooObjCacheManager::RooObjCacheManager ; (; const RooObjCacheManager & ; other, . RooAbsArg * ; owner = nullptr . ). Copy constructor. ; Definition at line 59 of file RooObjCacheManager.cxx. ◆ ~RooObjCacheManager(). RooObjCacheManager::~RooObjCacheManager ; (; ). override . Destructor. ; Definition at line 71 of file RooObjCacheManager.cxx. Member Function Documentation. ◆ Class(). static TClass * RooObjCacheManager::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooObjCacheManager::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooObjCacheManager::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 62 of file RooObjCacheManager.h. ◆ clearObsList(). static bool RooObjCacheManager::clearObsList ; (; ). inlinestatic . Definition at line 48 of file RooObjCacheManager.h. ◆ DeclFileName(). static const char * RooObjCacheManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooObjCacheManager.h. ◆ doClearObsList(). static void RooObjCacheManager::doClearObsList ; (; bool ; flag). inlinestatic . Definition at line 47 of file RooObjCacheManager.h. ◆ findConstantNodes(). void RooObjCacheManager::findConstantNodes ; (; const RooArgSet & ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:8445,clear,clearObsList,8445,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['clear'],['clearObsList']
Usability,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression split:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right""; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:2335,simpl,simple,2335,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,6,['simpl'],['simple']
Usability,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression splitted:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCompositeShape.html:2335,simpl,simple,2335,root/html528/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html528/TGeoCompositeShape.html,4,['simpl'],['simple']
Usability,"mposing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCII file (see -Scanning expressions-);; - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; drawing and stop the current command respectively, two text widgets where; input and output event lists can be specified, a message box and a RESET; button on the right that clear edited expression content (see Editing...); - a tree-type list on the main left panel where you can select among trees or; branches. The tree/branch will be detailed in the right panel.; Mapped trees are provided with context menus, activated by right-clicking;; - a view-type list on the right panel. The first column contain X, Y and; Z expression items, an optional cut and ten optional editable expressions.; Expressions and leaf-type items can be dragged or deleted. A right click on; the list-box or item activates context menus. Opening a new tree and saving a session :. To open a new tree in the viewer use <File/Open tree file> menu; The content of the file (keys) will be listed. Use <SetTreeName> function; from the context menu of the right panel, entering a tree name among those; l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeViewer.html:2353,clear,clear,2353,root/html530/TTreeViewer.html,https://root.cern,https://root.cern/root/html530/TTreeViewer.html,9,['clear'],['clear']
Usability,"mputation of the boundaries before iterating through all of the bins.; Parameters. pAxisthe axis to consider ; nPixelsthe number of pixels to render axis into ; isLogwhether the axis is log scale . Definition at line 5472 of file THistPainter.cxx. ◆ DeclFileName(). static const char * THistPainter::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file THistPainter.h. ◆ DefineColorLevels(). void THistPainter::DefineColorLevels ; (; Int_t ; ndivz). virtual . Define the color levels used to paint legos, surfaces etc.. ; Definition at line 9603 of file THistPainter.cxx. ◆ DistancetoPrimitive(). Int_t THistPainter::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute the distance from the point px,py to a line. ; Compute the closest distance of approach from point px,py to elements of an histogram. The distance is computed in pixels units.; Algorithm: Currently, this simple model computes the distance from the mouse to the histogram contour only. ; Implements TVirtualHistPainter.; Definition at line 3255 of file THistPainter.cxx. ◆ DrawPanel(). void THistPainter::DrawPanel ; (; ). overridevirtual . Display a panel with all histogram drawing options. ; Implements TVirtualHistPainter.; Definition at line 3444 of file THistPainter.cxx. ◆ ExecuteEvent(). void THistPainter::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Execute the actions corresponding to event. ; This function is called when a histogram is clicked with the locator at the pixel position px,py. ; Implements TVirtualHistPainter.; Definition at line 3464 of file THistPainter.cxx. ◆ GetBestFormat(). const char * THistPainter::GetBestFormat ; (; Double_t ; v, . Double_t ; e, . const char * ; f . ). static . This function returns the best format to print the error value (e) knowing the parameter value (v) and the format (f) used to print it. ; Definition at line 10714 of file THist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:153217,simpl,simple,153217,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simple']
Usability,"ms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.CClient program which allows the snooping of objects from a spyserv process ;  spyserv.CServer program which allows clients, ""spies"", to connect and snoop objects ;  TestAuth.CMacro test authentication methods stand alone ;  testTUDPSocket.CAs test echo server use udpserver.c in the same directory ;  treeClient.CClient program which creates and fills 2 histograms and a TTree ;  TUriTest.CRudimentary TUri test macro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:136734,simpl,simple,136734,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['simpl'],['simple']
Usability,"multiple times. After the first call above to TTree::Draw, a TEntryListArray is created and filled with the entries and the indices of the arrays that satisfied the selection cut (x > 0). In the subsequent calls to TTree::Draw, only these entries / subentries are used to fill histograms. About the class; The class derives from TEntryList and can be used basically in the same way. This same class is used to keep entries and subentries, so there are two types of TEntryListArray's:. The ones that only hold subentries; fEntry is set to the entry# for which the subentries correspond; fSubLists must be 0. The ones that hold entries and eventually lists with subentries in fSubLists.; fEntry = -1 for those; If there are no sublists for a given entry, all the subentries will be used in the selection. Additions with respect to TEntryList. Data members:; fSubLists: a container to hold the sublists; fEntry: the entry number if the list is used to hold subentries; fLastSubListQueried and fSubListIter: a pointer to the last sublist queried and an iterator to resume the loop from the last sublist queried (to speed up selection and insertion in TTree::Draw). Public methods:; Contains, Enter and Remove with subentry as argument; GetSubListForEntry: to return the sublist corresponding to the given entry. Protected methods:; AddEntriesAndSubLists: called by Add when adding two TEntryList arrays with sublists; ConvertToTEntryListArray: convert TEntryList to TEntryListArray; RemoveSubList: to remove the given sublist; RemoveSubListForEntry: to remove the sublist corresponding to the given entry; SetEntry: to get / set a sublist for the given entry . Definition at line 26 of file TEntryListArray.h. Public Member Functions;  TEntryListArray ();  Default c-tor. ;  ;  TEntryListArray (const char *name, const char *title);  c-tor with name and title ;  ;  TEntryListArray (const char *name, const char *title, const char *treename, const char *filename);  c-tor with name and title, which also ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListArray.html:1999,resume,resume,1999,doc/master/classTEntryListArray.html,https://root.cern,https://root.cern/doc/master/classTEntryListArray.html,1,['resume'],['resume']
Usability,"multithreading turned on?; 816 ; 817 ; 818 void pads (int numPads) { if (fMonitoring) fMonitoring->pads (numPads); } ///< preparation for monitoring; 819 void create (std::string histoName, int bins, double min, double max) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max); } ///< for monitoring; 820 void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max, bins2, min2, max2); } ///< for monitoring; 821 void addPoint (std::string histoName, double x) { if (fMonitoring) fMonitoring->addPoint (histoName, x); } ///< for monitoring; 822 void addPoint (std::string histoName, double x, double y) {if (fMonitoring) fMonitoring->addPoint (histoName, x, y); } ///< for monitoring; 823 void plot (std::string histoName, std::string options, int pad, EColor color) { if (fMonitoring) fMonitoring->plot (histoName, options, pad, color); } ///< for monitoring; 824 void clear (std::string histoName) { if (fMonitoring) fMonitoring->clear (histoName); } ///< for monitoring; 825 bool exists (std::string histoName) { if (fMonitoring) return fMonitoring->exists (histoName); return false; } ///< for monitoring; 826 ; 827 size_t convergenceCount () const { return m_convergenceCount; } ///< returns the current convergence count; 828 size_t maxConvergenceCount () const { return m_maxConvergenceCount; } ///< returns the max convergence count so far; 829 size_t minError () const { return m_minError; } ///< returns the smallest error so far; 830 ; 831 public:; 832 Timer m_timer; ///< timer for monitoring; 833 double m_minProgress; ///< current limits for the progress bar; 834 double m_maxProgress; ///< current limits for the progress bar; 835 ; 836 ; 837 size_t m_convergenceSteps; ///< number of steps without improvement to consider the DNN to have converged; 838 size_t m_batchSize; ///< mini-batch size; 839 size_t m_testRepetitions;; 840 double m_factorWeightDecay;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:31375,clear,clear,31375,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['clear'],['clear']
Usability,"myHisto->Fit(""gaus""); The call to Fit copies the global TF1 Gaussian function and attaches the copy to the histogram. When the histogram is deleted, the copy is deleted also.; When a pad is deleted or cleared, all objects in the pad with the kCanDelete bit set are deleted automatically. Currently the objects created by the DrawCopy methods, have the kCanDelete bit set and are therefore owned by the pad.; 8.4 Ownership by the User; The user owns all objects not described in one of the above cases. TObject has two bits, kCanDelete and kMustCleanup, that influence how an object is managed (in TObject::fBits). These are in an enumeration in TObject.h. To set these bits do:; MyObject->SetBit(kCanDelete); MyObject->SetBit(kMustCleanup); The bits can be reset and tested with the TObject::ResetBit and TObject::TestBit methods.; 8.4.1 The kCanDelete Bit; The gROOT collections (see above) own their members and will delete them regardless of the kCanDelete bit. In all other collections, when the collection Clear method is called (i.e. TList::Clear()), members with the kCanDelete bit set, are deleted and removed from the collection. If the kCanDelete bit is not set, the object is only removed from the collection but not deleted.; If a collection Delete (TList::Delete()) method is called, all objects in the collection are deleted without considering the kCanDelete bit. It is important to realize that deleting the collection (i.e. delete MyCollection), DOES NOT delete the members of the collection.; If the user specified MyCollection->SetOwner() the collection owns the objects and delete MyCollection will delete all its members. Otherwise, you need to:; // delete all member objects in the collection; MyCollection->Delete();. // and delete the collection object; delete MyCollection;; Note that kCanDelete is automatically set by the DrawCopy method and the user can set it for any object. For example, the user must manage all graphics primitives. If you want TCanvas to delete the pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:287025,Clear,Clear,287025,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Clear'],['Clear']
Usability,"n .rootrc, as documented in the THtml class reference page http://root.cern.ch/root/html/THtml. The following will enumerate some of the highlights.; 27.4.1 Referencing Documentation for other Libraries; When THtml generates documentation for classes it recognizes all class names known to ROOT. If THtml does not have sources for a class it determines the class’s library name. This has to be set by means of rootmap files, see Library AutoLoading of this User’s Guide. Given the library name, THtml searches for an entry in its map of libraries to documentation URLs. If it finds it, it will create a link to the documentation at that URL for all occurrences of a given class name. One can set the URL ../mylib/ for a library name MyLib by setting Root.Html.MyLib: ../mylib/ or by calling THtml::SetLibURL(""MyLib"", ""../mylib/""). Occurrences of class MyClass of MyLib will now be referenced as ../mylib/MyClass.html.; 27.4.2 Search Engine; THtml can invoke external search engines. The ROOT reference guide sets Root.Html.Search to http://www.google.com/search?q=%s+site%3A%u. Calling THtml::SetSearchStemURL() will set the same. If this URL stem is set, THtml will create search fields in the index pages. It will send the words entered in these search fields as %s in the URL; %u will be replaced by the current document’s path, allowing a site- and directory-specific search.; 27.4.3 ViewCVS; Most code is managed in a version control system like CVS. ViewCVS is a WWW reader interface to the versioning control system that allows e.g. tracking a file’s changes. THtml will reference these pages automatically if the .rootrc variable Root.Html.ViewCVS is set to the URL stem of the ViewCVS. installation. Alternatively, one can call THtml::SetViewCVS().; 27.4.4 Wiki Pages; In some contexts it might be desirable to let users comment on classes, e.g. for suggestions of use or alternatives, details of behavior, and cross references to other relevant classes. A successful example of this is the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1249806,guid,guide,1249806,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['guid'],['guide']
Usability,"n = """"); Save primitive as a C++ statement(s) on output stream out. TTreePerfStats(). Long64_t GetBytesRead() const; {return fBytesRead;}. Long64_t GetBytesReadExtra() const; {return fBytesReadExtra;}. Double_t GetCpuTime() const; {return fCpuTime;}. Double_t GetDiskTime() const; {return fDiskTime;}. TGraphErrors * GetGraphIO(); {return fGraphIO;}. TGraphErrors * GetGraphTime(); {return fGraphTime;}. const char * GetHostInfo() const; {return fHostInfo.Data();}. const char * GetName() const; {return fName.Data();}. Int_t GetNleaves() const; {return fNleaves;}. Long64_t GetNumEvents() const; {return 0;}. TPaveText * GetPave(); {return fPave;}. Int_t GetReadaheadSize() const; {return fReadaheadSize;}. Int_t GetReadCalls() const; {return fReadCalls;}. Double_t GetRealTime() const; {return fRealTime;}. TStopwatch * GetStopwatch() const; {return fWatch;}. Int_t GetTreeCacheSize() const; {return fTreeCacheSize;}. Double_t GetUnzipTime() const; {return fUnzipTime; }. void SimpleEvent(TVirtualPerfStats::EEventType ); {}. void PacketEvent(const char* , const char* , const char* , Long64_t , Double_t , Double_t , Double_t , Long64_t ); {}. void FileOpenEvent(TFile* , const char* , Double_t ); {}. void RateEvent(Double_t , Double_t , Long64_t , Long64_t ); {}. void SetBytesRead(Long64_t nbytes); {fBytesRead = nbytes;}. void SetBytesReadExtra(Long64_t nbytes); {fBytesReadExtra = nbytes;}. void SetCompress(Double_t cx); {fCompress = cx;}. void SetDiskTime(Double_t t); {fDiskTime = t;}. void SetNumEvents(Long64_t ); {}. void SetCpuTime(Double_t cptime); {fCpuTime = cptime;}. void SetGraphIO(TGraphErrors* gr); {fGraphIO = gr;}. void SetGraphTime(TGraphErrors* gr); {fGraphTime = gr;}. void SetHostInfo(const char* info); {fHostInfo = info;}. void SetName(const char* name); {fName = name;}. void SetNleaves(Int_t nleaves); {fNleaves = nleaves;}. void SetReadaheadSize(Int_t nbytes); {fReadaheadSize = nbytes;}. void SetReadCalls(Int_t ncalls); {fReadCalls = ncalls;}. void SetRealNorm(Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreePerfStats.html:13125,Simpl,SimpleEvent,13125,root/html532/TTreePerfStats.html,https://root.cern,https://root.cern/root/html532/TTreePerfStats.html,4,['Simpl'],['SimpleEvent']
Usability,"n = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual Bool_tTFormula::CheckOperands(Int_t operation, Int_t& err); virtual Bool_tTFormula::CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); voidTFormula::ClearFormula(Option_t* option = """"); virtual voidTFormula::Convert(UInt_t fromVersion); voidTF1::CreateFromCintClass(const char* name, void* ptr, Double_t xmin, Double_t xmax, Int_t npar, const char* cname, const char* fname); voidTF1::CreateFromFunctor(const char* name, Int_t npar); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tTFormula::EvalParFast(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive0(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive1(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive2(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive3(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive4(const Double_t* x, const Double_t* params); Short_tTFormula::GetAction(Int_t code) const; Short_tTFormula::GetActionOptimized(Int_t code) const; Int_tTFormula::GetActionParam(Int_t code) const; Int_tTFormula::GetActionParamOptimized(Int_t code) const; Int_t*TFormula::GetOper() const; Int_t*TFormula::GetOperOptimized() const; virtual Bool_tTFormula::IsString(Int_t oper) const; voidTFormula::MakePrimitive(const char* expr, Int_t pos); voidTObject::MakeZombie(); Int_tTFormula::PreCompile(); voidTFormula::SetAction(Int_t code, Int_t value, Int_t param = 0); voidTFormula::SetActionOptimized(Int_t code, Int_t value, Int_t param = 0); virtual Bool_tTFormula::StringToNumber(Int_t code). Data Members; public:. enum TF1::[unnamed] { kNotDraw; };; enum TFormula::[unnamed] { kEnd; kAdd; kSubstract; kMultiply; kDivide; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TF12.html:15568,Clear,ClearFormula,15568,root/html532/TF12.html,https://root.cern,https://root.cern/root/html532/TF12.html,6,['Clear'],['ClearFormula']
Usability,"n = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. TQueryDescription*fActQuerycurrent (actual) query; TStringfAddressserver address; Bool_tfAttachedkTRUE if attached; Bool_tfAutoEnableenable packages at session startup time; TStringfConfigFileconfiguration file name; Bool_tfConnectedkTRUE if connected; Bool_tfLocalkTRUE if session is local; Int_tfLogLevellog (debug) level; TStringfNamesession name; Int_tfNbHistosnumber of feedback histos; TList*fPackageslist of packages; Int_tfPortcommunication port; TProof*fProofpointer on TProof used by this session; TProofMgr*fProofMgrProof sessions manager; TList*fQuerieslist of queries in this session; Bool_tfSynckTRUE if in sync mode; TStringfTagsession unique identifier; TStringfUserNameuser name (on server); static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance Chart:. TObject. ←; TSessionDescription. Function documentation; const char * GetName() const; { return fQueryName; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionDescription.html:5505,feedback,feedback,5505,root/html602/TSessionDescription.html,https://root.cern,https://root.cern/root/html602/TSessionDescription.html,4,['feedback'],['feedback']
Usability,"n SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTrapEditor.html:22847,undo,undoing,22847,root/html604/TGeoTrapEditor.html,https://root.cern,https://root.cern/root/html604/TGeoTrapEditor.html,2,['undo'],['undoing']
Usability,"n SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrapEditor.html:22847,undo,undoing,22847,root/html602/TGeoTrapEditor.html,https://root.cern,https://root.cern/root/html602/TGeoTrapEditor.html,2,['undo'],['undoing']
Usability,"n TColorWheel.h:36; TColorWheel::fRmaxDouble_t fRmaxMaximum radius for rectangles.Definition TColorWheel.h:27; TColorWheel::PaintGrayvoid PaintGray() constDraw the gray colors + white + black.Definition TColorWheel.cxx:389; TColorWheel::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideReturn the color number pointed by the mouse.Definition TColorWheel.cxx:155; TColorWheel::Paintvoid Paint(Option_t *option="""") overridePaint the color wheel.Definition TColorWheel.cxx:225; TColorWheel::PaintCirclesvoid PaintCircles(Int_t coffset, Double_t angle) constDraw all colors of type circle.Definition TColorWheel.cxx:279; TColorWheel::fDrDouble_t fDrCircles radius.Definition TColorWheel.h:29; TColorWheel::PaintRectanglesvoid PaintRectangles(Int_t coffset, Double_t angle) constDraw all colors of type rectangle.Definition TColorWheel.cxx:306; TColorWheel::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overridealways return the color wheelDefinition TColorWheel.cxx:106; TColorWheel::Rotatevoid Rotate(Double_t x, Double_t y, Double_t &u, Double_t &v, Double_t ang) constRotate point x,y with an angle=ang.Definition TColorWheel.cxx:428; TColorWheel::fGraphTGraph * fGraph! pointer to utility graphDefinition TColorWheel.h:37; TColorWheel::~TColorWheel~TColorWheel() overridedestructorDefinition TColorWheel.cxx:94; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TTextBase class for several text objects.Definition TText.h:22; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; v@ vDefinition rootcling_impl.cxx:3699; Drawth1 Draw(). graf2dgpadincTColorWheel.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:17 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColorWheel_8h_source.html:6777,simpl,simple,6777,doc/master/TColorWheel_8h_source.html,https://root.cern,https://root.cern/doc/master/TColorWheel_8h_source.html,1,['simpl'],['simple']
Usability,"n THbookFile.cxx:91; TLine.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TTree.h; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::BypassStreamervoid BypassStreamer(Bool_t bypass=kTRUE)When the kBypassStreamer bit is set, the automatically generated Streamer can call directly TClass::W...Definition TClonesArray.cxx:321; TClonesArray::Clearvoid Clear(Option_t *option="""") overrideClear the clones array.Definition TClonesArray.cxx:420; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::GetY1Double_t GetY1() constDefinition TLine.h:52; TLine::GetX2Double_t GetX2() constDefinition TLine.h:51; TLine::GetX1Double_t GetX1() constDefinition TLine.h:50; TLine::GetY2Double_t GetY2() constDefinition TLine.h:53; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tcl_8C.html:4298,simpl,simple,4298,doc/master/tcl_8C.html,https://root.cern,https://root.cern/doc/master/tcl_8C.html,1,['simpl'],['simple']
Usability,"n TQCommand.h:27. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");; For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color; ; com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);; Color_tshort Color_tDefinition RtypesCore.h:85; TQCommand::SetRedoArgsvirtual void SetRedoArgs(Int_t nargs,...)Set redo parameters.Definition TQCommand.cxx:508; TQCommand::SetUndoArgsvirtual void SetUndoArgs(Int_t nargs,...)Set undo parameters.Definition TQCommand.cxx:542; 1st argument - the number of undo, redo parameters the other arguments - undo, redo values Since the number of undo,redo parameters is the same one can use com->SetArgs(1, new_color, old_color);; TQCommand::SetArgsvirtual void SetArgs(Int_t nargs,...)Set do/redo and undo parameters.Definition TQCommand.cxx:465. Undo, redo method execution com->Redo(); // execute redo method; com->Undo(); // execute undo method; TQCommand::Undovirtual void Undo(Option_t *option="""")Un-execute all merged commands and the command.Definition TQCommand.cxx:626; TQCommand::Redovirtual void Redo(Option_t *option="""")Execute command and then merge commands.Definition TQCommand.cxx:588. Merged commands It possible to group several commands together so an end user can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:2255,undo,undo,2255,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,3,['undo'],['undo']
Usability,"n `pythonizor_of_myclass` provides and injects a new; # implementation for `__str__`, the mechanism that Python provides to define; # how to represent objects as strings. This new implementation; # always returns the string ""This is a MyClass object"".; @pythonization('MyClass'); def pythonizor_of_myclass(klass):; klass.__str__ = lambda o : 'This is a MyClass object'; ; # Once we have defined our pythonizor function, let's see it in action.; # We will now use the `MyClass` class for the first time from Python: we will; # create a new instance of that class. At this moment, the pythonizor will; # execute and modify the class - pythonizors are always lazily run when a given; # class is used for the first time from a Python script.; my_object = ROOT.MyClass(); ; # Since the pythonizor already executed, we should now see the new behaviour.; # For that purpose, let's print `my_object` (should show ""This is a MyClass; # object"").; print(my_object); ; # The previous example is just a simple one, but there are many ways in which a; # class can be pythonized. Typical examples are the redefinition of dunder; # methods (e.g. `__iter__` and `__next__` to make your objects iterable from; # Python). If you need some inspiration, many ROOT classes are pythonized in; # the way we just saw; their pythonizations can be seen at:; # https://github.com/root-project/root/tree/master/bindings/pyroot/pythonizations/python/ROOT/pythonization; ; # The @pythonization decorator offers a few more options when it comes to; # matching classes that you want to pythonize. We saw that we can match a; # single class, but we can also specify a list of classes to pythonize.; #; # The following code defines a couple of new classes:; ROOT.gInterpreter.Declare('''; namespace NS {; class Class1 {};; class Class2 {};; }; '''); ; # Note that these classes belong to the `NS` namespace. As mentioned above, the; # @pythonization decorator accepts a parameter with the namespace of the class; # or classes to be pyt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html:3239,simpl,simple,3239,doc/master/pyroot002__pythonizationDecorator_8py.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html,1,['simpl'],['simple']
Usability,"n a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  ;  Static Public Member Functions inherited from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; virtual value_type evaluate () const =0;  Evaluate the category state and return. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; virtual void recomputeShape ()=0;  If a category depends on the shape of others, i.e. its state numbers or names depend o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:37421,clear,clearTypes,37421,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['clear'],['clearTypes']
Usability,"n actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:971313,simpl,simple,971313,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"n adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least squa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713074,guid,guide,713074,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['guid'],['guide']
Usability,"n and Fitting Libraries: libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for fitting is class TVirtualFitter and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is being re-organized and new fitting classes are present in MathCore for providing the fitting functionality and the use the minimization libraries via a new common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include: . Minuit:library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits. . Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions. ; Fumili: library providing the implementation of the original Fumili fitting algorithm. Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:. Matrix: general matrix package providing matrix TMatrix and vector TVector classes and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/MATH_Index.html:2203,Simpl,Simplex,2203,root/html534/MATH_Index.html,https://root.cern,https://root.cern/root/html534/MATH_Index.html,1,['Simpl'],['Simplex']
Usability,"n and stored, these are then bound and converted to type TGeoBBox and stored in fsolmap map using the name as its key. ; Definition at line 2707 of file TGDMLParse.cxx. ◆ EleProcess(). XMLNodePointer_t TGDMLParse::EleProcess ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLNodePointer_t ; parentn, . Bool_t ; hasIsotopes, . Bool_t ; hasIsotopesExtended . ). private . When the element keyword is found, this function is called, and the name and values of the element are converted into type TGeoElement and stored in felemap map using the name as its key. ; Definition at line 1086 of file TGDMLParse.cxx. ◆ Ellipsoid(). XMLNodePointer_t TGDMLParse::Ellipsoid ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLAttrPointer_t ; attr . ). private . In the solids section of the GDML file, an ellipsoid may be declared. ; Unfortunately, the ellipsoid is not supported under ROOT so, when the ellipsoid keyword is found, this function is called to convert it to a simple box with similar dimensions, and the dimensions required are taken and stored, these are then bound and converted to type TGeoBBox and stored in fsolmap map using the name as its key. ; Definition at line 2619 of file TGDMLParse.cxx. ◆ ElTube(). XMLNodePointer_t TGDMLParse::ElTube ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLAttrPointer_t ; attr . ). private . In the solids section of the GDML file, a ElTube may be declared. ; when the eltube keyword is found, this function is called, and the dimensions required are taken and stored, these are then bound and converted to type TGeoEltu and stored in fsolmap map using the name as its key. ; Definition at line 4024 of file TGDMLParse.cxx. ◆ Evaluate(). double TGDMLParse::Evaluate ; (; const char * ; evalline). private . Takes a string containing a mathematical expression and returns the value of the expression. ; Definition at line 411 of file TGDMLParse.cxx. ◆ GDMLReadFile(). TGeoVolume * TGDMLParse::GDMLReadFile ; (; const char * ; filenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDMLParse.html:31550,simpl,simple,31550,doc/master/classTGDMLParse.html,https://root.cern,https://root.cern/doc/master/classTGDMLParse.html,1,['simpl'],['simple']
Usability,"n at line 1670 of file TGenCollectionProxy.cxx. ◆ GetIncrement(). ULong_t TGenCollectionProxy::GetIncrement ; (; ); const. overridevirtual . Return the offset between two consecutive value_types (memory layout). ; Implements TVirtualCollectionProxy.; Definition at line 1004 of file TGenCollectionProxy.cxx. ◆ GetOnFileClass(). virtual TClass * TGenCollectionProxy::GetOnFileClass ; (; ); const. inlinevirtual . Definition at line 428 of file TGenCollectionProxy.h. ◆ GetReadMemberWiseActions(). TStreamerInfoActions::TActionSequence * TGenCollectionProxy::GetReadMemberWiseActions ; (; Int_t ; version). overridevirtual . Return the set of action necessary to stream in this collection member-wise coming from the old value class layout refered to by 'version'. ; Implements TVirtualCollectionProxy.; Definition at line 1798 of file TGenCollectionProxy.cxx. ◆ GetType(). EDataType TGenCollectionProxy::GetType ; (; ); const. overridevirtual . If the content is a simple numerical value, return its type (see TDataType) ; Implements TVirtualCollectionProxy.; Definition at line 1051 of file TGenCollectionProxy.cxx. ◆ GetValueClass(). TClass * TGenCollectionProxy::GetValueClass ; (; ); const. overridevirtual . Return a pointer to the TClass representing the content. ; Implements TVirtualCollectionProxy.; Definition at line 1038 of file TGenCollectionProxy.cxx. ◆ GetWriteMemberWiseActions(). TStreamerInfoActions::TActionSequence * TGenCollectionProxy::GetWriteMemberWiseActions ; (; ). overridevirtual . Return the set of action necessary to stream out this collection member-wise. ; Implements TVirtualCollectionProxy.; Definition at line 1820 of file TGenCollectionProxy.cxx. ◆ HasPointers(). Bool_t TGenCollectionProxy::HasPointers ; (; ); const. overridevirtual . Return true if the content is of type 'pointer to'. ; Implements TVirtualCollectionProxy.; Definition at line 1022 of file TGenCollectionProxy.cxx. ◆ Initialize(). TGenCollectionProxy * TGenCollectionProxy::Initialize ; (; Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:22167,simpl,simple,22167,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['simpl'],['simple']
Usability,"n at line 242 of file TGeoMatrix.h. ◆ Determinant(). Double_t TGeoRotation::Determinant ; (; ); const. computes determinant of the rotation matrix ; Definition at line 1364 of file TGeoMatrix.cxx. ◆ FastRotZ(). void TGeoRotation::FastRotZ ; (; const Double_t * ; sincos). Perform a rotation about Z having the sine/cosine of the rotation angle. ; Definition at line 1039 of file TGeoMatrix.cxx. ◆ GetAngles() [1/2]. void TGeoRotation::GetAngles ; (; Double_t & ; phi, . Double_t & ; theta, . Double_t & ; psi . ); const. Retrieve Euler angles. ; Definition at line 1340 of file TGeoMatrix.cxx. ◆ GetAngles() [2/2]. void TGeoRotation::GetAngles ; (; Double_t & ; theta1, . Double_t & ; phi1, . Double_t & ; theta2, . Double_t & ; phi2, . Double_t & ; theta3, . Double_t & ; phi3 . ); const. Retrieve rotation angles. ; Definition at line 1310 of file TGeoMatrix.cxx. ◆ GetInverse(). void TGeoRotation::GetInverse ; (; Double_t * ; invmat); const. Get the inverse rotation matrix (which is simply the transpose) ; Definition at line 1393 of file TGeoMatrix.cxx. ◆ GetPhiRotation(). Double_t TGeoRotation::GetPhiRotation ; (; Bool_t ; fixX = kFALSE); const. Returns rotation angle about Z axis in degrees. ; If the rotation is a pure rotation about Z, fixX parameter does not matter, otherwise its meaning is:; fixX = true : result is the phi angle of the projection of the rotated X axis in the un-rotated XY; fixX = false : result is the phi angle of the projection of the rotated Y axis - 90 degrees . Definition at line 1054 of file TGeoMatrix.cxx. ◆ GetRotationMatrix(). const Double_t * TGeoRotation::GetRotationMatrix ; (; ); const. inlineoverridevirtual . Implements TGeoMatrix.; Definition at line 239 of file TGeoMatrix.h. ◆ GetScale(). const Double_t * TGeoRotation::GetScale ; (; ); const. inlineoverridevirtual . Implements TGeoMatrix.; Definition at line 240 of file TGeoMatrix.h. ◆ GetTranslation(). const Double_t * TGeoRotation::GetTranslation ; (; ); const. inlineoverridevirtual . Imp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoRotation.html:22071,simpl,simply,22071,doc/master/classTGeoRotation.html,https://root.cern,https://root.cern/doc/master/classTGeoRotation.html,1,['simpl'],['simply']
Usability,"n at line 529 of file DecisionTreeNode.cxx. ◆ AddToSumTarget(). void TMVA::DecisionTreeNode::AddToSumTarget ; (; Float_t ; t). inline . add to sum target, if traininfo defined ; Definition at line 335 of file DecisionTreeNode.h. ◆ AddToSumTarget2(). void TMVA::DecisionTreeNode::AddToSumTarget2 ; (; Float_t ; t2). inline . add to sum target 2, if traininfo defined ; Definition at line 337 of file DecisionTreeNode.h. ◆ Class(). static TClass * TMVA::DecisionTreeNode::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::DecisionTreeNode::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::DecisionTreeNode::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 397 of file DecisionTreeNode.h. ◆ ClearNodeAndAllDaughters(). void TMVA::DecisionTreeNode::ClearNodeAndAllDaughters ; (; ). clear the nodes (their S/N, Nevents etc), just keep the structure of the tree ; Definition at line 346 of file DecisionTreeNode.cxx. ◆ CreateNode(). virtual Node * TMVA::DecisionTreeNode::CreateNode ; (; ); const. inlinevirtual . Implements TMVA::Node.; Definition at line 132 of file DecisionTreeNode.h. ◆ DeclFileName(). static const char * TMVA::DecisionTreeNode::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 397 of file DecisionTreeNode.h. ◆ GetAlpha(). Double_t TMVA::DecisionTreeNode::GetAlpha ; (; ); const. inline . return the critical point alpha, or -1 if traininfo undefined ; Definition at line 308 of file DecisionTreeNode.h. ◆ GetAlphaMinSubtree(). Double_t TMVA::DecisionTreeNode::GetAlphaMinSubtree ; (; ); const. inline . return the minimum alpha in the tree rooted at this node, or -1 if traininfo undefined ; Definition at line 313 of file DecisionTreeNode.h. ◆ GetCC(). Double_t TMVA::DecisionTreeNode::GetCC ; (; ); const. inline . return CC, or -1 if traininfo undefined ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html:16868,clear,clear,16868,doc/master/classTMVA_1_1DecisionTreeNode.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html,1,['clear'],['clear']
Usability,"n at line 971 of file RooProdPdf.cxx. ◆ makeRGPPName(). std::string RooProdPdf::makeRGPPName ; (; const char * ; pfx, . const RooArgSet & ; term, . const RooArgSet & ; iset, . const RooArgSet & ; nset, . const char * ; isetRangeName . ); const. private . Make an appropriate automatic name for a RooGenProdProj object in getPartIntList() ; Definition at line 1555 of file RooProdPdf.cxx. ◆ pdfList(). const RooArgList & RooProdPdf::pdfList ; (; ); const. inline . Definition at line 67 of file RooProdPdf.h. ◆ plotSamplingHint(). std::list< double > * RooProdPdf::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Forward the plot sampling hint from the p.d.f. that defines the observable obs. ; Reimplemented from RooAbsReal.; Definition at line 2106 of file RooProdPdf.cxx. ◆ printMetaArgs(). void RooProdPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 2189 of file RooProdPdf.cxx. ◆ processProductTerm(). std::vector< RooAbsReal * > RooProdPdf::processProductTerm ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset, . const char * ; isetRangeName, . const RooArgSet * ; term, . const RooArgSet & ; termNSet, . const RooArgSet & ; termISet, . bool & ; isOwned, . bool ; forceWrap = false . ); const. private . Calculate integrals of factorized product terms over observables iset while normalized to observables in nset. ; Definition at line 1382 of file RooProdPdf.cxx. ◆ rearrangeProduct(). void RooProdPdf::rearrangeProduct ; (; RooProdPdf::CacheElem & ; cache); const. private . Definition at line 989 of file RooProdPdf.cxx. ◆ redirectServersHook(). bool RooProdPdf::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overridevirtual . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:98170,intuit,intuitively,98170,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['intuit'],['intuitively']
Usability,"n be the case where the class definition is lost, or unavailable.; The current version of a shared library and an old file with old class versions (backward compatibility). This is often the case when reading old data.; Reading a file with a shared library built with MakeProject. This is the case when someone has already read the data without a shared library and has used ROOT MakeProject feature to reconstruct the class definitions and shared library (MakeProject is explained in detail later on). In case of a mismatch between the in-memory version and the persistent version of a class, ROOT maps the persistent one to the one in memory. This allows you to change the class definition at will, for example:. Change the order of data members in the class.; Add new data members. By default, the value of the missing member will be 0 or in case of an object it will be set to null.; Remove data members.; Move a data member to a base class or vice-versa.; Change the type of a member if it is a simple type or a pointer to a simple type. If a loss of precision occurs, a warning is given.; Add or remove a base class. The schema evolution for objects written on disk and in memory. ROOT supports schema evolution by keeping a class description of each version of the class that was ever written to disk, with the class. When it writes an object to file, it also writes the description of the current class version along with it. This description is implemented in the StreamerInfoclass.; 11.5.1 The TStreamerInfo Class; Each class has a list of StreamerInfo objects, one for each version of the class if that version was written to disk at least once. When reading an object from a file, the system uses the StreamerInfo list to decode an object into the current version. The StreamerInfo is made up of TStreamerElements . Each describes one persistent data member of the class. By default, all data members of a class are persistent. To exclude a data member (i.e. make it not persistent), add a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:491516,simpl,simple,491516,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['simpl'],['simple']
Usability,"n case one label does not exist yet. When the filling is terminated, it is possible to trim the number of bins to match the number of active labels by calling:; TH1::LabelsDeflate(axis);; Here axis may be X, Y, or Z. This operation is automatic when using TTree::Draw . Once bin labels have been created, they become persistent if the histogram is written to a file or when generating the C++ code via SavePrimitive .; 3.15 Histogram Stacks; A THStack is a collection of TH1 (or derived) objects. Use THStack::Add( TH1 *h) to add a histogram to the stack. The THStack does not own the objects in the list. Stacked histograms. By default, THStack::Draw draws the histograms stacked as shown in the left pad in the picture above. If the option ""nostack"" is used, the histograms are superimposed as if they were drawn one at a time using the ""same"" draw option . The right pad in this picture illustrates the THStack drawn with the ""nostack"" option.; hs->Draw(""nostack"");; Next is a simple example, for a more complex one see $ROOTSYS/tutorials/hist/hstack.C.; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; 3.16 TH2Poly; TH2Poly is a 2D Histogram class allowing to define polygonal bins of arbitrary shape.; Each bin in the TH2Poly histogram is a TH2PolyBin object. TH2PolyBin is a very simple class containing the vertices and contents of the polygonal bin as well as several related functions.; Bins are defined using one of the AddBin() methods. The bin definition should be done before filling.; The followin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:124169,simpl,simple,124169,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"n conditions. whichever algorithm is used, the output has to be checked:; (1) The L-curve should have approximate L-shape; and the final choice of tau should not be at the very edge of the; scanned region; (2) The scan result should have a well-defined minimum and the; final choice of tau should sit right in the minimum. Function Members (Methods); public:. TUnfoldDensity(const TUnfoldDensity&); TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""); virtual~TUnfoldDensity(); voidTObject::AbstractMethod(const char* method) const; voidTUnfoldSys::AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldDensity.html:5611,Clear,Clear,5611,root/html534/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html534/TUnfoldDensity.html,1,['Clear'],['Clear']
Usability,"n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1}, 1);; ; double ngen = nstats;; if (acceptancemodel == 1); ngen *= 2.0 / (23.0 / 15.0);; else; ngen *= 2.0 / (16.0 / 15.0);; RooRealVar ntot(""ntot"", ""ntot"", ngen, 0.0, 2.0 * ngen);; RooExtendPdf extended(""extended"", ""extended pdf"", pol, ntot);; int npoisson = rnd->Poisson(nstats);; ; // G e n e r a t e d a t a s e t f o r p s e u d o e x p e r i m e n t i; //-------------------------------------------------------------------------------; RooDataSet data(""data"", ""data"", {costheta, weight}, WeightVar(""weight""));; // generate nstats events; for (std::size_t j = 0; j < npoisson; j++) {; bool finished = false;; // use simple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account for acceptance; weight = 1.0 / eff;; // accept/reject; if (10.0 * rnd->Rndm() < eff * pol.getVal()); finished = true;; }; haccepted->Fill(costheta.getVal());; hweighted->Fill(costheta.getVal(), weight.getVal());; data.add({costheta, weight}, weight.getVal());; }; ; auto fillPulls = [&](std::size_t i) {; hc0pull[i]->Fill((c0.getVal() - c0gen) / c0.getError());; hc1pull[i]->Fill((c1.getVal() - c1gen) / c1.getError());; hntotpull[i]->Fill((ntot.getVal() - ngen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf611__weightedfits_8C.html:7231,simpl,simple,7231,doc/master/rf611__weightedfits_8C.html,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html,1,['simpl'],['simple']
Usability,"n event using the algorithm corresponding to the specified code. ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; RooAbsReal const & getMean () const;  Get the mean parameter. ;  ; RooAbsReal const & getSigma () const;  Get the sigma parameter. ;  ; RooAbsReal const & getX () const;  Get the x variable. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussian.html:2373,simpl,simple,2373,doc/master/classRooGaussian.html,https://root.cern,https://root.cern/doc/master/classRooGaussian.html,1,['simpl'],['simple']
Usability,"n example of a very simple use of the genetic algorithm of TMVA ;  TMVAMinimalClassification.C Minimal self-contained example for setting up TMVA with binary classification ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and column-wise storage performance ;  cernbuild.C Read data (CERN staff) from an ascii file and create a root file with a Tree ;  cernstaff.C Playing with a Tree containing variables of type character ;  circular.C Example of a circular Tree ;  clonesA_Event.CExample to write & read a Tree built with a complex class inheritance tree ;  clonesA_Event.cxx;  clonesA_Event.h;  copytree.C Copy a subset of a Tree to a new Tree ;  copytree2.C Copy a subset of a Tree to a new Tree, one branch in a separate file ;  copytree3.C Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries ;  drawsparse.C Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord ;  h1an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:160355,simpl,simple,160355,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['simpl'],['simple']
Usability,"n file; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); # And the created histogram is automatically attached to the file; print(""Histogram '{}' is attached to: '{}'.\n"".format(histo_2.GetName(), histo_2.GetDirectory().GetName())); # Before exiting the context, objects can be written to the file; f.WriteObject(histo_2, ""my_histogram""); ; # When the TFile.Close method is called, the current directory is automatically; # set again to ROOT.gROOT. Objects that were attached to the file inside the; # context are automatically deleted and made 'None' when the file is closed.; print(""Status after the first TFile context manager:""); print("" Current directory: '{}'."".format(ROOT.gDirectory.GetName())); print("" Accessing 'histo_2' gives: '{}'.\n"".format(histo_2)); ; # Also reading data from a TFile can be done in a context manager. Information; # stored in the objects of the file can be queried and used inside the context.; # After the context, the objects are not usable anymore because the file is; # automatically closed. This means you should use this pattern as a quick way; # to get information or modify objects from a certain file, without needing to; # keep the histograms alive afterwards.; with TFile.Open(""pyroot005_file_1.root"", ""read"") as f:; # Retrieve histogram using the name given to f.WriteObject in the previous; # with statement; histo_2_fromfile = f[""my_histogram""]; print(""Retrieved '{}' histogram from file '{}'.\n"".format(histo_2_fromfile.GetName(), f.GetName())); ; # Cleanup the file created for this tutorial; os.remove(""pyroot005_file_1.root""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot005__tfile__context__manager_8py.html:2654,usab,usable,2654,doc/master/pyroot005__tfile__context__manager_8py.html,https://root.cern,https://root.cern/doc/master/pyroot005__tfile__context__manager_8py.html,1,['usab'],['usable']
Usability,"n formula; TStringfSelection; TStatus*fStatus; Long64_tTSelector::fStatusselector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fTree.; Return kFALSE if any of the variable is not compilable. void DoFill(Long64_t entry, Double_t w, const Double_t* v). void DefVar(). int Version() const; { return 1; }. » Author: Maarten Ballintijn 24/09/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofDraw.h 39173 2011-05-12 18:04:44Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDraw.html:8153,Clear,ClearFormula,8153,root/html532/TProofDraw.html,https://root.cern,https://root.cern/root/html532/TProofDraw.html,1,['Clear'],['ClearFormula']
Usability,"n how closely the output matched the desired output ; Definition at line 1286 of file MethodMLP.cxx. ◆ UpdatePriors(). void TMVA::MethodMLP::UpdatePriors ; (; ). private . zjh ; Definition at line 1454 of file MethodMLP.cxx. ◆ UpdateRegulators(). void TMVA::MethodMLP::UpdateRegulators ; (; ). private . zjh ; Definition at line 1468 of file MethodMLP.cxx. ◆ UpdateSynapses(). void TMVA::MethodMLP::UpdateSynapses ; (; ). private . update synapse error fields and adjust the weights (if in sequential mode) ; Definition at line 1412 of file MethodMLP.cxx. Member Data Documentation. ◆ fBatchSize. Int_t TMVA::MethodMLP::fBatchSize. private . batch size, only matters if in batch learning mode ; Definition at line 192 of file MethodMLP.h. ◆ fBPMode. EBPTrainingMode TMVA::MethodMLP::fBPMode. private . backprop learning mode (sequential or batch) ; Definition at line 190 of file MethodMLP.h. ◆ fBpModeS. TString TMVA::MethodMLP::fBpModeS. private . backprop learning mode option string (sequential or batch) ; Definition at line 191 of file MethodMLP.h. ◆ fCalculateErrors. bool TMVA::MethodMLP::fCalculateErrors. private . compute inverse hessian matrix at the end of the training ; Definition at line 165 of file MethodMLP.h. ◆ fDecayRate. Double_t TMVA::MethodMLP::fDecayRate. private . decay rate for above learning rate ; Definition at line 189 of file MethodMLP.h. ◆ fDeviationsFromTargets. std::vector<std::pair<Float_t,Float_t> >* TMVA::MethodMLP::fDeviationsFromTargets. private . deviation from the targets, event weight ; Definition at line 204 of file MethodMLP.h. ◆ fEpochMon. Bool_t TMVA::MethodMLP::fEpochMon. private . create and fill epoch-wise monitoring histograms (makes outputfile big!) ; Definition at line 194 of file MethodMLP.h. ◆ fGA_nsteps. Int_t TMVA::MethodMLP::fGA_nsteps. private . GA settings: number of steps. ; Definition at line 197 of file MethodMLP.h. ◆ fGA_preCalc. Int_t TMVA::MethodMLP::fGA_preCalc. private . GA settings: number of pre-calc steps. ; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:50109,learn,learning,50109,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,"n in the global frame. It can be retrieved with:; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; The direction can be initialized in a similar manner as the current point:; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; TGeoManager::SetCurrentDirectionvoid SetCurrentDirection(Double_t *dir)Definition TGeoManager.h:518. Initializing the State; Setting the initial point and direction is not enough for initializing tracking. The modeller needs to find out where the initial point is located in the geometrical hierarchy. Due to the containment based architecture of the model, this is the deepest positioned object containing the point. For illustrating this, imagine that we have a simple structure with a top volume A and another one Bpositioned inside. Since Ais a top volume, its associated node A_1 will define MARS and our simple hierarchy of nodes (positioned volumes) will be: /A_1/B_1. Suppose now that the initial point is contained by B_1. This implies by default that the point is also contained by A_1, since B_1 have to be fully contained by this. After searching the point location, the modeller will consider that the point is located inside B_1, which will be considered as the representative object (node) for the current state. This is stored as: TGeoNode *TGeoNavigator::fCurrentNode and can be asked from the manager class only after the ‘'Where am I?’` was completed:; TGeoNode *current = gGeoManager->GetCurrentNode();; TGeoManager::GetCurrentNodeTGeoNode * GetCurrentNode() constDefinition TGeoManager.h:499; In order to find the location of the current point inside the hierarchy of nodes, after setting this point it is mandatory to call the ‘‘Where am I?’` method:; gGeoManager->FindNode();; TGeoManager::FindNodeTGeoNode * FindNode(Bool_t safe_start=kTRUE)Returns deepest node containing current p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:70834,simpl,simple,70834,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"n is cancel safe, they could call:; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; To cancel a thread TThread* th call:; th->Kill();; To cancel by thread name:; TThread::Kill(name);; To cancel a thread by ID:; TThread::Kill(tid);; To cancel a thread and delete th when cancel finished:; th->Delete();; Deleting of the thread instance by the operator delete is dangerous. Use th->Delete() instead. C++ delete is safe only if thread is not running. Often during the canceling, some clean up actions must be taken. To define clean up functions use:; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThread::CleanUpPop(1); // pop user function out of stack and; // execute it, thread resumes after this call; TThread::CleanUpPop(0); // pop user function out of stack; // _without_ executing it; Note: CleanUpPush and CleanUpPop should be used as corresponding pairs like brackets; unlike pthreads cleanup stack (which is not implemented here), TThread does not force this usage.; 23.2.4.7 Finishing thread; When a thread returns from a user function the thread is finished. It also can be finished by TThread::Exit(). Then, in case of thread-detached mode, the thread vanishes completely. By default, on finishing TThread executes the most recent cleanup function (CleanUpPop(1) is called automatically once).; 23.3 Advanced TThread: Launching a Method in a Thread; Consider a class Myclass with a member function that shall be launched as a thread.; void* Myclass::Thread0((void* arg); To start Thread0 as a TThread, class Myclass may provide a method:; Int_t Myclass::Threadstart(){; if(!mTh){; mTh= new TThread(""memberfunction"",; (void(*)(void *))&Thread0,(void*) this);; mTh->Run();; return 0;; }; return 1;; }; Here mTh is a TThre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1113208,resume,resumes,1113208,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['resume'],['resumes']
Usability,"n issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFunctorBinding.h>. Inheritance diagram for RooFunctorBinding:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooFunctorBinding() [1/3]. RooFunctorBinding::RooFunctorBinding ; (; ). default . ◆ RooFunctorBinding() [2/3]. RooFunctorBinding::RooFunctorBinding ; (; const char * ; name, . const char * ; title, . const ROOT::Math::IBaseFunctionMultiDim & ; ftor, . const RooArgList & ; v . ). Create a RooFit function that makes ftor usable in RooFit. ; Parameters. nameName of the object. ; titleTitle (e.g. for plotting) ; ftorFunctor instance to be evaluated. ; vRooFit variables to be passed to the function. . Definition at line 56 of file RooFunctorBinding.cxx. ◆ RooFunctorBinding() [3/3]. RooFunctorBinding::RooFunctorBinding ; (; const RooFunctorBinding & ; other, . const char * ; name = nullptr . ). Definition at line 72 of file RooFunctorBinding.cxx. ◆ ~RooFunctorBinding(). RooFunctorBinding::~RooFunctorBinding ; (; ). inlineoverride . Definition at line 37 of file RooFunctorBinding.h. Member Function Documentation. ◆ Class(). static TClass * RooFunctorBinding::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooFunctorBinding::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooFunctorBinding::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 51 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFunctorBinding.html:60808,usab,usable,60808,doc/master/classRooFunctorBinding.html,https://root.cern,https://root.cern/doc/master/classRooFunctorBinding.html,1,['usab'],['usable']
Usability,"n maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 62 of file RooFFTConvPdf.h. ◆ pdfObservable(). RooAbsArg & RooFFTConvPdf::pdfObservable ; (; RooAbsArg & ; histObservable); const. overrideprotectedvirtual . Return p.d.f. ; observable (which can be a function) to substitute given p.d.f. observable. Substitutes x by xprime if xprime is set. ; Reimplemented from RooAbsCachedPdf.; Definition at line 847 of file RooFFTConvPdf.cxx. ◆ prepareFFTBinning(). void RooFFTConvPdf::prepareFFTBinning ; (; RooRealVar & ; convVar); const. private . Try to improve the binning and inform user if possible. ; With a 10% buffer fraction, 930 raw bins yield 1024 FFT bins, a sweet spot for the speed of FFTW. ; Definition at line 302 of file RooFFTConvPdf.cxx. ◆ printMetaArgs(). void RooFFTConvPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 947 of file RooFFTConvPdf.cxx. ◆ scanPdf(). std::vector< double > RooFFTConvPdf::scanPdf ; (; RooRealVar & ; obs, . RooAbsPdf & ; pdf, . const RooDataHist & ; hist, . const RooArgSet & ; slicePos, . Int_t & ; N, . Int_t & ; N2, . Int_t & ; zeroBin, . double ; shift . ); const. protected . Scan the values of 'pdf' in observable 'obs' using the bin values stored in 'hist' at slice position 'slicePos' N is filled with the number of bins defined in hist, N2 is filled with N plus the number of buffer bins The return value is an array of doubles of length N2 with the sampled values. ; The caller takes ownership of the array ; Definition at line 665 of file RooFFTConvPdf.cxx. ◆ setBufferFraction(). void RooFFTConvPdf::setBufferFraction ; (; double ; frac). Change the size of the buffer on either side of the observable range to frac times the size of the range of the convolutio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:93939,intuit,intuitively,93939,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['intuit'],['intuitively']
Usability,"n mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. TGeoVolume * Volume(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t npar = 0); Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. TGeoVolume * Volume(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t npar = 0); Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. void SetAllIndex(); Assigns uid's for all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current nod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:44689,Clear,ClearAttributes,44689,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,4,['Clear'],['ClearAttributes']
Usability,"n of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. ; Caches with RooAbsArg derived payload require special care as server redirects cache operation mode changes and constant term optimization calls may need to be forwarded to such cache payload. This cache manager takes care of all these operations by forwarding these calls to the RooAbsCacheElement interface functions, which have a sensible default implementation. ; Definition at line 29 of file RooObjCacheManager.h. Public Member Functions;  RooObjCacheManager (const RooObjCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooObjCacheManager (RooAbsArg *owner=nullptr, Int_t maxSize=2, bool clearCacheOnServerRedirect=true, bool allowOptimize=false);  Constructor of object cache manager for given owner. ;  ;  ~RooObjCacheManager () override;  Destructor. ;  ; void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  If clearOnRedirect is false, forward constant term optimization calls to cache elements. ;  ; void insertObjectHook (RooAbsCacheElement &) override;  Set owner link on all object inserted into cache. ;  ; TClass * IsA () const override;  ; void operModeHook () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:1361,clear,clearOnRedirect,1361,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['clear'],['clearOnRedirect']
Usability,"n of h1 by h2.; 1253///; 1254/// `this = (c1*h1)*(c2*h2)`; 1255 ; 1256Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1257{; 1258 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1259 return kFALSE;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Project this profile into a 1-D histogram along X; 1264///; 1265/// The projection is always of the type TH1D.; 1266///; 1267/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1268/// to be equal to the errors of the profile.; 1269/// Option ""E"" is defined as the default one in the header file.; 1270/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1271/// - if option ""B"" is specified, the content of bin of the returned histogram; 1272/// will be equal to the GetBinEntries(bin) of the profile,; 1273/// otherwise (default) it will be equal to GetBinContent(bin); 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH1D using the 2-nd value as a weight.; 1280/// This makes sense only for profile filled with weights =1. If not, the error of the; 1281/// projected histogram obtained with this option will not be correct.; 1282 ; 1283TH1D *TProfile::ProjectionX(const char *name, Option_t *option) const; 1284{; 1285 ; 1286 TString opt = option;; 1287 opt.ToLower();; 1288 Int_t nx = fXaxis.GetNbins();; 1289 ; 1290 // Create the projection histogram; 1291 TString pname = name;; 1292 if (pname == ""_px"") {; 1293 pname = GetName();; 1294 pname.Append(""_px"");; 1295 }; 1296 TH1D *h1;; 1297 const TArrayD ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:46319,simpl,simply,46319,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['simpl'],['simply']
Usability,"n range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProduct with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgList components(); { RooArgList tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Sat Jun 20 16:42:32 2015 » Last generated: 2015-06-20 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:37959,intuit,intuitively,37959,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,2,['intuit'],['intuitively']
Usability,"n range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProduct with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgList components(); { RooArgList tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Sat Jun 20 17:30:24 2015 » Last generated: 2015-06-20 17:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooProduct.html:39457,intuit,intuitively,39457,root/html604/RooProduct.html,https://root.cern,https://root.cern/root/html604/RooProduct.html,2,['intuit'],['intuitively']
Usability,"n range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProduct with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgList components(); { RooArgList tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Tue Jun 30 14:35:02 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:39457,intuit,intuitively,39457,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,2,['intuit'],['intuitively']
Usability,"n request. TList * GetListOfPackages(); Get from the master the list of names of the packages available. TList * GetListOfEnabledPackages(); Get from the master the list of names of the packages enabled. void PrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1., Long64_t bytesread = -1); Print a progress bar on stderr. Used in batch mode. void Progress(Long64_t total, Long64_t processed); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Get query progress information. Connect a slot to this signal; to track progress. void Feedback(TList* objs); Get list of feedback objects. Connect a slot to this signal; to monitor the feedback object. void CloseProgressDialog(); Close progress dialog. void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset progress dialog. void StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total); Send startup message. void DataSetStatus(const char* msg, Bool_t status, Int_t done, Int_t total); Send dataset preparation status. void SendDataSetStatus(const char* msg, UInt_t n, UInt_t tot, Bool_t st); Send or notify data set status. void QueryResultReady(const char* ref); Notify availability of a query result. void ValidateDSet(TDSet* dset); Validate a TDSet. void AddInputData(TObject* obj, Bool_t push = kFALSE); Add data objects that might be needed during the processing of; the selector (see Process()). This object can be very large, so they; are distributed in an optimized way using a dedicated file.; If push is TRUE the input data are sent over even if no a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:70479,feedback,feedback,70479,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,14,"['Feedback', 'feedback']","['Feedback', 'feedback']"
Usability,"n sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionViewer(const char* title = ""ROOT Session Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionViewer.html:25780,feedback,feedback,25780,root/html528/TSessionViewer.html,https://root.cern,https://root.cern/root/html528/TSessionViewer.html,6,['feedback'],['feedback']
Usability,"n that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Computes how much space the given simple string needs. The return value is the width (in pixels) of the given string. string -- String whose width will be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen(). Int_t XTextWidth(const char* string, Int_t numChars = -1) const; Return text widht in pixels. void UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing charact",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGFont.html:10137,simpl,simple,10137,root/html528/TGFont.html,https://root.cern,https://root.cern/root/html528/TGFont.html,10,['simpl'],['simple']
Usability,"n the Draw() method means:. The axis should be drawn (option A),; The graph should be drawn as a simple line (option L).; By default a graph is drawn in the current pad in the current coordinate system. To define a suitable coordinate system and draw the axis the option A must be specified. TGraphPainter offers many options to paint the various kind of graphs.; It is separated from the graph classes so that one can have graphs without the graphics overhead, for example in a batch program.; When a displayed graph is modified, there is no need to call Draw() again; the image will be refreshed the next time the pad will be updated. A pad is updated after one of these three actions:. a carriage return on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. Option Description . ""A"" Produce a new plot with Axis around the graph . ""I"" Combine with option 'A' it draws invisible axis . ""L"" A simple polyline is drawn . ""F"" A fill area is drawn ('CF' draw a smoothed fill area) . ""C"" A smooth Curve is drawn . ""*"" A Star is plotted at each point . ""P"" The current marker is plotted at each point . ""B"" A Bar chart is drawn . ""1"" When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad. By default they start at 0. . ""X+"" The X-axis is drawn on the top side of the plot. . ""Y+"" The Y-axis is drawn on the right side of the plot. . ""PFC"" Palette Fill Color: graph's fill color is taken in the current palette. . ""PLC"" Palette Line Color: graph's line color is taken in the current palette. . ""PMC"" Palette Marker Color: graph's marker color is taken in the current palette. . ""RX"" Reverse the X axis. . ""RY"" Reverse the Y axis. . Drawing options can be combined. In the following example the graph is drawn as a smooth curve (option ""C"") with markers (option ""P"") and with axes (option ""A"").; {; auto c1 = new TCanvas(""c1"",""c1"",200,10,600,400);; ; c1->SetFillColo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:2032,simpl,simple,2032,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,1,['simpl'],['simple']
Usability,"n the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:24361,Learn,Learn,24361,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,1,['Learn'],['Learn']
Usability,"n the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:23744,Learn,Learn,23744,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['Learn'],['Learn']
Usability,"n the callback.; 14352 *; 14353 * TODO: What would be the best reaction here?; 14354 * (Note: The reaction may change, if there is a better; 14355 * idea.); 14356 */; 14357 ; 14358 /* For the moment, use option c: We look for a proper file,; 14359 * but since a file request is not always a script resource,; 14360 * the authorization check might be different. */; 14361 interpret_uri(conn,; 14362 path,; 14363 sizeof(path),; 14364 &file.stat,; 14365 &is_found,; 14366 &is_script_resource,; 14367 &is_websocket_request,; 14368 &is_put_or_delete_request,; 14369 &is_template_text_file);; 14370 callback_handler = NULL;; 14371 ; 14372 /* Here we are at a dead end:; 14373 * According to URI matching, a callback should be; 14374 * responsible for handling the request,; 14375 * we called it, but the callback declared itself; 14376 * not responsible.; 14377 * We use a goto here, to get out of this dead end,; 14378 * and continue with the default handling.; 14379 * A goto here is simpler and better to understand; 14380 * than some curious loop. */; 14381 goto no_callback_resource;; 14382 }; 14383 } else {; 14384#if defined(USE_WEBSOCKET); 14385 handle_websocket_request(conn,; 14386 path,; 14387 is_callback_resource,; 14388 subprotocols,; 14389 ws_connect_handler,; 14390 ws_ready_handler,; 14391 ws_data_handler,; 14392 ws_close_handler,; 14393 callback_data);; 14394#endif; 14395 }; 14396 return;; 14397 }; 14398 ; 14399 /* 8. handle websocket requests */; 14400#if defined(USE_WEBSOCKET); 14401 if (is_websocket_request) {; 14402 HTTP1_only;; 14403 if (is_script_resource) {; 14404 ; 14405 if (is_in_script_path(conn, path)) {; 14406 /* Websocket Lua script */; 14407 handle_websocket_request(conn,; 14408 path,; 14409 0 /* Lua Script */,; 14410 NULL,; 14411 NULL,; 14412 NULL,; 14413 NULL,; 14414 NULL,; 14415 conn->phys_ctx->user_data);; 14416 } else {; 14417 /* Script was in an illegal path */; 14418 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14419 }; 14420 } else {; 14421 mg_sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:423419,simpl,simpler,423419,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['simpl'],['simpler']
Usability,"n the callback.; 14353 *; 14354 * TODO: What would be the best reaction here?; 14355 * (Note: The reaction may change, if there is a better; 14356 * idea.); 14357 */; 14358 ; 14359 /* For the moment, use option c: We look for a proper file,; 14360 * but since a file request is not always a script resource,; 14361 * the authorization check might be different. */; 14362 interpret_uri(conn,; 14363 path,; 14364 sizeof(path),; 14365 &file.stat,; 14366 &is_found,; 14367 &is_script_resource,; 14368 &is_websocket_request,; 14369 &is_put_or_delete_request,; 14370 &is_template_text_file);; 14371 callback_handler = NULL;; 14372 ; 14373 /* Here we are at a dead end:; 14374 * According to URI matching, a callback should be; 14375 * responsible for handling the request,; 14376 * we called it, but the callback declared itself; 14377 * not responsible.; 14378 * We use a goto here, to get out of this dead end,; 14379 * and continue with the default handling.; 14380 * A goto here is simpler and better to understand; 14381 * than some curious loop. */; 14382 goto no_callback_resource;; 14383 }; 14384 } else {; 14385#if defined(USE_WEBSOCKET); 14386 handle_websocket_request(conn,; 14387 path,; 14388 is_callback_resource,; 14389 subprotocols,; 14390 ws_connect_handler,; 14391 ws_ready_handler,; 14392 ws_data_handler,; 14393 ws_close_handler,; 14394 callback_data);; 14395#endif; 14396 }; 14397 return;; 14398 }; 14399 ; 14400 /* 8. handle websocket requests */; 14401#if defined(USE_WEBSOCKET); 14402 if (is_websocket_request) {; 14403 HTTP1_only;; 14404 if (is_script_resource) {; 14405 ; 14406 if (is_in_script_path(conn, path)) {; 14407 /* Websocket Lua script */; 14408 handle_websocket_request(conn,; 14409 path,; 14410 0 /* Lua Script */,; 14411 NULL,; 14412 NULL,; 14413 NULL,; 14414 NULL,; 14415 NULL,; 14416 conn->phys_ctx->user_data);; 14417 } else {; 14418 /* Script was in an illegal path */; 14419 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14420 }; 14421 } else {; 14422 mg_sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:423452,simpl,simpler,423452,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['simpl'],['simpler']
Usability,"n the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Using a Macro to Read a TTree. Why using a macro?; As real analyses don't fit into simple TTree::Draw() invocations, and as it is quite cumbersome to type the same lines again and again in the Root prompt, simply create macros for commonly used code. A macro is a file that is interpreted by ROOT.; Creating and Editing the Macro; Create a macro (e.g. AnalyzeTree.C) using your favorite text editor, e.g. with vi, emacs, wordpad, Eclipse, Visual Studio,... The macro should start with the proper #include statements and should contain the function declaration with the same name than the macro itself. As we know we're going to use TFile and TTree (at least), we can already include their headers TFile.h and TTree.h. Then come the function implementation.; Function Implementation; Lets start with something simple: calculate the sum of all event sizes. For this we need a new variable of type int. Create (declare) it at the beginning of the function, and don't forget to initialize it to 0. At the end, the code in AnalyzeTree.C should look like this:; #include ""TFile.h""; #include ""TTree.h"". void AnalyzeTree(); {; // Variables used to store the data; Int_t totalSize = 0; // Sum of data size (in bytes) of all events. ... Opening the File and Getting the Tree; The first thing to do is to open the file containing the tree, by calling TFile::Open(), passing the file name, and then, if the file is open (i.e. if the pointer to it is not NULL), create a TTreeReader using the tree name and the file. At the end, the code in AnalyzeTree.C should look like this:; ... // open the file; TFile *f = TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");; if (f == 0) {; // if we cannot open the file, print an error message and return immediatly; printf(""Error: cannot open http://root.cern/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:2724,simpl,simple,2724,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['simpl'],['simple']
Usability,"n this canvas as a C++ macro file.Definition TCanvas.cxx:1822; TCanvas::HandleInputvirtual void HandleInput(EEventType button, Int_t x, Int_t y)Handle Input Events.Definition TCanvas.cxx:1234; TCanvas::UpdateAsyncvoid UpdateAsync() overrideAsynchronous pad update.Definition TCanvas.cxx:2545; TCanvas::GetSelectedTObject * GetSelected() const overrideDefinition TCanvas.h:141; TCanvas::GetEventXInt_t GetEventX() const overrideDefinition TCanvas.h:136; TCanvas::SetCanvasSizevoid SetCanvasSize(UInt_t ww, UInt_t wh) overrideSet Width and Height of canvas to ww and wh respectively.Definition TCanvas.cxx:1975; TCanvas::GetSelectedPadTVirtualPad * GetSelectedPad() const overrideDefinition TCanvas.h:146; TCanvas::SetCursorvoid SetCursor(ECursor cursor) overrideSet cursor.Definition TCanvas.cxx:1989; TCanvas::GetCanvasIDInt_t GetCanvasID() const overrideDefinition TCanvas.h:157; TCanvas::GetWindowWidthUInt_t GetWindowWidth() constDefinition TCanvas.h:161; TCanvas::FeedbackModevoid FeedbackMode(Bool_t set)Turn rubberband feedback mode on or off.Definition TCanvas.cxx:1128; TCanvas::SetClickSelectedvoid SetClickSelected(TObject *obj)Definition TCanvas.h:209; TCanvas::GetPadSaveTVirtualPad * GetPadSave() const overrideDefinition TCanvas.h:139; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TCanvas::Clearedvirtual void Cleared(TVirtualPad *pad)Emit pad Cleared signal.Definition TCanvas.cxx:770; TCanvas::GetWwUInt_t GetWw() const overrideDefinition TCanvas.h:163; TCanvas::OpaqueMovingBool_t OpaqueMoving() const overrideDefinition TCanvas.h:180; TCanvas::GetWhUInt_t GetWh() const overrideDefinition TCanvas.h:164; TCanvas::Classstatic TClass * Class(); TCanvas::SetSelectedvoid SetSelected(TObject *obj) overrideSet selected canvas.Definition TCanvas.cxx:2146; TCanvas::GetEventInt_t GetEvent() const overrideDefinition TCanvas.h:135; TCanvas::IsWebBool_t IsWeb() const overrideIs web canvas.Definition TCanvas.cxx:1496; TCanvas::SetBatchvoid Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:272886,feedback,feedback,272886,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['feedback'],['feedback']
Usability,"n this list one can still access the list to search for; 466/// other not yet deleted objects).; 467 ; 468void TList::Delete(Option_t *option); 469{; 470 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 471 R__COLLECTION_WRITE_GUARD();; 472 ; 473 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : kFALSE) : kFALSE;; 474 ; 475 TList removeDirectory; // need to deregister these from their directory; 476 ; 477 if (slow) {; 478 ; 479 // In some case, for example TParallelCoord, a list (the pad's list of; 480 // primitives) will contain both the container and the containees; 481 // (the TParallelCoorVar) but if the Clear is being called from; 482 // the destructor of the container of this list, one of the first; 483 // thing done will be the remove the container (the pad) for the; 484 // list (of Primitives of the canvas) that was connecting it; 485 // (indirectly) to the list of cleanups.; 486 ; 487 // To preserve this connection (without introducing one when there was none),; 488 // we re-use fCache to inform RecursiveRemove of the node currently; 489 // being cleared/deleted.; 490 while (fFirst) {; 491 auto tlk = fFirst;; 492 fFirst = fFirst->fNext;; 493 fSize--;; 494 ; 495 // Make node available to RecursiveRemove; 496 tlk->fNext.reset();; 497 tlk->fPrev.reset();; 498 fCache = tlk;; 499 ; 500 // delete only heap objects; 501 auto obj = tlk->GetObject();; 502 if (obj && ROOT::Detail::HasBeenDeleted(obj)); 503 Error(""Delete"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 504 obj, GetName());; 505 else if (obj && obj->IsOnHeap()); 506 TCollection::GarbageCollect(obj);; 507 else if (obj && obj->IsA()->GetDirectoryAutoAdd()); 508 removeDirectory.Add(obj);; 509 ; 510 // delete tlk;; 511 }; 512 ; 513 fFirst.reset();; 514 fLast.reset();; 515 fCache.reset();; 516 fSize = 0;; 517 ; 518 } else {; 519 ; 520 auto first = fFirst; //pointer to first entry in linked list; 521 fFirst.reset();; 522 fLast.reset();; 523 fCache.reset();; 524 fSize = 0;; 52",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:15340,clear,cleared,15340,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['clear'],['cleared']
Usability,"n to TProof::fLogFileW. ;  ; void SetInitTime () override;  Set init time. ;  ; void SetMerging (Bool_t on=kTRUE) override;  Switch on/off merge timer. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:4539,feedback,feedback,4539,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"n underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing characters to be underlined or overstruck.; x, y -- Coordinates at which first character of string is drawn.; firstChar -- Index of first character.; lastChar -- Index of one after the last character. TGTextLayout * ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; Computes the amount of screen space needed to display a multi-line,; justified string of text. Records all the measurements that were done; to determine to size and positioning of the individual lines of text;; this information can be used by the TGTextLayout::DrawText() procedure; to display the text quickly (without remeasuring it). This procedure is useful for simple widgets that want to display; single-font, multi-line text and want TGFont to handle the details. The return value is a TGTextLayout token that holds the measurement; information for the given string. The token is only valid for the given; string. If the string is freed, the token is no longer valid and must; also be deleted. The dimensions of the screen area needed to display the text are stored; in *width and *height. string -- String whose dimensions are to be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen().; wrapLength -- Longest permissible line length, in pixels. <= 0 means no; automatic wrapping: just let lines get as long as needed.; justify -- How to justify lines.; flags -- Flag bits OR-ed together. kTextIgnoreTabs means that tab; characters should not be expanded. kTextIgnoreNewlines; means that newline characters should not cause a line break.; width -- Filled with width of string.; height -- Filled with height of string. LayoutChunk_t * NewChunk(TGTextLayout* l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGFont.html:11842,simpl,simple,11842,root/html528/TGFont.html,https://root.cern,https://root.cern/root/html528/TGFont.html,10,['simpl'],['simple']
Usability,"n versions with bug fixes. We release about two production versions per year. The old version is the previous production version that people might need for some time before switching to the new version.; Release candidate; A Release Candidate is a preview of the next production release. It allows users to make their code ready for the new production release, and to provide early feedback.; Development release; Use this to get access to the latest and greatest, but as a side effect there might be some instabilities. However, by trying out the development version you can help us converge much more quickly to a stable version that can then become the new production version.; Nightlies; You can download nightly snapshots of ROOT. That's useful to check whether a bug fix actually fixes an issue you reported, or to see the newest feature you heard about. It helps us tremendously to get feedback from you on nightlies: please try them out and report back to us!; Using binaries; After unpacking / installing the binary, and before using ROOT you should use a special script distributed with ROOT:; source <pathname>/root/bin/thisroot.sh (there are versions for [t]csh and fish, too.); where <pathname> is the location where you unpacked the ROOT distribution.; Typically add these lines to your .profile or .login files. Docker (Experimental); We also provide ROOT in Docker containers, for more information see Docker Hub.; The following recent versions are available for download:. Latest ROOT Releases. ; Pro ; Release 6.20/04 - 2020-04-01 ; . Old ; Release 6.18/04 - 2019-09-11 ; ; ; . Version 6 ; ; Release 6.20/06 - 2020-06-10. Release 6.20/04 - 2020-04-01. Release 6.20/02 - 2020-03-15. Release 6.20/00 - 2020-02-26. Release 6.19/02 - 2020-01-10. Release 6.18/04 - 2019-09-11. Release 6.18/02 - 2019-08-23. . . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publicati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/downloading-root.html:3218,feedback,feedback,3218,d/downloading-root.html,https://root.cern,https://root.cern/d/downloading-root.html,1,['feedback'],['feedback']
Usability,"n'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static bool getFloorGlobal ();  ; static void setFloorGlobal (bool flag);  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:59802,clear,clearEvalErrorLog,59802,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"n'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static bool getFloorGlobal ();  ; static void setFloorGlobal (bool flag);  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:58572,clear,clearEvalErrorLog,58572,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"n't the covariance; 37# matrix. Normalising the covariance matrix is a good idea if your; 38# variables have different orders of magnitude.; 39principal = TPrincipal(n, ""ND""); 40 ; 41# Use a pseudo-random number generator; 42randomNum = gRandom; 43 ; 44# Make the m data-points; 45# Make a variable to hold our data; 46# Allocate memory for the data point; 47data = vector('double')(); 48for i in range(m):; 49 # First we create the un-correlated, random variables, according; 50 # to one of three distributions; 51 for j in range(n - c):; 52 if j % 3 == 0:; 53 data.push_back(randomNum.Gaus(5, 1)); 54 elif j % 3 == 1:; 55 data.push_back(randomNum.Poisson(8)); 56 else:; 57 data.push_back(randomNum.Exp(2)); 58 ; 59 # Then we create the correlated variables; 60 for j in range(c):; 61 data.push_back(0); 62 for k in range(n - c - j):; 63 data[n - c + j] += data[k]; 64 ; 65 # Finally we're ready to add this datapoint to the PCA; 66 principal.AddRow(data.data()); 67 data.clear(); 68 ; 69# Do the actual analysis; 70principal.MakePrincipals(); 71 ; 72# Print out the result on; 73principal.Print(); 74 ; 75# Test the PCA; 76principal.Test(); 77 ; 78# Make some histograms of the original, principal, residue, etc data; 79principal.MakeHistograms(); 80 ; 81# Make two functions to map between feature and pattern space; 82# Start a browser, so that we may browse the histograms generated; 83# above; 84principal.MakeCode(); 85b = TBrowser(""principalBrowser"", principal); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/principal_8py_source.html:2177,clear,clear,2177,doc/master/principal_8py_source.html,https://root.cern,https://root.cern/doc/master/principal_8py_source.html,1,['clear'],['clear']
Usability,"n() [4/4]. const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 455 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 305 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 415 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented from TObject.; Definition at line 76 of file RooAbsCollection.h. ◆ contains(). bool RooAbsCollection::contains ; (; const RooAbsArg & ; var); const. inlin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:36905,clear,clearStructureTags,36905,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['clear'],['clearStructureTags']
Usability,"n(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:17316,clear,cleared,17316,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,2,['clear'],['cleared']
Usability,"n(). bool RooRealSumFunc::isBinnedDistribution ; (; const RooArgSet & ; ); const. overridevirtual . Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ; Reimplemented from RooAbsReal.; Definition at line 148 of file RooRealSumFunc.cxx. ◆ plotSamplingHint(). std::list< double > * RooRealSumFunc::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented from RooAbsReal.; Definition at line 154 of file RooRealSumFunc.cxx. ◆ printMetaArgs(). void RooRealSumFunc::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooRealSumFunc to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 168 of file RooRealSumFunc.cxx. ◆ setCacheAndTrackHints(). void RooRealSumFunc::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Reimplemented from RooAbsArg.; Definition at line 160 of file RooRealSumFunc.cxx. ◆ setFloor(). void RooRealSumFunc::setFloor ; (; bool ; flag). inline . Definition at line 53 of file RooRealSumFunc.h. ◆ setFloorGlobal(). static void RooRealSumFunc::setFloorGlobal ; (; bool ; flag). inlinestatic . Definition at line 55 of file RooRealSumFunc.h. ◆ Streamer(). void RooRealSumFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooRealSumFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 78 of file RooRealSumFunc.h. ◆ translate(). void RooRealSumFunc::translate ; (; RooFit::Detai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:68204,intuit,intuitively,68204,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,2,['intuit'],['intuitively']
Usability,"n(pvalue);; 25.8.10 Progress Bars; A progress bar is a widget that shows that an operation is in progress and how much time is left. It is a long rectangular bar, initially empty, that fills with a color as a process is being performed. The filled-in area indicates the percentage of the process that has been completed. You should use this widget for waits exceeding one minute. For a very time consuming operation it is better to break the operation into subtasks and provide a progress bar for each of them. A progress bar may be oriented horizontally or vertically. The horizontally oriented progress bar fills with a color from left to right; the vertically oriented - from bottom to top. A percent complete message provides an indication of the completed part of the process. It is a good practice to include some descriptive text of the process to keep users informed and entertained while they are waiting for process completion.; The picture below shows the progress bars you can create using the classes TGProgressBar, TGHProgressBar, and TGHProgressBar.; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg2,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg3,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->Resize(200, 200);; 25.8.11 Static Widgets; The classes TGLabel and TGIcon show some information - text or graphics. The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1208619,progress bar,progress bars,1208619,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['progress bar'],['progress bars']
Usability,"n(tree);\n"",scriptfunc.Data());; 1961 fprintf(hf,""\n"");; 1962 fprintf(hf,""}\n"");; 1963 fprintf(hf,""\n"");; 1964 ; 1965 // generate code for class member function Process; 1966 fprintf(hf,""inline bool %s::Process(Long64_t entry)\n"",classname.Data());; 1967 fprintf(hf,""{\n"");; 1968 ; 1969 fprintf(hf,"" // The Process() function is called for each entry in the tree (or possibly\n""; 1970 "" // keyed object in the case of PROOF) to be processed. The entry argument\n""; 1971 "" // specifies which entry in the currently loaded tree is to be processed.\n""; 1972 "" // It can be passed to either TTree::GetEntry() or TBranch::GetEntry()\n""; 1973 "" // to read either all or the required parts of the data. When processing\n""; 1974 "" // keyed objects with PROOF, the object is already loaded and is available\n""; 1975 "" // via the fObject pointer.\n""; 1976 "" //\n""; 1977 "" // This function should contain the \""body\"" of the analysis. It can contain\n""; 1978 "" // simple or elaborate selection criteria, run algorithms on the data\n""; 1979 "" // of the event and typically fill histograms.\n\n"");; 1980 fprintf(hf,"" // WARNING when a selector is used with a TChain, you must use\n"");; 1981 fprintf(hf,"" // the pointer to the current TTree to call GetEntry(entry).\n"");; 1982 fprintf(hf,"" // The entry is always the local entry number in the current tree.\n"");; 1983 fprintf(hf,"" // Assuming that fChain is the pointer to the TChain being processed,\n"");; 1984 fprintf(hf,"" // use fChain->GetTree()->GetEntry(entry).\n"");; 1985 fprintf(hf,""\n"");; 1986 fprintf(hf,""\n"");; 1987 fprintf(hf,"" fDirector.SetReadEntry(entry);\n"");; 1988 if (fOptions & kNoHist) {; 1989 if (cutfilename) {; 1990 fprintf(hf,"" if (%s()) %s();\n"",cutscriptfunc.Data(),scriptfunc.Data());; 1991 } else {; 1992 fprintf(hf,"" %s();\n"",scriptfunc.Data());; 1993 }; 1994 } else {; 1995 if (cutfilename) {; 1996 fprintf(hf,"" if (%s()) htemp->Fill(%s());\n"",cutscriptfunc.Data(),scriptfunc.Data());; 1997 } else {; 1998 fprintf(hf,"" htemp->Fill(%s(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:75521,simpl,simple,75521,doc/master/TTreeProxyGenerator_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html,1,['simpl'],['simple']
Usability,"n); Set the version string - returns kFALSE if the format is incorrect. const char * GetVersion() const; Get the version string. Bool_t TestVersion(Int_t version) const; Check if given version number is defined in this rule. Bool_t SetChecksum(const TString& checksum); Set the checksum string - returns kFALSE if the format is incorrect. Bool_t TestChecksum(UInt_t checksum) const; Check if given checksum is defined in this rule. void SetSourceClass(const TString& classname); Set the source class of this rule (i.e. the onfile class). const char * GetSourceClass() const; Get the source class of this rule (i.e. the onfile class). void SetTargetClass(const TString& classname); Set the target class of this rule (i.e. the in memory class). const char * GetTargetClass() const; Get the targte class of this rule (i.e. the in memory class). void SetTarget(const TString& target); Set the target member of this rule (i.e. the in memory data member). const char * GetTargetString() const; Get the target data members of this rule as a simple string (i.e. the in memory data member). const TObjArray* GetTarget() const; Get the target data members of this rule (i.e. the in memory data member). void SetSource(const TString& source); Set the list of source members. This should be in the form of a declaration:; Int_t fOldMember; TNamed fName;. const TObjArray* GetSource() const; Get the list of source members as a TObjArray of TNamed object,; with the name being the member name and the title being its type. void SetInclude(const TString& include); Set the comma separated list of header files to include to be able; to compile this rule. const TObjArray* GetInclude() const; Return the list of header files to include to be able to; compile this rule as a TObjArray of TObjString. void SetEmbed(Bool_t embed); Set whether this rule should be save in the ROOT file (if true). Bool_t GetEmbed() const; Return true if this rule should be saved in the ROOT File. Bool_t IsValid() const; Return kTRUE i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__TSchemaRule.html:9871,simpl,simple,9871,root/html528/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html528/ROOT__TSchemaRule.html,6,['simpl'],['simple']
Usability,"n); TGraphErrors(const TGraphErrors& gr); TGraphErrors(const TH1* h); TGraphErrors(const char* filename, const char* format = ""%lg %lg %lg %lg"", Option_t* option = """"); TGraphErrors(const TVectorF& vx, const TVectorF& vy, const TVectorF& vex, const TVectorF& vey); TGraphErrors(const TVectorD& vx, const TVectorD& vy, const TVectorD& vex, const TVectorD& vey); TGraphErrors(Int_t n, const Float_t* x, const Float_t* y, const Float_t* ex = 0, const Float_t* ey = 0); TGraphErrors(Int_t n, const Double_t* x, const Double_t* y, const Double_t* ex = 0, const Double_t* ey = 0); virtual~TGraphErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); static Int_tCalculateScanfFields(const char* fmt); virtual Double_tTGraph::Chisquare(const TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tTGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareX(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareY(const TGraph* gr, Int_t left, Int_t right); virtual voidComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGraph::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGraph::Draw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTGraph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphErrors.html:2231,Clear,Clear,2231,root/html534/TGraphErrors.html,https://root.cern,https://root.cern/root/html534/TGraphErrors.html,1,['Clear'],['Clear']
Usability,"n)SIGNAL ; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidCreateDisabledPicture(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGButton::EmitSignals(Bool_t wasUp); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGPictureButton(const TGPictureButton&); TGPictureButton&operator=(const TGPictureButton&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGPictureButton.html:18224,Clear,ClearFlags,18224,root/html532/TGPictureButton.html,https://root.cern,https://root.cern/root/html532/TGPictureButton.html,2,['Clear'],['ClearFlags']
Usability,"n, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, const RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:76137,clear,clearEvalError,76137,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['clear'],['clearEvalError']
Usability,"n. ; . Function Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet2ByIndex(Int_t index) const; RooObjCacheManager&operator=(const RooObjCacheManager&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooCacheManager<RooAbsCacheElement>::reset(); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp, char* parent); voidRooCacheManager<RooAbsCacheElement>::sterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Bool_t_clearOnRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:1058,clear,clearCacheOnServerRedirect,1058,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,1,['clear'],['clearCacheOnServerRedirect']
Usability,"n. It is advisable however to define these properties just after the first creation of a volume namespace, since in case of volume families any new member created by the modeler inherits these properties.; In order to provide navigation features, volumes have to be able to find the proper container of any point defined in the local reference frame. This can be the volume itself, one of its positioned daughter volumes or none if the point is actually outside. On the other hand, volumes have to provide also other navigation methods such as finding the distances to its shape boundaries or which daughter will be crossed first. The implementation of these features is done at shape level, but the local mother-daughters management is handled by volumes that builds additional optimisation structures upon geometry closure. In order to have navigation features properly working one has to follow the general rules for building a valid geometry (see TGeoManager class).; Now let's make a simple volume representing a copper wire. We suppose that a medium is already created (see TGeoMedium class on how to create media). We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm and a half-length dZ=1cm :; TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);; TGeoTubeDefinition TGeoTube.h:17; One may omit the name for the shape if no retrieving by name is further needed during geometry building. The same shape can be shared by different volumes having different names and materials. Now let's make the volume for our wire. The prototype for volumes constructor looks like :; TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med); Since TGeoTube derives from the base shape class, we can provide it to the volume constructor :; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::TGeoVolumeTGeoVolume()dummy constructorDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:2757,simpl,simple,2757,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['simpl'],['simple']
Usability,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:125097,simpl,simple,125097,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['simpl'],['simple']
Usability,"n.; 3337 ; 3338 cl = GetIdMap()->Find(typeinfo.name());; 3339 ; 3340 if (cl) {; 3341 if (cl->IsLoaded()) return cl;; 3342 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3343 load = kTRUE;; 3344 } else {; 3345 // Note we might need support for typedefs and simple types!; 3346 ; 3347 // TDataType *objType = GetType(name, load);; 3348 //if (objType) {; 3349 // const char *typdfName = objType->GetTypeName();; 3350 // if (typdfName && strcmp(typdfName, name)) {; 3351 // cl = GetClass(typdfName, load);; 3352 // return cl;; 3353 // }; 3354 // }; 3355 }; 3356 ; 3357 if (!load) return nullptr;; 3358 ; 3359 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3360 if (dict) {; 3361 cl = (dict)();; 3362 if (cl) cl->PostLoadCheck();; 3363 return cl;; 3364 }; 3365 if (cl) return cl;; 3366 ; 3367 TIter next(gROOT->GetListOfClassGenerators());; 3368 TClassGenerator *gen;; 3369 while( (gen = (TClassGenerator*) next()) ) {; 3370 cl = gen->GetClass(typeinfo,load);; 3371 if (cl) {; 3372 cl->PostLoadCheck();; 3373 return cl;; 3374 }; 3375 }; 3376 ; 3377 // try AutoLoading the typeinfo; 3378 int autoload_old = gCling->SetClassAutoLoading(1);; 3379 if (!autoload_old) {; 3380 // Re-disable, we just meant to test; 3381 gCling->SetClassAutoLoading(0);; 3382 }; 3383 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3384 // Disable autoload to avoid potential infinite recursion; 3385 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3386 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3387 if (cl) {; 3388 return cl;; 3389 }; 3390 }; 3391 ; 3392 if (hint_pair_offset) {; 3393 int err = 0;; 3394 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3395 if (!err) {; 3396 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3397 free(demangled_name);; 3398 if (cl); 3399 return cl;; 3400 }; 3401 }; 3402 ; 3403 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:127848,simpl,simple,127848,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['simpl'],['simple']
Usability,"n::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the outpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:24433,learn,learning,24433,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,10,['learn'],['learning']
Usability,"n; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQUndoManager.html:19656,undo,undo,19656,root/html534/TQUndoManager.html,https://root.cern,https://root.cern/root/html534/TQUndoManager.html,2,['undo'],['undo']
Usability,"n; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:22758,Undo,Undo,22758,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,4,['Undo'],['Undo']
Usability,"n; method. Function Members (Methods); public:. virtual~TGeoParallelWorld(); voidTObject::AbstractMethod(const char* method) const; voidAddNode(const char* path); voidAddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); voidAddOverlap(const char* volname, Bool_t activate = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckOverlaps(Double_t ovlp = 0.001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; Bool_tCloseGeometry(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoPhysicalNode*FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); TGeoPhysicalNode*FindNode(Double_t[3] point); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoManager*GetGeometry() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoParallelWorld.html:1339,Clear,Clear,1339,root/html604/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html604/TGeoParallelWorld.html,1,['Clear'],['Clear']
Usability,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-04-23 20:07; This page has been automatically generated. For comments or suggestions regarding t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGDockableFrame.html:21426,undo,undock,21426,root/html534/TGDockableFrame.html,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html,2,['undo'],['undock']
Usability,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2010-09-23 20:05; This page has been automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGDockableFrame.html:21326,undo,undock,21326,root/html528/TGDockableFrame.html,https://root.cern,https://root.cern/root/html528/TGDockableFrame.html,1,['undo'],['undock']
Usability,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2011-07-04 15:28; This page has been automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGDockableFrame.html:21426,undo,undock,21426,root/html530/TGDockableFrame.html,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html,1,['undo'],['undock']
Usability,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2011-11-03 20:13; This page has been automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGDockableFrame.html:21426,undo,undock,21426,root/html532/TGDockableFrame.html,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html,2,['undo'],['undock']
Usability,"n@ kGreenDefinition Rtypes.h:66; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; qfloat * qDefinition THbookFile.cxx:89; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAnglevirtual void SetTextAngle(Float_t tangle=0)Set the text angle.Definition TAttText.h:43; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2I2-D histogram with an int per channel (see TH1 documentation)Definition TH2.h:225; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TTextBase class for several text objects.Definition TText.h:22; TText::DrawTextvirtual TText * DrawText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:176; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; AuthorGeorg Troska ; Definition in file candleplotwhiskers.C. tutorialshistcandleplotwhiskers.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/candleplotwhiskers_8C.html:4881,simpl,simple,4881,doc/master/candleplotwhiskers_8C.html,https://root.cern,https://root.cern/doc/master/candleplotwhiskers_8C.html,1,['simpl'],['simple']
Usability,"nBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nvecgeom;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  CBasicRNNLayerGeneric implementation ;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  Cclient_cert;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_cert;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_header;  Cmg_option;  Cmg_request_info;  Cmg_response_info;  Cmg_server_ports;  Cmg_websocket_subprotocols;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:91842,simpl,simple,91842,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['simpl'],['simple']
Usability,"nBase> fActionPtr;; 179 ; 180 /// Triggers the event loop in the RLoopManager; 181 void TriggerRun();; 182 ; 183 /// Get the pointer to the encapsulated result.; 184 /// Ownership is not transferred to the caller.; 185 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 186 T *Get(); 187 {; 188 if (fActionPtr != nullptr && !fActionPtr->HasRun()); 189 TriggerRun();; 190 return fObjPtr.get();; 191 }; 192 ; 193 void ThrowIfNull(); 194 {; 195 if (fObjPtr == nullptr); 196 throw std::runtime_error(""Trying to access the contents of a null RResultPtr."");; 197 }; 198 ; 199 RResultPtr(std::shared_ptr<T> objPtr, RDFDetail::RLoopManager *lm,; 200 std::shared_ptr<RDFInternal::RActionBase> actionPtr); 201 : fLoopManager(lm), fObjPtr(std::move(objPtr)), fActionPtr(std::move(actionPtr)); 202 {; 203 }; 204 ; 205public:; 206 using Value_t = T; ///< Convenience alias to simplify access to proxied type; 207 static constexpr ULong64_t kOnce = 0ull; ///< Convenience definition to express a callback must be executed once; 208 ; 209 RResultPtr() = default;; 210 RResultPtr(const RResultPtr &) = default;; 211 RResultPtr(RResultPtr &&) = default;; 212 RResultPtr &operator=(const RResultPtr &) = default;; 213 RResultPtr &operator=(RResultPtr &&) = default;; 214 explicit operator bool() const { return bool(fObjPtr); }; 215 ; 216 /// Convert a RResultPtr<T2> to a RResultPtr<T>.; 217 ///; 218 /// Useful e.g. to store a number of RResultPtr<TH1D> and RResultPtr<TH2D> in a std::vector<RResultPtr<TH1>>.; 219 /// The requirements on T2 and T are the same as for conversion between std::shared_ptr<T2> and std::shared_ptr<T>.; 220 template <typename T2,; 221 std::enable_if_t<std::is_constructible<std::shared_ptr<T>, std::shared_ptr<T2>>::value, int> = 0>; 222 RResultPtr(const RResultPtr<T2> &r) : fLoopManager(r.fLoopManager), fObjPtr(r.fObjPtr), fActionPtr(r.fActionPtr); 223 {; 224 }; 225 ; 226 /// Get a const reference to the encapsulated object.; 227 /// Trigger",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:8284,simpl,simplify,8284,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['simpl'],['simplify']
Usability,"nBinsnumber of bins to scan, if = -1 no scan is done (default); RooArgSetfNuisanceParameters; RooArgSetfPOI; RooAbsPdf*fPdf; ROOT::Math::IBaseFunctionOneDim*fPosteriorFunctionfunction representing the posterior; RooAbsPdf*fPosteriorPdfnormalized (on the poi) posterior pdf ; RooAbsPdf*fPriorPOI; RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPOI,						 const RooArgSet* nuisanceParameters ); TNamed( TString(name), TString(title) ),; constructor. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); constructor from Model Config. ~BayesianCalculator(); destructor. void ClearAll() const; clear cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model. RooAbsReal* GetPosteriorFunction() const; build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters. RooAbsPdf* GetPosteriorPdf() const; build and return the posterior pdf (i.e posterior function normalized to all range of poi; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region. void SetIntegrationType(const char* type). SimpleInterval* GetInterval(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__BayesianCalculator.html:8355,clear,clear,8355,root/html528/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__BayesianCalculator.html,1,['clear'],['clear']
Usability,nCalculator.cxx;  BernsteinCorrection.cxx;  ConfidenceBelt.cxx;  DetailedOutputAggregator.cxx;  FeldmanCousins.cxx;  FrequentistCalculator.cxx;  Heaviside.cxx;  HLFactory.cxx;  HybridCalculator.cxx;  HybridCalculatorOriginal.cxx;  HybridPlot.cxx;  HybridResult.cxx;  HypoTestCalculatorGeneric.cxx;  HypoTestInverter.cxx;  HypoTestInverterOriginal.cxx;  HypoTestInverterPlot.cxx;  HypoTestInverterResult.cxx;  HypoTestPlot.cxx;  HypoTestResult.cxx;  LikelihoodInterval.cxx;  LikelihoodIntervalPlot.cxx;  MarkovChain.cxx;  MCMCCalculator.cxx;  MCMCInterval.cxx;  MCMCIntervalPlot.cxx;  MetropolisHastings.cxx;  ModelConfig.cxx;  NeymanConstruction.cxx;  NumberCountingPdfFactory.cxx;  NumberCountingUtils.cxx;  PdfProposal.cxx;  PointSetInterval.cxx;  ProfileInspector.cxx;  ProfileLikelihoodCalculator.cxx;  ProfileLikelihoodTestStat.cxx;  ProposalHelper.cxx;  RatioOfProfiledLikelihoodsTestStat.cxx;  RooStatsUtils.cxx;  SamplingDistPlot.cxx;  SamplingDistribution.cxx;  SequentialProposal.cxx;  SimpleInterval.cxx;  SimpleLikelihoodRatioTestStat.cxx;  SPlot.cxx;  ToyMCImportanceSampler.cxx;  ToyMCSampler.cxx;  ToyMCStudy.cxx;  UniformProposal.cxx;  UpperLimitMCSModule.cxx;  ► sql;  ► mysql;  ► inc;  LinkDef.h;  TMySQLResult.h;  TMySQLRow.h;  TMySQLServer.h;  TMySQLStatement.h;  ► src;  TMySQLResult.cxx;  TMySQLRow.cxx;  TMySQLServer.cxx;  TMySQLStatement.cxx;  ► odbc;  ► inc;  LinkDef.h;  TODBCResult.h;  TODBCRow.h;  TODBCServer.h;  TODBCStatement.h;  ► src;  TODBCResult.cxx;  TODBCRow.cxx;  TODBCServer.cxx;  TODBCStatement.cxx;  ► oracle;  ► inc;  LinkDef.h;  TOracleResult.h;  TOracleRow.h;  TOracleServer.h;  TOracleStatement.h;  ► src;  TOracleResult.cxx;  TOracleRow.cxx;  TOracleServer.cxx;  TOracleStatement.cxx;  ► pgsql;  ► inc;  LinkDef.h;  TPgSQLResult.h;  TPgSQLRow.h;  TPgSQLServer.h;  TPgSQLStatement.h;  ► src;  TPgSQLResult.cxx;  TPgSQLRow.cxx;  TPgSQLServer.cxx;  TPgSQLStatement.cxx;  ► sapdb;  ► inc;  LinkDef.h;  TSapDBResult.h;  TSapDBRow.h;  TSapDBServer.h;  ► src;  T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:87039,Simpl,SimpleInterval,87039,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Simpl'],['SimpleInterval']
Usability,"nInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); 816 AddDoublePtrParam();; 817 ; 818 // We need an extra Double_t* for the gradient return result.; 819 if (AddCladArrayRef) {; 820 prototypeArguments.Append("","");; 821 prototypeArguments.Append(""Double_t*"");; 822 }; 823 ; 824 // Initialize the method call using real function name (cling name) defined; 825 // by Process",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:28816,clear,clear,28816,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['clear'],['clear']
Usability,"nProxy::Initialize(Bool_t silent) const; virtual TGenCollectionProxy*TEmulatedCollectionProxy::InitializeEx(Bool_t silent); voidTEmulatedCollectionProxy::ReadItems(int nElements, TBuffer& b); voidReadMap(int nElements, TBuffer& b); voidTEmulatedCollectionProxy::Shrink(UInt_t nCurr, UInt_t left, Bool_t force); voidTEmulatedCollectionProxy::WriteItems(int nElements, TBuffer& b); voidWriteMap(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedMapProxy.html:4600,clear,clear,4600,root/html532/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedMapProxy.html,2,['clear'],['clear']
Usability,"nStop, Bool_t, const char* wgtVarName = 0); virtual~RooVectorDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); const RooVectorDataStore*cache() const; virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kTRUE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidRooAbsDataStore::checkInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:2062,Clear,Clear,2062,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,1,['Clear'],['Clear']
Usability,"nUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::MnFcn&, const ROOT::Minuit2::GradientCalculator&, const ROOT::Minuit2::MinimumSeed&, const ROOT::Minuit2::MnStrategy&, unsigned int, double) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; ROOT::Minuit2::SimplexMinimizer&operator=(const ROOT::Minuit2::SimplexMinimizer&); virtual const ROOT::Minuit2::MinimumSeedGenerator&SeedGenerator() const; ROOT::Minuit2::SimplexMinimizerSimplexMinimizer(); ROOT::Minuit2::SimplexMinimizerSimplexMinimizer(const ROOT::Minuit2::SimplexMinimizer&). Data Members; private:. ROOT::Minuit2::SimplexBuilderfBuilder; ROOT::Minuit2::SimplexSeedGeneratorfSeedGenerator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimplexMinimizer(); {}. ~SimplexMinimizer(); {}. » Last changed: root/minuit2:$Id: SimplexMinimizer.h 21530 2007-12-20 11:14:35Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Minuit2__SimplexMinimizer.html:3500,Simpl,SimplexMinimizer,3500,root/html532/ROOT__Minuit2__SimplexMinimizer.html,https://root.cern,https://root.cern/root/html532/ROOT__Minuit2__SimplexMinimizer.html,10,['Simpl'],"['SimplexBuilderfBuilder', 'SimplexMinimizer', 'SimplexMinimizerSimplexMinimizer', 'SimplexSeedGeneratorfSeedGenerator']"
Usability,"n_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TH2::FitSlicesXvirtual void FitSlicesX(TF1 *f1=nullptr, Int_t firstybin=0, Int_t lastybin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along X in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1016; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:99",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:11122,simpl,simple,11122,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['simpl'],['simple']
Usability,"n_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TH2::FitSlicesXvirtual void FitSlicesX(TF1 *f1=nullptr, Int_t firstybin=0, Int_t lastybin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along X in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1016; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:16257,simpl,simple,16257,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,1,['simpl'],['simple']
Usability,"n_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); virtual Bool_tTProof::CancelStagingDataSet(const char* dataset); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTProof::ClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidTProof::ClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; TDrawFeedback*TProof::CreateDrawFeedback(); voidTProof::DataSetStatus(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; Int_tTProof::Deactiv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:2428,Clear,ClearInputData,2428,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,6,['Clear'],['ClearInputData']
Usability,"nal function? There is no abstract base class? No templates? It implies that you plan to keep the pointless T in front of all the names of ROOT, even though you will have access to namespaces (finally) and thus can move past the 1970's C practice of avoiding name collisions by a sort of weird Hungarian notation. It implies that you plan to maintain the outdated interfaces which make no use of templates. Templates are one of the most powerful features of C++, are more relevant to performance critical tasks than inheritance, and help ensure the type-safety of code (thereby ensuring the accuracy of data by helping to prevent accidental narrowing etc). It implies that you intend to continue to encourage the use of bare new and delete operators, instead of relying on the more efficient, reliable, and safe method of using RAII. Why? This begs the obvious question: why bother migrating at all? You wish to migrate to the modern and superior C++11 in order to not take advantage of its features? Why not just simply maintain ROOT5 and CINT, and just refuse to upgrade? ROOT is not a particularly good framework that is written in a language that isn't quite C++. If you are going to break away and make/use/write cling, then fix the poor design decisions: cling will probably break compatibility anyways despite your best efforts, so you might as well take the time and effort to refactor and clean up the code base. A simple example, taken from this website: """""" TFFTComplex One of the interface classes to the FFTW package, can be used directly or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes complex input/output discrete Fourier transforms (DFT) in one or more dimensions. For the detailed information on the computed transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it: 1) Create an instance of TFFTComplex - this will allocate input and output arrays (unless an in-place transform is specified) 2) Run the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:10317,simpl,simply,10317,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simply']
Usability,"nal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTProofPlayer::Feedback(TList* objs)SIGNAL ; voidTProofPlayer::FeedBackCanvas(const char* name, Bool_t create); virtual Long64_tTProofPlayer::Finalize(TQueryResult* qr); virtual Long64_tTProofPlayer::Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTProofPlayer::GetCacheSize(); virtual TQueryResult*TProofPlayer::GetCurrentQuery() const; virtual Int_tTProofPlayer::GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTProofPlayer::GetEventsProcessed() const; virtual TVirtualProofPlayer::EExitStatusTProofPlayer::GetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual TList*TProofPlayer::GetInputList() const; virtual Int_tTProofPlayer::GetLearnEntries(); TList*TQObject::GetListOfClassSignals() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerLocal.html:5099,Feedback,Feedback,5099,root/html532/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html532/TProofPlayerLocal.html,4,['Feedback'],['Feedback']
Usability,"nal_name, Int_t, const T &... params);  Emit a signal with a varying number of arguments. ;  ; TList * GetListOfClassSignals () const;  Returns pointer to list of signals of this class. ;  ; TList * GetListOfConnections () const;  ; TList * GetListOfSignals () const;  ; virtual Bool_t HasConnection (const char *signal_name) const;  Return true if there is any object connected to this signal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TQCommand * GetCommand ();  Return a command which is doing redo/undo action. ;  ;  Static Public Member Functions inherited from TList; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSeqCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:23067,undo,undo,23067,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"nals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoRotationEditor.html:22027,undo,undoing,22027,root/html534/TGeoRotationEditor.html,https://root.cern,https://root.cern/root/html534/TGeoRotationEditor.html,2,['undo'],['undoing']
Usability,"nalsBlocked() const; Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* recei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveStraightLineSet.html:3036,Clear,ClearProjectedList,3036,root/html532/TEveStraightLineSet.html,https://root.cern,https://root.cern/root/html532/TEveStraightLineSet.html,4,['Clear'],['ClearProjectedList']
Usability,"nalsBlocked() const; Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTEveStraightLineSet::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveScalableStraightLineSet.html:3137,Clear,ClearProjectedList,3137,root/html532/TEveScalableStraightLineSet.html,https://root.cern,https://root.cern/root/html532/TEveScalableStraightLineSet.html,8,['Clear'],['ClearProjectedList']
Usability,"nalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Float_t*TAttBBox::AssertBBox(); TEveRGBAPalette*AssertPalette(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTAttBBox::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveDigitSet.html:4448,Clear,ClearStamps,4448,root/html532/TEveDigitSet.html,https://root.cern,https://root.cern/root/html532/TEveDigitSet.html,4,['Clear'],['ClearStamps']
Usability,"nalyzer;  CTModuleDocInfo;  CTMonaLisaText;  CTMonaLisaValue;  CTMonaLisaWriter;  CTMonitor;  CTMPClientBase class for multiprocess applications' clients ;  CTMPWorkerThis class works in conjuction with TMPClient, reacting to messages received from it as specified by the Notify and HandleInput methods ;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStep;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorDataMap;  CTPackageDescription;  CTPacketizer;  CTPacketizerAdapti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:144306,simpl,simple,144306,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['simpl'],['simple']
Usability,"name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringfNameIdentfier for this object; TProof*fProofhandle to PROOF session; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatsFeedback(TProof* proof = 0); Constructor. ~TStatsFeedback(); Destructor. void Feedback(TList* objs); Display feedback. const char * GetName() const; { return fName.Data(); }. ULong_t Hash() const; { return fName.Hash(); }. » Author: G. Ganis May 2012 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatsFeedback.html:9027,feedback,feedback,9027,root/html534/TStatsFeedback.html,https://root.cern,https://root.cern/root/html534/TStatsFeedback.html,3,"['Feedback', 'feedback']","['Feedback', 'feedback']"
Usability,"name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this method returns the uncertainties on the unfolding result arising from the background source source and its normalisation uncertainty. See method SubtractBackground() how to set the normalisation uncertainty ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1144 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundUncorr(). void TUnfoldSys::GetEmatrixSysBackgroundUncorr ; (; TH2 * ; ematrix, . const char * ; source, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background uncorrelated uncertainty ; Parameters. [in]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result arising from the background source source and the uncorrelated (background histogram uncertainties). Also see method SubtractBackground() ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1229 of file TUnfoldSys.cxx. ◆ GetEmatrixSysSource(). void TUnfoldSys::GetEmatrixSysSource ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from a systematic variation of the response matrix ; Parameters. [in,out]ematrixcovariance mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:39390,clear,clearEmat,39390,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,name. Multiple streams can write to same file. . OutputStream(ostream&) Send output to given C++ stream. Multiple message streams can write to same c++ stream . The return value is the unique ID of the defined stream. PyROOT; The RooMsgService::addStream() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArg of the function. . Definition at line 177 of file RooMsgService.cxx. ◆ anyDebug(). bool RooMsgService::anyDebug ; (; ). static . Returns true if any debug level stream is active. ; Definition at line 138 of file RooMsgService.cxx. ◆ Class(). static TClass * RooMsgService::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooMsgService::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooMsgService::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 246 of file RooMsgService.h. ◆ clearErrorCount(). void RooMsgService::clearErrorCount ; (; ). inline . Definition at line 200 of file RooMsgService.h. ◆ debugCode(). Int_t & RooMsgService::debugCode ; (; ). inline . Definition at line 207 of file RooMsgService.h. ◆ debugWorkspace(). RooWorkspace * RooMsgService::debugWorkspace ; (; ). Definition at line 147 of file RooMsgService.cxx. ◆ DeclFileName(). static const char * RooMsgService::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 246 of file RooMsgService.h. ◆ deleteStream(). void RooMsgService::deleteStream ; (; Int_t ; id). Delete stream with given unique ID code. ; Definition at line 293 of file RooMsgService.cxx. ◆ errorCount(). Int_t RooMsgService::errorCount ; (; ); const. inline . Definition at line 199 of file RooMsgService.h. ◆ getStream(). StreamConfig & RooMsgService::getStream ; (; Int_t ; id). inline . Definition at line 161 of file RooMsgService.h. ◆ getStreamStatus(). bool RooMsgService::get,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:17967,clear,clearErrorCount,17967,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['clear'],['clearErrorCount']
Usability,"napsesarray of pointers to synapses, no structural data; boolTMVA::MethodANNBase::fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:20071,learn,learning,20071,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,5,"['clear', 'learn']","['clear', 'learning']"
Usability,"nates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInit(); voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGComboBox(const TGComboBox&); TGComboBox&operator=(const TGComboBox&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCann",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGComboBox.html:17048,Clear,ClearFlags,17048,root/html532/TGComboBox.html,https://root.cern,https://root.cern/root/html532/TGComboBox.html,2,['Clear'],['ClearFlags']
Usability,"nc (passThrough, myweights, gradients);; 313 // return value;; 314 // }; 315 // };; 316 ; 317 ; 318 ; 319 ///< list all the minimizer types; 320 enum MinimizerType; 321 {; 322 fSteepest ///< SGD; 323 };; 324 ; 325 ; 326 ; 327 ; 328 ; 329 /*! \brief Steepest Gradient Descent algorithm (SGD); 330 *; 331 * Implements a steepest gradient descent minimization algorithm; 332 */; 333 class Steepest; 334 {; 335 public:; 336 ; 337 size_t m_repetitions;; 338 ; 339 ; 340 /*! \brief c'tor; 341 *; 342 * C'tor; 343 *; 344 * \param learningRate denotes the learning rate for the SGD algorithm; 345 * \param momentum fraction of the velocity which is taken over from the last step; 346 * \param repetitions re-compute the gradients each ""repetitions"" steps; 347 */; 348 Steepest (double learningRate = 1e-4,; 349 double momentum = 0.5,; 350 size_t repetitions = 10); 351 : m_repetitions (repetitions); 352 , m_alpha (learningRate); 353 , m_beta (momentum); 354 {}; 355 ; 356 /*! \brief operator to call the steepest gradient descent algorithm; 357 *; 358 * entry point to start the minimization procedure; 359 *; 360 * \param fitnessFunction (templated) function which has to be provided. This function is minimized; 361 * \param weights (templated) a reference to a container of weights. The result of the minimization procedure; 362 * is returned via this reference (needs to support std::begin and std::end; 363 * \param passThrough (templated) object which can hold any data which the fitness function needs. This object; 364 * is not touched by the minimizer; This object is provided to the fitness function when; 365 * called; 366 */; 367 template <typename Function, typename Weights, typename PassThrough>; 368 double operator() (Function& fitnessFunction, Weights& weights, PassThrough& passThrough);; 369 ; 370 ; 371 double m_alpha; ///< internal parameter (learningRate); 372 double m_beta; ///< internal parameter (momentum); 373 std::vector<double> m_prevGradients; ///< vector remembers the gradie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:9202,learn,learningRate,9202,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['learn'],['learningRate']
Usability,"nce Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t > Class Template Reference. ; template<typename Architecture_t, typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >RMSProp Optimizer class. ; This class represents the RMSProp Optimizer with options for applying momentum. ; Definition at line 45 of file RMSProp.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TRMSProp (DeepNet_t &deepNet, Scalar_t learningRate=0.001, Scalar_t momentum=0.0, Scalar_t rho=0.9, Scalar_t epsilon=1e-7);  Constructor. ;  ;  ~TRMSProp ()=default;  Destructor. ;  ; std::vector< std::vector< Matrix_t > > & GetBiasUpdates ();  ; std::vector< Matrix_t > & GetBiasUpdatesAt (size_t i);  ; Scalar_t GetEpsilon () const;  ; Scalar_t GetMomentum () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ; Scalar_t GetRho () const;  ; std::vector< std::vector< Matrix_t > > & GetWeightUpdates ();  ; std::vector< Matrix_t > & GetWeightUpdatesAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:1144,learn,learningRate,1144,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['learn'],['learningRate']
Usability,"nce parameters; RooStats::ProofConfig*fProofConfig!; const RooDataSet*fProtoDatain dev; stringfSamplingDistNamename of the model; Double_tfSize; vector<RooStats::TestStatistic*>fTestStatistics; Double_tfToysInTails; Bool_tfUseMultiGenUse PrepareMultiGen?; static Bool_tfgAlwaysUseMultiGenUse PrepareMultiGen always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetAlwaysUseMultiGen(Bool_t flag); { fgAlwaysUseMultiGen = flag ; }. ToyMCSampler(); Proof constructor. Do not use. ToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys). ~ToyMCSampler(). Bool_t CheckConfig(void); only checks, no guessing/determination (do this in calculators,; e.g. using ModelConfig::GuessObsAndNuisance(...)). RooArgList* EvaluateAllTestStatistics(RooAbsData& data, const RooArgSet& poi); Evaluate all test statistics, returning result and any detailed output.; PDF parameter values are saved in case they are modified by; TestStatistic::Evaluate (eg. SimpleLikelihoodRatioTestStat). const RooArgList* EvaluateAllTestStatistics(RooAbsData& data, const RooArgSet& poi, RooStats::DetailedOutputAggregator& detOutAgg). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramPoint). RooDataSet* GetSamplingDistributions(RooArgSet& paramPoint); Use for serial and parallel runs. RooDataSet* GetSamplingDistributionsSingleWorker(RooArgSet& paramPoint); This is the main function for serial runs. It is called automatically; from inside GetSamplingDistribution when no ProofConfig is given.; You should not call this function yourself. This function should; be used by ToyMCStudy on the workers (ie. when you explicitly want; a serial run although ProofConfig is present). void GenerateGlobalObservables(RooAbsPdf& pdf) const. RooAbsData* GenerateToyData(RooArgSet& paramPoint, double& weight, RooAbsPdf& pdf) const; This method generates a toy data set for the given parameter point taking; global observables into account.; The values of the generated global observ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__ToyMCSampler.html:5980,Simpl,SimpleLikelihoodRatioTestStat,5980,root/html602/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__ToyMCSampler.html,2,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,"nce& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject*); virtual Bool_tCheckObject(const void*, const TClass*); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBufferJSON.html:2185,Clear,Clear,2185,root/html602/TBufferJSON.html,https://root.cern,https://root.cern/root/html602/TBufferJSON.html,2,['Clear'],['Clear']
Usability,"nce& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject*); virtual Bool_tCheckObject(const void*, const TClass*); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0, const char* member_name = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0, const char* member_name = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0, Int_t arraylen = -1); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:2213,Clear,Clear,2213,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,1,['Clear'],['Clear']
Usability,"nce. Namespaces; namespace  BitPacking;  . Classes; struct  AxisConfigToType;  Converts a RAxisConfig of whatever kind to the corresponding RAxisBase-derived object. More...;  ; struct  AxisConfigToType< RAxisConfig::kEquidistant >;  ; struct  AxisConfigToType< RAxisConfig::kGrow >;  ; struct  AxisConfigToType< RAxisConfig::kIrregular >;  ; struct  AxisConfigToType< RAxisConfig::kLabels >;  ; class  RArraySizeField;  An artificial field that provides the size of a fixed-size array. More...;  ; class  RCluster;  An in-memory subset of the packed and compressed pages of a cluster. More...;  ; class  RClusterDescriptorBuilder;  A helper class for piece-wise construction of an RClusterDescriptor. More...;  ; class  RClusterGroupDescriptorBuilder;  A helper class for piece-wise construction of an RClusterGroupDescriptor. More...;  ; class  RClusterPool;  Managed a set of clusters containing compressed and packed pages. More...;  ; class  RColumn;  A column is a storage-backed array of a simple, fixed-size type, from which pages can be mapped into memory. More...;  ; class  RColumnDescriptorBuilder;  A helper class for piece-wise construction of an RColumnDescriptor. More...;  ; class  RColumnElementBase;  A column element encapsulates the translation between basic C++ types and their column representation. More...;  ; struct  RColumnInfo;  ; struct  RComputeGlobalBin;  Recursively gets the total number of regular bins before the current dimension, when computing a global bin that is in under- or overflow in at least one dimension. More...;  ; struct  RComputeGlobalBin<-1, NDIMS, BINS, AXES >;  ; struct  RComputeGlobalBinRaw;  Recursively computes a zero-based global bin index, given... More...;  ; struct  RComputeGlobalBinRaw<-1, NDIMS, BINS, AXES, BINTYPE >;  ; struct  RComputeLocalBins;  Recursively computes the number of regular bins before the current dimension, as well as the number of under- and overflow bins left to account for, after the current dimension. More..",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:1259,simpl,simple,1259,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,1,['simpl'],['simple']
Usability,"nch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; WARNING: Currently only ONE TTree object can be 'cached' per TFile object.; This call disable the cache for the other TTree objects read from the same; TFile object as this TTree (The SetCacheSize called __last__ wins).; To cache multiple TTree objects in the same ROOT file, you must create; one TFile object per TTree object. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:120396,learn,learning,120396,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['learn'],['learning']
Usability,"nchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:3703,undo,undo,3703,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,10,['undo'],['undo']
Usability,"nclude <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2b.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h); : TGMainFrame(p,w,h) {. // Creates widgets of the example; fEcanvas = new TRootEmbeddedCanvas (""Ecanvas"",this,200,200);; AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY, 10,10,10,1));; TGHorizontalFrame *hframe=new TGHorizontalFrame(this, 200,40);; TGTextButton *draw = new TGTextButton(hframe,""&Draw"");; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; hframe->AddFrame(draw, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; TGTextButton *exit = new TGTextButton(hframe,""&Exit "",; ""gApplication->Terminate()"");; hframe->AddFrame(exit, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; AddFrame(hframe,new TGLayoutHints(kLHintsCenterX,2,2,2,2));. // Sets window name and shows the main frame; SetWindowName(""Simple Example"");; MapSubwindows();; Resize(GetDefaultSize());; MapWindow();; }; 25.5 Widgets Overview; The word widget is a contraction of windows and gadget. Almost all GUI elements are widgets. A button is a widget, a menu item is a widget, a scrollbar is a widget, and a complete dialog box is a widget too. Some widgets may have sub widgets. For example, a dialog box can contain buttons, text fields, a combo-box, etc.; On the screen widgets look like rectangular areas with special behaviors. In terms of the object-oriented programming we can define a widget in ROOT as an object of a class deriving from TGObject.; This section presents all currently supported widgets in ROOT and their most useful methods. All of them can be considered as building blocks for an application, and most of them can be found in dialogs. Provided snippets of the code will give you practical guidelines where and how to use certain widgets. The macro $ROOTSYS/tutorials/gui/guitest.C contains the complete source code. Wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1145787,Simpl,Simple,1145787,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simple']
Usability,"nction = DNN::EOutputFunction::kSigmoid;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////////; 111/// MLP can handle classification with 2 classes and regression with; 112/// one regression-target; 113 ; 114Bool_t TMVA::MethodDNN::HasAnalysisType(Types::EAnalysisType type,; 115 UInt_t numberClasses,; 116 UInt_t /*numberTargets*/ ); 117{; 118 if (type == Types::kClassification && numberClasses == 2 ) return kTRUE;; 119 if (type == Types::kMulticlass ) return kTRUE;; 120 if (type == Types::kRegression ) return kTRUE;; 121 ; 122 return kFALSE;; 123}; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// default initializations; 127 ; 128void TMVA::MethodDNN::Init() {; 129 Log() << kWARNING; 130 << ""MethodDNN is deprecated and it will be removed in future ROOT version. ""; 131 ""Please use MethodDL ( TMVA::kDL)""; 132 << Endl;; 133 ; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Options to be set in the option string:; 138///; 139/// - LearningRate <float> DNN learning rate parameter.; 140/// - DecayRate <float> Decay rate for learning parameter.; 141/// - TestRate <int> Period of validation set error computation.; 142/// - BatchSize <int> Number of event per batch.; 143///; 144/// - ValidationSize <string> How many events to use for validation. ""0.2""; 145/// or ""20%"" indicates that a fifth of the; 146/// training data should be used. ""100""; 147/// indicates that 100 events should be used.; 148 ; 149void TMVA::MethodDNN::DeclareOptions(); 150{; 151 ; 152 DeclareOptionRef(fLayoutString=""SOFTSIGN|(N+100)*2,LINEAR"",; 153 ""Layout"",; 154 ""Layout of the network."");; 155 ; 156 DeclareOptionRef(fValidationSize = ""20%"", ""ValidationSize"",; 157 ""Part of the training data to use for ""; 158 ""validation. Specify as 0.2 or 20% to use a ""; 159 ""fifth of the data set as validation set. ""; 160 ""Specify as 100 to use exactly 100 events. ""; 161 ""(Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:4718,learn,learning,4718,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['learn'],['learning']
Usability,"nction"" which; has been overridden by the user. void Evolution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSize ( spread ) by this factor; (if ofSteps == successSteps nothing is changed, if ofSteps < successSteps, the spread; is divided by the factor). using this function one can increase the stepSize of the mutation when we have; good success (to pass fast through the easy phase-space) and reduce the stepSize; if we are in a difficult ""territory"" of the phase-space. Bool_t HasConverged(Int_t steps = 10, Double_t ratio = 0.1); gives back true if the last ""steps"" steps have lead to an improvement of the; ""fitness"" of the ""individuals"" of at least ""improvement"". this gives a simple measure of if the fitness of the individuals is; converging and no major improvement is to be expected soon. GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0). GeneticPopulation& GetGeneticPopulation(); { return fPopulation; }. Double_t GetSpread() const; { return fSpread; }. void SetSpread(Double_t s); { fSpread = s; }. void SetMakeCopies(Bool_t s); { fMakeCopies = s; }. Bool_t GetMakeCopies(); { return fMakeCopies; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__GeneticAlgorithm.html:5178,simpl,simple,5178,root/html534/TMVA__GeneticAlgorithm.html,https://root.cern,https://root.cern/root/html534/TMVA__GeneticAlgorithm.html,2,['simpl'],['simple']
Usability,"nctionDefinition NeuralNet.h:697; TMVA::DNN::Layer::LayerLayer(size_t numNodes, EnumFunction activationFunction, ModeOutputValues eModeOutputValues=ModeOutputValues::DIRECT)c'tor for defining a LayerDefinition NeuralNet.cxx:166; TMVA::DNN::Net::m_layersstd::vector< Layer > m_layerslayer-structure-dataDefinition NeuralNet.h:1272; TMVA::DNN::Net::inputSizesize_t inputSize() constinput size of the DNNDefinition NeuralNet.h:1098; TMVA::DNN::Net::numNodessize_t numNodes(size_t trainingStartLayer=0) constreturns the number of nodes in this netDefinition NeuralNet.cxx:556; TMVA::DNN::Net::fillDropContainervoid fillDropContainer(DropContainer &dropContainer, double dropFraction, size_t numNodes) constprepare the drop-out-container (select the nodes which are to be dropped out)Definition NeuralNet.cxx:572; TMVA::DNN::Net::numWeightssize_t numWeights(size_t trainingStartLayer=0) constreturns the number of weights in this netDefinition NeuralNet.cxx:540; TMVA::DNN::Settings::clearvoid clear(std::string histoName)for monitoringDefinition NeuralNet.h:824; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings::SettingsSettings(TString name, size_t _convergenceSteps=15, size_t _batchSize=10, size_t _testRepetitions=7, double _factorWeightDecay=1e-5, TMVA::DNN::EnumRegularization _regularization=TMVA::DNN::EnumRegularization::NONE, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true)c'torDefinition NeuralNet.cxx:232; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_minErrordouble m_minErrorDefinition NeuralNet.h:859; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:26810,clear,clearvoid,26810,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,2,['clear'],"['clear', 'clearvoid']"
Usability,"nctions inherited from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; value_type evaluate () const override;  Evaluate the category state and return. ;  ; void recomputeShape () override;  Ask server category to recompute shape, and copy its information. ;  ;  Protected Member Functions inherited from RooAbsCategoryLValue; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=tru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSuperCategory.html:39373,clear,clearTypes,39373,doc/master/classRooSuperCategory.html,https://root.cern,https://root.cern/doc/master/classRooSuperCategory.html,1,['clear'],['clearTypes']
Usability,"nctions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; ROOT::Experimental::RCanvas Class ReferenceGraphics » ROOT7 Graphics » ROOT7 Pad related classes. ; A window's topmost RPad. ; AuthorAxel Naumann axel@.nosp@m.cern.nosp@m..ch ; Date2015-07-08 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition at line 47 of file RCanvas.hxx. Public Member Functions;  RCanvas ();  Create a temporary RCanvas; for long-lived ones please use Create(). ;  ;  ~RCanvas () override=default;  ; template<class PANEL > ; bool AddPanel (std::shared_ptr< PANEL > &panel);  Insert panel into the canvas, canvas should be shown at this moment. ;  ; void ClearOnClose (const std::shared_ptr< void > &handle);  Set handle which will be cleared when connection is closed. ;  ; void ClearShown ();  clear IsShown() flag ;  ; void ClearUpdated ();  clear IsUpdated() flag ;  ; std::string CreateJSON ();  Provide JSON which can be used for offline display. ;  ; const RCanvas * GetCanvas () const override;  Access to the top-most canvas, if any (const version). ;  ; RCanvas * GetCanvas () override;  Access to the top-most canvas, if any (non-const version). ;  ; int GetHeight () const;  Get canvas height. ;  ; uint64_t GetModified () const;  Get modify counter. ;  ; const std::string & GetTitle () const;  Get the canvas's title. ;  ; std::string GetUID () const;  Return unique identifier for the canvas Used in iPython display. ;  ; int GetWidth () const;  Get canvas width. ;  ; std::string GetWindowAddr () const;  Returns window name used to display canvas. ;  ; std::string GetWindowUrl (bool remote);  Returns window URL which can be used for connection. ;  ; void Hide ();  Hide all canvas displays. ;  ; bool IsModified () const;  Returns true is canvas was modified since last painting. ;  ; bool IsShown () const;  returns true if Show() method was",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html:1109,clear,clear,1109,doc/master/classROOT_1_1Experimental_1_1RCanvas.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html,2,['clear'],['clear']
Usability,"nction ; function). inline . add a preprocess function object ; Definition at line 74 of file Measurement.h. ◆ AddPOI(). void RooStats::HistFactory::Measurement::AddPOI ; (; const std::string & ; POI). inline . append parameter to vector of PoIs ; Definition at line 49 of file Measurement.h. ◆ AddPreprocessFunction(). void RooStats::HistFactory::Measurement::AddPreprocessFunction ; (; std::string ; name, . std::string ; expression, . std::string ; dependencies . ). Add a preprocessed function by giving the function a name, a functional expression, and a string with a bracketed list of dependencies (eg ""SigXsecOverSM[0,3]"") ; Definition at line 112 of file Measurement.cxx. ◆ ClearConstantParams(). void RooStats::HistFactory::Measurement::ClearConstantParams ; (; ). inline . empty vector of constant parameters ; Definition at line 60 of file Measurement.h. ◆ ClearParamValues(). void RooStats::HistFactory::Measurement::ClearParamValues ; (; ). inline . clear map of parameter values ; Definition at line 70 of file Measurement.h. ◆ GetAsimovDatasets(). std::vector< RooStats::HistFactory::Asimov > & RooStats::HistFactory::Measurement::GetAsimovDatasets ; (; ). inline . get vector of defined Asimov Datasets ; Definition at line 82 of file Measurement.h. ◆ GetBinHigh(). int RooStats::HistFactory::Measurement::GetBinHigh ; (; ). inline . Definition at line 98 of file Measurement.h. ◆ GetBinLow(). int RooStats::HistFactory::Measurement::GetBinLow ; (; ). inline . Definition at line 97 of file Measurement.h. ◆ GetConstantParams(). std::vector< std::string > & RooStats::HistFactory::Measurement::GetConstantParams ; (; ). inline . get vector of all constant parameters ; Definition at line 62 of file Measurement.h. ◆ GetFunctionObjects() [1/2]. std::vector< RooStats::HistFactory::PreprocessFunction > & RooStats::HistFactory::Measurement::GetFunctionObjects ; (; ). inline . get vector of defined function objects ; Definition at line 77 of file Measurement.h. ◆ GetFunctionObjects() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1Measurement.html:16357,clear,clear,16357,doc/master/classRooStats_1_1HistFactory_1_1Measurement.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1Measurement.html,1,['clear'],['clear']
Usability,"nctor.C for a running example.; . Function Members (Methods); public:. virtual~TF1(); voidTObject::AbstractMethod(const char* method) const; static voidAbsValue(Bool_t reject = kTRUE); virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static voidCalcGaussLegendreSamplingPoints(Int_t num, Double_t* x, Double_t* w, Double_t eps = 3.0E-11); virtual Double_tCentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 9.9999999999999995E-7); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voidCopy(TObject& f1) const; virtual char*TFormula::DefinedString(Int_t code); virtual Double_tTFormula::DefinedValue(Int_t code); virtual Int_tTFormula::DefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDerivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tDerivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tDerivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tDerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* option = ""al"")MEN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:6024,Clear,Clear,6024,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,1,['Clear'],['Clear']
Usability,"nd ();  dtor. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Returns the name of redo command. ;  ; Int_t GetStatus () const;  Returns a number of sequential undo or redo operations. ;  ; const char * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:3291,undo,undo,3291,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"nd = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgSet.html:12980,clear,clearStructureTags,12980,root/html534/RooArgSet.html,https://root.cern,https://root.cern/root/html534/RooArgSet.html,2,['clear'],['clearStructureTags']
Usability,"nd = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:13014,clear,clearStructureTags,13014,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,4,['clear'],['clearStructureTags']
Usability,"nd namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char* path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Return the list of globals. const TSeqCollection * GetListOfGlobalFunctions(); Return the list of global functions. const TSeqCollection * GetListOfPragmas(); Return the list of pragmas. const TSeqCollection * GetListOfSysIncFiles(); Return the list of system include files. const TSeqCollection * GetListOfUsers(); reads from ""/etc/passwd"". Char_t AllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); [static utility function]. if all the strings in ""*pList"" have the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTabCom.html:7931,clear,clears,7931,root/html528/TTabCom.html,https://root.cern,https://root.cern/root/html528/TTabCom.html,6,['clear'],['clears']
Usability,"nd older jquery-ui; support custom requests to remote objects, demonstrated in httptextlog.C tutorial; rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; See also the JSRoot 3.9 examples page and the JSRoot 3.9 release notes. Class Reference Guide; The ROOT reference guide is moving to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers many nice features we are now exploring and trying to get the best of them. Having MathJax rendered math formula is one of them. The documentation can be structured in a more logical way using groups. Still there is a lot to do but big progresses have been done. We developed also a Doxygen filter allowing to execute macros given as examples in the documentation and show the resulting picture directly in the documentation.; Tutorials; The tutorials in $ROOTSYS/tutorials are also presented on the web thanks to Doxygen. They are now part of the reference guide allowing nice cross-referencing with the classes documentation. Here also a filter has been developed to generate the resulting picture.; Build, Configuration and Testing Infrastructure; ROOT uses the CMake cross-platform build-generator tool as a primary build system. CMake does not build the project, it generates the files needed by your build tool (GNU make, Ninja, Visual Studio, etc) for building ROOT. The classic build with configure/make is is still available but it will not be evolving with the new features of ROOT.; We added full support for C++14.; Minor changes in the build system:. Renamed build option POSTGRESQL_LIBRARIES to POSTGRESQL_LIBRARY; Added build option builtin_openssl to build OpenSSL internally. This is specially needed for the latest Mac OSX (El Capitan). Patch Releases; Release 6.06/02; Core. Make TListOfFunctions::Get thread-safe; Make TPluginManager thread-safe ROOT-7927; Properly handle the case of an executable with a space in its full pathname when search for linked",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:23448,guid,guide,23448,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['guid'],['guide']
Usability,"nd optimization convolution generation context that uses a smearing algorithm. Otherwise return a standard accept/reject sampling context on the convoluted shape. ; Reimplemented from RooAbsPdf.; Definition at line 168 of file RooNumConvPdf.cxx. ◆ initialize(). void RooNumConvPdf::initialize ; (; ); const. protected . One-time initialization of object. ; Definition at line 148 of file RooNumConvPdf.cxx. ◆ IsA(). TClass * RooNumConvPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 78 of file RooNumConvPdf.h. ◆ model(). RooAbsReal & RooNumConvPdf::model ; (; ); const. inline . Definition at line 54 of file RooNumConvPdf.h. ◆ pdf(). RooAbsReal & RooNumConvPdf::pdf ; (; ); const. inline . Definition at line 53 of file RooNumConvPdf.h. ◆ printMetaArgs(). void RooNumConvPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 201 of file RooNumConvPdf.cxx. ◆ profileData(). const TH2 * RooNumConvPdf::profileData ; (; ); const. inline . Definition at line 49 of file RooNumConvPdf.h. ◆ setCallProfiling(). void RooNumConvPdf::setCallProfiling ; (; bool ; flag, . Int_t ; nbinX = 40, . Int_t ; nbinCall = 40, . Int_t ; nCallHigh = 1000 . ). inline . Definition at line 47 of file RooNumConvPdf.h. ◆ setCallWarning(). void RooNumConvPdf::setCallWarning ; (; Int_t ; threshold = 2000). inline . Definition at line 46 of file RooNumConvPdf.h. ◆ setConvolutionWindow(). void RooNumConvPdf::setConvolutionWindow ; (; RooAbsReal & ; centerParam, . RooAbsReal & ; widthParam, . double ; widthScaleFactor = 1 . ). inline . Definition at line 44 of file RooNumConvPdf.h. ◆ Streamer(). void RooNumConvPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:79991,intuit,intuitively,79991,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,1,['intuit'],['intuitively']
Usability,"nd subtraction ; This prepares the data members for the base class TUnfold, such that the background is properly taken into account. ; Definition at line 377 of file TUnfoldSys.cxx. ◆ GetBackground(). void TUnfoldSys::GetBackground ; (; TH1 * ; bgrHist, . const char * ; bgrSource = nullptr, . const Int_t * ; binMap = nullptr, . Int_t ; includeError = 3, . Bool_t ; clearHist = kTRUE . ); const. get background into a histogram ; Parameters. [in,out]bgrHisttarget histogram, content and errors will be altered ; [in]bgrSource(default=nullptr) name of backgrond source or zero to add all sources of background ; [in]binMap(default=nullptr) remap histogram bins ; [in]includeError(default=3) include uncorrelated(1), correlated (2) or both (3) sources of uncertainty in the histogram errors ; [in]clearHist(default=true) reset histogram before adding up the specified background sources. the array binMap is explained with the method GetOutput(). The flag clearHist may be used to add background from several sources in successive calls to GetBackground(). ; Definition at line 565 of file TUnfoldSys.cxx. ◆ GetBgrSources(). TSortedList * TUnfoldSys::GetBgrSources ; (; void ; ); const. Get a new list of all background sources. ; The user is responsible for deleting the list get list of name of background sources ; Definition at line 1528 of file TUnfoldSys.cxx. ◆ GetChi2Sys(). Double_t TUnfoldSys::GetChi2Sys ; (; void ; ). calculate total chi**2 including all systematic errors ; Definition at line 1366 of file TUnfoldSys.cxx. ◆ GetDeltaSysBackgroundScale(). Bool_t TUnfoldSys::GetDeltaSysBackgroundScale ; (; TH1 * ; hist_delta, . const char * ; source, . const Int_t * ; binMap = nullptr . ). correlated one-sigma shifts from background normalisation uncertainty ; Parameters. [out]hist_deltahistogram to store shifts ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins. returns true if the background source was found. ; This method retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:34449,clear,clearHist,34449,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearHist']
Usability,"nd vAxis are the default directions for forward; (inverted) and upwards. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void SetStereo(Bool_t stereo, Bool_t quad_buf = kTRUE); Enable stereo rendering.; If quad_buf is true rendering is done into separate left and right GL; buffers. This requires hardware support. Otherwise left and right images; get rendered into left and right half of the window.; Note that mouse highlighting and selection will not work exactly right; as image for each eye gets slightly shifted and there are two different; directions through the mouse pointer, one for each eye. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal with button id and modifier state. void UnClicked(TObject* obj, UInt_t button, UInt_t state); Emit UnClicked signal with button id and modifier state. void MouseIdle(TGLPhysical",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLViewer.html:35796,guid,guides,35796,root/html604/TGLViewer.html,https://root.cern,https://root.cern/root/html604/TGLViewer.html,2,['guid'],['guides']
Usability,"nd(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; void Add (TObject *obj) override;  ; void Add (TObject *obj, Option_t *opt) override;  Add command to the list of merged commands. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual Bool_t CanRedo () const;  Returns kTRUE if Redo action is possible, kFALSE if it's not. ;  ; virtual Bool_t CanUndo () const;  Returns kTRUE if Undo action is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:4583,undo,undo,4583,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"nd() and range-based for loops; RooAbsCollection::iterator(): same; RooAbsCollection::fwdIterator(): same; RooWorkspace::componentIterator(): use RooWorkspace::components() with range-based loop. Deprecation of legacy test statistics classes in public interface; Instantiating the following classes and even including their header files is deprecated, and the headers will be removed in ROOT 6.34:. RooAbsTestStatistic; RooAbsOptTestStatistic; RooNLLVar; RooChi2Var; RooXYChi2Var. Please use the higher-level functions RooAbsPdf::createNLL() and RooAbsPdf::createChi2() if you want to create objects that represent test statistics.; Change of RooParamHistFunc; The RooParamHistFunc didn’t take any observable RooRealVar as constructor argument. It assumes as observable the internal variables in the passed RooDataHist. This means it was in most contexts unusable, because the input can’t be changed, other than loading a different bin in the dataset.; Furthermore, there was actually a constructor that took a RooAbsArg x, but it was simply ignored.; To fix all these problems, the existing constructors were replaced by a new one that takes the observable explicitly.; Since the old constructors resulted in wrong computation graphs that caused trouble with the new CPU evaluation backend, they had to be removed without deprecation. Please adapt your code if necessary.; Renaming of some RooFit classes; The RooPower was renamed to RooPowerSum, and RooExpPoly was renamed to RooLegacyExpPoly.; This was a necessary change, because the names of these classes introduced in ROOT 6.28 collided with some classes in CMS combine, which were around already long before. Therefore, the classes had to be renamed to not cause any problems for CMS.; In the unlikeliy case where you should have used these new classes for analysis already, please adapt your code to the new names and re-create your workspaces.; RDataFrame. The RDataFrame constructors that take in input one or more file names (or globs ther",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:14020,simpl,simply,14020,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['simpl'],['simply']
Usability,"ndEntry.; 335 Long64_t fEndEntry = -1LL;; 336 Long64_t fBeginEntry = 0LL; ///< This allows us to propagate the range to the TTreeCache; 337 bool fProxiesSet = false; ///< True if the proxies have been set, false otherwise; 338 bool fSetEntryBaseCallingLoadTree = false; ///< True if during the LoadTree execution triggered by SetEntryBase.; 339 ; 340 // Flag to activate or deactivate warnings in case the friend trees have; 341 // more entries than the main one. In some cases we may want to deactivate; 342 // this behaviour, notably in multithreaded runs where we have to partition; 343 // the main tree but keep the entire friend trees in every thread to ensure; 344 // alignment.; 345 bool fWarnAboutLongerFriends{true};; 346 void WarnIfFriendsHaveMoreEntries();; 347 ; 348 // List of branches for which we want to suppress the printed error about; 349 // missing branch when switching to a new tree; 350 std::vector<std::string> fSuppressErrorsForMissingBranches{};; 351 std::vector<std::string> fMissingProxies{};; 352 ; 353 friend class ROOT::Internal::TTreeReaderValueBase;; 354 friend class ROOT::Internal::TTreeReaderArrayBase;; 355 ; 356 ClassDefOverride(TTreeReader, 0); // A simple interface to read trees; 357};; 358 ; 359#endif // defined TTreeReader; Long64_tlong long Long64_tDefinition RtypesCore.h:69; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TNotifyLink.h; TTreeReaderUtils.h; TTree.h; ROOT::Internal::TFriendProxyDefinition TFriendProxy.h:22; ROOT::Internal::TNamedBranchProxyDefinition TTreeReaderUtils.h:43; ROOT::Internal::TTreeReaderArrayBaseBase class of TTreeReaderArray.Definition TTreeReaderArray.h:29; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; TBranchProxyDirectorThis class is used to 'drive' and hold a serie of TBranchProxy objects which represen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:14798,simpl,simple,14798,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['simpl'],['simple']
Usability,"ndPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* lab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:2107,clear,clearValueDirty,2107,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,4,['clear'],['clearValueDirty']
Usability,"ndex, Double_t lower, Double_t upper, Double_t cl = -1., Double_t leftside = -1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tCheckParameters(RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; RooStats::ConfidenceBeltConfidenceBelt(); RooStats::ConfidenceBeltConfidenceBelt(const char* name); RooStats::ConfidenceBeltConfidenceBelt(const RooStats::ConfidenceBelt&); RooStats::ConfidenceBeltConfidenceBelt(const char* name, const char* title); RooStats::ConfidenceBeltConfidenceBelt(const char* name, RooAbsData&); RooStats::ConfidenceBeltConfidenceBelt(const char* name, const char* title, RooAbsData&); vector<Double_t>ConfidenceLevels() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooStats::AcceptanceRegion*GetAcceptanceRegion(RooArgSet&, Double_t cl = -1., Double_t leftside = -1.); Double_tGetAcceptanceRegionMax(RooArgSet&, Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__ConfidenceBelt.html:1339,Clear,Clear,1339,root/html532/RooStats__ConfidenceBelt.html,https://root.cern,https://root.cern/root/html532/RooStats__ConfidenceBelt.html,4,['Clear'],['Clear']
Usability,"ndim). static . Global switch to cache all integral values that integrate at least ndim dimensions numerically. ; Definition at line 1165 of file RooRealIntegral.cxx. ◆ setCacheNumeric(). void RooRealIntegral::setCacheNumeric ; (; bool ; flag). inline . Definition at line 55 of file RooRealIntegral.h. ◆ Streamer(). void RooRealIntegral::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooRealIntegral::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 150 of file RooRealIntegral.h. ◆ sum(). double RooRealIntegral::sum ; (; ); const. protectedvirtual . Perform summation of list of category dependents to be integrated. ; Definition at line 939 of file RooRealIntegral.cxx. ◆ translate(). void RooRealIntegral::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 1035 of file RooRealIntegral.cxx. Member Data Documentation. ◆ _anaList. RooSetProxy RooRealIntegral::_anaList. protected . Set of observables over which is integrated/summed analytically. ; Definition at line 119 of file RooRealIntegral.h. ◆ _cacheAllNDim. Int_t RooRealIntegral::_cacheAllNDim. staticprotected . ! Cache all integrals with given numeric dimension ; Definition at line 145 of file RooRealIntegral.h. ◆ _cacheNum. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:74847,simpl,simple,74847,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['simpl'],['simple']
Usability,"nding on the context, using TTask might still be a valid solution. ; TTask is a base class that can be used to build a complex tree of Tasks. Each TTask derived class may contain other TTasks that can be executed recursively, such that a complex program can be dynamically built and executed by invoking the services of the top level Task or one of its subtasks.; Use the TTask::Add function to add a subtask to an existing TTask. To execute a TTask, one calls the ExecuteTask function. ExecuteTask will call recursively:. the TTask::Exec function of the derived class; TTask::ExecuteTasks to execute for each task the list of its subtasks. If the top level task (see example below) is added to the list of Root browsable objects, the tree of tasks can be visualized by the Root browser. The browser can be used to start a task, set break points at the beginning of a task or when the task has completed. At a breakpoint, data structures generated by the execution up this point may be inspected asynchronously and then the execution can be resumed by selecting the ""Continue"" function of a task.; A Task may be active or inactive (controlled by TTask::SetActive). When a task is not active, its sub tasks are not executed.; A TTask tree may be made persistent, saving the status of all the tasks.; The Root browser's picture below has been generated by executing the following script: {; TTask *aliroot = new TTask(""aliroot"",""ALICE reconstruction main task"");; TTask *geominit = new TTask(""geomInit"",""Initialize ALICE geometry"");; TTask *matinit = new TTask(""matInit"",""Initialize ALICE materials"");; TTask *physinit = new TTask(""physInit"",""Initialize Physics processes"");; TTask *tracker = new TTask(""tracker"",""Track reconstruction manager"");; TTask *tpcrec = new TTask(""tpcrec"",""TPC reconstruction"");; TTask *itsrec = new TTask(""itsrec"",""ITS reconstruction"");; TTask *muonrec = new TTask(""muonRec"",""Muon Reconstruction"");; TTask *phosrec = new TTask(""phosRec"",""Phos Reconstruction"");; TTask *richre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTask.html:1551,resume,resumed,1551,doc/master/classTTask.html,https://root.cern,https://root.cern/doc/master/classTTask.html,1,['resume'],['resumed']
Usability,"ndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:31",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQUndoManager.html:20161,undo,undo,20161,root/html604/TQUndoManager.html,https://root.cern,https://root.cern/root/html604/TQUndoManager.html,3,"['Undo', 'undo']","['Undo', 'undo']"
Usability,"ndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:29",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:20161,undo,undo,20161,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,3,"['Undo', 'undo']","['Undo', 'undo']"
Usability,"ndow location px, py; This is provided for use when embedding GL viewer into pad. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Process event of type 'event' - one of EEventType types,; occuring at window location px, py; This is provided for use when embedding GL viewer into pad. void PrintObjects(); Pass viewer for print capture by TGLOutput. void SelectionChanged(); Update GUI components for embedded viewer selection change. void OverlayDragFinished(); An overlay operation can result in change to an object.; Refresh geditor. void RefreshPadEditor(TObject* obj = 0); Update GED editor if it is set. void SetEventHandler(TGEventHandler* handler); Set the event-handler. The event-handler is owned by the viewer.; If GLWidget is set, the handler is propagated to it. If called with handler=0, the current handler will be deleted; (also from TGLWidget). void RemoveOverlayElement(TGLOverlayElement* el); Remove overlay element. void ClearCurrentOvlElm(); Reset current overlay-element to zero, eventually notifying the; old one that the mouse has left.; Usually called when mouse leaves the window. TGLViewer(const TGLViewer& ). TGLViewer & operator=(const TGLViewer& ). Bool_t CanLoopOnPrimitives() const; TVirtualViewer3D interface ... mostly a facade; Forward to TGLScenePad. { return kTRUE; }. Bool_t PreferLocalFrame() const; Only implemented because they're abstract ... should throw an; exception or assert they are not called. { return kTRUE; }. void BeginScene(); {}. Bool_t BuildingScene() const; { return kFALSE; }. void EndScene(); {}. Int_t AddObject(const TBuffer3D& , Bool_t* = 0); { return TBuffer3D::kNone; }. Int_t AddObject(UInt_t , const TBuffer3D& , Bool_t* = 0); { return TBuffer3D::kNone; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); { return kFALSE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}. void ResetCameras(); { SetupCameras(kTRUE); }. void ResetCamerasAfterNextUpdate(); { fResetCamerasOnNextUpdate = kTRUE; }. TGLWidget* GetGLW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLViewer.html:34702,Clear,ClearCurrentOvlElm,34702,root/html532/TGLViewer.html,https://root.cern,https://root.cern/root/html532/TGLViewer.html,4,['Clear'],['ClearCurrentOvlElm']
Usability,"ndow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTGDoubleSlider::ChangeCursor(Event_t* event); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static voidTGDoubleSlider::FixBounds(Float_t& min, Float_t& max); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TStringTGDoubleSlider::GetSString() const; voidTObject::MakeZombie(); TGWindow&TGWindow::operator=(const TGWindow& tgw); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGDoubleHSlider.html:15617,Clear,ClearFlags,15617,root/html532/TGDoubleHSlider.html,https://root.cern,https://root.cern/root/html532/TGDoubleHSlider.html,4,['Clear'],['ClearFlags']
Usability,"ndow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHorizontalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGHorizontalFrame.html:2492,Clear,Clear,2492,root/html532/TGHorizontalFrame.html,https://root.cern,https://root.cern/root/html532/TGHorizontalFrame.html,2,['Clear'],['Clear']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecExtraEvent(); TRecExtraEvent(const TRecExtraEvent&); ~TRecExtraEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecExtraEvent.html:2535,Resume,Resume,2535,root/html532/TRecExtraEvent.html,https://root.cern,https://root.cern/root/html532/TRecExtraEvent.html,2,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecGuiEvent(); TRecGuiEvent(const TRecGuiEvent&); ~TRecGuiEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecGuiEvent.html:2553,Resume,Resume,2553,root/html532/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html532/TRecGuiEvent.html,2,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecWinPair(const TRecWinPair&); TRecWinPair(Window_t key, Window_t value); ~TRecWinPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecWinPair.html:2548,Resume,Resume,2548,root/html532/TRecWinPair.html,https://root.cern,https://root.cern/root/html532/TRecWinPair.html,2,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecorder(); TRecorder(const TRecorder&); TRecorder(const char* filename, Option_t* option = ""READ""); virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecorder.html:2542,Resume,Resume,2542,root/html532/TRecorder.html,https://root.cern,https://root.cern/root/html532/TRecorder.html,1,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecorder(); TRecorder(const char* filename, Option_t* option = ""READ""); virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorder.html:2542,Resume,Resume,2542,root/html534/TRecorder.html,https://root.cern,https://root.cern/root/html534/TRecorder.html,1,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. virtual~TRecExtraEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecExtraEvent.html:2583,Resume,Resume,2583,root/html602/TRecExtraEvent.html,https://root.cern,https://root.cern/root/html602/TRecExtraEvent.html,2,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. virtual~TRecGuiEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecGuiEvent.html:2577,Resume,Resume,2577,root/html602/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html602/TRecGuiEvent.html,2,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. virtual~TRecWinPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecWinPair.html:2572,Resume,Resume,2572,root/html602/TRecWinPair.html,https://root.cern,https://root.cern/root/html602/TRecWinPair.html,2,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorder.html:2566,Resume,Resume,2566,root/html602/TRecorder.html,https://root.cern,https://root.cern/root/html602/TRecorder.html,2,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecEvent.html:2566,Resume,Resume,2566,root/html602/TRecEvent.html,https://root.cern,https://root.cern/root/html602/TRecEvent.html,2,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderState.html:2565,Resume,Resume,2565,root/html602/TRecorderState.html,https://root.cern,https://root.cern/root/html602/TRecorderState.html,2,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidChangeStat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecorderState.html:2517,Resume,Resume,2517,root/html532/TRecorderState.html,https://root.cern,https://root.cern/root/html532/TRecorderState.html,1,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector&); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorderState.html:2517,Resume,Resume,2517,root/html534/TRecorderState.html,https://root.cern,https://root.cern/root/html534/TRecorderState.html,1,['Resume'],['Resume']
Usability,"ndows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TRecEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecEvent.html:2518,Resume,Resume,2518,root/html532/TRecEvent.html,https://root.cern,https://root.cern/root/html532/TRecEvent.html,2,['Resume'],['Resume']
Usability,"ne 152 of file RInterfaceBase.cxx. ◆ GetColumnType(). std::string ROOT::RDF::RInterfaceBase::GetColumnType ; (; std::string_view ; column). Return the type of a given column as a string. ; Returnsthe type of the required column.; This is not an action nor a transformation, just a query to the RDataFrame object. Example usage:; auto colType = d.GetColumnType(""columnName"");; // Print column type; std::cout << ""Column "" << colType << "" has type "" << colType << std::endl;. Definition at line 197 of file RInterfaceBase.cxx. ◆ GetColumnTypeNamesList(). ROOT::RDF::ColumnNames_t ROOT::RDF::RInterfaceBase::GetColumnTypeNamesList ; (; const ColumnNames_t & ; columnList). protected . Definition at line 407 of file RInterfaceBase.cxx. ◆ GetDefinedColumnNames(). ROOT::RDF::ColumnNames_t ROOT::RDF::RInterfaceBase::GetDefinedColumnNames ; (; ). Returns the names of the defined columns. ; Returnsthe container of the defined column names.; This is not an action nor a transformation, just a simple utility to get the columns names that have been defined up to the node. If no column has been defined, e.g. on a root node, it returns an empty collection. Example usage:; auto defColNames = d.GetDefinedColumnNames();; // Print defined columns' names; for (auto &&defColName : defColNames) std::cout << defColName << std::endl;. Definition at line 309 of file RInterfaceBase.cxx. ◆ GetLoopManager(). RDFDetail::RLoopManager * ROOT::RDF::RInterfaceBase::GetLoopManager ; (; ); const. inlineprotected . Definition at line 128 of file RInterfaceBase.hxx. ◆ GetNFiles(). unsigned int ROOT::RDF::RInterfaceBase::GetNFiles ; (; ). Definition at line 27 of file RInterfaceBase.cxx. ◆ GetNRuns(). unsigned int ROOT::RDF::RInterfaceBase::GetNRuns ; (; ); const. Gets the number of event loops run. ; ReturnsThe number of event loops run by this RDataFrame instance; This method returns the number of events loops run so far by this RDataFrame instance.; Example usage: ROOT::RDataFrame df(1);; std::cout << df.GetNR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html:10005,simpl,simple,10005,doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html,1,['simpl'],['simple']
Usability,"ne 57 of file TEveProjectionManager.h. ◆ GetImportEmpty(). Bool_t TEveProjectionManager::GetImportEmpty ; (; ); const. inline . Definition at line 60 of file TEveProjectionManager.h. ◆ GetProjection(). TEveProjection * TEveProjectionManager::GetProjection ; (; ). inline . Definition at line 49 of file TEveProjectionManager.h. ◆ HandleElementPaste(). Bool_t TEveProjectionManager::HandleElementPaste ; (; TEveElement * ; el). overridevirtual . React to element being pasted or dnd-ed. ; Return true if redraw is needed (virtual method). ; Reimplemented from TEveElement.; Definition at line 172 of file TEveProjectionManager.cxx. ◆ ImportElements(). TEveElement * TEveProjectionManager::ImportElements ; (; TEveElement * ; el, . TEveElement * ; ext_list = nullptr . ). virtual . Recursively import elements and apply projection to the newly imported objects. ; If ext_list is not 0 the new element is also added to the list. This simplifies construction of complex views where projected elements are distributed into several scenes for optimization of updates and rendering.; Returns the projected replica of el. Can be 0, if el and none of its children are projectable. ; Definition at line 279 of file TEveProjectionManager.cxx. ◆ ImportElementsRecurse(). TEveElement * TEveProjectionManager::ImportElementsRecurse ; (; TEveElement * ; el, . TEveElement * ; parent . ). virtual . If el is TEveProjectable add projected instance else add plain TEveElementList to parent. ; Call the same function on el's children.; Returns the projected replica of el. Can be 0, if el and none of its children are projectable. ; Definition at line 225 of file TEveProjectionManager.cxx. ◆ IsA(). TClass * TEveProjectionManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEveElementList.; Definition at line 77 of file TEveProjectionManager.h. ◆ operator=(). TEveProjectionManager & TEveProjectionManager::operator= ; (; const TEveProjectionManager & ; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveProjectionManager.html:40047,simpl,simplifies,40047,doc/master/classTEveProjectionManager.html,https://root.cern,https://root.cern/doc/master/classTEveProjectionManager.html,1,['simpl'],['simplifies']
Usability,"ne Brun; *-* comments extracted from the MINUIT documentation file.; -; *. void mnhess(); Calculates the full second-derivative matrix of FCN*-*-; *-* ===================================================; *-* by taking finite differences. When calculating diagonal; *-* elements, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local minimum*-*-*-; *-* ===========================================; *-* Attempts to improve on a good local minimum by finding a; *-* better one. The quadratic part of FCN is removed by MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =======================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:44781,simpl,simplex,44781,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,10,['simpl'],['simplex']
Usability,"ne containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBinomialEfficiencyFitter.html:1473,simpl,simply,1473,root/html526/TBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/root/html526/TBinomialEfficiencyFitter.html,11,['simpl'],['simply']
Usability,"ne tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. TFumili(Int_t maxpar = 25); TFumili(const TFumili&); virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:3193,simpl,simple,3193,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,6,['simpl'],['simple']
Usability,"ne tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFumili.html:3193,simpl,simple,3193,root/html602/TFumili.html,https://root.cern,https://root.cern/root/html602/TFumili.html,4,['simpl'],['simple']
Usability,"ne(0.66,0.24,0.66,0.26);; 282 line->Draw();; 283 line = new TLine(0.76,0.24,0.76,0.26);; 284 line->Draw();; 285 line = new TLine(0.86,0.24,0.86,0.26);; 286 line->Draw();; 287 line = new TLine(0.96,0.24,0.96,0.26);; 288 line->Draw();; 289}; c#define c(i)Definition RSha256.hxx:101; kWhite@ kWhiteDefinition Rtypes.h:65; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextAnglevirtual void SetTextAngle(Float_t tangle=0)Set the text angle.Definition TAttText.h:43; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; TPave::SetBorderSizevirtual void SetBorderSize(Int_t bordersize=4)Sets the border size of the TPave box and shadow.Definition TPave.h:77; TTextBase class for several text objects.Definition TText.h:22; lineTLine * lineDefinition entrylistblock_figure1.C:235; ptTPaveText * ptDefinition entrylistblock_figure1.C:7; textTText * textDefinition entrylistblock_figure1.C:9; arrowDefinition RArrowDS.hxx:17. treetreedocmacrosentrylistblock_f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/entrylistblock__figure1_8C_source.html:9889,simpl,simple,9889,doc/master/entrylistblock__figure1_8C_source.html,https://root.cern,https://root.cern/doc/master/entrylistblock__figure1_8C_source.html,1,['simpl'],['simple']
Usability,"ne3D(temp1, temp2);; 6736 temp1[0] = x;; 6737 temp1[1] = y1;; 6738 temp1[2] = z;; 6739 temp2[0] = x;; 6740 temp2[1] = y2;; 6741 temp2[2] = z;; 6742 gPad->PaintLine3D(temp1, temp2);; 6743 temp1[0] = x;; 6744 temp1[1] = y;; 6745 temp1[2] = z1;; 6746 temp2[0] = x;; 6747 temp2[1] = y;; 6748 temp2[2] = z2;; 6749 gPad->PaintLine3D(temp1, temp2);; 6750 temp1[0] = x;; 6751 temp1[1] = y;; 6752 temp1[2] = z;; 6753 view->WCtoNDC(temp1, &temp2[0]);; 6754 gPad->PaintPolyMarker(1, &temp2[0], &temp2[1]);; 6755 }; 6756 }; 6757 ; 6758 // Paint the Front Box if needed; 6759 if (Hoption.FrontBox) {; 6760 fLego->InitMoveScreen(-1.1,1.1);; 6761 fLego->SetDrawFace(&TPainter3dAlgorithms::DrawFaceMove2);; 6762 fLego->FrontBox(90);; 6763 }; 6764 ; 6765 // Paint the Axis if needed; 6766 if (!Hoption.Axis && !Hoption.Same && !Hoption.Lego && !Hoption.Surf) {; 6767 TGaxis axis;; 6768 PaintLegoAxis(&axis, 90);; 6769 }; 6770 ; 6771 fLego.reset();; 6772}; 6773 ; 6774////////////////////////////////////////////////////////////////////////////////; 6775/// Calculate range and clear pad (canvas).; 6776 ; 6777void THistPainter::PaintFrame(); 6778{; 6779 ; 6780 if (Hoption.Same) return;; 6781 ; 6782 RecalculateRange();; 6783 ; 6784 if (Hoption.Lego || Hoption.Surf || Hoption.Tri ||; 6785 Hoption.Contour == 14 || Hoption.Error >= 100) {; 6786 TObject *frame = gPad->FindObject(""TFrame"");; 6787 if (frame) gPad->Remove(frame);; 6788 return;; 6789 }; 6790 ; 6791 //The next statement is always executed on non-iOS platform,; 6792 //on iOS depends on pad mode.; 6793 if (!gPad->PadInSelectionMode() && !gPad->PadInHighlightMode()); 6794 gPad->PaintPadFrame(Hparam.xmin,Hparam.ymin,Hparam.xmax,Hparam.ymax);; 6795}; 6796 ; 6797////////////////////////////////////////////////////////////////////////////////; 6798/// [Paint functions associated to an histogram.](\ref HP28""); 6799 ; 6800void THistPainter::PaintFunction(Option_t *); 6801{; 6802 auto lnk = fFunctions->FirstLink();; 6803 ; 6804 while (lnk) {; 6805 auto o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:247390,clear,clear,247390,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"neC);; 2314 fTabSize.clear();; 2315 fX = xsave;; 2316 fY = ysave;; 2317 if (fError) return 0;; 2318 return 1;; 2319}; 2320 ; 2321////////////////////////////////////////////////////////////////////////////////; 2322/// Check if the Latex syntax is correct; 2323 ; 2324Int_t TLatex::CheckLatexSyntax(TString &text); 2325{; 2326 const Char_t *kWord1[] = {""{}^{"",""{}_{"",""^{"",""_{"",""#scale{"",""#color{"",""#font{"",""#sqrt{"",""#[]{"",""#{}{"",""#||{"",; 2327 ""#bar{"",""#vec{"",""#dot{"",""#hat{"",""#ddot{"",""#acute{"",""#grave{"",""#check{"",""#tilde{"",""#slash{"",""#bf{"",""#it{"",""#mbox{"",; 2328 ""\\scale{"",""\\color{"",""\\font{"",""\\sqrt{"",""\\[]{"",""\\{}{"",""\\||{"",""#(){"",""\\(){"",; 2329 ""\\bar{"",""\\vec{"",""\\dot{"",""\\hat{"",""\\ddot{"",""\\acute{"",""\\grave{"",""\\check{"",""\\bf{"",""\\it{"",""\\mbox{""}; // check for }; 2330 const Char_t *kWord2[] = {""#scale["",""#color["",""#font["",""#sqrt["",""#kern["",""#lower["",""\\scale["",""\\color["",""\\font["",""\\sqrt["",""\\kern["",""\\lower[""}; // check for ]{ + }; 2331 const Char_t *kWord3[] = {""#frac{"",""\\frac{"",""#splitline{"",""\\splitline{""}; // check for }{ then }; 2332 const Char_t *kLeft1[] = {""#left["",""\\left["",""#left{"",""\\left{"",""#left|"",""\\left|"",""#left("",""\\left(""};; 2333 const Char_t *kLeft2[] = {""#[]{"",""#[]{"",""#{}{"",""#{}{"",""#||{"",""#||{"",""#(){"",""#(){""};; 2334 const Char_t *kRight[] = {""#right]"",""\\right]"",""#right}"",""\\right}"",""#right|"",""\\right|"",""#right)"",""\\right)""};; 2335 const Int_t lkWord1[] = {4,4,2,2,7,7,6,6,4,4,4,5,5,5,5,6,7,7,7,7,7,4,4,6,7,7,6,6,4,4,4,4,4,5,5,5,5,6,7,7,7,4,4,6};; 2336 const Int_t lkWord2[] = {7,7,6,6,6,7,7,7,6,6,6,7} ;; 2337 const Int_t lkWord3[] = {6,6,11,11} ;; 2338 Int_t nkWord1 = 44, nkWord2 = 12, nkWord3 = 4;; 2339 Int_t i,k ;; 2340 Int_t nLeft1 , nRight , nOfLeft, nOfRight;; 2341 Int_t lLeft1 = 6 ;; 2342 Int_t lLeft2 = 4 ;; 2343 Int_t lRight = 7 ;; 2344 nLeft1 = nRight = 8 ;; 2345 nOfLeft = nOfRight = 0 ;; 2346 ; 2347 Char_t buf[11] ; for (i=0;i<11;i++) buf[i]=0;; 2348 Bool_t opFound ;; 2349 Int_t opFrac = 0;; 2350 Int_t length = text.Length() ;; 2351 ; 23",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:83321,clear,clear,83321,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['clear'],['clear']
Usability,"neSeg(const TGeoConeSeg&); TGeoConeSeg(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoConeSeg(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual~TGeoConeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:1586,Clear,Clear,1586,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,1,['Clear'],['Clear']
Usability,"ned extended likelihood fits (Binned(),Extended()) on data generated; // with a Poisson fluctuation on Nobs (Extended()); RooMCStudy *mcs = new RooMCStudy(model, mjjj, Binned(), Silence(), Extended(true),; FitOptions(Extended(true), PrintEvalErrors(-1)));; ; // C u s t o m i z e m a n a g e r; // ---------------------------------; ; // Add module that randomizes the summed value of nsig+nbkg; // sampling from a uniform distribution between 0 and 1000; //; // In general one can randomize a single parameter, or a; // sum of N parameters, using either a uniform or a Gaussian; // distribution. Multiple randomization can be executed; // by a single randomizer module; ; RooRandomizeParamMCSModule randModule;; randModule.sampleSumUniform(RooArgSet(nsig, nbkg), 50, 500);; mcs->addModule(randModule);; ; // Add profile likelihood calculation of significance. Redo each; // fit while keeping parameter nsig fixed to zero. For each toy,; // the difference in -log(L) of both fits is stored, as well; // a simple significance interpretation of the delta(-logL); // using Dnll = 0.5 sigma^2; ; RooDLLSignificanceMCSModule sigModule(nsig, 0);; mcs->addModule(sigModule);; ; // R u n m a n a g e r , m a k e p l o t s; // ---------------------------------------------; ; // Run 1000 experiments. This configuration will generate a fair number; // of (harmless) MINUIT warnings due to the instability of the Chebychev polynomial fit; // at low statistics.; mcs->generateAndFit(500);; ; // Make some plots; TH1 *dll_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,dll_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *z_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,significance_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,nsigerr"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_nsig = mcs->fitParDataSet().createHistogram(""nsig,nsigerr"", AutoBinning(40), AutoBinning(40));; ; // Draw plots on canvas; TCanva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html:2817,simpl,simple,2817,doc/master/rf803__mcstudy__addons2_8C.html,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html,1,['simpl'],['simple']
Usability,"neralLayer< Architecture_t >::SetInputWidth ; (; size_t ; inputWidth). inline . Definition at line 220 of file GeneralLayer.h. ◆ SetIsTraining(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetIsTraining ; (; bool ; isTraining). inline . Definition at line 224 of file GeneralLayer.h. ◆ SetWidth(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetWidth ; (; size_t ; width). inline . Definition at line 223 of file GeneralLayer.h. ◆ Update(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::Update ; (; const Scalar_t ; learningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:25655,learn,learning,25655,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learning']
Usability,"neralized as follows:. Opening of the connection to the system; Definition of main frame (top level window); Creation of widgets as children of the top-level frame; assign them desired properties following the steps:; Create a new widget passing its parent in the constructor; Connect widget’s signals with desired slots to ensure desired functionality; Define widget’s layout and add it to the parent list of children; Set main window attributes; Map all sub windows; Initialize the layout algorithm via Resize(GetDefaultSize()) method; Map the main frame; Execution of the even-processing loop. 25.4.1 A Standalone Version; As usual a standalone program in C++ has to contain a main() function - the starting point for the application execution. In this case it is better to separate the program code creating a program header file example2a.h with the MyMainFrame class declaration and example2a.cxx- with the class methods implementation. To run our simple example as a standalone application we need to create in addition an object of class TApplication. It will make a correct initialization of the dictionaries if it is not yet done. It will be responsible for holding everything together and to handle all events in the application. Its environment provides an interface to the ROOT graphics system and by calling the Run() method the event loop starts and the application program is waiting for the user action. The application exits only if the top level window is not closed. Two header files are used in addition: TApplication.h - for the class TApplication and TGClient.h that is used to make initial connection to the graphics system. The class TApplication must be instantiated only once in any given application. The original list of argument options can be retrieved via the Argc() and Argv() methods.; Note: to have signals/slots working we need to create a dictionary for the class MyMainFrame, i.e. we create the file ex2aLinkDef.h containing the line:; #pragma link C++ class MyMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1142152,simpl,simple,1142152,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"nes that we have already created.; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; Volume Families; A volume family is represented by the class TGeoVolumeMulti. It rep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:41866,simpl,simple,41866,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"nestatic . ReturnsName of the file containing the class declaration ; Definition at line 58 of file TMLPAnalyzer.h. ◆ DrawDInput(). void TMLPAnalyzer::DrawDInput ; (; Int_t ; i). Draws the distribution (on the test sample) of the impact on the network output of a small variation of the ith input. ; Definition at line 284 of file TMLPAnalyzer.cxx. ◆ DrawDInputs(). void TMLPAnalyzer::DrawDInputs ; (; ). Draws the distribution (on the test sample) of the impact on the network output of a small variation of each input. ; DrawDInputs() draws something that approximates the distribution of the derivative of the NN w.r.t. each input. That quantity is recognized as one of the measures to determine key quantities in the network.; What is done is to vary one input around its nominal value and to see how the NN changes. This is done for each entry in the sample and produces a distribution.; What you can learn from that is:; is variable a really useful, or is my network insensitive to it ?; is there any risk of big systematic ? Is the network extremely sensitive to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve as input for an ""educated guess"" when optimizing the network. ; Definition at line 311 of file TMLPAnalyzer.cxx. ◆ DrawNetwork(). void TMLPAnalyzer::DrawNetwork ; (; Int_t ; neuron, . const char * ; signal, . const char * ; bg . ). Draws the distribution of the neural network (using ith neuron). ; Two distributions are drawn, for events passing respectively the ""signal"" and ""background"" cuts. Only the test sample is used. ; Definition at line 337 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviation(). TProfile * TMLPAnalyzer::DrawTruthDeviation ; (; Int_t ; outnode = 0, . Option_t * ; option = """" . ). Create a profile of the difference of the MLP output minus the true value for a given output node outnode, vs the true value for outnode, for all test data events. ; This method is mainly useful when doing regress",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMLPAnalyzer.html:14457,learn,learn,14457,doc/master/classTMLPAnalyzer.html,https://root.cern,https://root.cern/doc/master/classTMLPAnalyzer.html,1,['learn'],['learn']
Usability,"nestaticconstexpr . ReturnsVersion of this class ; Definition at line 146 of file TUnfoldSys.h. ◆ ClearResults(). void TUnfoldSys::ClearResults ; (; void ; ). overrideprotectedvirtual . Clear all data members which depend on the unfolding results. ; Reimplemented from TUnfold.; Definition at line 650 of file TUnfoldSys.cxx. ◆ DeclFileName(). static const char * TUnfoldSys::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 146 of file TUnfoldSys.h. ◆ DoBackgroundSubtraction(). void TUnfoldSys::DoBackgroundSubtraction ; (; void ; ). protected . perform background subtraction ; This prepares the data members for the base class TUnfold, such that the background is properly taken into account. ; Definition at line 377 of file TUnfoldSys.cxx. ◆ GetBackground(). void TUnfoldSys::GetBackground ; (; TH1 * ; bgrHist, . const char * ; bgrSource = nullptr, . const Int_t * ; binMap = nullptr, . Int_t ; includeError = 3, . Bool_t ; clearHist = kTRUE . ); const. get background into a histogram ; Parameters. [in,out]bgrHisttarget histogram, content and errors will be altered ; [in]bgrSource(default=nullptr) name of backgrond source or zero to add all sources of background ; [in]binMap(default=nullptr) remap histogram bins ; [in]includeError(default=3) include uncorrelated(1), correlated (2) or both (3) sources of uncertainty in the histogram errors ; [in]clearHist(default=true) reset histogram before adding up the specified background sources. the array binMap is explained with the method GetOutput(). The flag clearHist may be used to add background from several sources in successive calls to GetBackground(). ; Definition at line 565 of file TUnfoldSys.cxx. ◆ GetBgrSources(). TSortedList * TUnfoldSys::GetBgrSources ; (; void ; ); const. Get a new list of all background sources. ; The user is responsible for deleting the list get list of name of background sources ; Definition at line 1528 of file TUnfoldSys.cxx. ◆ GetCh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:33861,clear,clearHist,33861,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearHist']
Usability,"net. ;  ; Scalar_t fRho;  The Rho constant used by the optimizer. ;  ; std::vector< std::vector< Matrix_t > > fWeightUpdates;  The accumulation of the past Weights for performing updates. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor1;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor2;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor1;  working tensor used to keep a temporary copy of weights or weight gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor2;  working tensor used to keep a temporary copy of weights or weight gradients ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/RMSProp.h>. Inheritance diagram for TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 47 of file RMSProp.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 48 of file RMSProp.h. Constructor & Destructor Documentation. ◆ TRMSProp(). template<typename Architecture_t , typename Layer_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:4479,learn,learning,4479,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['learn'],['learning']
Usability,"new TGDoubleVSlider(p,100,kDoubleScaleNo,dsliderID);; vDslider->SetRange(-10,10);; 25.8.9 Triple Slider; The new TGTripleHSlider and TGTripleVSlider classes inherit from the double slider widgets and allow easy selection of a range and a pointer value. The pointer position can be constrained into the selected range or can be relative to it. To change the slider range value press the left mouse button near to the left/right (top/bottom) edges of the slider. To change both values simultaneously press the mouse button near to the slider center. To change pointer value press the mouse on the pointer and drag it to the desired position.; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; 25.8.10 Progress Bars; A progress bar is a widget that shows that an operation is in progress and how much time is left. It is a long rectangular bar, initially empty, that fills with a color as a process is being performed. The filled-in area indicates the percentage of the process that has been completed. You should use this widget for waits exceeding one minute. For a very time consuming operation it is better to break the operation into subtasks and provide a progress bar for each of them. A progress bar may be oriented horizontally or vertically. The horizontally oriented progress bar fills with a color from left to right; the vertically oriented - from bottom to top. A percent complete message provides an indication of the completed part of the process. It is a good practice to include some descriptive text of the process to keep users informed and entertained while they are waiting for process completion.; The picture below shows the progress bars you can create using the classes TGProgressBar, TGHProgressBar, and TGHProgressBar.; // vertic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1207689,progress bar,progress bar,1207689,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Progress Bar', 'progress bar']","['Progress Bars', 'progress bar']"
Usability,"new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THistPainter.html:69621,simpl,simply,69621,root/html532/THistPainter.html,https://root.cern,https://root.cern/root/html532/THistPainter.html,8,['simpl'],['simply']
Usability,"nextel->GetType() == TStreamerInfo::kCacheDelete ) {; 2439 continue;; 2440 }; 2441 // NOTE: We should verify that the rule's source are 'before'; 2442 // or 'at' this branch.; 2443 // fprintf(stderr,""%s/%d[%zu] pushd %zu %s\n"",GetName(),fID,fIDs.size(),i,nextel->GetName());; 2444 fNewIDs.push_back(i);; 2445 fNewIDs.back().fElement = nextel;; 2446 fNewIDs.back().fInfo = fInfo;; 2447 }; 2448 } else if (elt && offset==TStreamerInfo::kMissing) {; 2449 // Still re-assign fID properly.; 2450 fNewIDs.clear();; 2451 size_t ndata = fInfo->GetNelement();; 2452 for (size_t i = 0; i < ndata; ++i) {; 2453 if (fInfo->GetElement(i) == elt) {; 2454 fID = i;; 2455 break;; 2456 }; 2457 }; 2458 } else {; 2459 // We have not even found the element .. this is strange :(; 2460 // fNewIDs.clear();; 2461 // fID = -3;; 2462 // SetBit(kDoNotProcess);; 2463 }; 2464 if (fOnfileObject==nullptr && (fType==31 || fType==41 || (0 <= fType && fType <=2) ) && fInfo->GetNelement(); 2465 && fInfo->GetElement(0)->GetType() == TStreamerInfo::kCacheNew); 2466 {; 2467 SetOnfileObject(fInfo);; 2468 }; 2469 }; 2470 if (fType == 3 || fType == 4 || (fType == 0 && fID == -2) || fType == 2) {; 2471 // Need to add the rule targeting transient members.; 2472 TStreamerInfo *localInfo = fInfo;; 2473 if (fType == 3 || fType == 4) {; 2474 // Don't we have real version information?; 2475 // Not unless there is a subbranch with a non-split element of the class.; 2476 // Search for the correct version.; 2477 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 2478 }; 2479 ; 2480 TString prefix(GetFullName());; 2481 if (fType == 2 && fID >= 0) {; 2482 auto start = prefix.Length();; 2483 if (prefix[start - 1] == '.'); 2484 --start;; 2485 std::string_view view(prefix.Data(), start);; 2486 auto cutoff = view.find_last_of('.');; 2487 if (cutoff != std::string::npos) {; 2488 prefix.Remove(cutoff + 1);; 2489 }; 2490 }; 2491 if (prefix[prefix.Length()-1] != '.') {; 2492 if (fType == 3 || fType == 4 || prefix.Index('.') != TStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:88001,clear,clear,88001,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['clear'],['clear']
Usability,"nfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM fitters)Definition Fitter.h:560; ROOT::Fit::Fitter::DoUnbinnedLikelihoodFitbool DoUnbinnedLikelihoodFit(bool extended=false",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:43833,simpl,simple,43833,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['simpl'],['simple']
Usability,"nfo : [dataset] : Added class ""Background""; : Add Tree bkg_tree of type Background with 10000 events; ; ; ; **/; ; /****; # Booking Methods; ; Here we book the TMVA methods. We book a Boosted Decision Tree method (BDT); ; **/; ; // Boosted Decision Trees; if (useTMVABDT) {; factory.BookMethod(&loader, TMVA::Types::kBDT, ""BDT"",; ""!V:NTrees=200:MinNodeSize=2.5%:MaxDepth=2:BoostType=AdaBoost:AdaBoostBeta=0.5:""; ""UseBaggedBoost:BaggedSampleFraction=0.5:SeparationType=GiniIndex:nCuts=20"");; }; /**; ; #### Booking Deep Neural Network; ; Here we book the DNN of TMVA. See the example TMVA_Higgs_Classification.C for a detailed description of the; options; ; **/; ; if (useTMVADNN) {; ; TString layoutString(; ""Layout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR"");; ; // Training strategies; // one can catenate several training strings with different parameters (e.g. learning rates or regularizations; // parameters) The training string must be concatenates with the `|` delimiter; TString trainingString1(""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""MaxEpochs=10,WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0."");; ; TString trainingStrategyString(""TrainingStrategy="");; trainingStrategyString += trainingString1; // + ""|"" + trainingString2 + ....; ; // Build now the full DNN Option string; ; TString dnnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:""; ""WeightInitialization=XAVIER"");; dnnOptions.Append("":"");; dnnOptions.Append(layoutString);; dnnOptions.Append("":"");; dnnOptions.Append(trainingStrategyString);; ; TString dnnMethodName = ""TMVA_DNN_CPU"";; // use GPU if available; #ifdef R__HAS_TMVAGPU; dnnOptions += "":Architecture=GPU"";; dnnMethodName = ""TMVA_DNN_GPU"";; #elif defined(R__HAS_TMVACPU); dnnOptions += "":Architecture=CPU"";; #endif; ; factory.BookMethod(&loader, TMVA::Types::kDL, dnnMethodName, dnnOptions);; }; ; /***; ### B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:54390,learn,learning,54390,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['learn'],['learning']
Usability,"nfo; Int_tfSVNRev; TGLabel*fSelector; TStringfSessionUrl; TGCheckButton*fSmoothSpeedouse smooth speedometer update; TGSpeedo*fSpeedospeedometer; Bool_tfSpeedoEnabledwhether to enable the speedometer; TTimefStartTime; TProofProgressDialog::EQueryStatusfStatus; TGTextButton*fStop; TGTextBuffer*fTextQuery; TGLabel*fTimeLab; TGLabel*fTitleLab; TGraph*fTotSGraph; TGLabel*fTotal; TGTextButton*fUpdtSpeedo; static Bool_tfgKeepDefault; static Bool_tfgLogQueryDefault; static TStringfgTextQueryDefault. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); Create PROOF processing progress dialog. void ToggleOdometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle but",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressDialog.html:3651,progress bar,progress bar,3651,root/html528/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html,6,['progress bar'],['progress bar']
Usability,"nfo_IsLoaded(ClassInfo_t* info) const; virtual Bool_tClassInfo_IsValid(ClassInfo_t* info) const; virtual Bool_tClassInfo_IsValidMethod(ClassInfo_t* info, const char* method, const char* proto, Long_t* offset) const; virtual const char*ClassInfo_Name(ClassInfo_t* info) const; virtual void*ClassInfo_New(ClassInfo_t* info) const; virtual void*ClassInfo_New(ClassInfo_t* info, int n) const; virtual void*ClassInfo_New(ClassInfo_t* info, void* arena) const; virtual void*ClassInfo_New(ClassInfo_t* info, int n, void* arena) const; virtual intClassInfo_Next(ClassInfo_t* info) const; virtual Long_tClassInfo_Property(ClassInfo_t* info) const; virtual intClassInfo_RootFlag(ClassInfo_t* info) const; virtual intClassInfo_Size(ClassInfo_t* info) const; virtual Long_tClassInfo_Tagnum(ClassInfo_t* info) const; virtual const char*ClassInfo_Title(ClassInfo_t* info) const; virtual const char*ClassInfo_TmpltName(ClassInfo_t* info) const; virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearFileBusy(); virtual voidClearStack(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreateListOfBaseClasses(TClass* cl); virtual voidCreateListOfDataMembers(TClass* cl); virtual voidCreateListOfMethodArgs(TFunction* m); virtual voidCreateListOfMethods(TClass* cl); virtual intDataMemberInfo_ArrayDim(DataMemberInfo_t* dminfo) const; virtual voidDataMemberInfo_Delete(DataMemberInfo_t* dminfo) const; virtual DataMemberInfo_t*DataMemberInfo_Factory(ClassInfo_t* clinfo = 0) const; virtual DataMemberInfo_t*DataMemberInfo_FactoryCopy(DataMemberInfo_t* dminfo) const; virtual Bool_tDataMemberInfo_IsValid(DataMemberInfo_t* dminfo) const; virtual intDataMemberInfo_MaxIndex(DataMemberInfo_t* dminfo, Int_t dim) const; virtual const char*DataMemberInfo_Name(DataMemberInfo_t* dminfo) const; virtual intDataMemberInfo_Next(DataMe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:5401,Clear,Clear,5401,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,1,['Clear'],['Clear']
Usability,"nfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTUnfold::AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; Bool_tTUnfold::AddRegularisationCondition(Int_t nEle, const Int_t* indices, const Double_t* rowData); Bool_tTUnfold::AddRegularisationCondition(Int_t i0, Double_t f0, Int_t i1 = -1, Double_t f1 = 0., Int_t i2 = -1, Double_t f2 = 0.); voidTUnfold::ClearHistogram(TH1* h, Double_t x = 0.) const; virtual voidTUnfoldSys::ClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidTUnfoldSys::DoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; Int_tTUnfold::GetBinFromRow(int ix) const; Double_tGetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*TUnfold::GetDXDAZ(int i) const; const TMatrixDSparse*TUnfold::GetDXDtauSquared() const; const TMatrixDSparse*TUnfold::GetDXDY() const; const TMatrixDSpar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldDensity.html:16360,Clear,ClearHistogram,16360,root/html602/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html,2,['Clear'],['ClearHistogram']
Usability,"nformation and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1086for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1087 ; 1088\anchor rnode; 1089### RDataFrame objects as function arguments and return values; 1090RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); 1091functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; 1092which includes all available compile-time information about what that node does. One way to cope with this complication; 1093is to use template functions and/or C++14 auto return types:; 1094~~~{.cpp}; 1095template <typename RDF>; 1096auto ApplySomeFilters(RDF df); 1097{; 1098 return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; 1099}; 1100~~~; 1101 ; 1102A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; 1103converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; 1104~~~{.cpp}; 1105// a function that conditionally adds a Range to an RDataFrame node.; 1106RNode MaybeAddRange(RNode df, bool mustAddRange); 1107{; 1108 return mustAddRange ? df.Range(1) : df;; 1109}; 1110// use as :; 1111ROOT::RDataFrame df(10);; 1112auto maybeRangedDF = MaybeAddRange(df, true);; 1113~~~; 1114 ; 1115The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1116loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1117 ; 1118\anchor RDFCollections; 1119### Storing RDataFrame objects in collections; 1120 ; 1121ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1122 ; 1123~~~{.cp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:64650,simpl,simpler,64650,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simpler']
Usability,"nformation and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1126for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1127 ; 1128\anchor rnode; 1129### RDataFrame objects as function arguments and return values; 1130RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); 1131functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; 1132which includes all available compile-time information about what that node does. One way to cope with this complication; 1133is to use template functions and/or C++14 auto return types:; 1134~~~{.cpp}; 1135template <typename RDF>; 1136auto ApplySomeFilters(RDF df); 1137{; 1138 return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; 1139}; 1140~~~; 1141 ; 1142A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; 1143converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; 1144~~~{.cpp}; 1145// a function that conditionally adds a Range to an RDataFrame node.; 1146RNode MaybeAddRange(RNode df, bool mustAddRange); 1147{; 1148 return mustAddRange ? df.Range(1) : df;; 1149}; 1150// use as :; 1151ROOT::RDataFrame df(10);; 1152auto maybeRangedDF = MaybeAddRange(df, true);; 1153~~~; 1154 ; 1155The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1156loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1157 ; 1158\anchor RDFCollections; 1159### Storing RDataFrame objects in collections; 1160 ; 1161ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1162 ; 1163~~~{.cp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:66330,simpl,simpler,66330,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simpler']
Usability,"ng SHOw XXXX command."");; 3912 Printf("" In addition, the SHOw commands listed starting here have no"");; 3913 Printf("" corresponding SET command for obvious reasons."");; 3914 ; 3915 Printf("" "");; 3916 Printf("" SHOw CORrelations"");; 3917 Printf("" Calculates and prints the parameter correlations from the"");; 3918 Printf("" error matrix."");; 3919 ; 3920 Printf("" "");; 3921 Printf("" SHOw COVariance"");; 3922 Printf("" Prints the (external) covariance (error) matrix."");; 3923 ; 3924 Printf("" "");; 3925 Printf("" SHOw EIGenvalues"");; 3926 Printf("" Calculates and prints the eigenvalues of the covariance"");; 3927 Printf("" matrix."");; 3928 ; 3929 Printf("" "");; 3930 Printf("" SHOw FCNvalue"");; 3931 Printf("" Prints the current value of FCN."");; 3932 goto L99;; 3933 }; 3934//______________________________________________________________________________; 3935//; 3936// Command SIMPLEX; 3937//; 3938 if( !strncmp(comd.Data(),""SIM"",3) ) {; 3939 Printf("" ***>SIMplex [maxcalls] [tolerance]"");; 3940 Printf("" Performs a function minimization using the simplex method of"");; 3941 Printf("" Nelder and Mead. Minimization terminates either when the"");; 3942 Printf("" function has been called (approximately) [maxcalls] times,"");; 3943 Printf("" or when the estimated vertical distance to minimum (EDM) is"");; 3944 Printf("" less than [tolerance]."");; 3945 Printf("" The default value of [tolerance] is 0.1*UP(see SET ERRordef)."");; 3946 goto L99;; 3947 }; 3948//______________________________________________________________________________; 3949//; 3950// Command STANDARD; 3951//; 3952 if( !strncmp(comd.Data(),""STA"",3) ) {; 3953 Printf("" ***>STAndard"");; 3954 goto L99;; 3955 }; 3956//______________________________________________________________________________; 3957//; 3958// Command STOP; 3959//; 3960 if( !strncmp(comd.Data(),""STO"",3) ) {; 3961 Printf("" ***>STOP"");; 3962 Printf("" Same as EXIT."");; 3963 goto L99;; 3964 }; 3965//______________________________________________________________________________; 39",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:132489,simpl,simplex,132489,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['simpl'],['simplex']
Usability,"ng a class description of each version of the class that was ever written to disk, with the class. When it writes an object to file, it also writes the description of the current class version along with it. This description is implemented in the StreamerInfoclass.; 11.5.1 The TStreamerInfo Class; Each class has a list of StreamerInfo objects, one for each version of the class if that version was written to disk at least once. When reading an object from a file, the system uses the StreamerInfo list to decode an object into the current version. The StreamerInfo is made up of TStreamerElements . Each describes one persistent data member of the class. By default, all data members of a class are persistent. To exclude a data member (i.e. make it not persistent), add a “!” after the comment marks. For example the pointer *fPainter of a TH1 is not persistent:; TVirtualHistPainter* fPainter //!pointer to histogram painter; 11.5.2 The TStreamerElement Class; A TStreamerElement describes a data member of a simple type, object, array, pointer, or container. The offset in the TStreamerElement is the starting address of the data for that data member.; BASE TNamed offset= 0 type=67 The basis for a named object; BASE TAttLine offset= 28 type= 0 Line attributes; In this example, the TNamed data starts at byte 0, and TAttLine starts at byte 28. The offset is machine and compiler dependent and is computed when the StreamerInfo is analyzed. The types are defined in the file TStreamerInfo.h and listed here:; enum EReadWrite {; kBase=0, kChar=1,kShort=2,kInt=3,kLong=4,; kFloat=5, kCounter=6,kCharStar=7, kDouble=8,kUChar=11,; kUShort=12, kUInt=13,kULong=14,kBits=15,kOffsetL=20,; kOffsetP=40, kObject=61,kAny=62,kObjectp=63,kObjectP=64,; kTString=65, kTObject=66,kTNamed=67,kSkip=100,kSkipL=120,; kSkipP=140, kConv=200, kConvL=220,kConvP=240,kStreamer=500,; kStreamLoop=501, kMissing=99999; };; The method TClass::GetStreamerInfo analyzes the StreamerInfo the same way it would be analyzed by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:492756,simpl,simple,492756,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"ng and draw on top of it the; 428option `SAME` should be use. The histogram drawn with the option; 429`SAME` uses the coordinates system available in the current pad.; 430 ; 431This option can be used alone or combined with any valid drawing option but; 432some combinations must be use with care.; 433 ; 434\anchor HP060a; 435#### Limitations; 436 ; 437- It does not work when combined with the `LEGO` and `SURF` options unless the; 438 histogram plotted with the option `SAME` has exactly the same; 439 ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; 440 lego plots [histograms' stacks](\ref HP26) should be used.; 441 ; 442 ; 443\anchor HP061; 444### Colors automatically picked in palette; 445 ; 446\since **ROOT version 6.09/01**; 447 ; 448When several histograms are painted in the same canvas thanks to the option ""SAME""; 449or via a `THStack` it might be useful to have an easy and automatic way to choose; 450their color. The simplest way is to pick colors in the current active color; 451palette. Palette coloring for histogram is activated thanks to the options `PFC`; 452(Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; 453When one of these options is given to `TH1::Draw` the histogram get its color; 454from the current color palette defined by `gStyle->SetPalette(...)`. The color; 455is determined according to the number of objects having palette coloring in; 456the current pad.; 457 ; 458Begin_Macro(source); 459../../../tutorials/hist/histpalettecolor.C; 460End_Macro; 461 ; 462Begin_Macro(source); 463../../../tutorials/hist/thstackpalettecolor.C; 464End_Macro; 465 ; 466Begin_Macro(source); 467../../../tutorials/hist/thstack2palettecolor.C; 468End_Macro; 469 ; 470\anchor HP06; 471### Superimposing two histograms with different scales in the same pad; 472 ; 473 ; 474The following example creates two histograms, the second histogram is the bins; 475integral of the first one. It shows a procedure to draw the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:22177,simpl,simplest,22177,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simplest']
Usability,"ng and maintaining the Win32GDK version of ROOT. Bertrand has also many other contributions like the nice RootShower example (since 2001).; Valeriy Onoutchin has been working on several ROOT packages, in particular the graphics sub-system for Windows and the GUI Builder (since 2000).; Gerri Ganis has been working on the authentication procedures to be used by the root daemons and the PROOF system (since 2002).; Maarten Ballintijn (MIT) is one of the main developers of the PROOF sub-system (since 1995).; Valeri Fine (now at BNL) ported ROOT to Windows and contributed largely to the 3-D graphics. He is currently working on the Qt layer of ROOT (since 1995).; Victor Perevoztchikov (BNL) worked on key elements of the I/O system, in particular the improved support for STL collections (1997-2001).; Nenad Buncic developed the HTML documentation generation system and integrated the X3D viewer inside ROOT (1995-1997).; Suzanne Panacek was the author of the first version of this User’s Guide and very active in preparing tutorials and giving lectures about ROOT (1999-2002).; Axel Naumann has been developing further the HTML Reference Guide and helps in porting ROOT under Windows (cygwin/gcc implementation) (since 2000).; Anna Kreshuk has developed the Linear Fitter and Robust Fitter classes as well as many functions in TMath, TF1, TGraph (since 2005).; Richard Maunder has contributed to the GL viewer classes (since 2004).; Timur Pocheptsov has contributed to the GL viewer classes and GL in pad classes (since 2004).; Sergei Linev has developed the XML driver and the TSQLFile classes (since 2003).; Stefan Roiser has been contributing to the reflex and cintex packages (since 2005).; Lorenzo Moneta has been contributing the MathCore, MathMore, Smatrix & Minuit2 packages (since 2005).; Wim Lavrijsen is the author of the PyRoot package (since 2004).; Further we would like to thank all the people mentioned in the $ROOTSYS/README/CREDITS file for their contributions, and finally, every",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:4706,Guid,Guide,4706,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Guid'],['Guide']
Usability,"ng and pressing Enter at the end.; Another way is from the right panel context menu : ExecuteCommand. All commands can be interrupted at any time by pressing the STOP button from the bottom-left You can toggle recording of the current command in the history file by checking the Rec button from the top-right. Context menus; You can activate context menus by right-clicking on items or inside the right panel.; Context menus for mapped items from the left tree-type list : The items from the left that are provided with context menus are tree and branch items. You can directly activate the MENU marked methods of TTree from this menu.; Context menu for the right panel:; A general context menu is activated if the user right-clicks the right panel.; Commands are :; EmptyAll : clears the content of all expressions;; ExecuteCommand : execute a ROOT command;; MakeSelector : equivalent of TTree::MakeSelector();; NewExpression : add an expression item in the right panel;; Process : equivalent of TTree::Process();; SaveSource : save the current session as a C++ macro;; SetScanFileName : define a name for the file where TTree::Scan command is redirected when the <Scan> button is checked;; SetTreeName : open a new tree with this name in the viewer;. A specific context menu is activated if expressions/leaves are right-clicked.; Commands are :; Draw : draw a histogram for this item;; EditExpression : pops-up the expression editor;; Empty : empty the name and alias of this item;; RemoveItem : removes clicked item from the list;; Scan : scan this expression;; SetExpression : edit name and alias for this item by hand;. Starting the viewer. From the TBrowser: Select a tree in the TBrowser, then call the StartViewer() method from its context menu (right-click on the tree).; From the command line: Start a ROOT session in the directory where you have your tree. You will need first to load the library for TTreeViewer and optionally other libraries for user defined classes (you can do this late",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeViewer.html:5980,clear,clears,5980,doc/master/classTTreeViewer.html,https://root.cern,https://root.cern/doc/master/classTTreeViewer.html,1,['clear'],['clears']
Usability,ng how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlcreatedb.py Create a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlfilldb.py Fill run catalog with nfiles entries ;  SQLiteIPLocation.C ;  SQLitePlatformDistribution.C ;  SQLiteTimeVersionOfRoot.C ;  SQLiteVersionsOfRoot.C ;  sqlselect.CQuery example to MySQL test database ;  sqlselect.py Query example to MySQL test database ;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cros,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:164475,simpl,simple,164475,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"ng loss. ;  . #include <TMVA/DNN/DLMinimizers.h>; Member Typedef Documentation. ◆ DeepNet_t. template<typename Architecture_t > . using TMVA::DNN::TDLGradientDescent< Architecture_t >::DeepNet_t = TDeepNet<Architecture_t>. Definition at line 67 of file DLMinimizers.h. ◆ Matrix_t. template<typename Architecture_t > . using TMVA::DNN::TDLGradientDescent< Architecture_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 69 of file DLMinimizers.h. ◆ Scalar_t. template<typename Architecture_t > . using TMVA::DNN::TDLGradientDescent< Architecture_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 68 of file DLMinimizers.h. Constructor & Destructor Documentation. ◆ TDLGradientDescent() [1/2]. template<typename Architecture_t > . TMVA::DNN::TDLGradientDescent< Architecture_t >::TDLGradientDescent. Definition at line 163 of file DLMinimizers.h. ◆ TDLGradientDescent() [2/2]. template<typename Architecture_t > . TMVA::DNN::TDLGradientDescent< Architecture_t >::TDLGradientDescent ; (; Scalar_t ; learningRate, . size_t ; convergenceSteps, . size_t ; testInterval . ). Definition at line 172 of file DLMinimizers.h. Member Function Documentation. ◆ GetConvergenceCount(). template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetConvergenceCount ; (; ); const. inline . Getters. ; Definition at line 146 of file DLMinimizers.h. ◆ GetConvergenceSteps(). template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetConvergenceSteps ; (; ); const. inline . Definition at line 147 of file DLMinimizers.h. ◆ GetTestError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTestError ; (; ); const. inline . Definition at line 149 of file DLMinimizers.h. ◆ GetTestInterval(). template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTestInterval ; (; ); const. inline . Definition at line 150 of file DLMi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:4832,learn,learningRate,4832,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,1,['learn'],['learningRate']
Usability,"ng result induced by varying the normalisation of the identified background by one sigma. ; the array binMap is explained with the method GetOutput(). ; Definition at line 1086 of file TUnfoldSys.cxx. ◆ GetEmatrixFromVyy(). void TUnfoldSys::GetEmatrixFromVyy ; (; const TMatrixDSparse * ; vyy, . TH2 * ; ematrix, . const Int_t * ; binMap, . Bool_t ; clearEmat . ). protected . propagate an error matrix on the input vector to the unfolding result ; Parameters. [in]vyyinput error matrix ; [in,out]ematrixhistogram to be updated ; [in]binMapmapping of histogram bins ; [in]clearEmatif set, clear histogram before adding this covariance contribution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:37831,clear,clearEmat,37831,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,2,['clear'],"['clear', 'clearEmat']"
Usability,"ng size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look like:; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; Here is running example and source code; 1.11.5 TTree API; Simple TTree::Draw operation can be performed with following code:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::pz>5"");; To get access to selected branches, one should use TSelector class:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; import { TSelector, treeProcess } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function called before reading of TTree starts; }. selector.Process = function() {; // function called for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:28557,Simpl,Simple,28557,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['Simpl'],['Simple']
Usability,"ng verbose and debug flag appropriately ; Definition at line 510 of file MethodANNBase.cxx. ◆ PrintNetwork(). void TMVA::MethodANNBase::PrintNetwork ; (; ); const. virtual . print network representation, for debugging ; Definition at line 533 of file MethodANNBase.cxx. ◆ PrintNeuron(). void TMVA::MethodANNBase::PrintNeuron ; (; TNeuron * ; neuron); const. private . print a neuron, for debugging ; Definition at line 573 of file MethodANNBase.cxx. ◆ ProcessOptions(). void TMVA::MethodANNBase::ProcessOptions ; (; ). virtual . do nothing specific at this moment ; Implements TMVA::MethodBase.; Reimplemented in TMVA::MethodMLP.; Definition at line 157 of file MethodANNBase.cxx. ◆ ReadWeightsFromStream() [1/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Implements TMVA::MethodBase. ◆ ReadWeightsFromStream() [2/3]. void TMVA::MethodANNBase::ReadWeightsFromStream ; (; std::istream & ; istr). virtual . destroy/clear the network then read it back in from the weights file ; Implements TMVA::MethodBase.; Definition at line 889 of file MethodANNBase.cxx. ◆ ReadWeightsFromStream() [3/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromXML(). void TMVA::MethodANNBase::ReadWeightsFromXML ; (; void * ; wghtnode). virtual . read MLP from xml weight file ; Implements TMVA::MethodBase.; Definition at line 767 of file MethodANNBase.cxx. ◆ SetActivation(). void TMVA::MethodANNBase::SetActivation ; (; TActivation * ; activation). inline . Definition at line 83 of file MethodANNBase.h. ◆ SetNeuronInputCalculator(). void TMVA::MethodANNBase::SetNeuronInputCalculator ; (; TNeuronInput * ; inputCalculator). inline . Definition at line 87 of file MethodANNBase.h. ◆ Streamer(). virtual void TMVA::MethodANNBase::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase.; Reimplemented in TMVA::Metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html:41547,clear,clear,41547,doc/master/classTMVA_1_1MethodANNBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html,1,['clear'],['clear']
Usability,"ng(), methodTitle);; 2570 importances[ny] += SROC - SSROC;; 2571 // std::cout << ""SubSeed: "" << y << "" y:"" << ybitset << "" x-y "" << x - y << "" "" << std::bitset<32>(x - y) <<; 2572 // "" ny "" << ny << "" SROC "" << SROC << "" SSROC "" << SSROC << "" Importance = "" << importances[ny] <<; 2573 // std::endl; cleaning information; 2574 TMVA::MethodBase *ssmethod =; 2575 dynamic_cast<TMVA::MethodBase *>(fMethodsMap[ybitset.to_string().c_str()][0][0]);; 2576 TMVA::ResultsClassification *ssresults = (TMVA::ResultsClassification *)ssmethod->Data()->GetResults(; 2577 ssmethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2578 delete ssresults;; 2579 delete subseedloader;; 2580 this->DeleteAllMethods();; 2581 fMethodsMap.clear();; 2582 }; 2583 }; 2584 }; 2585 std::cout << ""--- Variable Importance Results (Random)"" << std::endl;; 2586 return GetImportance(nbits, importances, varNames);; 2587}; 2588 ; 2589////////////////////////////////////////////////////////////////////////////////; 2590 ; 2591TH1F *TMVA::Factory::GetImportance(const int nbits, std::vector<Double_t> importances, std::vector<TString> varNames); 2592{; 2593 TH1F *vih1 = new TH1F(""vih1"", """", nbits, 0, nbits);; 2594 ; 2595 gStyle->SetOptStat(000000);; 2596 ; 2597 Float_t normalization = 0.0;; 2598 for (int i = 0; i < nbits; i++) {; 2599 normalization = normalization + importances[i];; 2600 }; 2601 ; 2602 Float_t roc = 0.0;; 2603 ; 2604 gStyle->SetTitleXOffset(0.4);; 2605 gStyle->SetTitleXOffset(1.2);; 2606 ; 2607 std::vector<Double_t> x_ie(nbits), y_ie(nbits);; 2608 for (Int_t i = 1; i < nbits + 1; i++) {; 2609 x_ie[i - 1] = (i - 1) * 1.;; 2610 roc = 100.0 * importances[i - 1] / normalization;; 2611 y_ie[i - 1] = roc;; 2612 std::cout << ""--- "" << varNames[i - 1] << "" = "" << roc << "" %"" << std::endl;; 2613 vih1->GetXaxis()->SetBinLabel(i, varNames[i - 1].Data());; 2614 vih1->SetBinContent(i, roc);; 2615 }; 2616 TGraph *g_ie = new TGraph(nbits + 2, &x_ie[0], &y_ie[0]);; 2617 g_ie->SetTitle("""");; 2618 ; 261",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:106931,clear,clear,106931,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['clear'],['clear']
Usability,"ng(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EEventType { kUnDefined; kPacket; kStart; kStop; kFile; kFileOpen; kFileRead; kRate; kNumEventType; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * EventType(TVirtualPerfStats::EEventType type); Return the name of the event type. virtual ~TVirtualPerfStats(); {}. void SimpleEvent(TVirtualPerfStats::EEventType type). void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead). void FileOpenEvent(TFile* file, const char* filename, Double_t start). void FileReadEvent(TFile* file, Int_t len, Double_t start). void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen). void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead). Long64_t GetBytesRead() const. void SetNumEvents(Long64_t num). Long64_t GetNumEvents() const. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPerfStats.h 38055 2011-02-11 22:06:25Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualPerfStats.html:6573,Simpl,SimpleEvent,6573,root/html532/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html,1,['Simpl'],['SimpleEvent']
Usability,"ng...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TTabCom Class Reference. . Definition at line 52 of file TTabCom.h. Public Types; enum  { kDebug = 17; };  ; enum  EContext_t { ;   kUNKNOWN_CONTEXT =-1; , kSYS_UserName; , kSYS_EnvVar; , kCINT_stdout; , ;   kCINT_stderr; , kCINT_stdin; , kCINT_Edit; , kCINT_Load; , ;   kCINT_Exec; , kCINT_EXec; , kCINT_pragma; , kCINT_includeSYS; , ;   kCINT_includePWD; , kCINT_cpp; , kROOT_Load; , kSYS_FileName; , ;   kCXX_NewProto; , kCXX_ConstructorProto; , kCXX_ScopeProto; , kCXX_DirectProto; , ;   kCXX_IndirectProto; , kCXX_ScopeMember; , kCXX_DirectMember; , kCXX_IndirectMember; , ;   kCXX_Global; , kCXX_GlobalProto; , kNUM_PAT. };  ; typedef TList TContainer;  ; typedef TListIter TContIter;  . Public Member Functions;  TTabCom ();  Default constructor. ;  ; virtual ~TTabCom ();  ; void ClearAll ();  clears all lists except for user names and system include files. ;  ; void ClearClasses ();  Clear classes and namespace collections. ;  ; void ClearCppDirectives ();  Forget all Cpp directives seen so far. ;  ; void ClearEnvVars ();  Forget all environment variables seen so far. ;  ; void ClearFiles ();  Close all files. ;  ; void ClearGlobalFunctions ();  Forget all global functions seen so far. ;  ; void ClearGlobals ();  Forget all global variables seen so far. ;  ; void ClearPragmas ();  Forget all pragmas seen so far. ;  ; void ClearSysIncFiles ();  Close system files. ;  ; void ClearUsers ();  Forget all user seen so far. ;  ; const TSeqCollection * GetListOfClasses ();  Return the list of classes. ;  ; const TSeqCollection * GetListOfCppDirectives ();  Return the list of CPP directives. ;  ; const TSeqCollection * GetListOfEnvVars ();  Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. ;  ; const TSeqCollection * GetListOfFilesInPath (const char path[]);  ""path""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:1088,clear,clears,1088,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['clear'],['clears']
Usability,"ng...; Searching...; No Matches. Boost.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: M. Fischler 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class Boost, a 4x4 symmetric matrix representation of; 12// an axial Lorentz transformation; 13//; 14// Created by: Mark Fischler Mon Nov 1 2005; 15//; 16#include ""Math/GenVector/Boost.h""; 17#include ""Math/GenVector/LorentzVector.h""; 18#include ""Math/GenVector/PxPyPzE4D.h""; 19#include ""Math/GenVector/DisplacementVector3D.h""; 20#include ""Math/GenVector/Cartesian3D.h""; 21#include ""Math/GenVector/GenVector_exception.h""; 22 ; 23#include <cmath>; 24#include <algorithm>; 25 ; 26//#ifdef TEX; 27/**; 28 ; 29 A variable names bgamma appears in several places in this file. A few; 30 words of elaboration are needed to make its meaning clear. On page 69; 31 of Misner, Thorne and Wheeler, (Exercise 2.7) the elements of the matrix; 32 for a general Lorentz boost are given as; 33 ; 34 \f[ \Lambda^{j'}_k = \Lambda^{k'}_j; 35 = (\gamma - 1) n^j n^k + \delta^{jk} \f]; 36 ; 37 where the n^i are unit vectors in the direction of the three spatial; 38 axes. Using the definitions, \f$ n^i = \beta_i/\beta \f$ , then, for example,; 39 ; 40 \f[ \Lambda_{xy} = (\gamma - 1) n_x n_y; 41 = (\gamma - 1) \beta_x \beta_y/\beta^2 \f]; 42 ; 43 By definition, \f[ \gamma^2 = 1/(1 - \beta^2) \f]; 44 ; 45 so that \f[ \gamma^2 \beta^2 = \gamma^2 - 1 \f]; 46 ; 47 or \f[ \beta^2 = (\gamma^2 - 1)/\gamma^2 \f]; 48 ; 49 If we insert this into the expression for \f$ \Lambda_{xy} \f$, we get; 50 ; 51 \f[ \Lambda_{xy} = (\gamma - 1) \gamma^2/(\gamma^2 - 1) \beta_x \beta_y \f]; 52 ; 53 or, finally; 54 ; 55 \f[ \Lambda_{xy} = \gamma^2/(\gamma+1) \beta_x \beta_y \f]; 56 ; 57 The expression \f$ \gamma^2/(\gamma+1) \f$ is what we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Boost_8cxx_source.html:1127,clear,clear,1127,doc/master/Boost_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Boost_8cxx_source.html,1,['clear'],['clear']
Usability,"ng64_t processed) override;  ; void Progress (TSlave *, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti) override;  ; void Progress (TSlave *, TProofProgressInfo *pi) override;  ; Int_t ReinitSelector (TQueryResult *qr) override;  Reinitialize fSelector using the selector files in the query result. ;  ; void RemoveQueryResult (const char *ref) override;  Remove all query result instances referenced 'ref' from the list of results. ;  ; void RestorePreviousQuery () override;  ; Int_t SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE) override;  Save the partial results of this query to a dedicated file under the user data directory. ;  ; void SetCurrentQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetInitTime () override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetMerging (Bool_t=kTRUE) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; virtual void StopFeedback ();  Stop feedback (may not be used in this class). ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop the process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback list (may not be used in this class). ;  ; void StoreOutput (TList *out) override;  Store output list (may not be used in this class). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:7000,feedback,feedback,7000,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"ng64_t processed) override;  ; void Progress (TSlave *, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti) override;  ; void Progress (TSlave *, TProofProgressInfo *pi) override;  ; Int_t ReinitSelector (TQueryResult *qr) override;  Reinitialize fSelector using the selector files in the query result. ;  ; void RemoveQueryResult (const char *ref) override;  Remove all query result instances referenced 'ref' from the list of results. ;  ; void RestorePreviousQuery () override;  ; Int_t SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE) override;  Save the partial results of this query to a dedicated file under the user data directory. ;  ; void SetCurrentQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetInitTime () override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetMerging (Bool_t=kTRUE) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop the process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback list (may not be used in this class). ;  ; void StoreOutput (TList *out) override;  Store output list (may not be used in this class). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &z",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:5852,feedback,feedback,5852,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,2,['feedback'],['feedback']
Usability,"ngMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj, Bool_t& merged); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges; on the axis (i.e. if they can be just Add-ed for merging). void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerRemote.html:19210,feedback,feedback,19210,root/html532/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html532/TProofPlayerRemote.html,8,['feedback'],['feedback']
Usability,"ngTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. void FillLeaves(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeaves(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. Int_t SetParent(const TObject* obj, const Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TRefTable * GetRefTable() const; {return fRefTable;}. void SetReadEntry(Long64_t entry); {fReadEntry = entry;}. » Author: Rene Brun 19/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchRef.h 22689 2008-03-17 16:21:23Z rdm $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchRef.html:13527,clear,cleared,13527,root/html526/TBranchRef.html,https://root.cern,https://root.cern/root/html526/TBranchRef.html,1,['clear'],['cleared']
Usability,"ng_impl.cxx:3690; v4@ v4Definition rootcling_impl.cxx:3692; v3@ v3Definition rootcling_impl.cxx:3691; v1@ v1Definition rootcling_impl.cxx:3689; The supported operators are; +, -, *, /; +=, -=, *=, /=; <, >, ==, !=, <=, >=, &&, ||; ~, !; &, |, ^; &=, |=, ^=; <<=, >>=. The most common mathematical functions are supported. It is possible to invoke them passing RVecs as arguments.; abs, fdim, fmod, remainder; floor, ceil, trunc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations are vectorized:; fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case, it can be constructed with the address of the memory associated to it and its length. For example: std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"". If any method which implies a re-allocation is called, e.g. emplace_back or resize, the adopted memory is released and new one is allocated. The previous content is copied in the new memory and preserved. Sorting and manipulation of indices. Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms can be used, for example sorting: RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; v@ vDefinition rootcling_impl.cxx:3687; For convenience, helpers are provided too: auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:4695,simpl,simply,4695,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,1,['simpl'],['simply']
Usability,"ng_impl.cxx:3702; v4@ v4Definition rootcling_impl.cxx:3704; v3@ v3Definition rootcling_impl.cxx:3703; v1@ v1Definition rootcling_impl.cxx:3701; The supported operators are; +, -, *, /; +=, -=, *=, /=; <, >, ==, !=, <=, >=, &&, ||; ~, !; &, |, ^; &=, |=, ^=; <<=, >>=. The most common mathematical functions are supported. It is possible to invoke them passing RVecs as arguments.; abs, fdim, fmod, remainder; floor, ceil, trunc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations are vectorized:; fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case, it can be constructed with the address of the memory associated to it and its length. For example: std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"". If any method which implies a re-allocation is called, e.g. emplace_back or resize, the adopted memory is released and new one is allocated. The previous content is copied in the new memory and preserved. Sorting and manipulation of indices. Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms can be used, for example sorting: RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; v@ vDefinition rootcling_impl.cxx:3699; For convenience, helpers are provided too: auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html:4696,simpl,simply,4696,doc/master/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html,1,['simpl'],['simply']
Usability,"nge current fill area attributes if necessary.Definition TAttFill.cxx:216; TAttFill::SaveFillAttributesvirtual void SaveFillAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001)Save fill attributes as C++ statement(s) on output stream out.Definition TAttFill.cxx:239; TAttLine::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::Modifyvirtual void Modify()Change current line attributes if necessary.Definition TAttLine.cxx:247; TAttLine::Copyvoid Copy(TAttLine &attline) constCopy this line attributes to a new TAttLine.Definition TAttLine.cxx:177; TAttLine::SaveLineAttributesvirtual void SaveLineAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1)Save line attributes as C++ statement(s) on output stream out.Definition TAttLine.cxx:275; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::Copyvoid Copy(TObject &line) const overrideCopy this line to line.Definition TLine.cxx:76; TLine::fX2Double_t fX2X of 2nd point.Definition TLine.h:27; TLine::fY2Double_t fY2Y of 2nd point.Definition TLine.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TArrow_8cxx_source.html:20033,simpl,simple,20033,doc/master/TArrow_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TArrow_8cxx_source.html,1,['simpl'],['simple']
Usability,"nge(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:53381,simpl,simplex,53381,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,5,['simpl'],['simplex']
Usability,"nge+9);; firstaxis->AddRange(new TParallelCoordRange(firstaxis,-1.263024,-0.755292));; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kOrange@ kOrangeDefinition Rtypes.h:67; kViolet@ kVioletDefinition Rtypes.h:67; TCanvas.h; TFile.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TNtuple.h; TParallelCoordRange.h; TParallelCoordVar.h; TParallelCoord.h; TRandom.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TParallelCoordRangeA TParallelCoordRange is a range used for parallel coordinates plots.Definition TParallelCoordRange.h:25; TParallelCoordVarTParallelCoord axes.Definition TParallelCoordVar.h:24; TParallelCoordVar::AddRangevoid AddRange(TParallelCoordRange *range)Add a range to the current selection on the axis.Definition TParallelCoordVar.cxx:102; TParallelCoordParallel Coordinates class.Definition TParallelCoord.h:28; TParallelCoord::AddSelectionvoid AddSelection(const char *title)Add a selection.Definition TParallelCoord.cxx:242; TParallelCoord::GetCurrentSelectionTParallelCoordSelect * GetCurrentSelection()Return the selection currently being edited.Definition TParallelCoord.cxx:438",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/parallelcoord_8C.html:3215,simpl,simple,3215,doc/master/parallelcoord_8C.html,https://root.cern,https://root.cern/doc/master/parallelcoord_8C.html,1,['simpl'],['simple']
Usability,"nge. . ReturnsThe caller owns the returned std::list. ; Reimplemented from RooAbsReal.; Definition at line 329 of file RooAddition.cxx. ◆ printMetaArgs(). void RooAddition::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Reimplemented from RooAbsArg.; Definition at line 253 of file RooAddition.cxx. ◆ setData(). bool RooAddition::setData ; (; RooAbsData & ; data, . bool ; cloneData = true . ). overridevirtual . Reimplemented from RooAbsReal.; Definition at line 241 of file RooAddition.cxx. ◆ Streamer(). void RooAddition::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooAddition::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 76 of file RooAddition.h. ◆ translate(). void RooAddition::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 160 of file RooAddition.cxx. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooAddition::_cacheMgr. mutableprotected . ! The cache manager ; Definition at line 72 of file RooAddition.h. ◆ _ownedList. RooArgList RooAddition::_ownedList. protected . List of owned components. ; Definition at line 63 of file RooAddition.h. ◆ _set. RooListProxy RooAddition::_set. protected . set of terms to be summed ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:67179,simpl,simple,67179,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,1,['simpl'],['simple']
Usability,"nges.py;   Use Range to limit the amount of data processed. ;  ; file  df007_snapshot.C;   Write ROOT data with RDataFrame. ;  ; file  df007_snapshot.py;   Write ROOT data with RDataFrame. ;  ; file  df008_createDataSetFromScratch.C;   Create data from scratch with RDataFrame. ;  ; file  df008_createDataSetFromScratch.py;   Create data from scratch with RDataFrame. ;  ; file  df009_FromScratchVSTTree.C;   Compare creation of a ROOT dataset with RDataFrame and TTree. ;  ; file  df010_trivialDataSource.C;   Use the ""trivial data source"", an example data source implementation. ;  ; file  df010_trivialDataSource.py;   Use the ""trivial data source"", an example data source implementation. ;  ; file  df012_DefinesAndFiltersAsStrings.C;   Use just-in-time-compiled Filters and Defines for quick prototyping. ;  ; file  df012_DefinesAndFiltersAsStrings.py;   Use just-in-time-compiled Filters and Defines for quick prototyping. ;  ; file  df013_InspectAnalysis.C;   Use callbacks to update a plot and a progress bar during the event loop. ;  ; file  df014_CSVDataSource.C;   Process a CSV file with RDataFrame and the CSV data source. ;  ; file  df014_CSVDataSource.py;   Process a CSV file with RDataFrame and the CSV data source. ;  ; file  df015_LazyDataSource.C;   Use the lazy RDataFrame data source to concatenate computation graphs. ;  ; file  df016_vecOps.C;   Process collections in RDataFrame with the help of RVec. ;  ; file  df016_vecOps.py;   Process collections in RDataFrame with the help of RVec. ;  ; file  df017_vecOpsHEP.C;   Use RVecs to plot the transverse momentum of selected particles. ;  ; file  df017_vecOpsHEP.py;   Use RVecs to plot the transverse momentum of selected particles. ;  ; file  df018_customActions.C;   Implement a custom action to fill THns. ;  ; file  df019_Cache.C;   Cache a processed RDataFrame in memory for further usage. ;  ; file  df019_Cache.py;   Cache a processed RDataFrame in memory for further usage. ;  ; file  df020_helpers.C;   Show usage of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__dataframe.html:3458,progress bar,progress bar,3458,doc/master/group__tutorial__dataframe.html,https://root.cern,https://root.cern/doc/master/group__tutorial__dataframe.html,1,['progress bar'],['progress bar']
Usability,"ngle classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); constructors. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBase* CurrentMethod(); {return fCurrentMethod;}. UInt_t CurrentMethodIdx(); training a single classifier. {return fCurrentMethodIdx;}. Double_t CalcMethodWeight(); calculate weight of single method. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodBoost.html:24500,Clear,ClearAll,24500,root/html604/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html,1,['Clear'],['ClearAll']
Usability,"ngle classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); constructors. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBase* CurrentMethod(); {return fCurrentMethod;}. UInt_t CurrentMethodIdx(); training a single classifier. {return fCurrentMethodIdx;}. Double_t CalcMethodWeight(); calculate weight of single method. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBoost.html:24492,Clear,ClearAll,24492,root/html602/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBoost.html,1,['Clear'],['ClearAll']
Usability,"nificance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear ();; 320 m_weights.clear ();; 321 }; 322 ; 323 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 324 *; 325 */; 326 void ClassificationSettings::endTestCycle () ; 327 {; 328 if (m_output.empty ()); 329 return;; 330 double minVal = *std::min_element (begin (m_output), end (m_output));; 331 double maxVal = *std::max_element (begin (m_output), end (m_output));; 332 const size_t numBinsROC = 1000;; 333 const size_t numBinsData = 100;; 334 ; 335 std::vector<double> truePositives (numBinsROC+1, 0);; 336 std::vector<double> falsePositives (numBinsROC+1, 0);; 337 std::vector<double> trueNegatives (numBinsROC+1, 0);; 338 std::vector<double> falseNegatives (numBinsROC+1, 0);; 339 ; 340 std::vector<double> x (numBinsData, 0);; 341 std::vector<double> datSig (numBinsData+1, 0);; 342 std::vector<double> datBkg (numBinsData+1, 0);; 343 ; 344 double binSizeROC = (maxVal - minVal)/(double)numBinsROC;; 345 double binSizeData = (maxVal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:12115,clear,clear,12115,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['clear'],['clear']
Usability,"nihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; voidChanged(); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidCollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparenc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveScene.html:2450,Clear,Clear,2450,root/html532/TEveScene.html,https://root.cern,https://root.cern/root/html532/TEveScene.html,4,['Clear'],['Clear']
Usability,"nimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:50164,SIMPL,SIMPLEX,50164,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['SIMPL'],['SIMPLEX']
Usability,"nimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,; unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,; const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) times, or when",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:54169,SIMPL,SIMPLEX,54169,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['SIMPL'],['SIMPLEX']
Usability,"nimum is found, the search area is shifted to be centered at the best value. Random points are chosen uniformly over a hypercube determined by current step sizes. The Metropolis algorithm accepts a worse point with probability exp(-d/UP), where d is the degradation. Improved points are of course always accepted. Actual steps are random multiples of the nominal steps (DIRIN). ; Definition at line 6818 of file TMinuit.cxx. ◆ mnset(). void TMinuit::mnset ; (; ). virtual . Interprets the commands that start with SET and SHOW. ; Called from MNEXCM file characteristics for SET INPUT 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED ' explanation of print level numbers -1:3 and strategies 0:2 identification of debug options things that can be set or shown options not intended for normal users ; Definition at line 6913 of file TMinuit.cxx. ◆ mnsimp(). void TMinuit::mnsimp ; (; ). virtual . Minimization using the simplex method of Nelder and Mead. ; Performs a minimization using the simplex method of Nelder and Mead (ref. – Comp. J. 7,308 (1965)). ; Definition at line 7431 of file TMinuit.cxx. ◆ mnstat(). void TMinuit::mnstat ; (; Double_t & ; fmin, . Double_t & ; fedm, . Double_t & ; errdef, . Int_t & ; npari, . Int_t & ; nparx, . Int_t & ; istat . ). virtual . Returns concerning the current status of the minimization. ; User-called Namely, it returns:; FMIN: the best function value found so far; FEDM: the estimated vertical distance remaining to minimum; ERRDEF: the value of UP defining parameter uncertainties; NPARI: the number of currently variable parameters; NPARX: the highest (external) parameter number defined by user; ISTAT: a status integer indicating how good is the covariance matrix:; 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix . Definition at line 7638 of file TMinuit.cxx. ◆ mntiny(). void TMinuit::mntiny ; (; Double_t ; epsp1, . Double_t & ; epsbak . ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:64484,simpl,simplex,64484,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['simpl'],['simplex']
Usability,"ning of the dataset list of this dataset. void Browse(TBrowser* b); Browse this dataset (called by TBrowser). TObject * Clone(const char* newname = """") const; the custom implementation fo the TObject::Clone. void Delete(Option_t* opt = """"). Delete - deletes the list of the TDataSet objects and all ""Structural Members""; as well; This method doesn't affect the ""Associated Members"". TDataSet * FindByPath(const char* path) const; Aliase for TDataSet::Find(const Char_t *path) method. TDataSet * Find(const char* path) const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByName(const char* name, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This is method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * First() const; Return the first object in the list. Returns 0 when list is empty. void AddMain(TDataSet* set); add data set to main data set. TDataSet * GetMainSet(); return pointer to the main dataset. TObject * GetObject() const; The depricated method (left here for the sake of the backward compatibility). TDataSet * Last() const; Return the last object in the list. Returns 0 when list is empty. TDataSet * Next() const; Return the object next to this one in the parent structure; This co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSet.html:14373,simpl,simplify,14373,root/html528/TDataSet.html,https://root.cern,https://root.cern/root/html528/TDataSet.html,10,['simpl'],['simplify']
Usability,"ning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; name, . const Matrix_t & ; matrix . ). Definition at line 521 of file GeneralLayer.h. ◆ WriteTensorToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteTensorToXML ; (; void * ; node, . const char * ; name, . const std::vector< Matrix_t > & ; tensor . ). helper functions for XML ; Definition at line 496 of file GeneralLayer.h. Member Data Documentation. ◆ fActivationGradi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:26367,learn,learning,26367,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learning']
Usability,"ningful only if; validation is required).; Returns kTRUE on success. Int_t SetDataSetTreeName(const char* dataset, const char* treename); Set/Change the name of the default tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. TMap * GetDataSets(const char* uri = """", const char* optStr = """"); Lists all datasets that match given uri.; The 'optStr' can contain a comma-separated list of servers for which the; information is wanted. If ':lite:' (case insensitive) is specified in 'optStr'; only the global information in the TFileCollection is retrieved; useful to only; get the list of available datasets. void ShowDataSets(const char* uri = """", const char* optStr = """"); Shows datasets in locations that match the uri.; By default shows the user's datasets and global ones. Bool_t ExistsDataSet(const char* dataset); Returns kTRUE if 'dataset' exists, kFALSE otherwise. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). TFileCollection * GetDataSet(const char* dataset, const char* optStr = """"); Get a list of TFileInfo objects describing the files of the specified; dataset.; To get the short version (containing only the global meta information); specify optStr = ""S:"" or optStr = ""short:"".; To get the sub-dataset of files located on a given server(s) specify; the list of servers (comma-separated) in the 'optStr' field. void ShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); display meta-info for given dataset usi. Int_t RemoveDataSet(const char* dataset, const char* optStr = """"); Remove the specified dataset from the PROOF cluster.; Files are not deleted. TList* FindDataSets(const char* searchString, const char* optStr = """"); Find datasets, returns in a TList all found datasets. Bool_t Req",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:92806,Clear,ClearDataSetCache,92806,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['Clear'],"['Clear', 'ClearDataSetCache']"
Usability,"niqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; TGLEmbeddedViewer*SpawnGLEmbeddedViewer(TGedEditor* ged = 0, Int_t border = 0); TGLSAViewer*SpawnGLViewer(TGedEditor* ged = 0, Bool_t stereo = kFALSE); voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; voidSwitchStereo(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveViewer(const char* n = ""TEveViewer"", const char* t = """"); voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveViewer.html:17920,Undo,UndockWindow,17920,root/html602/TEveViewer.html,https://root.cern,https://root.cern/root/html602/TEveViewer.html,2,['Undo'],"['UndockWindow', 'UndockWindowDestroySlot']"
Usability,"nit(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18701,undo,undo,18701,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,20,['undo'],['undo']
Usability,"nitialization) {; 820 case EInitialization::kGauss:; 821 net.initializeWeights(WeightInitializationStrategy::XAVIER,; 822 std::back_inserter(weights));; 823 break;; 824 case EInitialization::kUniform:; 825 net.initializeWeights(WeightInitializationStrategy::XAVIERUNIFORM,; 826 std::back_inserter(weights));; 827 break;; 828 default:; 829 net.initializeWeights(WeightInitializationStrategy::XAVIER,; 830 std::back_inserter(weights));; 831 break;; 832 }; 833 ; 834 int idxSetting = 0;; 835 for (auto s : fTrainingSettings) {; 836 ; 837 EnumRegularization r = EnumRegularization::NONE;; 838 switch(s.regularization) {; 839 case ERegularization::kNone: r = EnumRegularization::NONE; break;; 840 case ERegularization::kL1: r = EnumRegularization::L1; break;; 841 case ERegularization::kL2: r = EnumRegularization::L2; break;; 842 }; 843 ; 844 Settings * settings = new Settings(TString(), s.convergenceSteps, s.batchSize,; 845 s.testInterval, s.weightDecay, r,; 846 MinimizerType::fSteepest, s.learningRate,; 847 s.momentum, 1, s.multithreading);; 848 std::shared_ptr<Settings> ptrSettings(settings);; 849 ptrSettings->setMonitoring (0);; 850 Log() << kINFO; 851 << ""Training with learning rate = "" << ptrSettings->learningRate (); 852 << "", momentum = "" << ptrSettings->momentum (); 853 << "", repetitions = "" << ptrSettings->repetitions (); 854 << Endl;; 855 ; 856 ptrSettings->setProgressLimits ((idxSetting)*100.0/(fSettings.size ()),; 857 (idxSetting+1)*100.0/(fSettings.size ()));; 858 ; 859 const std::vector<double>& dropConfig = ptrSettings->dropFractions ();; 860 if (!dropConfig.empty ()) {; 861 Log () << kINFO << ""Drop configuration"" << Endl; 862 << "" drop repetitions = "" << ptrSettings->dropRepetitions(); 863 << Endl;; 864 }; 865 ; 866 int idx = 0;; 867 for (auto f : dropConfig) {; 868 Log () << kINFO << "" Layer "" << idx << "" = "" << f << Endl;; 869 ++idx;; 870 }; 871 Log () << kINFO << Endl;; 872 ; 873 DNN::Steepest minimizer(ptrSettings->learningRate(),; 874 ptrSettings->momentum(),; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:30289,learn,learningRate,30289,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['learn'],['learningRate']
Usability,"nition at line 224 of file GeneralLayer.h. ◆ SetWidth(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetWidth ; (; size_t ; width). inline . Definition at line 223 of file GeneralLayer.h. ◆ Update(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::Update ; (; const Scalar_t ; learningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:25923,learn,learningRate,25923,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learningRate']
Usability,"nition at line 328 of file TTreeProcessorMT.cxx. ◆ GetTasksPerWorkerHint(). unsigned int TTreeProcessorMT::GetTasksPerWorkerHint ; (; ). static . Retrieve the current value for the desired number of tasks per worker. ; ReturnsThe desired number of tasks to be created per worker. TTreeProcessorMT uses this value as an hint. ; Definition at line 528 of file TTreeProcessorMT.cxx. ◆ Process(). void TTreeProcessorMT::Process ; (; std::function< void(TTreeReader &)> ; func). Process the entries of a TTree in parallel. ; The user-provided function receives a TTreeReader which can be used to iterate on a subrange of entries TTreeProcessorMT::Process([](TTreeReader& readerSubRange) {; // Select branches to read; while (readerSubRange.Next()) {; // Use content of current entry; }; });; ROOT::TTreeProcessorMT::Processvoid Process(std::function< void(TTreeReader &)> func)Process the entries of a TTree in parallel.Definition TTreeProcessorMT.cxx:454; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:44; TTreeReader::Nextbool Next()Move to the next entry (or index of the TEntryList if that is set).Definition TTreeReader.h:209; The user needs to be aware that each of the subranges can potentially be processed in parallel. This means that the code of the user function should be thread safe.; Parameters. [in]funcUser-defined function that processes a subrange of entries . Definition at line 454 of file TTreeProcessorMT.cxx. ◆ SetTasksPerWorkerHint(). void TTreeProcessorMT::SetTasksPerWorkerHint ; (; unsigned int ; tasksPerWorkerHint). static . Set the hint for the desired number of tasks created per worker. ; Parameters. [in]tasksPerWorkerHintDesired number of tasks per worker. This allows to create a reasonable number of tasks even if any of the processed files features a bad clustering, for example with a lot of entries and just a few entries per cluster, or to limit the number of tasks spawned when ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMT.html:6208,simpl,simple,6208,doc/v632/classROOT_1_1TTreeProcessorMT.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMT.html,1,['simpl'],['simple']
Usability,"nition at line 330 of file TTreeProcessorMT.cxx. ◆ GetTasksPerWorkerHint(). unsigned int TTreeProcessorMT::GetTasksPerWorkerHint ; (; ). static . Retrieve the current value for the desired number of tasks per worker. ; ReturnsThe desired number of tasks to be created per worker. TTreeProcessorMT uses this value as an hint. ; Definition at line 535 of file TTreeProcessorMT.cxx. ◆ Process(). void TTreeProcessorMT::Process ; (; std::function< void(TTreeReader &)> ; func). Process the entries of a TTree in parallel. ; The user-provided function receives a TTreeReader which can be used to iterate on a subrange of entries TTreeProcessorMT::Process([](TTreeReader& readerSubRange) {; // Select branches to read; while (readerSubRange.Next()) {; // Use content of current entry; }; });; ROOT::TTreeProcessorMT::Processvoid Process(std::function< void(TTreeReader &)> func)Process the entries of a TTree in parallel.Definition TTreeProcessorMT.cxx:460; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeReader::Nextbool Next()Move to the next entry (or index of the TEntryList if that is set).Definition TTreeReader.h:216; The user needs to be aware that each of the subranges can potentially be processed in parallel. This means that the code of the user function should be thread safe.; Parameters. [in]funcUser-defined function that processes a subrange of entries . Definition at line 460 of file TTreeProcessorMT.cxx. ◆ SetTasksPerWorkerHint(). void TTreeProcessorMT::SetTasksPerWorkerHint ; (; unsigned int ; tasksPerWorkerHint). static . Set the hint for the desired number of tasks created per worker. ; Parameters. [in]tasksPerWorkerHintDesired number of tasks per worker. This allows to create a reasonable number of tasks even if any of the processed files features a bad clustering, for example with a lot of entries and just a few entries per cluster, or to limit the number of tasks spawned when ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TTreeProcessorMT.html:6575,simpl,simple,6575,doc/master/classROOT_1_1TTreeProcessorMT.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TTreeProcessorMT.html,1,['simpl'],['simple']
Usability,"nition at line 460 of file RGeomData.cxx. ◆ BuildDescription(). void RGeomDescription::BuildDescription ; (; TGeoNode * ; topnode, . TGeoVolume * ; topvolume . ). private . Build geometry description. ; Definition at line 494 of file RGeomData.cxx. ◆ ChangeConfiguration(). bool RGeomDescription::ChangeConfiguration ; (; const std::string & ; json). Change configuration by client Returns true if any parameter was really changed. ; Definition at line 2105 of file RGeomData.cxx. ◆ ChangeNodeVisibility(). bool RGeomDescription::ChangeNodeVisibility ; (; const std::vector< std::string > & ; path, . bool ; on . ). Change visibility for specified element Returns true if changes was performed. ; Definition at line 1850 of file RGeomData.cxx. ◆ ClearAllPhysVisibility(). bool RGeomDescription::ClearAllPhysVisibility ; (; ). Reset all custom visibility settings. ; Definition at line 2089 of file RGeomData.cxx. ◆ ClearCache(). void RGeomDescription::ClearCache ; (; ). Clear cached data, need to be clear when connection broken. ; Definition at line 1381 of file RGeomData.cxx. ◆ ClearDescription(). void RGeomDescription::ClearDescription ; (; ). private . Clear geometry description. ; Definition at line 478 of file RGeomData.cxx. ◆ ClearDrawData(). void RGeomDescription::ClearDrawData ; (; ). Clear raw data. Will be rebuild when next connection will be established. ; Definition at line 1370 of file RGeomData.cxx. ◆ ClearPhysNodeVisibility(). bool RGeomDescription::ClearPhysNodeVisibility ; (; const std::vector< std::string > & ; path). Reset custom visibility of physical node by path. ; Definition at line 2065 of file RGeomData.cxx. ◆ CollectNodes(). void RGeomDescription::CollectNodes ; (; RGeomDrawing & ; drawing, . bool ; all_nodes = false . ). private . Collect nodes which are used in visibles. ; Definition at line 721 of file RGeomData.cxx. ◆ CopyMaterialProperties(). void RGeomDescription::CopyMaterialProperties ; (; TGeoVolume * ; vol, . RGeomNode & ; node . ). private . C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:12786,clear,clear,12786,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['clear'],['clear']
Usability,"nition at line 552 of file TGTextEntry.cxx. ◆ SetInsertMode(). void TGTextEntry::SetInsertMode ; (; EInsertMode ; mode = kInsert). virtual . Sets the mode how characters are entered to the text entry. ; Definition at line 596 of file TGTextEntry.cxx. ◆ SetMaxLength(). void TGTextEntry::SetMaxLength ; (; Int_t ; maxlen). virtual . Set the maximum length of the text in the editor. ; If the text is currently too long, it is chopped off at the limit. Any marked text will be unmarked. The cursor position is set to 0 and the first part of the string is shown. See also GetMaxLength(). ; Definition at line 636 of file TGTextEntry.cxx. ◆ SetState(). void TGTextEntry::SetState ; (; Bool_t ; state). virtual . Set state of widget. If kTRUE=enabled, kFALSE=disabled. ; Reimplemented in TGNumberEntryField.; Definition at line 498 of file TGTextEntry.cxx. ◆ SetText(). void TGTextEntry::SetText ; (; const char * ; text, . Bool_t ; emit = kTRUE . ). virtual . Sets text entry to text, clears the selection and moves the cursor to the end of the line. ; If necessary the text is truncated to fit MaxLength(). See also GetText(). ; Reimplemented in TGNumberEntryField.; Definition at line 611 of file TGTextEntry.cxx. ◆ SetTextColor() [1/2]. void TGTextEntry::SetTextColor ; (; Pixel_t ; color, . Bool_t ; local = kTRUE . ). virtual . Changes text color. ; If local is true color is changed locally. ; Definition at line 1761 of file TGTextEntry.cxx. ◆ SetTextColor() [2/2]. void TGTextEntry::SetTextColor ; (; TColor * ; color, . Bool_t ; local = kTRUE . ). virtual . Changes text color. ; If local is true color is changed locally. ; Definition at line 1777 of file TGTextEntry.cxx. ◆ SetTitle(). virtual void TGTextEntry::SetTitle ; (; const char * ; label). inlinevirtual . Definition at line 155 of file TGTextEntry.h. ◆ SetToolTipText(). void TGTextEntry::SetToolTipText ; (; const char * ; text, . Long_t ; delayms = 500 . ). virtual . Set tool tip text associated with this text entry. ; The delay i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEntry.html:65187,clear,clears,65187,doc/master/classTGTextEntry.html,https://root.cern,https://root.cern/doc/master/classTGTextEntry.html,1,['clear'],['clears']
Usability,"nition at line 61 of file RooUniform.cxx. ◆ getGenerator(). Int_t RooUniform::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Advertise internal generator. ; Reimplemented from RooAbsPdf.; Definition at line 107 of file RooUniform.cxx. ◆ IsA(). TClass * RooUniform::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 50 of file RooUniform.h. ◆ Streamer(). void RooUniform::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooUniform::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 50 of file RooUniform.h. ◆ translate(). void RooUniform::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 53 of file RooUniform.cxx. Member Data Documentation. ◆ x. RooListProxy RooUniform::x. protected . Definition at line 43 of file RooUniform.h. Libraries for RooUniform:. [legend]; The documentation for this class was generated from the following files:; roofit/roofit/inc/RooUniform.h; roofit/roofit/src/RooUniform.cxx. RooUniform. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:11 (GVA Time) using Doxygen 1.9.8 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUniform.html:76775,simpl,simple,76775,doc/master/classRooUniform.html,https://root.cern,https://root.cern/doc/master/classRooUniform.html,1,['simpl'],['simple']
Usability,"niz Gunceler, Danilo Piparo; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#include ""TH2Poly.h""; 14#include ""TMultiGraph.h""; 15#include ""TGraph.h""; 16#include ""TInterpreter.h""; 17#include ""Riostream.h""; 18#include ""TList.h""; 19#include ""TMath.h""; 20#include <cassert>; 21 ; 22ClassImp(TH2Poly);; 23 ; 24/** \class TH2Poly; 25 \ingroup Histograms; 262D Histogram with Polygonal Bins; 27 ; 28## Overview; 29`TH2Poly` is a 2D Histogram class (TH2) allowing to define polygonal; 30bins of arbitrary shape.; 31 ; 32Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; 33`TH2PolyBin` is a very simple class containing the vertices (stored; 34as `TGraph`s or `TMultiGraph`s ) and contents of the polygonal; 35bin as well as several related functions.; 36 ; 37Essentially, a `TH2Poly` is a TList of `TH2PolyBin` objects; 38with methods to manipulate them.; 39 ; 40Bins are defined using one of the `AddBin()` methods. The bin definition; 41should be done before filling.; 42 ; 43The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w); 44`. `w` is the weight.; 45If no weight is specified, it is assumed to be 1.; 46 ; 47Not all histogram's area need to be binned. Filling an area without bins,; 48will falls into the overflows. Adding a bin is not retroactive; it doesn't; 49affect previous fillings. A `Fill()` call, that; 50was previously ignored due to the lack of a bin at the specified location, is; 51not reconsidered when that location is binned later.; 52 ; 53If there are two overlapping bins, the first one in the list will be incremented; 54by `Fill()`.; 55 ; 56The histogram may automatically extends its limits if a bin outside",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:1186,simpl,simple,1186,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['simpl'],['simple']
Usability,"nkenFrame); virtual~TGShutter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddItem(TGShutterItem* item); virtual TGShutterItem*AddPage(const char* item = ""Page"")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGShutter.html:1589,Clear,Clear,1589,root/html532/TGShutter.html,https://root.cern,https://root.cern/root/html532/TGShutter.html,2,['Clear'],['Clear']
Usability,"nkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:51859,simpl,simplex,51859,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,10,['simpl'],['simplex']
Usability,"nline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t nrows, const double* data) const; { return Use(0,nrows-1,data); }. template <class Element> inline TMatrixTSym<Element> &TMatrixTSym<Element> Use(TMatrixTSym<double>& a); { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(const TMatrixTSym<double>& a) const; { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline TMatrixTSym<Element> TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixTSym<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixTSym<Element> operator()(Int_t rown, Int_t coln). void Mult(const TMatrixTSym<double>& a); { TMult(a); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). Bool_t IsSymmetric() const; { return kTRUE; }. TMatrixTSym <Element> & Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id$ » Last generated: 2015-03-14 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixTSym_double_.html:22537,Clear,Clear,22537,root/html534/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html,1,['Clear'],['Clear']
Usability,"nline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t nrows, const double* data) const; { return Use(0,nrows-1,data); }. template <class Element> inline TMatrixTSym<Element> &TMatrixTSym<Element> Use(TMatrixTSym<double>& a); { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(const TMatrixTSym<double>& a) const; { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline TMatrixTSym<Element> TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixTSym<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixTSym<Element> operator()(Int_t rown, Int_t coln). void Mult(const TMatrixTSym<double>& a); { TMult(a); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). Bool_t IsSymmetric() const; { return kTRUE; }. TMatrixTSym <Element> & Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMatrixTSym_double_.html:23488,Clear,Clear,23488,root/html604/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html,1,['Clear'],['Clear']
Usability,"nline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t nrows, const double* data) const; { return Use(0,nrows-1,data); }. template <class Element> inline TMatrixTSym<Element> &TMatrixTSym<Element> Use(TMatrixTSym<double>& a); { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(const TMatrixTSym<double>& a) const; { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline TMatrixTSym<Element> TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixTSym<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixTSym<Element> operator()(Int_t rown, Int_t coln). void Mult(const TMatrixTSym<double>& a); { TMult(a); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). Bool_t IsSymmetric() const; { return kTRUE; }. TMatrixTSym <Element> & Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id$ » Last generated: 2015-06-30 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSym_double_.html:23440,Clear,Clear,23440,root/html602/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSym_double_.html,1,['Clear'],['Clear']
Usability,"nmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGDockButton::DrawBorder(); virtual voidTGButton::EmitSignals(Bool_t wasUp); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTGWindow::kEditDisableGrab; stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDockHideButton.html:15522,Clear,ClearFlags,15522,root/html602/TGDockHideButton.html,https://root.cern,https://root.cern/root/html602/TGDockHideButton.html,2,['Clear'],['ClearFlags']
Usability,"nmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGTextButton::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGButton::EmitSignals(Bool_t wasUp); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTGTextButton::Init(); voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TEveGedNameTextButton&operator=(const TEveGedNameTextButton&); TEveGedNameTextButton(const TEveGedNameTextButton&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveGedNameTextButton.html:16445,Clear,ClearFlags,16445,root/html602/TEveGedNameTextButton.html,https://root.cern,https://root.cern/root/html602/TEveGedNameTextButton.html,2,['Clear'],['ClearFlags']
Usability,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualViewer3D* Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); Create a Viewer 3D of specified type. virtual ~TVirtualViewer3D(); {}. Bool_t PreferLocalFrame() const; Viewers must always handle master (absolute) positions - and; buffer producers must be able to supply them. Some viewers may; prefer local frame & translation - and producers can optionally; supply them. Bool_t CanLoopOnPrimitives() const; Viewers can implement their own loop over pad's primitive list. { return kFALSE; }. void PadPaint(TVirtualPad* ); When they can, TPad::Paint() and TPad::PaintModified() simply; call the following function:. {}. void ObjectPaint(TObject* , Option_t* = """"); {}. void BeginScene(); Addition/removal of objects must occur between Begin/EndUpdate calls. Bool_t BuildingScene() const. void EndScene(). Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Simple object addition - buffer represents a unique single positioned object. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Complex object addition - for adding physical objects which have common logical; shapes. In this case buffer describes template shape (aside from kCore). Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0). void CloseComposite(). void AddCompositeOp(UInt_t operation). TObject * SelectObject(Int_t , Int_t ); {return 0;}. void DrawViewer(); {}. void PrintObjects(); {}. void ResetCameras(); {}. void ResetCamerasAfterNextUpdate(); {}. » Author: Olivier Couet 05/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualViewer3D.html:17703,Simpl,Simple,17703,root/html534/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html534/TVirtualViewer3D.html,1,['Simpl'],['Simple']
Usability,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAllowDirectiveswhether directives are to be interpreted; Bool_tfCheckForMethodwhether to check the current line for a method; TStringfClassDescrTagtag for finding the class description; enum TDocParser::fClassDocStatewhether we found the class description; TStringfCommentcurrent comment; Bool_tfCommentAtBOLat the beginning of the current line, fParseContext contained kComment; TClass*fCurrentClasscurrent class context of sources being parsed; TStringfCurrentFilecurrent source / header file name; TStringfCurrentMethodTagname_idx of the currently parsed method; TStringfCurrentModulecurrent module context of sources being parsed; TListfDataMembers[6]data members (by access, plus enums); Int_tfDirectiveCountindex of directive for current method; TListfDirectiveHandlershandler for doc directives (TDocDirective objects); TDocParser::EDocContextfDocContextcurrent context of parsed sources for documenting; TDocOutput*fDocOutputTDocOutput invoking us; set<UInt_t>fExtraLinesWithAnchorlines that need an additional anchor; TStringfFirstClassDocfirst class-doc found - per file, taken if fLastClassDoc is empty; THtml*fHtmlTHtml object using us; TStringfLastClassDoclast class-doc found - becomes class doc at ClassImp or first method; TStringfLineCommentcurrent line with links and directives for doc; UInt_tfLineNocurrent line number; Long_tfLineNumbersource line number; TStringfLineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<std::string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocParser.html:10254,undo,undocumented,10254,root/html528/TDocParser.html,https://root.cern,https://root.cern/root/html528/TDocParser.html,4,['undo'],['undocumented']
Usability,"nning ;  fillrandom.C Fill a 1-D histogram from a parametric function ;  fillrandom.py Fill a 1-D histogram from a parametric function ;  FirstContour.C Make a contour plot and get the first contour in a TPolyMarker ;  h1draw.C 1-D histogram drawing options ;  h2proj.C;  hbars.C Example of bar charts with 1-d histograms ;  histpalettecolor.C Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  hksimple.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:123162,simpl,simple,123162,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"nning the hypothesis test results of a HypoTestCalculator for various values of the parameter of interest. More...;  ; class  HypoTestInverterPlot;  Class to plot a HypoTestInverterResult, the output of the HypoTestInverter calculator. More...;  ; class  HypoTestInverterResult;  HypoTestInverterResult class holds the array of hypothesis test results and compute a confidence interval. More...;  ; class  HypoTestPlot;  This class provides the plots for the result of a study performed with any of the HypoTestCalculatorGeneric (e.g. More...;  ; class  HypoTestResult;  HypoTestResult is a base class for results from hypothesis tests. More...;  ; class  IntervalCalculator;  IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. More...;  ; struct  LikelihoodFunction;  ; class  LikelihoodInterval;  LikelihoodInterval is a concrete implementation of the RooStats::ConfInterval interface. More...;  ; class  LikelihoodIntervalPlot;  This class provides simple and straightforward utilities to plot a LikelihoodInterval object. More...;  ; class  MarkovChain;  Stores the steps in a Markov Chain of points. More...;  ; class  MaxLikelihoodEstimateTestStat;  MaxLikelihoodEstimateTestStat: TestStatistic that returns maximum likelihood estimate of a specified parameter. More...;  ; class  MCMCCalculator;  Bayesian Calculator estimating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function. More...;  ; class  MCMCInterval;  MCMCInterval is a concrete implementation of the RooStats::ConfInterval interface. More...;  ; class  MCMCIntervalPlot;  This class provides simple and straightforward utilities to plot a MCMCInterval object. More...;  ; class  MetropolisHastings;  This class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo. More...;  ; class  MinNLLTestStat;  MinNLLTestStat is an implementati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:3744,simpl,simple,3744,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['simpl'],['simple']
Usability,"nnotation via picking. ;  ; void DoASavImageGUIBaseName (const char *t);  Update base-name. ;  ; void DoASavImageGUIOutMode (Int_t m);  Update output mode. ;  ; void DoASavImageStart ();  Start auto-rotator image auto-save. ;  ; void DoASavImageStop ();  Stop auto-rotator image auto-save. ;  ; void DoCameraCenterExt ();  Set external camera center. ;  ; void DoCameraHome ();  CameraHome was clicked. ;  ; void DoCameraOverlay ();  Update viewer with GUI state. ;  ; void DoCaptureCenter ();  Capture camera-center via picking. ;  ; void DoClearColor (Pixel_t color);  Clear-color was changed. ;  ; void DoDrawCameraCenter ();  Draw camera center. ;  ; void DoIgnoreSizesOnUpdate ();  ResetCamerasOnUpdate was toggled. ;  ; void DoResetCamerasOnUpdate ();  ResetCamerasOnUpdate was toggled. ;  ; void DoRotatorStart ();  Start auto-rotator. ;  ; void DoRotatorStop ();  Stop auto-rotator. ;  ; void DoUpdateScene ();  UpdateScene was clicked. ;  ; TClass * IsA () const override;  ; void SetGuides ();  Configuration of guides GUI called from SetModel(). ;  ; void SetModel (TObject *obj) override;  Sets model or disables/hides viewer. ;  ; void SetRotatorMode ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateCameraCenter ();  Update current camera with GUI state. ;  ; void UpdateMaxDrawTimes ();  Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. ;  ; void UpdatePointLineStuff ();  Slot for point-sizes and line-widths. ;  ; void UpdateRotator ();  Update rotator related variables. ;  ; void UpdateStereo ();  Update stereo related variables. ;  ; void UpdateViewerAxes (Int_t id);  Update viewer with GUI state. ;  ; void UpdateViewerReference ();  Update viewer with GUI state. ;  ; virtual void ViewerRedraw ();  Initiate redraw of the viewer. ;  ;  Public Member Functions inherited from TGedFrame;  TGedFrame (const TGWindow *p=nullptr, Int_t width=140, Int_t height=30, U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewerEditor.html:1722,guid,guides,1722,doc/master/classTGLViewerEditor.html,https://root.cern,https://root.cern/doc/master/classTGLViewerEditor.html,1,['guid'],['guides']
Usability,"node, const char *name, Matrix_t &matrix);  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Static Protected Member Functions; static size_t CalculateNormDim (int axis, size_t c, size_t h, size_t w);  . Private Attributes; Tensor_t fDerivatives;  First fDerivatives of the activations of this layer. ;  ; TDescriptors * fDescriptors = nullptr;  ; Scalar_t fEpsilon;  ; Matrix_t fIVar;  ; Scalar_t fMomentum;  The weight decay. ;  ; Matrix_t fMu;  ; Matrix_t fMu_Training;  ; int fNormAxis;  Normalization axis. For each element of this axis we will compute mean and stddev. ;  ; Tensor_t fReshapedData;  ; int fTrai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html:7819,learn,learningRate,7819,doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGGroupFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGGroupFrame.html:2759,Clear,Clear,2759,root/html532/TGGroupFrame.html,https://root.cern,https://root.cern/root/html532/TGGroupFrame.html,2,['Clear'],['Clear']
Usability,"norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); Create progress bar. void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). TGProgressBar(const TGWindow* p, UInt_t w, UInt_t h, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); { }. Float_t GetMin() const; { return fMin; }. Float_t GetMax() const; { return fMax; }. Float_t GetPosition() const; { return fPos; }. EFillType GetFillType() const; { return fFillType; }. EBarType GetBarType() const; { return fBarType; }. Bool_t GetShowPos() const; { return fShowPos; }. TString GetFormat() const; { return fFormat; }. const char* GetValueFormat() const; { return fFormat.Data(); }. Bool_t UsePercent() const; { return fPercent; }. Pixel_t GetBarColor() const; { return fBarColorGC.GetForeground(); }. GContext_t GetNormGC() const; { return fNormGC; }. FontStruct_t GetFontStruct() const; { ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGProgressBar.html:21643,progress bar,progress bar,21643,root/html602/TGProgressBar.html,https://root.cern,https://root.cern/root/html602/TGProgressBar.html,4,['progress bar'],['progress bar']
Usability,"nputFrame(TGWindow* parent, Int_t w, Int_t h); virtual~TSessionInputFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); voidAddObject(TObject* obj); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(TSessionViewer* gui); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionInputFrame.html:1501,Clear,Clear,1501,root/html532/TSessionInputFrame.html,https://root.cern,https://root.cern/root/html532/TSessionInputFrame.html,2,['Clear'],['Clear']
Usability,"ns in C++;; -- Return results to python for processing, ploting, etc;; -- Run entire plot making code in python for stacking, labeling, etc.; Granted, this is probably a more complex approach than most of us in physics are willing to tolerate. I suspect that you do not have much choice since the user community wants CINT-like functionality from ROOT (and one feature of the ROOT project that makes it great is a full consideration of what experiments and users need for data taking and analysis).; Thanks for the interesting discussion! I have learned quite a bit about ROOT plans and it all seems very promising. Cheers!. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:52 Permalink . Dependency on Python . In my experience, getting python scripts to work is a very unreliable affair. They almost always have dependencies on external packages and if you don't have EXACTLY the same version of python you only have about a 50% chance that anything you use will work. The language is simply not stable. C++ is bad enough. Scripting languages are much, much worse. The maintainers think the language is their playtoy and they take no responsibility to maintain backward compatibility from release to release. Python is just a Bad Idea(tm). Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:52 Permalink . CINT need to be communitized, that's the whole problem . Indeed, for decade, Cint never made it to open-source because of ROOT dependencies and backward compatiblities. Now that I am seeing this arguement is no more, and we are going to dig up some old grave.. I don't see why Cint shouldn't be taking over by open source or boost. I don't see how we are going to leverage on Clang/Cling at all... all I am seeing is regression session will be made at a far higher degree. I ""plussoie"" Renee's point, mixing technologies is a very , veRY, VERY bad idea. Mostly because Python isn't an ISO standard like many others langage. We should stick to C++ ISO and that's all we ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:19015,simpl,simply,19015,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simply']
Usability,"ns that the axis; syetem should be define (option ""A"") and that the graph should; be drawn as a simple line (option ""L""). By default a graph is drawn; in the current pad in the current coordinates system. To define a suitable; coordinates system and drawn the axis the option ""A"" must be; specified. TGraphPainter offers many options to paint the various kind of graphs. The TGraphPainter class specializes in the drawing of graphs. It is; separated from the graph so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is not need to call the; Draw() method again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. ""A""; Axis are drawn around the graph. ""L""; A simple polyline between every points is drawn. ""F""; A fill area is drawn ('CF' draw a smooth fill area). ""C""; A smooth Curve is drawn. ""*""; A Star is plotted at each point. ""P""; Idem with the current marker. ""B""; A Bar chart is drawn at each point. ""1""; ylow=rwymin. ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Several drawing options can be combined. In the following example the graph; is drawn as a smooth curve (option ""C"") and with markers (option ""P""). The; option ""A"" request the definition of the axis. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",200,10,600,400);. c1->SetFillColor(42);; c1->SetGrid();. const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; gr = new TGraph(n,x,y);; gr->SetLineColor(2);; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerSize(1.5);; gr->SetMarkerStyle(21);; gr->SetTitle(""Option ACP example"");; gr->GetXaxis()->SetTitle(""X title",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:1802,simpl,simple,1802,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,2,['simpl'],['simple']
Usability,"ns |; Private Types |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Internal::TExecutor Class Reference. ; This class implements the interface to execute the same task multiple times, sequentially or in parallel depending on the execution policy passed as a first parameter on construction, and possibly with different arguments every time. . ROOT::Internal::TExecutor::Map; The two possible usages of the Map method are:. Map(F func, unsigned nTimes): func is executed nTimes with no arguments; Map(F func, T& args): func is executed on each element of the collection of arguments args. For either signature, func is executed as many times as needed by a pool of n workers; where n tipically defaults to the number of cores.; A collection containing the result of each execution is returned.; Note: the user is responsible for the deletion of any object that might be created upon execution of func, returned objects included. ROOT::::Internal::TExecutor never deletes what it returns, it simply forgets it.; Parameters. funca callable object, such as a lambda expression, an std::function, a functor object or a function that takes zero arguments (for the first signature) or one (for the second signature). ; argsa standard vector, a ROOT::TSeq of integer type or an initializer list for the second signature. An integer only for the first. Note: in cases where the function to be executed takes more than zero/one argument but all are fixed except zero/one, the function can be wrapped in a lambda or via std::bind to give it the right signature.; Return value:; An std::vector. The elements in the container will be the objects returned by func. ROOT::Internal::TExecutor::MapReduce; This set of methods behaves exactly like Map, but takes an additional function as a third argument. This function is applied to the set of objects returned by the corresponding Map execution to ""squash"" them into a single object. The signature of the reduce function should be (c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html:1209,simpl,simply,1209,doc/v632/classROOT_1_1Internal_1_1TExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html,2,['simpl'],['simply']
Usability,"ns: double sized border, white background and a bit wider to allow for text to be printed in the bar. ; Definition at line 238 of file TGProgressBar.cxx. ◆ ~TGHProgressBar(). TGHProgressBar::~TGHProgressBar ; (; ). inlineoverride . Definition at line 108 of file TGProgressBar.h. Member Function Documentation. ◆ Class(). static TClass * TGHProgressBar::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGHProgressBar::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGHProgressBar::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 118 of file TGProgressBar.h. ◆ DeclFileName(). static const char * TGHProgressBar::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 118 of file TGProgressBar.h. ◆ DoRedraw(). void TGHProgressBar::DoRedraw ; (; ). overrideprotectedvirtual . Draw horizontal progress bar. ; Implements TGProgressBar.; Definition at line 265 of file TGProgressBar.cxx. ◆ GetDefaultSize(). TGDimension TGHProgressBar::GetDefaultSize ; (; ); const. inlineoverridevirtual . std::cout << fWidth << ""x"" << fHeight << std::endl; ; Reimplemented from TGFrame.; Definition at line 110 of file TGProgressBar.h. ◆ IsA(). TClass * TGHProgressBar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGFrame.; Definition at line 118 of file TGProgressBar.h. ◆ SavePrimitive(). void TGHProgressBar::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a horizontal progress bar as a C++ statement(s) on output stream out. ; Reimplemented from TGFrame.; Definition at line 464 of file TGProgressBar.cxx. ◆ ShowPosition(). void TGHProgressBar::ShowPosition ; (; Bool_t ; set = kTRUE, . Bool_t ; percent = kTRUE, . const char * ; format = ""%.2f"" . ). Show postion text, either in percent or form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:33104,progress bar,progress bar,33104,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"ns;  CrossValidation (TString jobName, TMVA::DataLoader *dataloader, TFile *outputFile, TString options);  ;  CrossValidation (TString jobName, TMVA::DataLoader *dataloader, TString options);  ;  ~CrossValidation ();  ; void Evaluate ();  Does training, test set evaluation and performance evaluation of using cross-evalution. ;  ; Factory & GetFactory ();  ; UInt_t GetNumFolds ();  ; const std::vector< CrossValidationResult > & GetResults () const;  ; TString GetSplitExpr ();  ; void InitOptions ();  ; virtual TClass * IsA () const;  ; void ParseOptions ();  Method to parse the internal option string. ;  ; void SetNumFolds (UInt_t i);  ; void SetSplitExpr (TString splitExpr);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLoader ();  Method to get the pointer to TMVA::DataLoader object. ;  ; TFile * GetFile ();  Method to get the pointer to TFile object. ;  ; std::vector< OptionMap > & GetMethods ();  Method get the Booked methods in a option map object. ;  ; Bool_t HasMethod (TString methodname, TString methodtitle);  function to check methods booked ;  ; Bool_t IsModelPersistence ();  Method to see if the algorithm model is saved in xml or serialized files. ;  ; Bool_t IsSilentFile ();  Method to see if a file is available to save results. ;  ; Bool_t IsVerbose ();  Method to see if the algorithm should print extra information. ;  ; void SetDataLoader (DataLoader *dalaloader);  Method to set the pointer to TMVA::DataLoader object. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html:2199,learn,learning,2199,doc/master/classTMVA_1_1CrossValidation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html,1,['learn'],['learning']
Usability,"nset = 0, Bool_t clipInvalid = kFALSE) const; static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:3087,clear,clearValueDirty,3087,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,1,['clear'],['clearValueDirty']
Usability,"nset, . const char * ; rangeName, . int & ; code . ); const. protected . Retrieve object representing projection integral of input p.d.f over observables iset, while normalizing over observables nset. ; The code argument returned by reference is the unique code defining this particular projection configuration ; Definition at line 109 of file RooProjectedPdf.cxx. ◆ initGenerator(). void RooProjectedPdf::initGenerator ; (; Int_t ; code). inlineoverridevirtual . Interface for one-time initialization to setup the generator for the specified code. ; Reimplemented from RooAbsPdf.; Definition at line 34 of file RooProjectedPdf.h. ◆ IsA(). TClass * RooProjectedPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 73 of file RooProjectedPdf.h. ◆ printMetaArgs(). void RooProjectedPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the integration operation. ; Reimplemented from RooAbsArg.; Definition at line 254 of file RooProjectedPdf.cxx. ◆ redirectServersHook(). bool RooProjectedPdf::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Intercept a server redirection all and update list of dependents if necessary Specifically update the set proxy 'deps' which introduces the dependency on server value dirty flags of ourselves. ; Reimplemented from RooAbsPdf.; Definition at line 211 of file RooProjectedPdf.cxx. ◆ selfNormalized(). bool RooProjectedPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 36 of file RooProjectedPdf.h. ◆ Streamer(). void Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:80025,intuit,intuitively,80025,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"nsion] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight); static TSelectorDraw::(anonymous)kWarn. Class Charts. Inheritance Chart:. TObject. ←; TSelector. ←; TSelectorDraw. ←. TEvePointSelector. TEveSelectorToEventList. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Return the last values corresponding to the i-th component; of the formula being processed (where the component are ':' separated).; The actual number of entries is:; GetSelectedRows() % tree->GetEstimate(); Note GetSelectedRows currently returns the actual number of values plotted; and thus if the formula contains arrays, this number might be greater than; the number of entries in the trees.; By default TTree::Draw creates the arrays obtained; with all GetVal and GetW with a length corresponding to the; parameter fEstimate. By default fEstimate=10000 and can be modified; via TTree::SetEstim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelectorDraw.html:10506,simpl,simplest,10506,root/html602/TSelectorDraw.html,https://root.cern,https://root.cern/root/html602/TSelectorDraw.html,4,['simpl'],['simplest']
Usability,"nsional array; TNDArrayT<float> N-dimensional array; TNDArrayT<int> N-dimensional array; TNDArrayT<long> N-dimensional array; TNDArrayT<short> N-dimensional array; TNDArrayT<unsigned int> N-dimensional array; TNDArrayT<unsigned long> N-dimensional array; TNDArrayT<unsigned short> N-dimensional array; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetFileStager Implementation for a 'rootd' backend; TNetSystem Directory handler for NetSystem; TNetXNGFile ROOT class definition; TNetXNGFileStager ! Interface to a 'XRD' staging; TNetXNGSystem ROOT class definition; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObjectSpy Spy object pointer for deletion; TObjectTable Table of active objects; TOptionListItem Element in the list of options.; TOrdCollection An ordered collection; TOrdCollectionIter Ordered collection iterator; TOutputListSelectorDataMap Converter from output list to TSelector data members; TPARA PARA shape; TPBHandleDSType Streamable PBHandleDSType; TPBHistType Streamable PBHistType; TPBReadType Streamable PBReadType; TPCON PCON shape; TPDF PDF driver; TPGON PGON shape; TPMERegexp Wrapper for Perl-like regular expression matching.; TPRegexp Perl Compatible Regular Expression Class; TPServerSocket Parallel server socket; TPSocket Parallel client socket; TPackageDescription Package description; TPacketizer Generate work pac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:110894,simpl,simple,110894,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,['simpl'],['simple']
Usability,"nsional array; TNDArrayT<float> N-dimensional array; TNDArrayT<int> N-dimensional array; TNDArrayT<long> N-dimensional array; TNDArrayT<short> N-dimensional array; TNDArrayT<unsigned int> N-dimensional array; TNDArrayT<unsigned long> N-dimensional array; TNDArrayT<unsigned short> N-dimensional array; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetFileStager Implementation for a 'rootd' backend; TNetSystem Directory handler for NetSystem; TNetXNGFile ROOT class definition; TNetXNGFileStager ! Interface to a 'XRD' staging; TNetXNGSystem ROOT class definition; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObjectSpy Spy object pointer for deletion; TObjectTable Table of active objects; TOrdCollection An ordered collection; TOrdCollectionIter Ordered collection iterator; TOutputListSelectorDataMap Converter from output list to TSelector data members; TPARA PARA shape; TPBHandleDSType Streamable PBHandleDSType; TPBHistType Streamable PBHistType; TPBReadType Streamable PBReadType; TPCON PCON shape; TPDF PDF driver; TPGON PGON shape; TPMERegexp Wrapper for Perl-like regular expression matching.; TPRegexp Perl Compatible Regular Expression Class; TPServerSocket Parallel server socket; TPSocket Parallel client socket; TPackageDescription Package description; TPacketizer Generate work packets for parallel processing; TPacketizerAdaptive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:117089,simpl,simple,117089,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['simpl'],['simple']
Usability,"nsional general purpose Monte Carlo event generator (integrator) with hyper-cubical ""foam of cells"". Certain features of full version of FOAM are omitted. mFOAM is intended as an easy to use tool for MC simulation/integration in few dimensions. It relies heavily on ROOT package, borrowing persistency of classes from ROOT. mFOAM can be easily used from the ROOT shell. For more difficult problems the full FOAM may be better. How to run application programs ?; The application program can be run in two modes: it can be simply interpreted by CLING or compiled. The first method is simpler but results in slower execution. The second method employs ACLiC - The Automatic Compiler of Libraries, which automatizes the process of compilation and linking.; In /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials there are 3 demonstration programs:; foam_kanwa.C; is a simple example how to run FOAM in interactive mode. To run this macro issue the following simple command from the Linux shell:; root foam_kanwa.C; or from CLING:; root [0] .x foam_kanwa.C; Simulation will start and graphical canvas with plot of the distribution function appear. In this example we defined the distribution function simply as a global function function Camel2.; foam_demo.C; shows usage of FOAM in compiled mode, which is the preferred method. The integrand function is defined now as a Density method from class TFDISTR inheriting from abstract class TFoamIntegrand. User can modify interface to integrand function according to their needs but they should always remember to define Density method which provides the density distribution. Enter CLING interpreter and type:; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; to load FOAM library, compile and execute macro foam_demo.C. A shared object foam_demo_C.so is created in the current directory. At the end of exploration phase FOAM object including distribution function will be written to disk.; foam_demopers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__FOAM.html:1225,simpl,simple,1225,doc/master/group__tutorial__FOAM.html,https://root.cern,https://root.cern/doc/master/group__tutorial__FOAM.html,1,['simpl'],['simple']
Usability,"nsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFractionFitter.html:17553,simpl,simply,17553,root/html534/TFractionFitter.html,https://root.cern,https://root.cern/root/html534/TFractionFitter.html,2,['simpl'],['simply']
Usability,"nsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:16381,simpl,simply,16381,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,4,['simpl'],['simply']
Usability,"nsive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * If the objects are added using the placement new then the Clear must; deallocate the memory.; * If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); pu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClonesArray.html:3723,Clear,Clear,3723,root/html604/TClonesArray.html,https://root.cern,https://root.cern/root/html604/TClonesArray.html,2,['Clear'],['Clear']
Usability,"nsive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:3723,Clear,Clear,3723,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['Clear'],['Clear']
Usability,"nsive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClonesArray.html:3723,Clear,Clear,3723,root/html602/TClonesArray.html,https://root.cern,https://root.cern/root/html602/TClonesArray.html,2,['Clear'],['Clear']
Usability,"nsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDimdimension of the function to be minimized ; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char* type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. void Clear(); clear resources (parameters) for consecutives minimizations. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__Minuit2Minimizer.html:6293,clear,clear,6293,root/html534/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__Minuit2Minimizer.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,nsparency; }. Bool_t CanEditMainTrans() const; { return fCanEditMainTrans; }. Bool_t HasMainTrans() const; { return fMainTrans != 0; }. TRef& GetSource(); { return fSource; }. TObject* GetSourceObject() const; { return fSource.GetObject(); }. void SetSourceObject(TObject* o). void DumpSourceObject(); // *MENU*; void InspectSourceObject(); // *MENU*. { fSource = o; }. void* GetUserData() const; { return fUserData; }. void SetUserData(void* ud); { fUserData = ud; }. Bool_t IsPickable() const; { return fPickable; }. void SetPickable(Bool_t p); { fPickable = p; }. void SetCSCBits(UChar_t f); { fCSCBits |= f; }. void ResetCSCBits(UChar_t f); { fCSCBits &= ~f; }. Bool_t TestCSCBits(UChar_t f) const; { return (fCSCBits & f) != 0; }. void ResetAllCSCBits(); { fCSCBits = 0; }. void CSCImplySelectAllChildren(); { fCSCBits |= kCSCBImplySelectAllChildren; }. void CSCTakeAnyParentAsMaster(); { fCSCBits |= kCSCBTakeAnyParentAsMaster; }. void CSCApplyMainColorToAllChildren(); { fCSCBits |= kCSCBApplyMainColorToAllChildren; }. void CSCApplyMainColorToMatchingChildren(); { fCSCBits |= kCSCBApplyMainColorToMatchingChildren; }. void CSCApplyMainTransparencyToAllChildren(); { fCSCBits |= kCSCBApplyMainTransparencyToAllChildren; }. void CSCApplyMainTransparencyToMatchingChildren(); { fCSCBits |= kCSCBApplyMainTransparencyToMatchingChildren; }. void StampColorSelection(); { AddStamp(kCBColorSelection); }. void StampTransBBox(); { AddStamp(kCBTransBBox); }. void StampObjProps(); { AddStamp(kCBObjProps); }. void StampVisibility(); void StampElementAdded() { AddStamp(kCBElementAdded); }; void StampElementRemoved() { AddStamp(kCBElementRemoved); }. { AddStamp(kCBVisibility); }. void ClearStamps(); { fChangeBits = 0; }. UChar_t GetChangeBits() const; { return fChangeBits; }. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveElement.html:36896,Clear,ClearStamps,36896,root/html534/TEveElement.html,https://root.cern,https://root.cern/root/html534/TEveElement.html,1,['Clear'],['ClearStamps']
Usability,nsparency; }. Bool_t CanEditMainTrans() const; { return fCanEditMainTrans; }. Bool_t HasMainTrans() const; { return fMainTrans != 0; }. TRef& GetSource(); { return fSource; }. TObject* GetSourceObject() const; { return fSource.GetObject(); }. void SetSourceObject(TObject* o). void DumpSourceObject(); // *MENU*; void InspectSourceObject(); // *MENU*. { fSource = o; }. void* GetUserData() const; { return fUserData; }. void SetUserData(void* ud); { fUserData = ud; }. Bool_t IsPickable() const; { return fPickable; }. void SetPickable(Bool_t p); { fPickable = p; }. void SetCSCBits(UChar_t f); { fCSCBits |= f; }. void ResetCSCBits(UChar_t f); { fCSCBits &= ~f; }. Bool_t TestCSCBits(UChar_t f) const; { return (fCSCBits & f) != 0; }. void ResetAllCSCBits(); { fCSCBits = 0; }. void CSCImplySelectAllChildren(); { fCSCBits |= kCSCBImplySelectAllChildren; }. void CSCTakeAnyParentAsMaster(); { fCSCBits |= kCSCBTakeAnyParentAsMaster; }. void CSCApplyMainColorToAllChildren(); { fCSCBits |= kCSCBApplyMainColorToAllChildren; }. void CSCApplyMainColorToMatchingChildren(); { fCSCBits |= kCSCBApplyMainColorToMatchingChildren; }. void CSCApplyMainTransparencyToAllChildren(); { fCSCBits |= kCSCBApplyMainTransparencyToAllChildren; }. void CSCApplyMainTransparencyToMatchingChildren(); { fCSCBits |= kCSCBApplyMainTransparencyToMatchingChildren; }. void StampColorSelection(); { AddStamp(kCBColorSelection); }. void StampTransBBox(); { AddStamp(kCBTransBBox); }. void StampObjProps(); { AddStamp(kCBObjProps); }. void StampVisibility(); void StampElementAdded() { AddStamp(kCBElementAdded); }; void StampElementRemoved() { AddStamp(kCBElementRemoved); }. { AddStamp(kCBVisibility); }. void ClearStamps(); { fChangeBits = 0; }. UChar_t GetChangeBits() const; { return fChangeBits; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveElement.html:37218,Clear,ClearStamps,37218,root/html604/TEveElement.html,https://root.cern,https://root.cern/root/html604/TEveElement.html,1,['Clear'],['ClearStamps']
Usability,nsparency; }. Bool_t CanEditMainTrans() const; { return fCanEditMainTrans; }. Bool_t HasMainTrans() const; { return fMainTrans != 0; }. TRef& GetSource(); { return fSource; }. TObject* GetSourceObject() const; { return fSource.GetObject(); }. void SetSourceObject(TObject* o). void DumpSourceObject(); // *MENU*; void InspectSourceObject(); // *MENU*. { fSource = o; }. void* GetUserData() const; { return fUserData; }. void SetUserData(void* ud); { fUserData = ud; }. Bool_t IsPickable() const; { return fPickable; }. void SetPickable(Bool_t p); { fPickable = p; }. void SetCSCBits(UChar_t f); { fCSCBits |= f; }. void ResetCSCBits(UChar_t f); { fCSCBits &= ~f; }. Bool_t TestCSCBits(UChar_t f) const; { return (fCSCBits & f) != 0; }. void ResetAllCSCBits(); { fCSCBits = 0; }. void CSCImplySelectAllChildren(); { fCSCBits |= kCSCBImplySelectAllChildren; }. void CSCTakeAnyParentAsMaster(); { fCSCBits |= kCSCBTakeAnyParentAsMaster; }. void CSCApplyMainColorToAllChildren(); { fCSCBits |= kCSCBApplyMainColorToAllChildren; }. void CSCApplyMainColorToMatchingChildren(); { fCSCBits |= kCSCBApplyMainColorToMatchingChildren; }. void CSCApplyMainTransparencyToAllChildren(); { fCSCBits |= kCSCBApplyMainTransparencyToAllChildren; }. void CSCApplyMainTransparencyToMatchingChildren(); { fCSCBits |= kCSCBApplyMainTransparencyToMatchingChildren; }. void StampColorSelection(); { AddStamp(kCBColorSelection); }. void StampTransBBox(); { AddStamp(kCBTransBBox); }. void StampObjProps(); { AddStamp(kCBObjProps); }. void StampVisibility(); void StampElementAdded() { AddStamp(kCBElementAdded); }; void StampElementRemoved() { AddStamp(kCBElementRemoved); }. { AddStamp(kCBVisibility); }. void ClearStamps(); { fChangeBits = 0; }. UChar_t GetChangeBits() const; { return fChangeBits; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveElement.html:37218,Clear,ClearStamps,37218,root/html602/TEveElement.html,https://root.cern,https://root.cern/root/html602/TEveElement.html,1,['Clear'],['ClearStamps']
Usability,"nspector;  Utility class to plot conditional MLE of nuisance parameters vs. More...;  ; class  ProfileLikelihoodCalculator;  The ProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for tools which can produce both a RooStats HypoTestResult and ConfInterval). More...;  ; class  ProfileLikelihoodTestStat;  ProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset. More...;  ; class  ProofConfig;  Holds configuration options for proof and proof-lite. More...;  ; class  ProposalFunction;  ProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm. More...;  ; class  ProposalHelper;  ; class  RatioOfProfiledLikelihoodsTestStat;  TestStatistic that returns the ratio of profiled likelihoods. More...;  ; struct  RooStatsConfig;  ; class  SamplingDistPlot;  This class provides simple and straightforward utilities to plot SamplingDistribution objects. More...;  ; class  SamplingDistribution;  This class simply holds a sampling distribution of some test statistic. More...;  ; class  SamplingSummary;  ; class  SamplingSummaryLookup;  ; class  SequentialProposal;  Class implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step. More...;  ; class  SimpleInterval;  SimpleInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  SimpleLikelihoodRatioTestStat;  TestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood. More...;  ; class  SPlot;  A class to calculate ""sWeights"" used to create an ""sPlot"". More...;  ; class  TestStatistic;  TestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class. More...;  ; class  TestStatSampler;  TestStatSampler is an interface",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:7051,simpl,simple,7051,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['simpl'],['simple']
Usability,"nst Char_t* columnName = 0) const; voidTDataSet::UnMark()MENU ; voidTDataSet::UnMarkAll()MENU ; virtual voidTTable::Update(); virtual voidTTable::Update(TDataSet* set, UInt_t opt = 0); virtual Int_tUpdateOffsets(const TTableDescriptor* newDesciptor); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTDataSet::AddMain(TDataSet* set); Bool_tTTable::BoundsOk(const char* where, Int_t at) const; virtual voidTTable::Clear(Option_t* opt = """"); voidTTable::CopyStruct(Char_t* dest, const Char_t* src); Char_t*TTable::Create(); virtual voidTTable::Delete(Option_t* opt = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Bool_tTTable::EntryLoop(const Char_t* exprFileName, Int_t& action, TObject* obj, Int_t nentries = 1000000000, Int_t firstentry = 0, Option_t* option = """"); virtual TTableDescriptor*GetDescriptorPointer() const; TDataSet*TDataSet::GetRealParent(); virtual voidInit(TClass* classPtr); voidTDataSet::MakeCollection(); voidTObject::MakeZombie(); Bool_tTTable::OutOfBoundsError(const char* where, Int_t i) const; voidTTable::ReAlloc(Int_t newsize); static voidSetCommentsSetName(const char* name = "".comments""); virtual voidSetDescriptorPointer(TTableDescriptor* list); Int_tTTable::SetfN(Long_t len); virtual voidTDataSet::SetMother(TObject* mother); voidTTable::SetTablePointer(void* table); virtual voidTTable::SetType(const char *const type); voidTTable::SetUsedRows(Int_t n); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds, void* user); voidTTable::StreamerHeader(TBuffer& b, Version_t version = 3); voidTTable::StreamerTable(TBuffer& b, Version_t version = 3). Data Members; public:.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTableDescriptor.html:12731,Clear,Clear,12731,root/html532/TTableDescriptor.html,https://root.cern,https://root.cern/root/html532/TTableDescriptor.html,1,['Clear'],['Clear']
Usability,"nst Char_t* columnName = 0) const; voidTDataSet::UnMark()MENU ; voidTDataSet::UnMarkAll()MENU ; virtual voidTTable::Update(); virtual voidTTable::Update(TDataSet* set, UInt_t opt = 0); virtual Int_tUpdateOffsets(const TTableDescriptor* newDesciptor); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTDataSet::AddMain(TDataSet* set); Bool_tTTable::BoundsOk(const char* where, Int_t at) const; virtual voidTTable::Clear(Option_t* opt = """"); voidTTable::CopyStruct(Char_t* dest, const Char_t* src); Char_t*TTable::Create(); virtual voidTTable::Delete(Option_t* opt = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Bool_tTTable::EntryLoop(const Char_t* exprFileName, Int_t& action, TObject* obj, Int_t nentries = 1000000000, Int_t firstentry = 0, Option_t* option = """"); virtual TTableDescriptor*GetDescriptorPointer() const; TDataSet*TDataSet::GetRealParent(); virtual voidInit(TClass* classPtr); voidTDataSet::MakeCollection(); voidTObject::MakeZombie(); Bool_tTTable::OutOfBoundsError(const char* where, Int_t i) const; voidTTable::ReAlloc(Int_t newsize); static voidSetCommentsSetName(const char* name = "".comments""); virtual voidSetDescriptorPointer(TTableDescriptor* list); Int_tTTable::SetfN(Long_t len); virtual voidTDataSet::SetMother(TObject* mother); voidTTable::SetTablePointer(void* table); virtual voidTTable::SetType(const char *const type); voidTTable::SetUsedRows(Int_t n); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds, void* user); voidTTable::StreamerHeader(TBuffer& b, Version_t version = 3); voidTTable::StreamerTable(TBuffer& b, Version_t version = 3). private:. TTableDescri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTableDescriptor.html:12705,Clear,Clear,12705,root/html534/TTableDescriptor.html,https://root.cern,https://root.cern/root/html534/TTableDescriptor.html,1,['Clear'],['Clear']
Usability,"nst Char_t* columnName = 0) const; voidTDataSet::UnMark()MENU ; voidTDataSet::UnMarkAll()MENU ; virtual voidTTable::Update(); virtual voidTTable::Update(TDataSet* set, UInt_t opt = 0); virtual Int_tUpdateOffsets(const TTableDescriptor* newDesciptor); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTDataSet::AddMain(TDataSet* set); Bool_tTTable::BoundsOk(const char* where, Int_t at) const; virtual voidTTable::Clear(Option_t* opt = """"); voidTTable::CopyStruct(Char_t* dest, const Char_t* src); Char_t*TTable::Create(); virtual voidTTable::Delete(Option_t* opt = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Bool_tTTable::EntryLoop(const Char_t* exprFileName, Int_t& action, TObject* obj, Int_t nentries = 1000000000, Int_t firstentry = 0, Option_t* option = """"); virtual TTableDescriptor*GetDescriptorPointer() const; TDataSet*TDataSet::GetRealParent(); virtual voidInit(TClass* classPtr); voidTDataSet::MakeCollection(); voidTObject::MakeZombie(); Bool_tTTable::OutOfBoundsError(const char* where, Int_t i) const; voidTTable::ReAlloc(Int_t newsize); static voidSetCommentsSetName(const char* name = "".comments""); virtual voidSetDescriptorPointer(TTableDescriptor* list); Int_tTTable::SetfN(Long_t len); virtual voidTDataSet::SetMother(TObject* mother); voidTTable::SetTablePointer(void* table); virtual voidTTable::SetType(const char*const type); voidTTable::SetUsedRows(Int_t n); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds, void* user); voidTTable::StreamerHeader(TBuffer& b, Version_t version = 3); voidTTable::StreamerTable(TBuffer& b, Version_t version = 3). private:. TTableDescrip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableDescriptor.html:12890,Clear,Clear,12890,root/html602/TTableDescriptor.html,https://root.cern,https://root.cern/root/html602/TTableDescriptor.html,2,['Clear'],['Clear']
Usability,"nst Int_t& index, const Double_t& value) const. Data Members; private:. RooArgList*_constParamList; RooMinimizer*_context; Bool_t_doEvalErrorWall; RooArgList*_floatParamList; RooAbsReal*_funct; RooArgList*_initConstParamList; RooArgList*_initFloatParamList; ofstream*_logfile; double_maxFCN; int_nDim; int_numBadNLL; int_printEvalErrors; bool_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMinimizerFcn(RooAbsReal* funct, RooMinimizer* context, bool verbose = false). ROOT::Math::IBaseFunctionMultiDim* Clone() const. unsigned int NDim() const; { return _nDim; }. RooArgList* GetFloatParamList(); { return _floatParamList; }. RooArgList* GetConstParamList(); { return _constParamList; }. RooArgList* GetInitFloatParamList(); { return _initFloatParamList; }. RooArgList* GetInitConstParamList(); { return _initConstParamList; }. void SetEvalErrorWall(Bool_t flag); { _doEvalErrorWall = flag ; }. void SetPrintEvalErrors(Int_t numEvalErrors); { _printEvalErrors = numEvalErrors ; }. Bool_t SetLogFile(const char* inLogfile). ofstream* GetLogFile(); { return _logfile; }. void SetVerbose(Bool_t flag = kTRUE); { _verbose = flag ; }. Double_t& GetMaxFCN(); { return _maxFCN; }. Int_t GetNumInvalidNLL(); { return _numBadNLL; }. Bool_t Synchronize(vector<ROOT::Fit::ParameterSettings>& parameters, Bool_t optConst, Bool_t verbose). void ApplyCovarianceMatrix(TMatrixDSym& V). Double_t GetPdfParamVal(Int_t index). Double_t GetPdfParamErr(Int_t index). void SetPdfParamErr(Int_t index, Double_t value). void ClearPdfParamAsymErr(Int_t index). void SetPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal). Bool_t SetPdfParamVal(const Int_t& index, const Double_t& value) const. double DoEval(const double* x) const. » Last changed: Thu Nov 3 20:08:37 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMinimizerFcn.html:3143,Clear,ClearPdfParamAsymErr,3143,root/html532/RooMinimizerFcn.html,https://root.cern,https://root.cern/root/html532/RooMinimizerFcn.html,1,['Clear'],['ClearPdfParamAsymErr']
Usability,"nst RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:6691,clear,clearValueAndShapeDirty,6691,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"nst RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooAbsReal*RooAbsPdf::createChi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DKeysPdf.html:2809,clear,clearValueDirty,2809,root/html532/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html532/Roo2DKeysPdf.html,1,['clear'],['clearValueDirty']
Usability,"nst TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBBoxEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBoxEditor.html:21326,undo,undoing,21326,root/html528/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html528/TGeoBBoxEditor.html,1,['undo'],['undoing']
Usability,"nst TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBBoxEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoBBoxEditor.html:21426,undo,undoing,21426,root/html530/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html530/TGeoBBoxEditor.html,1,['undo'],['undoing']
Usability,"nst TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBBoxEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoBBoxEditor.html:21426,undo,undoing,21426,root/html532/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html532/TGeoBBoxEditor.html,2,['undo'],['undoing']
Usability,"nst TGWindow* p = 0, UInt_t w = 1, UInt_t type = 1, Int_t id = -1, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground(), Bool_t reversed = kFALSE, Bool_t mark_ends = kFALSE, Bool_t constrained = kTRUE, Bool_t relative = kFALSE); virtual~TGTripleHSlider(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTripleHSlider.html:2847,Clear,Clear,2847,root/html532/TGTripleHSlider.html,https://root.cern,https://root.cern/root/html532/TGTripleHSlider.html,2,['Clear'],['Clear']
Usability,"nst TH1* h, const char* opt = 0, Double_t valbeg = 0, Double_t valend = 0); TSpline3(const char* title, const TGraph* g, const char* opt = 0, Double_t valbeg = 0, Double_t valend = 0); TSpline3(const char* title, Double_t* x, Double_t* y, Int_t n, const char* opt = 0, Double_t valbeg = 0, Double_t valend = 0); TSpline3(const char* title, Double_t* x, const TF1* func, Int_t n, const char* opt = 0, Double_t valbeg = 0, Double_t valend = 0); TSpline3(const char* title, Double_t xmin, Double_t xmax, Double_t* y, Int_t n, const char* opt = 0, Double_t valbeg = 0, Double_t valend = 0); TSpline3(const char* title, Double_t xmin, Double_t xmax, const TF1* func, Int_t n, const char* opt = 0, Double_t valbeg = 0, Double_t valend = 0); virtual~TSpline3(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDerivative(Double_t x) const; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTSpline::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTSpline::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTSpline::ExecuteEvent(Int_t event, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpline3.html:1451,Clear,Clear,1451,root/html532/TSpline3.html,https://root.cern,https://root.cern/root/html532/TSpline3.html,2,['Clear'],['Clear']
Usability,"nst TString& fallback_tag = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveParamList.html:2442,Clear,ClearStamps,2442,root/html532/TEveParamList.html,https://root.cern,https://root.cern/root/html532/TEveParamList.html,4,['Clear'],['ClearStamps']
Usability,"nst TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodDT.html:22179,simpl,simply,22179,root/html534/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodDT.html,2,['simpl'],['simply']
Usability,"nst TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Bool_t MonitorBoost(TMVA::MethodBoost* booster). Double_t PruneTree(const Int_t methodIndex). Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodDT.html:21179,simpl,simply,21179,root/html528/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html,4,['simpl'],['simply']
Usability,"nst TString& tag, const TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; static voidCheckAndFixBoxOrientationEv(TEveVector[8] box); static voidCheckAndFixBoxOrientationFv(Float_t[8][3] box); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTAttBBox::ComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveShape.html:2688,Clear,ClearProjectedList,2688,root/html602/TEveShape.html,https://root.cern,https://root.cern/root/html602/TEveShape.html,2,['Clear'],['ClearProjectedList']
Usability,"nst char *cmd, const char *ord, Bool_t logtomacro=kFALSE);  Send command to be executed on node of ordinal 'ord' (use ""0"" for master). ;  ; void Feedback (TList *objs);  Get list of feedback objects. ;  ; Long64_t Finalize (const char *queryref, Bool_t force=kFALSE);  Finalize query with reference ref. ;  ; Long64_t Finalize (Int_t query=-1, Bool_t force=kFALSE);  Finalize the qry-th query in fQueries. ;  ; TList * FindDataSets (const char *searchString, const char *optStr="""");  Find datasets, returns in a TList all found datasets. ;  ; Long64_t GetBytesRead () const;  ; Int_t GetClientProtocol () const;  ; const char * GetConfDir () const;  ; const char * GetConfFile () const;  ; Float_t GetCpuTime () const;  ; const char * GetDataPoolUrl () const;  ; TMap * GetDataSetQuota (const char *optStr="""");  returns a map of the quotas of all groups ;  ; TString Getenv (const char *env, const char *ord=""0"");  Get value of environment variable 'env' on node 'ord'. ;  ; TList * GetFeedbackList () const;  Return feedback list. ;  ; const char * GetGroup () const;  ; const char * GetImage () const;  ; TList * GetInputList ();  Get input list. ;  ; TMacro * GetLastLog ();  Fill a TMacro with the log lines since the last reading (fLogFileR) Return (TMacro *)0 if no line was logged. ;  ; TList * GetListOfEnabledPackages ();  Get from the master the list of names of the packages enabled. ;  ; TList * GetListOfPackages ();  Get from the master the list of names of the packages available. ;  ; TList * GetListOfSlaveInfos ();  Returns list of TSlaveInfo's. In case of error return 0. ;  ; TList * GetLoadedMacros () const;  ; void GetLog (Int_t start=-1, Int_t end=-1);  Ask for remote logs in the range [start, end]. ;  ; Int_t GetLogLevel () const;  ; TMacro * GetMacroLog ();  ; TProofMgr * GetManager ();  ; const char * GetMaster () const;  ; void GetMaxQueries ();  Get max number of queries whose full results are kept in the remote sandbox. ;  ; TFileCollection * GetMissingFiles (TQue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:10897,feedback,feedback,10897,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['feedback'],['feedback']
Usability,"nst char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void HandleCheckFile (TMessage *mess);  Handle file checking request. ;  ;  Protected Member Functions inherited from TApplication;  TApplication ();  Default ctor. Can be used by classes deriving from TApplication. ;  ; virtual void Forum (const char *line);  The function ("".forum <type>"") submits a new post on the ROOT forum via web browser. ;  ; virtual void GitHub (const char *line);  The function ("".gh <type>"") submits a new issue on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Member Functions; static void ErrorHandler (Int_t level, Bool_t abort, const char *location, const char *msg);  The error handler function. ;  ;  Static Protected Member Functions inherited from TApplicati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:18375,guid,guide,18375,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['guid'],['guide']
Usability,"nst char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooThresholdCategory.html:2225,clear,clearValueDirty,2225,root/html532/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html,2,['clear'],['clearValueDirty']
Usability,"nst char* method) const; virtual voidActivated()SIGNAL ; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D&, Bool_t* = 0); virtual Int_tAddObject(UInt_t, const TBuffer3D&, Bool_t* = 0); virtual voidTGLViewerBase::AddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*TGLViewerBase::AddScene(TGLSceneBase* scene); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplySelection(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidAutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); virtual voidBeginScene(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tCanLoopOnPrimitives() const; virtual voidTGLViewerBase::Changed(); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearCurrentOvlElm(); virtual voidClicked(TObject* obj)SIGNAL ; virtual voidClicked(TObject* obj, UInt_t button, UInt_t state)SIGNAL ; TGLClip*TGLViewerBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); TGLColorSet&ColorSet(); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; virtual voidCreateGLWidget(); TGLCamera&CurrentCamera() const; TGLLockable::ELockTGLLocka",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLViewer.html:2463,Clear,Clear,2463,root/html532/TGLViewer.html,https://root.cern,https://root.cern/root/html532/TGLViewer.html,4,['Clear'],['Clear']
Usability,"nst char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfAreaBin area; Bool_tfChangedFor the 3D Painter; Double_tfContentBin content; Int_tfNumberBin number of the bin in TH2Poly; TObject*fPolyObject holding the polygon definition; Double_tfXmaxX maximum value; Double_tfXminX minimum value; Double_tfYmaxY maximum value; Double_tfYminY minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH2PolyBin(). TH2PolyBin(TObject* poly, Int_t bin_number). virtual ~TH2PolyBin(). void ClearContent(); {fContent = 0;}. void Fill(Double_t w); {fContent = fContent+w; SetChanged(true);}. Double_t GetArea(). Double_t GetContent() const; {return fContent;}. Bool_t GetChanged() const; {return fChanged;}. Int_t GetBinNumber() const; {return fNumber;}. TObject * GetPolygon() const; {return fPoly;}. Double_t GetXMax(). Double_t GetXMin(). Double_t GetYMax(). Double_t GetYMin(). Bool_t IsInside(Double_t x, Double_t y) const. void SetChanged(Bool_t flag); {fChanged = flag;}. void SetContent(Double_t content); {fContent = content; SetChanged(true);}. » Author: Olivier Couet, Deniz Gunceler » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2PolyBin.html:5986,Clear,ClearContent,5986,root/html534/TH2PolyBin.html,https://root.cern,https://root.cern/root/html534/TH2PolyBin.html,1,['Clear'],['ClearContent']
Usability,"nst char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNtuple.html:3002,Clear,Clear,3002,root/html602/TNtuple.html,https://root.cern,https://root.cern/root/html602/TNtuple.html,2,['Clear'],['Clear']
Usability,"nst char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* vare",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNtupleD.html:3011,Clear,Clear,3011,root/html602/TNtupleD.html,https://root.cern,https://root.cern/root/html602/TNtupleD.html,2,['Clear'],['Clear']
Usability,"nst char* s, const char* cmd, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = kRaisedFrame|kDoubleBorder); virtual~TGTextButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextButton.html:4396,Clear,Clear,4396,root/html532/TGTextButton.html,https://root.cern,https://root.cern/root/html532/TGTextButton.html,2,['Clear'],['Clear']
Usability,"nst char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const; Int_tTProof::GetClientProtocol() const; const char*TProof::GetConfDir() const; const char*TProof::GetConfFile() const; Float_tTProof::GetCpuTime() const; const char*TProof::GetDataPoolUrl() const; virtual TFileCollection*GetDataSet(const char* uri, const char* = 0); TMap*TProof::GetDataSetQuota(const char* optStr = """"); virtual TMap*GetDataSets(const char* uri = """", const char* = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const TList*TProof::GetEnvVars(); TList*TProof::GetFeedbackList() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLite.html:6279,Feedback,Feedback,6279,root/html532/TProofLite.html,https://root.cern,https://root.cern/root/html532/TProofLite.html,1,['Feedback'],['Feedback']
Usability,"nst debug (non-debug) ROOT? . Microsoft's STL classes (std::string, std::vector,...) are different for debug and optimized mode. When calling a ROOT function that expects a STL object as an argument, the caller (e.g. your code) and ROOT must agree on what the object looks like. Thus if you link against ROOT libraries built as debug (non-debug) you must also compile your code as debug (non-debug). ACLiC does that automatically for you. ; . Changing the Displayed Title in Canvas. . Disable the title and add yourself your own title with a TPaveLabel: ; gStyle->SetOptTitle(0);; TPaveLabel *title = new TPaveLabel(.11,.95,.35,.99,""new title"",""brndc"");; title->Draw(); ; Changing the Displayed Title in Canvas. ; . Segmentation violation in TASImage::InitVisual () on Mac . The configure command should specify explicitly where ROOT should find all X11-related libs. ./configure --with-x11-libdir=/opt/local/lib/ ; --with-xpm-libdir=/opt/local/lib/ ; --with-xft-libdir=/opt/local/lib/ ; --with-xext-libdir=/opt/local/lib/; A simple Draw(0 or a Browser opening might cause a Segmentation violation in TASImage::InitVisual () on Mac. ; . How do I start PROOF? . Type at the ROOT prompt:. root [0] TProof::Open(""""); How do I start PROOF? ; . How to render graphics in a file, without displaying the image on the screen ? . Run in batch mode:. root -b -q myscript.C. or in your program add:. gROOT->SetBatch();; ; . Prerequisites for building ROOT from source. . To successfully build ROOT a number of prerequisite packages must be installed. Check the prerequisites page for the list of packages needed for your platform.; ; . How to use ROOT libraries in Xcode on Mac OS X? . The easiest way is to use cmake and let it create the Xcode project, this has the advantage that the dictionaries are created automatically. The CMakeLists.txt file will define the libraries and executables to be added to the Xcode project. An example from the ROOT Event example (found in root/test) can be downloaded here. J",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:6275,simpl,simple,6275,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['simpl'],['simple']
Usability,"nst set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:3291,Clear,Clear,3291,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,2,['Clear'],['Clear']
Usability,"nst set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDecay.html:2695,Clear,Clear,2695,root/html534/RooDecay.html,https://root.cern,https://root.cern/root/html534/RooDecay.html,1,['Clear'],['Clear']
Usability,"nst set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPEffDecay.html:2997,Clear,Clear,2997,root/html534/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPEffDecay.html,4,['Clear'],['Clear']
Usability,"nst set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBDecay.html:2895,Clear,Clear,2895,root/html534/RooBDecay.html,https://root.cern,https://root.cern/root/html534/RooBDecay.html,1,['Clear'],['Clear']
Usability,"nst set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgusBG.html:2719,Clear,Clear,2719,root/html534/RooArgusBG.html,https://root.cern,https://root.cern/root/html534/RooArgusBG.html,38,['Clear'],['Clear']
Usability,"nst set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:4871,Clear,Clear,4871,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,1,['Clear'],['Clear']
Usability,"nst. inline . Definition at line 122 of file TGTextEntry.h. ◆ HasOwnFont(). Bool_t TGTextEntry::HasOwnFont ; (; ); const. inline . Definition at line 158 of file TGTextEntry.h. ◆ Home(). void TGTextEntry::Home ; (; Bool_t ; mark = kFALSE). Moves the text cursor to the left end of the line. ; If mark is kTRUE text will be marked towards the first position, if not any marked text will be unmarked if the cursor is moved. See also End(). ; Definition at line 983 of file TGTextEntry.cxx. ◆ Init(). void TGTextEntry::Init ; (; ). protectedvirtual . Do default initialization. ; Definition at line 315 of file TGTextEntry.cxx. ◆ Insert(). void TGTextEntry::Insert ; (; const char * ; newText). virtual . Removes any currently selected text, inserts newText, sets it as the new contents of the text entry. ; Definition at line 779 of file TGTextEntry.cxx. ◆ InsertText(). void TGTextEntry::InsertText ; (; const char * ; text, . Int_t ; pos . ). virtual . Inserts text at position pos, clears the selection and moves the cursor to the end of the line. ; If necessary the text is truncated to fit MaxLength(). See also GetText(), SetText(), AppendText(), RemoveText(). ; Definition at line 1675 of file TGTextEntry.cxx. ◆ IsA(). TClass * TGTextEntry::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGFrame.; Definition at line 184 of file TGTextEntry.h. ◆ IsCursorOutOfFrame(). Bool_t TGTextEntry::IsCursorOutOfFrame ; (; ). protectedvirtual . Returns kTRUE if cursor is out of frame. ; Definition at line 1568 of file TGTextEntry.cxx. ◆ IsEdited(). Bool_t TGTextEntry::IsEdited ; (; ); const. inline . Definition at line 129 of file TGTextEntry.h. ◆ IsFrameDrawn(). Bool_t TGTextEntry::IsFrameDrawn ; (; ); const. inline . Definition at line 128 of file TGTextEntry.h. ◆ Layout(). void TGTextEntry::Layout ; (; ). inlineoverridevirtual . Reimplemented from TGFrame.; Definition at line 130 of file TGTextEntry.h. ◆ MarkWord(). void TGTextEntry::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEntry.html:57866,clear,clears,57866,doc/master/classTGTextEntry.html,https://root.cern,https://root.cern/doc/master/classTGTextEntry.html,1,['clear'],['clears']
Usability,"nst; List folder contents; If option contains ""dump"", the Dump function of contained objects is called.; If option contains ""print"", the Print function of contained objects is called.; By default the ls function of contained objects is called.; Indentation is used to identify the folder tree. The if option contains a <regexp> it be used to match the name of the objects. Int_t Occurence(const TObject* obj) const; Return occurence number of object in the list of objects of this folder.; The function returns the number of objects with the same name as object; found in the list of objects in this folder before object itself.; If only one object is found, return 0. void RecursiveRemove(TObject* obj); Recursively remove object from a folder. void Remove(TObject* obj); Remove object from this folder. obj must be a TObject or a TFolder. void SaveAs(const char* filename = """", Option_t* option = """") const; Save all objects in this folder in filename.; Each object in this folder will have a key in the file where the name of; the key will be the name of the object. void SetOwner(Bool_t owner = kTRUE); Set ownership.; If the folder is declared owner, when the folder is deleted, all; the objects added via TFolder::Add are deleted via TObject::Delete,; otherwise TObject::Clear is called. NOTE that folder ownership can be set:; - via TFolder::SetOwner; - or via TCollection::SetOwner on the collection specified to TFolder::AddFolder. void operator=(const TFolder& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TCollection * GetListOfFolders() const; { return fFolders; }. Bool_t IsFolder() const; { return kTRUE; }. » Author: Rene Brun 02/09/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TFolder.h 27436 2009-02-12 14:54:52Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFolder.html:12770,Clear,Clear,12770,root/html532/TFolder.html,https://root.cern,https://root.cern/root/html532/TFolder.html,1,['Clear'],['Clear']
Usability,"nst; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:3974,clear,clearShapeDirty,3974,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,3,['clear'],['clearShapeDirty']
Usability,"nst; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:4420,clear,clearShapeDirty,4420,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,2,['clear'],['clearShapeDirty']
Usability,"nst; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:4420,clear,clearShapeDirty,4420,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,6,['clear'],['clearShapeDirty']
Usability,"nst; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddItem(TGLVEntry* item); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGContainer::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidTGContainer::ClearViewPort(); virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn)SIGNAL ; virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGContainer::CurrentChanged(TGFrame* f)SIGNAL ; virtual voidTGContainer::CurrentChanged(Int_t x, Int_t y)SIGNAL ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLVContainer.html:2160,Clear,ClearViewPort,2160,root/html532/TGLVContainer.html,https://root.cern,https://root.cern/root/html532/TGLVContainer.html,4,['Clear'],['ClearViewPort']
Usability,"nst;  ; TSessionOutputFrame * GetOutputFrame () const;  ; TGPopupMenu * GetPopupQry () const;  ; TGPopupMenu * GetPopupSrv () const;  ; const TGPicture * GetProofConPict () const;  ; const TGPicture * GetProofDisconPict () const;  ; const TGPicture * GetQueryConPict () const;  ; const TGPicture * GetQueryDisconPict () const;  ; TSessionQueryFrame * GetQueryFrame () const;  ; TSessionServerFrame * GetServerFrame () const;  ; TSessionFrame * GetSessionFrame () const;  ; TGListTree * GetSessionHierarchy () const;  ; TGListTreeItem * GetSessionItem () const;  ; TList * GetSessions () const;  ; TGStatusBar * GetStatusBar () const;  ; Bool_t HandleTimer (TTimer *) override;  Handle animation timer. ;  ; TClass * IsA () const override;  ; Bool_t IsAutoSave () const;  ; Bool_t IsBusy () const;  ; void LogMessage (const char *msg, Bool_t all);  Load/append a log msg in the log frame. ;  ; void MyHandleMenu (Int_t);  Handle session viewer custom popup menus. ;  ; void OnCascadeMenu ();  Handle feedback histograms configuration menu. ;  ; void OnListTreeClicked (TGListTreeItem *entry, Int_t btn, Int_t x, Int_t y);  Handle mouse clicks in list tree. ;  ; void OnListTreeDoubleClicked (TGListTreeItem *entry, Int_t btn);  Handle mouse double clicks in list tree (connect to server). ;  ; Bool_t ProcessMessage (Longptr_t msg, Longptr_t parm1, Longptr_t) override;  Handle messages send to the TSessionViewer object. ;  ; void QueryResultReady (char *query);  Handle signal ""query result ready"" coming from Proof session. ;  ; void ReadConfiguration (const char *filename=nullptr);  Read configuration file and populate list of sessions list of queries and list of packages. ;  ; void ResetSession ();  Reset Proof session. ;  ; void SetBusy (Bool_t busy=kTRUE);  ; void SetChangePic (Bool_t change);  ; void SetLogWindow (TSessionLogView *log);  ; void ShowEnabledPackages ();  Query list of enabled packages from proof and display it into a new text window. ;  ; void ShowInfo (const char *txt)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionViewer.html:2683,feedback,feedback,2683,doc/master/classTSessionViewer.html,https://root.cern,https://root.cern/doc/master/classTSessionViewer.html,1,['feedback'],['feedback']
Usability,"nstance when changing from; 289/// signal to background tree, or using TChains as input) The; 290/// TTreeFormulas, that hold the input expressions need to be; 291/// re-associated with the new tree, which is done here; 292 ; 293void TMVA::DataSetFactory::ChangeToNewTree( TreeInfo& tinfo, const DataSetInfo & dsi ); 294{; 295 TTree *tr = tinfo.GetTree()->GetTree();; 296 ; 297 //tr->SetBranchStatus(""*"",1); // nor needed when using TTReeFormula; 298 tr->ResetBranchAddresses();; 299 ; 300 Bool_t hasDollar = kTRUE; // Set to false if wants to enable only some branch in the tree; 301 ; 302 // 1) the input variable formulas; 303 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" create input formulas for tree "" << tr->GetName() << Endl;; 304 std::vector<TTreeFormula*>::const_iterator formIt, formItEnd;; 305 for (formIt = fInputFormulas.begin(), formItEnd=fInputFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 306 fInputFormulas.clear();; 307 TTreeFormula* ttf = 0;; 308 fInputTableFormulas.clear(); // this contains shallow pointer copies; 309 ; 310 bool firstArrayVar = kTRUE;; 311 int firstArrayVarIndex = -1;; 312 int arraySize = -1;; 313 for (UInt_t i = 0; i < dsi.GetNVariables(); i++) {; 314 ; 315 // create TTreeformula; 316 if (! dsi.IsVariableFromArray(i) ) {; 317 ttf = new TTreeFormula(Form(""Formula%s"", dsi.GetVariableInfo(i).GetInternalName().Data()),; 318 dsi.GetVariableInfo(i).GetExpression().Data(), tr);; 319 CheckTTreeFormula(ttf, dsi.GetVariableInfo(i).GetExpression(), hasDollar);; 320 fInputFormulas.emplace_back(ttf);; 321 fInputTableFormulas.emplace_back(std::make_pair(ttf, (Int_t) 0));; 322 } else {; 323 // it is a variable from an array; 324 if (firstArrayVar) {; 325 ; 326 // create a new TFormula; 327 ttf = new TTreeFormula(Form(""Formula%s"", dsi.GetVariableInfo(i).GetInternalName().Data()),; 328 dsi.GetVariableInfo(i).GetExpression().Data(), tr);; 329 CheckTTreeFormula(ttf, dsi.GetVariableInfo(i).GetExpression(), hasDollar);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:12145,clear,clear,12145,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"nstructor ; Definition at line 2256 of file TGeoMatrix.cxx. ◆ TGeoGenTrans() [4/4]. TGeoGenTrans::TGeoGenTrans ; (; const char * ; name, . Double_t ; dx, . Double_t ; dy, . Double_t ; dz, . Double_t ; sx, . Double_t ; sy, . Double_t ; sz, . TGeoRotation * ; rot . ). constructor ; Definition at line 2269 of file TGeoMatrix.cxx. ◆ ~TGeoGenTrans(). TGeoGenTrans::~TGeoGenTrans ; (; ). override . destructor ; Definition at line 2282 of file TGeoMatrix.cxx. Member Function Documentation. ◆ Class(). static TClass * TGeoGenTrans::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoGenTrans::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoGenTrans::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 395 of file TGeoMatrix.h. ◆ Clear(). void TGeoGenTrans::Clear ; (; Option_t * ; option = """"). overridevirtual . clear the fields of this transformation ; Reimplemented from TGeoCombiTrans.; Definition at line 2287 of file TGeoMatrix.cxx. ◆ DeclFileName(). static const char * TGeoGenTrans::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 395 of file TGeoMatrix.h. ◆ GetScale(). const Double_t * TGeoGenTrans::GetScale ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoCombiTrans.; Definition at line 393 of file TGeoMatrix.h. ◆ Inverse(). TGeoHMatrix TGeoGenTrans::Inverse ; (; ); const. overridevirtual . Return a temporary inverse of this. ; Reimplemented from TGeoCombiTrans.; Definition at line 2312 of file TGeoMatrix.cxx. ◆ IsA(). TClass * TGeoGenTrans::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoCombiTrans.; Definition at line 395 of file TGeoMatrix.h. ◆ MakeClone(). TGeoMatrix * TGeoGenTrans::MakeClone ; (; ); const. inlineoverridevirtual . Make a clone of this matrix. ; Reimplemented from TGeoC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGenTrans.html:20108,clear,clear,20108,doc/master/classTGeoGenTrans.html,https://root.cern,https://root.cern/doc/master/classTGeoGenTrans.html,1,['clear'],['clear']
Usability,"nstructor from TEveUtil Monte Carlo track. TEveTrack(TEveRecTrackD* t, TEveTrackPropagator* prop = 0); Constructor from TEveRecTrack<double> reconstructed track. TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop = 0); Constructor from TEveRecTrack<float> reconstructed track.; It is recomended to use constructor with TEveRecTrack<double> since; TEveTrackPropagator operates with double type. TEveTrack(const TEveTrack& t); Copy constructor. Track paremeters are copied but the; extrapolation is not perfermed so you should still call; MakeTrack() to do that.; If points of 't' are locked, they are cloned. ~TEveTrack(); Destructor. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Returns list-tree icon for TEveTrack. void ComputeBBox(); Compute the bounding box of the track. void SetStdTitle(); Set standard track title based on most data-member values. void SetTrackParams(const TEveTrack& t); Copy track parameters from t. Track-propagator is set, too.; PathMarks are cleared - you can copy them via SetPathMarks(t).; If track 't' is locked, you should probably clone its points; over - use TEvePointSet::ClonePoints(t);. void SetPathMarks(const TEveTrack& t); Copy path-marks from t. void SetPropagator(TEveTrackPropagator* prop); Set track's render style.; Reference counts of old and new propagator are updated. void SetAttLineAttMarker(TEveTrackList* tl); Set line and marker attributes from TEveTrackList. void MakeTrack(Bool_t recurse = kTRUE); Calculate track representation based on track data and current; settings of the propagator.; If recurse is true, descend into children. void CopyVizParams(const TEveElement* el); Copy visualization parameters from element el. void WriteVizParams(ostream& out, const TString& var); Write visualization parameters. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, return TEveTrackProjected class. void SortPathMarksByTime(); Sort registerd pat-marks by time. void PrintPathMarks(); Print registered ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrack.html:31330,clear,cleared,31330,root/html530/TEveTrack.html,https://root.cern,https://root.cern/root/html530/TEveTrack.html,3,['clear'],['cleared']
Usability,"nstructor from TEveUtil Monte Carlo track. TEveTrack(TEveRecTrackD* t, TEveTrackPropagator* prop = 0); Constructor from TEveRecTrack<double> reconstructed track. TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop = 0); Constructor from TEveRecTrack<float> reconstructed track.; It is recomended to use constructor with TEveRecTrack<double> since; TEveTrackPropagator operates with double type. TEveTrack(const TEveTrack& t); Copy constructor. Track paremeters are copied but the; extrapolation is not perfermed so you should still call; MakeTrack() to do that.; If points of 't' are locked, they are cloned. ~TEveTrack(); Destructor. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Returns list-tree icon for TEveTrack. void ComputeBBox(); Compute the bounding box of the track. void SetStdTitle(); Set standard track title based on most data-member values. void SetTrackParams(const TEveTrack& t); Copy track parameters from t. Track-propagator is set, too.; PathMarks are cleared - you can copy them via SetPathMarks(t).; If track 't' is locked, you should probably clone its points; over - use TEvePointSet::ClonePoints(t);. void SetPathMarks(const TEveTrack& t); Copy path-marks from t. void SetPropagator(TEveTrackPropagator* prop); Set track's render style.; Reference counts of old and new propagator are updated. void SetAttLineAttMarker(TEveTrackList* tl); Set line and marker attributes from TEveTrackList. void MakeTrack(Bool_t recurse = kTRUE); Calculate track representation based on track data and current; settings of the propagator.; If recurse is true, descend into children. void CopyVizParams(const TEveElement* el); Copy visualization parameters from element el. void WriteVizParams(ostream& out, const TString& var); Write visualization parameters. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, return TEveTrackProjected class. void SortPathMarksByTime(); Sort registered pat-marks by time. void PrintPathMarks(); Print registered",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrack.html:31862,clear,cleared,31862,root/html534/TEveTrack.html,https://root.cern,https://root.cern/root/html534/TEveTrack.html,6,['clear'],['cleared']
Usability,"nstructor. ~RooNumConvPdf(); Destructor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return const_cast<RooAbsReal&>(_origPdf.arg()) ; }. RooAbsReal& model() const; { return const_cast<RooAbsReal&>(_origModel.arg()) ; }. RooNumConvolution& conv() const; WVE Store all properties of RooNumConvolution here so that can be take; along in the copy ctor. { if (!_init) initialize() ; return *_conv ; }. » ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:43652,clear,clearConvolutionWindow,43652,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,11,['clear'],['clearConvolutionWindow']
Usability,"nstructor. ~TEveWindow(); Destructor. void PreDeleteElement(); Called before the element is deleted, thus offering the last chance; to detach from acquired resources and from the framework itself.; Here the request is just passed to TEveManager.; If you override it, make sure to call base-class version. void PreUndock(); Virtual function called before a window is undocked. void PostDock(); Virtual function called after a window is docked. void NameTitleChanged(); Name or title of the window changed - propagate to frames.; Virtual from TEveElement. void PopulateEmptyFrame(TEveCompositeFrame* ef); Populate given frame-slot - intended for initial population; of a new slot or low-level window-swapping.; No layout or window-mapping is done. void SwapWindow(TEveWindow* w); Swap frames with the given window. void SwapWindowWithCurrent(); Swap frames with the current window. void UndockWindow(); Undock the window - put it into a dedicated main-frame. void UndockWindowDestroySlot(); Undock the window - put it into a dedicated main-frame.; The old window slot is destroyed. void ReplaceWindow(TEveWindow* w); Replace this window with the passed one.; Eve parentship is properly handled.; This will most likely lead to the destruction of this window.; Layout is called on the frame. void DestroyWindow(); Destroy eve-window - replace it with an empty frame-slot. void DestroyWindowAndSlot(); Destroy eve-window and its frame-slot. void ClearEveFrame(); Clears eve-frame associated with this window.; This is used in special case when the window is embedded in a foreign; GUI container and gets deleted from this side.; In particular, this happens when TRootBrowser closes a tab. void SetShowTitleBar(Bool_t x); Set display state of the title-bar.; This is forwarded to eve-frame. Bool_t IsCurrent() const; Returns true if this window is the current one. void MakeCurrent(); Make this window current. void SetCurrent(Bool_t curr); Set current state of this eve-window.; Protected method - called ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveWindow.html:23255,Undo,UndockWindowDestroySlot,23255,root/html602/TEveWindow.html,https://root.cern,https://root.cern/root/html602/TEveWindow.html,4,['Undo'],"['Undock', 'UndockWindowDestroySlot']"
Usability,"nt . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Support Guidelines for submitting a bug. Introduction; The RootTalk mailing list and forum can be used to pass information of general interest to the ROOT user community or to submit problems that you cannot solve with the information provided in the Documentation. Several thousands users read the list and forum and my provide you with solutions to your problem.; Only if you are convinced that your problem is a real bug of the ROOT software then follow the instructions on how to report a bug with JIRA.; When you submit a bug, please follow these guidelines:. If you submit a problem, always indicate your ROOT version number (e.g. 6.02.00, 5.34.22) and the platform you are running on (e.g. Ubuntu 14 gcc49, SLC6 clang35).; The bug title subject line should clearly identify the problem.; If you use a non recent version of ROOT, try to test your problem with newer version. If this is too difficult, consult the release and development notes to check if your problem has not already been solved.; Try to quickly search the internet and look in the forum if your problem has been already solved.; Try to share the maximum amount of information. A bug report which only says ""My macro crashes when running on kubuntu but on windows works"" is much less likely to be solved quickly than a complete message with a gdb stacktrace and a reproducer (see next item).; Send a minimal program or macro reproducing the problem. Make sure that your script can be executed directly. If it uses a data file, send the smallest possible data file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/guidelines-submitting-bug.html:2420,guid,guidelines,2420,d/guidelines-submitting-bug.html,https://root.cern,https://root.cern/d/guidelines-submitting-bug.html,1,['guid'],['guidelines']
Usability,"nt algorithm (SGD) ; Implements a steepest gradient descent minimization algorithm ; Definition at line 333 of file NeuralNet.h. Public Member Functions;  Steepest (double learningRate=1e-4, double momentum=0.5, size_t repetitions=10);  c'tor ;  ; template<typename Function , typename Weights , typename PassThrough > ; double operator() (Function &fitnessFunction, Weights &weights, PassThrough &passThrough);  operator to call the steepest gradient descent algorithm ;  . Public Attributes; double m_alpha;  internal parameter (learningRate) ;  ; double m_beta;  internal parameter (momentum) ;  ; std::vector< double > m_localGradients;  local gradients for reuse in thread. ;  ; std::vector< double > m_localWeights;  local weights for reuse in thread. ;  ; std::vector< double > m_prevGradients;  vector remembers the gradients of the previous step ;  ; size_t m_repetitions;  . #include <TMVA/NeuralNet.h>; Constructor & Destructor Documentation. ◆ Steepest(). TMVA::DNN::Steepest::Steepest ; (; double ; learningRate = 1e-4, . double ; momentum = 0.5, . size_t ; repetitions = 10 . ). inline . c'tor ; C'tor; Parameters. learningRatedenotes the learning rate for the SGD algorithm ; momentumfraction of the velocity which is taken over from the last step ; repetitionsre-compute the gradients each ""repetitions"" steps . Definition at line 348 of file NeuralNet.h. Member Function Documentation. ◆ operator()(). template<typename Function , typename Weights , typename PassThrough > . double TMVA::DNN::Steepest::operator() ; (; Function & ; fitnessFunction, . Weights & ; weights, . PassThrough & ; passThrough . ). operator to call the steepest gradient descent algorithm ; implementation of the steepest gradient descent algorithm; entry point to start the minimization procedure; Parameters. fitnessFunction(templated) function which has to be provided. This function is minimized ; weights(templated) a reference to a container of weights. The result of the minimization procedure is retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Steepest.html:1293,learn,learningRate,1293,doc/master/classTMVA_1_1DNN_1_1Steepest.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Steepest.html,1,['learn'],['learningRate']
Usability,"nt and save a capture in a png file. ;  ; file  games.C;  This macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT. ;  ; file  gtreeTableTest.C;  This TableTest class is a simple example of how to use a TGTreeTable. ;  ; file  guilabels.C;  This macro gives an example of how to create different kind of labels and the possibility to enable/disable them. ;  ; file  guitest.C;  Test program for ROOT native GUI classes Exactly like $ROOTSYS/test/guitest.cxx but using the new signal and slots communication mechanism. ;  ; file  guitest_playback.C;  This macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved. ;  ; file  guiWithCLING.C;  A simple example of entering CLING commands and having the CLING output in a ROOT GUI application window. ;  ; file  iconAsXPMData.C;  A simple example of creating icon image from XPM data, included into the code. ;  ; file  listBox.C;  This macro gives an example of how to create a list box and how to set and use its multiple selection feature. ;  ; file  mditest.C;  GUI MDI features. ;  ; file  ntupleTableTest.C;  This TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface. ;  ; file  numberEntry.C;  This macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry. ;  ; file  simpleTableTest.C;  This TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface. ;  ; file  Slider3Demo.C;  Simple macro showing capabilities of triple slider. ;  ; file  splitbuttonTest.C;  A simple example that shows the usage of a TGSplitButton. ;  ; file  splitterHorizontal.C;  This macro gives an example of how to create a horizontal splitter. ;  ; file  splitterVertical.C;  This macro gives an example of how",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__gui.html:2295,simpl,simple,2295,doc/master/group__tutorial__gui.html,https://root.cern,https://root.cern/doc/master/group__tutorial__gui.html,1,['simpl'],['simple']
Usability,"nt ipos); check if the character at position i is part of a scientific notation. Bool_t IsHexadecimal(const TString& formula, int ipos); check if the character at position i is part of a scientific notation. TFormula(). ~TFormula(). TFormula(const char* name, const char* formula = """", bool addToGlobList = true); -; *-* Constructor; *-* When TF1 is constructed using C++ function, TF1 need space to keep parameters values.; -. TFormula(const char* name, const char* formula = """", bool addToGlobList = true). TFormula& operator=(const TFormula& rhs); -; *-* = Operator; -. Int_t Compile(const char* expression = """"); Compile the given expression with Cling; backward compatibility method to be used in combination with the empty constructor; if no expression is given , the current stored formula (retrieved with GetExpFormula()) or the title is used.; return 0 if the formula compilation is successfull. void Copy(TObject& f1) const. void Clear(Option_t* option = """"); clear the formula setting expression to empty and reset the variables and parameters containers. bool PrepareEvalMethod(); -; *-* Sets TMethodCall to function inside Cling environment; *-* TFormula uses it to execute function.; *-* After call, TFormula should be ready to evaluate formula.; -. void InputFormulaIntoCling(); -; *-* Inputs formula, transfered to C++ code into Cling; -. void FillDefaults(); -; *-* Fill structures with default variables, constants and function shortcuts; -; #ifdef ROOT_CPLUSPLUS11. void HandlePolN(TString& formula); -; *-* Handling polN; *-* If before 'pol' exist any name, this name will be treated as variable used in polynomial; *-* eg.; *-* varpol2(5) will be replaced with: [5] + [6]*var + [7]*var^2; *-* Empty name is treated like variable x.; -. void HandleParametrizedFunctions(TString& formula); -; *-* Handling parametrized functions; *-* Function can be normalized, and have different variable then x.; *-* Variables should be placed in brackets after function name.; *-* No brackets a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFormula.html:11172,clear,clear,11172,root/html604/TFormula.html,https://root.cern,https://root.cern/root/html604/TFormula.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"nt number otherwise. TAxis * GetXaxis() const; Get x axis of the graph. TAxis * GetYaxis() const; Get y axis of the graph. void InitGaus(Double_t xmin = 0, Double_t xmax = 0); Compute Initial values of parameters for a gaussian. void InitExpo(Double_t xmin = 0, Double_t xmax = 0); Compute Initial values of parameters for an exponential. void InitPolynom(Double_t xmin = 0, Double_t xmax = 0); Compute Initial values of parameters for a polynom. Int_t InsertPoint(); Insert a new point at the mouse position. Double_t Integral(Int_t first = 0, Int_t last = -1) const; Integrate the TGraph data within a given (index) range; Note that this function computes the area of the polygon enclosed by the points of the TGraph.; The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; with the first one. It is clear that the order of the point is essential in defining the polygon.; Also note that the segments should not intersect. NB: if last=-1 (default) last is set to the last point.; if (first <0) the first point (0) is taken. Method:; There are many ways to calculate the surface of a polygon. It all depends on what kind of data; you have to deal with. The most evident solution would be to divide the polygon in triangles and; calculate the surface of them. But this can quickly become complicated as you will have to test; every segments of every triangles and check if they are intersecting with a current polygon's; segment or if it goes outside the polygon. Many calculations that would lead to many problems...; The solution (implemented by R.Brun); Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; segments don't intersect.; It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; vertex. Then it subtracts from it the result of the y coordina",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph.html:35786,clear,clear,35786,root/html534/TGraph.html,https://root.cern,https://root.cern/root/html534/TGraph.html,6,['clear'],['clear']
Usability,"nt size sum.; Creating the Histogram; You then create the object with new TH1F(""hPosX"", ""Position in X"", 20, -5, 5);; Associate error bars with this histogram (see TH1F::Sumw2()); Filling the Histogram; The goal is to fill the histogram with the value of fPosX from the tree for all particles with a momentum > 40. You will need access to the particles' total momentum and their X position. Each TTree entry has several particles; it's thus easiest to use one TTreeReaderArray each for these Double_t values, for instance TTreeReaderArray particlesMomentum(myReader, ""fParticles.fMomentum"");. The TTreeReaderArray works just like the TTreeReaderValue we have used before, but gives you access to the number of particles using particlesMomentum.GetSize() and the n-th particle using the particlesMomentum[n] operator.; The analysis happens in loops. The outer loop is iterating through the TTree entries, using the TTreeReader::Next() loop - just as before. For each TTree entry, loop over all particles of the TTree entry with a simple for loop. For each particle, check that its momentum is > 40; if it is, fill the histogram (see TH1F::Fill()) with the fPosX value of that particle.; This step involves writing some code (similar to the code you have for the event size). If you get lost (SPOILER ALERT!): the solution is at the end of this page.; Fitting and Drawing the Histogram; Once the histogram is filled, fit it with a pol2 using TH1::Fit(""pol2""). Here ""pol2"" is ROOT's short name for ""polynomial of 2nd degree"", i.e. [0] + [1]x + [2]x*x, aka ""parabola"".; ""Fitting"" means using a function (in this case the pol2) with one or more free parameters ([0]..[2] in this case) and looking for those values of the parameters that result in the function passing as closely as possible through the data points, where ""close"" takes the points' uncertainties into account. You should first fit and then draw, to see the fit together with the histogram.; At the end, you should get something like this:. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/histogramming.html:3372,simpl,simple,3372,d/histogramming.html,https://root.cern,https://root.cern/d/histogramming.html,1,['simpl'],['simple']
Usability,"nt to the current cursor position in stack. ;  ; UInt_t GetLimit () const;  Returns a maximum number of commands which could be located in stack. ;  ; TClass * IsA () const override;  ; Bool_t IsLogging () const;  Returns kTRUE if logging is ON. ;  ; void ls (Option_t *option="""") const override;  Lists all commands in stack. ;  ; void Redo (Option_t *option="""") override;  Performs redo action. Move cursor position forward in history stack. ;  ; virtual void SetLimit (UInt_t limit);  Returns a maximum number of commands which could be located in stack. ;  ; virtual void SetLogging (Bool_t on=kTRUE);  Start logging. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Undo (Option_t *option="""") override;  Performs undo action. Move cursor position backward in history stack. ;  ;  Public Member Functions inherited from TQCommand;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:2064,undo,undo,2064,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"nt to this object. Note that this method can be called; 2942 /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; 2943 /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; 2944 /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; 2945 /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; 2946 /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; 2947 /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; 2948 /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; 2949 /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; 2950 /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; 2951 /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; 2952 /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; 2953 /// the requested columns for the particular entry being processed.; 2954 /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; 2955 /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; 2956 /// diagnostics, SaveGraph(), etc.; 2957 ///; 2958 /// ### Optional methods; 2959 ///; 2960 /// If these methods are implemented they enable extra functionality as per the description below.; 2961 ///; 2962 /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:166875,simpl,simple,166875,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['simpl'],['simple']
Usability,"nt using the algorithm corresponding to the specified code. ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; RooAbsReal const & getMedian () const;  Get the median parameter. ;  ; RooAbsReal const & getShapeK () const;  Get the shape parameter. ;  ; RooAbsReal const & getX () const;  Get the x variable. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; bool useStandardParametrization () const;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLognormal.html:2744,simpl,simple,2744,doc/master/classRooLognormal.html,https://root.cern,https://root.cern/doc/master/classRooLognormal.html,1,['simpl'],['simple']
Usability,"nt variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCommittee(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption, TDirectory* theTargetDir = 0); constructor. MethodCommittee(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor for calculating Committee-MVA using previously generatad decision trees; the result of the previous training (the decision trees) are read in via the; weightfile. Make sure the ""theVariables"" correspond to the ones used in; creating the ""weight""-file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NMembers <string> number of members in the committee; UseMemberDecision <bool> use signal information from event (otherwise assume signal); UseWeightedMembers <bool> use weighted trees or simple average in classification from the forest. BoostType <string> boosting type; available values are: AdaBoost <default>; Bagging. void ProcessOptions(); process user options. void Init( void ); common initialisation with defaults for the Committee-Method. ~MethodCommittee( void ); destructor. void WriteStateToFile() const; Function to write options and weights to file. void Train( void ); training. Double_t Boost(TMVA::MethodBase* , UInt_t imember); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. Double_t AdaBoost(TMVA::MethodBase* ); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCommittee.html:18292,simpl,simple,18292,root/html528/TMVA__MethodCommittee.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html,4,['simpl'],['simple']
Usability,"nt(bin); 3565 ; 3566Bool_t TEfficiency::SetPassedEvents(Int_t bin,Int_t events); 3567{; 3568 if(events <= fTotalHistogram->GetBinContent(bin)) {; 3569 fPassedHistogram->SetBinContent(bin,events);; 3570 return true;; 3571 }; 3572 else {; 3573 Error(""SetPassedEvents(Int_t,Int_t)"",""total number of events (%.1lf) in bin %i is less than given number of passed events %i"",fTotalHistogram->GetBinContent(bin),bin,events);; 3574 return false;; 3575 }; 3576}; 3577 ; 3578////////////////////////////////////////////////////////////////////////////////; 3579/// Sets the histogram containing the passed events; 3580///; 3581/// The given histogram is cloned and stored internally as histogram containing; 3582/// the passed events. The given histogram has to be consistent with the current; 3583/// fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)).; 3584/// The method returns whether the fPassedHistogram has been replaced (true) or; 3585/// not (false).; 3586///; 3587/// Note: The list of associated functions fFunctions is cleared.; 3588///; 3589/// Option:; 3590/// - ""f"": force the replacement without checking the consistency; 3591/// This can lead to inconsistent histograms and useless results; 3592/// or unexpected behaviour. But sometimes it might be the only; 3593/// way to change the histograms. If you use this option, you; 3594/// should ensure that the fTotalHistogram is replaced by a; 3595/// consistent one (with respect to rPassed) as well.; 3596 ; 3597Bool_t TEfficiency::SetPassedHistogram(const TH1& rPassed,Option_t* opt); 3598{; 3599 TString option = opt;; 3600 option.ToLower();; 3601 ; 3602 Bool_t bReplace = option.Contains(""f"");; 3603 ; 3604 if(!bReplace); 3605 bReplace = CheckConsistency(rPassed,*fTotalHistogram);; 3606 ; 3607 if(bReplace) {; 3608 delete fPassedHistogram;; 3609 // do not add cloned histogram to gDirectory; 3610 {; 3611 TDirectory::TContext ctx(nullptr);; 3612 fPassedHistogram = (TH1*)(rPassed.Clone());; 3613 fPassedHistogram->SetNormFactor(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:142206,clear,cleared,142206,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['clear'],['cleared']
Usability,"nt* c, Window_t id, const TGWindow* parent = 0); TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); virtual voidChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGCompositeFrame.html:2475,Clear,Clear,2475,root/html532/TGCompositeFrame.html,https://root.cern,https://root.cern/root/html532/TGCompositeFrame.html,2,['Clear'],['Clear']
Usability,"nt. ;  ; Float_t fTextAngle;  Text angle. ;  ; Color_t fTextColor;  Text color. ;  ; Font_t fTextFont;  Text font. ;  ; Float_t fTextSize;  Text size. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . Private Member Functions; void ClearPixmap (Drawable *pix);  Clear the pixmap pix. ;  ; void CloseWindow1 ();  Delete current window. ;  ; void CollectImageColors (ULong_t pixel, ULong_t *&orgcolors, Int_t &ncolors, Int_t &maxcolors);  Collect in orgcolors all different original image colors. ;  ; void CopyWindowtoPixmap (Drawable *pix, Int_t xpos, Int_t ypos);  Copy area of current window in the pixmap pix. ;  ; void FindBestVisual ();  Find best visual, i.e. ;  ; Int_t FindColor (ULong_t pixel, ULong_t *orgcolors, Int_t ncolors);  Returns index in orgcolors (and fNewColors) for pixel. ;  ; void FindUsableVisual (RXVisualInfo *vlist, Int_t nitems);  Check if visual is usable, if so set fVisual, fDepth, fColormap, fBlackPixel and fWhitePixel. ;  ; void ImgPickPalette (RXImage *image, Int_t &ncol, Int_t *&R, Int_t *&G, Int_t *&B);  Returns in R G B the ncol colors of the palette used by the image. ;  ; void MakeOpaqueColors (Int_t percent, ULong_t *orgcolors, Int_t ncolors);  Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors. ;  ; void MapColorStruct (ColorStruct_t *color, RXColor &xcolor);  Map a ColorStruct_t to a XColor structure. ;  ; void MapCursor (ECursor cursor, Int_t &xcursor);  ; void MapEvent (Event_t &ev, void *xev, Bool_t tox=kTRUE);  Map Event_t structure to XEvent structure. ;  ; void MapEventMask (UInt_t &emask, UInt_t &xemask, Bool_t tox=kTRUE);  Map event mask to or from X. ;  ; void MapGCValues (GCValues_t &gval, ULong_t &xmask, RXGCValues &xgval, Bool_t tox=kTRUE);  Map a GCValues_t to a XCGValues structure if tox is true. ;  ; void MapKeySym (UInt_t &keysym, UInt_t &xkeysym, Bool_t tox=kTRUE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:49548,usab,usable,49548,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['usab'],['usable']
Usability,"nt. protected . current cursor position ; Definition at line 43 of file TGTextEdit.h. ◆ fCursor0GC. GContext_t TGTextEdit::fCursor0GC. protected . graphics context for erasing cursor ; Definition at line 37 of file TGTextEdit.h. ◆ fCursor1GC. GContext_t TGTextEdit::fCursor1GC. protected . graphics context for drawing cursor ; Definition at line 38 of file TGTextEdit.h. ◆ fCursorState. Int_t TGTextEdit::fCursorState. protected . cursor state (1=drawn, 2=erased) ; Definition at line 39 of file TGTextEdit.h. ◆ fEnableCursorWithoutFocus. Bool_t TGTextEdit::fEnableCursorWithoutFocus. protected . enable cursor visibility when focus went out from text editor window (default is kTRUE) ; Definition at line 47 of file TGTextEdit.h. ◆ fEnableMenu. Bool_t TGTextEdit::fEnableMenu. protected . enable context menu with editor actions ; Definition at line 45 of file TGTextEdit.h. ◆ fgCursor0GC. TGGC * TGTextEdit::fgCursor0GC = nullptr. staticprotected . Definition at line 50 of file TGTextEdit.h. ◆ fgCursor1GC. TGGC * TGTextEdit::fgCursor1GC = nullptr. staticprotected . Definition at line 51 of file TGTextEdit.h. ◆ fHistory. TGTextEditHist* TGTextEdit::fHistory. protected . undo manager ; Definition at line 46 of file TGTextEdit.h. ◆ fInsertMode. EInsertMode TGTextEdit::fInsertMode. protected . OPTION={GetMethod=""GetInsertMode"";SetMethod=""SetInsertMode"";Items=(kInsert=""&Insert"",kReplace=""&Replace"")} ; Definition at line 44 of file TGTextEdit.h. ◆ fMenu. TGPopupMenu* TGTextEdit::fMenu. protected . popup menu with editor actions ; Definition at line 41 of file TGTextEdit.h. ◆ fSearch. TGSearchType* TGTextEdit::fSearch. protected . structure used by search dialog ; Definition at line 42 of file TGTextEdit.h. Libraries for TGTextEdit:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGTextEdit.h; gui/gui/src/TGTextEdit.cxx. TGTextEdit. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:37 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEdit.html:61512,undo,undo,61512,doc/master/classTGTextEdit.html,https://root.cern,https://root.cern/doc/master/classTGTextEdit.html,1,['undo'],['undo']
Usability,"nt;  variable that holds the option of how to treat negative event weights in training ;  ; UInt_t fNNodesMax;  max # of nodes ;  ; Double_t fNodePurityLimit;  purity limit for sig/bkg nodes ;  ; Bool_t fNoNegWeightsInTraining;  ignore negative event weights in the training ;  ; Int_t fNTrees;  number of decision trees requested ;  ; Bool_t fPairNegWeightsGlobal;  pair ev. with neg. and pos. weights in training sample and ""annihilate"" them ;  ; DecisionTree::EPruneMethod fPruneMethod;  method used for pruning ;  ; TString fPruneMethodS;  prune method option String ;  ; Double_t fPruneStrength;  a parameter to set the ""amount"" of pruning..needs to be adjusted ;  ; Bool_t fRandomisedTrees;  choose a random subset of possible cut variables at each node during training ;  ; LossFunctionBDT * fRegressionLossFunctionBDTG;  ; TString fRegressionLossFunctionBDTGS;  the option string determining the loss function for BDT regression ;  ; std::map< const TMVA::Event *, std::vector< double > > fResiduals;  individual event residuals for gradient boost ;  ; SeparationBase * fSepType;  the separation used in node splitting ;  ; TString fSepTypeS;  the separation (option string) used in node splitting ;  ; Double_t fShrinkage;  learning rate for gradient boost; ;  ; Double_t fSigToBkgFraction;  Signal to Background fraction assumed during training. ;  ; Bool_t fSkipNormalization;  true for skipping normalization at initialization of trees ;  ; std::vector< const TMVA::Event * > fSubSample;  subsample for bagged grad boost ;  ; std::vector< const TMVA::Event * > * fTrainSample;  pointer to sample actually used in training (fEventSample or fSubSample) for example ;  ; Bool_t fTrainWithNegWeights;  yes there are negative event weights and we don't ignore them ;  ; Bool_t fUseExclusiveVars;  individual variables already used in fisher criterium are not anymore analysed individually for node splitting ;  ; Bool_t fUseFisherCuts;  use multivariate splits using the Fisher criterium ;  ; U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:37837,learn,learning,37837,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['learn'],['learning']
Usability,"nt> Randomize(float alpha, float beta, Double_t& seed); Randomize matrix element values. void TMatrixTBase<Element> Streamer(TBuffer& b); Stream an object of class TMatrixTBase<Element>. template<class Element> Element TMatrixTBase<Element> SetTol(float newTol). Element * GetElements(). Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fNcols+fColLwb-1; }. Int_t GetNcols() const; { return fNcols; }. Int_t GetNoElements() const; { return fNelems; }. Element GetTol() const; { return fTol; }. const Element * GetMatrixArray() const. Element * GetMatrixArray(). const Int_t * GetRowIndexArray() const. Int_t * GetRowIndexArray(). const Int_t * GetColIndexArray() const. Int_t * GetColIndexArray(). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data). TMatrixTBase<Element> & SetColIndexArray(Int_t* data). void Clear(Option_t* option = """"). void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. TMatrixTBase<Element> & GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). TMatrixTBase<Element> & ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1). Double_t Determinant() const; { AbstractMethod(""Determinant()""); return 0.; }. void Determinant(Double_t& d1, Double_t& d2) const; { AbstractMethod(""Determinant()""); d1 = 0.; d2 = 0.; }. Element NormInf() const; { return RowNorm(); }. Element Norm1() const; { return ColNorm(); }. Element operator()(Int_t rown, Int_t coln) const. Element & operator()(Int_t rown, Int_t coln). » Last changed: root/matrix:$Id: TMatrixTBase.h 20882 2007-11-19 11:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixTBase_float_.html:21293,Clear,Clear,21293,root/html532/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html532/TMatrixTBase_float_.html,1,['Clear'],['Clear']
Usability,"nt> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id: TVectorT.h 39086 2011-05-04 09:36:17Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVectorT_double_.html:18523,Clear,Clear,18523,root/html532/TVectorT_double_.html,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html,1,['Clear'],['Clear']
Usability,"nt> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t nrows, const float* data) const; { return Use(0,nrows-1,data); }. template <class Element> inline TMatrixTSym<Element> &TMatrixTSym<Element> Use(TMatrixTSym<float>& a); { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(const TMatrixTSym<float>& a) const; { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline TMatrixTSym<Element> TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixTSym<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixTSym<Element> operator()(Int_t rown, Int_t coln). void Mult(const TMatrixTSym<float>& a); { TMult(a); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). Bool_t IsSymmetric() const; { return kTRUE; }. TMatrixTSym <Element> & Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id$ » Last generated: 2015-03-14 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixTSym_float_.html:22365,Clear,Clear,22365,root/html534/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html534/TMatrixTSym_float_.html,1,['Clear'],['Clear']
Usability,"nt> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t nrows, const float* data) const; { return Use(0,nrows-1,data); }. template <class Element> inline TMatrixTSym<Element> &TMatrixTSym<Element> Use(TMatrixTSym<float>& a); { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(const TMatrixTSym<float>& a) const; { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline TMatrixTSym<Element> TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixTSym<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixTSym<Element> operator()(Int_t rown, Int_t coln). void Mult(const TMatrixTSym<float>& a); { TMult(a); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). Bool_t IsSymmetric() const; { return kTRUE; }. TMatrixTSym <Element> & Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMatrixTSym_float_.html:23114,Clear,Clear,23114,root/html604/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html,1,['Clear'],['Clear']
Usability,"nt> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t nrows, const float* data) const; { return Use(0,nrows-1,data); }. template <class Element> inline TMatrixTSym<Element> &TMatrixTSym<Element> Use(TMatrixTSym<float>& a); { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(const TMatrixTSym<float>& a) const; { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline TMatrixTSym<Element> TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixTSym<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixTSym<Element> operator()(Int_t rown, Int_t coln). void Mult(const TMatrixTSym<float>& a); { TMult(a); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). Bool_t IsSymmetric() const; { return kTRUE; }. TMatrixTSym <Element> & Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id$ » Last generated: 2015-06-30 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSym_float_.html:23068,Clear,Clear,23068,root/html602/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSym_float_.html,1,['Clear'],['Clear']
Usability,"ntFunctionMultiDim&); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(const ROOT::Math::IGradientMultiDim&); virtual TClass*IsA() const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TPyMultiGradFunction(PyObject* self = 0). private:. TPyMultiGradFunction&operator=(const TPyMultiGradFunction&); TPyMultiGradFunction(const TPyMultiGradFunction& src). Data Members; private:. PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyMultiGradFunction(PyObject* self = 0); Construct a TPyMultiGradFunction derived with <self> as the underlying. ~TPyMultiGradFunction(); Destructor. Only deref if still holding on to Py_None (circular otherwise). unsigned int NDim() const; Simply forward the call to python self. double DoEval(const double* x) const; Simply forward the call to python self. void Gradient(const double* x, double* grad) const; Simply forward the call to python self. void FdF(const double* x, double& f, double* df) const; Simply forward the call to python self. double DoDerivative(const double* x, unsigned int icoord) const; Simply forward the call to python self. ROOT::Math::IBaseFunctionMultiDim* Clone() const; Math::IMultiGenFunction implementation. { return new TPyMultiGenFunction( fPySelf ); }. TPyMultiGenFunction& operator=(const TPyMultiGradFunction& ); { return *this; }. TPyMultiGradFunction(PyObject* self = 0); ctor/dtor, and assignment. » Last changed: Tue Jun 2 16:31:16 2015 » Last generated: 2015-06-02 16:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPyMultiGradFunction.html:2404,Simpl,Simply,2404,root/html604/TPyMultiGradFunction.html,https://root.cern,https://root.cern/root/html604/TPyMultiGradFunction.html,5,['Simpl'],['Simply']
Usability,"ntLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. TMultiLayerPerceptr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:8054,simpl,simple,8054,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,2,['simpl'],['simple']
Usability,"ntLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. virtual~TMultiLayer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMultiLayerPerceptron.html:8054,simpl,simple,8054,root/html602/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html602/TMultiLayerPerceptron.html,4,['simpl'],['simple']
Usability,"nt_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch(const char* name, const char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNtuple.html:2947,Clear,Clear,2947,root/html532/TNtuple.html,https://root.cern,https://root.cern/root/html532/TNtuple.html,1,['Clear'],['Clear']
Usability,"nt_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch(const char* name, const char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* vare",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNtupleD.html:2958,Clear,Clear,2958,root/html532/TNtupleD.html,https://root.cern,https://root.cern/root/html532/TNtupleD.html,1,['Clear'],['Clear']
Usability,"nt_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooThresholdCategory.html:2241,clear,clearValueAndShapeDirty,2241,root/html534/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"nt_t fNEntriesSinceSorting; ///<! Number of entries processed since the last re-sorting of branches; 144 std::vector<std::pair<Long64_t,TBranch*>> fSortedBranches; ///<! Branches to be processed in parallel when IMT is on, sorted by average task time; 145 std::vector<TBranch*> fSeqBranches; ///<! Branches to be processed sequentially when IMT is on; 146 Float_t fTargetMemoryRatio{1.1f}; ///<! Ratio for memory usage in uncompressed buffers versus actual occupancy. 1.0; 147 /// indicates basket should be resized to exact memory usage, but causes significant; 148/// memory churn.; 149#ifdef R__TRACK_BASKET_ALLOC_TIME; 150 mutable std::atomic<ULong64_t> fAllocationTime{0}; ///<! Time spent reallocating basket memory buffers, in microseconds.; 151#endif; 152 mutable std::atomic<UInt_t> fAllocationCount{0}; ///<! Number of reallocations basket memory buffers.; 153 ; 154 static Int_t fgBranchStyle; ///< Old/New branch style; 155 static Long64_t fgMaxTreeSize; ///< Maximum size of a file containing a Tree; 156 ; 157private:; 158 // For simplicity, although fIMTFlush is always disabled in non-IMT builds, we don't #ifdef it out.; 159 mutable bool fIMTFlush{false}; ///<! True if we are doing a multithreaded flush.; 160 mutable std::atomic<Long64_t> fIMTTotBytes; ///<! Total bytes for the IMT flush baskets; 161 mutable std::atomic<Long64_t> fIMTZipBytes; ///<! Zip bytes for the IMT flush baskets.; 162 ; 163 void InitializeBranchLists(bool checkLeafCount);; 164 void SortBranchesByTime();; 165 Int_t FlushBasketsImpl() const;; 166 void MarkEventCluster();; 167 Long64_t GetMedianClusterSize();; 168 ; 169protected:; 170 virtual void KeepCircular();; 171 virtual TBranch *BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel);; 172 virtual TBranch *BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel);; 173 virtual TBranch *BranchImpRef(const char* branchname, const char* cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:7876,simpl,simplicity,7876,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['simpl'],['simplicity']
Usability,"nt_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. » Last changed: Mon Dec 7 13:48:35 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:5287,clear,clearOnRedirect,5287,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,1,['clear'],['clearOnRedirect']
Usability,"nt_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTGComboBox::Init(); voidTObject::MakeZombie(); TGWindow&TGWindow::operator=(const TGWindow& tgw); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGFontTypeComboBox.html:17351,Clear,ClearFlags,17351,root/html532/TGFontTypeComboBox.html,https://root.cern,https://root.cern/root/html532/TGFontTypeComboBox.html,6,['Clear'],['ClearFlags']
Usability,"nt_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInit(); voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGComboBox&operator=(const TGComboBox&); TGComboBox(const TGComboBox&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTGWi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGComboBox.html:17021,Clear,ClearFlags,17021,root/html602/TGComboBox.html,https://root.cern,https://root.cern/root/html602/TGComboBox.html,2,['Clear'],['ClearFlags']
Usability,nt_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:19051,learn,learning,19051,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['learn'],['learning']
Usability,"nt_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTubeEditor.html:21244,undo,undoing,21244,root/html528/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html528/TGeoTubeEditor.html,1,['undo'],['undoing']
Usability,"nt_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTubeEditor.html:21344,undo,undoing,21344,root/html530/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html530/TGeoTubeEditor.html,1,['undo'],['undoing']
Usability,"nt_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTubeEditor.html:21344,undo,undoing,21344,root/html532/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html532/TGeoTubeEditor.html,2,['undo'],['undoing']
Usability,"nt_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube segment editor. ~TGeoTubeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTubeSegEditor.html:22808,undo,undoing,22808,root/html604/TGeoTubeSegEditor.html,https://root.cern,https://root.cern/root/html604/TGeoTubeSegEditor.html,2,['undo'],['undoing']
Usability,"nt_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube segment editor. ~TGeoTubeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTubeSegEditor.html:22808,undo,undoing,22808,root/html602/TGeoTubeSegEditor.html,https://root.cern,https://root.cern/root/html602/TGeoTubeSegEditor.html,2,['undo'],['undoing']
Usability,"nt_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). virtual ~TGProgressBar(); { }. Float_t GetMin() const; { return fMin; }. Float_t GetMax() const; { return fMax; }. Float_t GetPosition() const; { return fPos; }. EFillType GetFillType() const; { return fFillType; }. EBarType GetBarType() const; { return fBarType; }. Bool_t GetShowPos() const; { return fShowPos; }. TString GetFormat() const; { return fFormat; }. const char* GetValueFormat() const; { return fFormat.Data(); }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGProgressBar.html:19478,progress bar,progress bar,19478,root/html528/TGProgressBar.html,https://root.cern,https://root.cern/root/html528/TGProgressBar.html,6,['progress bar'],['progress bar']
Usability,"nt_tTObject::TestBits(UInt_t f) const; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidCreateDisabledPicture(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TStringGetTypeString() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGSlider&operator=(const TGSlider&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGSlider.html:14979,Clear,ClearFlags,14979,root/html532/TGSlider.html,https://root.cern,https://root.cern/root/html532/TGSlider.html,2,['Clear'],['ClearFlags']
Usability,"ntainer_type::iterator TMVA::DNN::Net::iterator_type. Definition at line 1066 of file NeuralNet.h. Constructor & Destructor Documentation. ◆ Net() [1/2]. TMVA::DNN::Net::Net ; (; ). inline . c'tor ; Definition at line 1074 of file NeuralNet.h. ◆ Net() [2/2]. TMVA::DNN::Net::Net ; (; const Net & ; other). inline . d'tor ; Definition at line 1085 of file NeuralNet.h. Member Function Documentation. ◆ addLayer() [1/2]. void TMVA::DNN::Net::addLayer ; (; Layer && ; layer). inline . Definition at line 1095 of file NeuralNet.h. ◆ addLayer() [2/2]. void TMVA::DNN::Net::addLayer ; (; Layer & ; layer). inline . add a layer (layout) ; Definition at line 1094 of file NeuralNet.h. ◆ backPropagate(). template<typename Settings > . void TMVA::DNN::Net::backPropagate ; (; std::vector< std::vector< LayerData > > & ; layerPatternData, . const Settings & ; settings, . size_t ; trainFromLayer, . size_t ; totalNumWeights . ); const. Definition at line 1355 of file NeuralNet.icc. ◆ clear(). void TMVA::DNN::Net::clear ; (; ). inline . Definition at line 1251 of file NeuralNet.h. ◆ compute(). template<typename Weights > . std::vector< double > TMVA::DNN::Net::compute ; (; const std::vector< double > & ; input, . const Weights & ; weights . ); const. compute the net with the given input and the given weights ; compute the neural net; Parameters. inputthe input data ; weightsthe weight data . Definition at line 1037 of file NeuralNet.icc. ◆ computeError(). template<typename ItWeight > . std::tuple< double, double > TMVA::DNN::Net::computeError ; (; const Settings & ; settings, . std::vector< LayerData > & ; lastLayerData, . Batch & ; batch, . ItWeight ; itWeightBegin, . ItWeight ; itWeightEnd . ); const. Definition at line 1321 of file NeuralNet.icc. ◆ dE(). void TMVA::DNN::Net::dE ; (; ). ◆ dropOutWeightFactor(). template<typename WeightsType , typename DropProbabilities > . void TMVA::DNN::Net::dropOutWeightFactor ; (; WeightsType & ; weights, . const DropProbabilities & ; drops, . bool ; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html:8277,clear,clear,8277,doc/master/classTMVA_1_1DNN_1_1Net.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html,1,['clear'],['clear']
Usability,"ntainment. This is accomplished by positioning some volumes inside others. Any volume is an un-positioned object in the sense that it defines only a local frame (matching the one of its shape). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a local geometrical transformation of the daughter with respect to the mother coordinate system. These transformations will be subsequently used in the example.; Q: “I see the lines defining the top level volume as in the previous example, but what about the other volumes named REPLICA and ROOT?”; A: You will also notice that several other volumes are created by using lines like:; TGeoVolume *someVolume = gGeoManager->MakeXXX(""someName"",; ptrMedium, /* parameters coresponding to XXX ...*/); In the method above XXX represent some shape name (Box, Tube, etc.). This is just a simple way of creating a volume having a given shape in one-step (see also section: “Creating and Positioning Volumes”). As for REPLICA and ROOT volumes, they are just some virtual volumes used for grouping and positioning together other real volumes. See “Positioned Volumes (Nodes)”. The same structure represented by (a real or) a virtual volume can be replicated several times in the geometry.; Q: “Fine, so probably the real volumes are the ones composing the letters R, O and T. Why one have to define so many volumes to make an R?”; A: Well, in real life some objects have much more complex shapes that an R. The modeller cannot just know all of them; the idea is to make a complex object by using elementary building blocks that have known shapes (called primitive shapes). Gluing these together in the appropriate way is the user responsibility.; Q: “I am getting the global picture but not making much out of it… There are also a lot of calls to TGeoVolume::AddNode() that I do not understand.”; A: A volume is positioned inside another one b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:880886,simpl,simple,880886,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"ntains 'built', reset this StreamerInfo as if Build or BuildOld; 2614/// was never called on it (useful to force their re-running).; 2615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105607,clear,clear,105607,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * If the objects are added using the placement new then the Clear must; deallocate the memory.; * If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClonesArray.html:3946,clear,clearing,3946,root/html604/TClonesArray.html,https://root.cern,https://root.cern/root/html604/TClonesArray.html,3,"['Clear', 'clear']","['Clear', 'clearing']"
Usability,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:3946,clear,clearing,3946,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,6,"['Clear', 'clear']","['Clear', 'clearing']"
Usability,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClonesArray.html:3946,clear,clearing,3946,root/html602/TClonesArray.html,https://root.cern,https://root.cern/root/html602/TClonesArray.html,3,"['Clear', 'clear']","['Clear', 'clearing']"
Usability,"ntation. ◆ Class(). static TClass * TGFont::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGFont::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGFont::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 209 of file TGFont.h. ◆ ComputeTextLayout(). TGTextLayout * TGFont::ComputeTextLayout ; (; const char * ; string, . Int_t ; numChars, . Int_t ; wrapLength, . Int_t ; justify, . Int_t ; flags, . UInt_t * ; width, . UInt_t * ; height . ); const. Computes the amount of screen space needed to display a multi-line, justified string of text. ; Records all the measurements that were done to determine to size and positioning of the individual lines of text; this information can be used by the TGTextLayout::DrawText() procedure to display the text quickly (without remeasuring it).; This procedure is useful for simple widgets that want to display single-font, multi-line text and want TGFont to handle the details.; The return value is a TGTextLayout token that holds the measurement information for the given string. The token is only valid for the given string. If the string is freed, the token is no longer valid and must also be deleted.; The dimensions of the screen area needed to display the text are stored in *width and *height.; string – String whose dimensions are to be computed. numChars – Number of characters to consider from string, or < 0 for strlen(). wrapLength – Longest permissible line length, in pixels. <= 0 means no automatic wrapping: just let lines get as long as needed. justify – How to justify lines. flags – Flag bits OR-ed together. kTextIgnoreTabs means that tab characters should not be expanded. kTextIgnoreNewlines means that newline characters should not cause a line break. width – Filled with width of string. height – Filled with height of string. ; Definition at line 661 of file TGFont.cxx. ◆ DeclFileNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFont.html:16174,simpl,simple,16174,doc/master/classTGFont.html,https://root.cern,https://root.cern/doc/master/classTGFont.html,1,['simpl'],['simple']
Usability,"ntents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 502 of file RooProduct.cxx. ◆ realComponents(). const RooArgList & RooProduct::realComponents ; (; ); const. inline . Definition at line 50 of file RooProduct.h. ◆ setCacheAndTrackHints(). void RooProduct::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Label OK'ed components of a RooProduct with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 479 of file RooProduct.cxx. ◆ Streamer(). void RooProduct::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooProduct::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 93 of file RooProduct.h. ◆ translate(). void RooProduct::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 493 of file RooProduct.cxx. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooProduct::_cacheMgr. mutableprotected . Definition at line 82 of file RooProduct.h. ◆ _compCSet. RooListProxy RooProduct::_compCSet. protected . Definition at line 72 of file RooProduct.h. ◆ _compRSet. RooListProxy RooProduct::_compRSet. protected . Definition at line 71 of file RooProduct.h. Libraries for RooProduct:. [legend]; The docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:68857,simpl,simple,68857,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,1,['simpl'],['simple']
Usability,"nter or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance Chart:. TTabCom. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char[] path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:8191,Clear,ClearUsers,8191,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,2,['Clear'],['ClearUsers']
Usability,"nter to TGeoManager owning this volume; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TGeoMedium*TGeoVolume::fMediumtracking medium; TStringTNamed::fNameobject identifier; TObjArray*TGeoVolume::fNodesarray of nodes inside this volume; Int_tTGeoVolume::fNtotaltotal number of physical nodes; Int_tTGeoVolume::fNumbervolume serial number in the list of volumes; TStringTGeoVolume::fOption! option - if any; Int_tTGeoVolume::fRefCountreference counter; TGeoShape*TGeoVolume::fShapeshape; vector<ThreadData_t*>fThreadData! Thread specific data vector; Int_tfThreadSize! Thread vector size; TStringTNamed::fTitleobject title; TGeoExtension*TGeoVolume::fUserExtension! Transient user-defined extension to volumes; TGeoVoxelFinder*TGeoVolume::fVoxelsfinder object for bounding boxes; static TGeoMedium*TGeoVolume::fgDummyMedium! dummy medium. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads). Int_t GetCurrentNodeIndex() const. Int_t GetNextNodeIndex() const. void SetCurrentNodeIndex(Int_t index). void SetNextNodeIndex(Int_t index). TGeoVolumeAssembly(); Default constructor. TGeoVolumeAssembly(const char* name); Constructor. Just the name has to be provided. Assemblies does not have their own; shape or medium. ~TGeoVolumeAssembly(); Destructor. The assembly is owner of its ""shape"". void AddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); Add a component to the assembly. void AddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option); Add an overlapping node - not allowed for assemblies. TGeoVolume * CloneVolume() const; Clone this volume.; build a volume with same name, shape and medium. TGeoVolume * Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Division makes no sense for ass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeAssembly.html:33839,Clear,ClearThreadData,33839,root/html534/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeAssembly.html,1,['Clear'],['ClearThreadData']
Usability,"nterface* interface = 0, UInt_t nrows = 50, UInt_t ncolumns = 20); virtual~TGTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTable.html:4748,Clear,Clear,4748,root/html532/TGTable.html,https://root.cern,https://root.cern/root/html532/TGTable.html,1,['Clear'],['Clear']
Usability,"nternal::VecOps::RVecInlineStorageSize< T >::value >inline; at(size_type pos) constROOT::VecOps::RVecN< T, Internal::VecOps::RVecInlineStorageSize< T >::value >inline; at(size_type pos, value_type fallback)ROOT::VecOps::RVecN< T, Internal::VecOps::RVecInlineStorageSize< T >::value >inline; at(size_type pos, value_type fallback) constROOT::VecOps::RVecN< T, Internal::VecOps::RVecInlineStorageSize< T >::value >inline; back()ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; back() constROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; Base typedefROOT::Internal::VecOps::SmallVectorTemplateCommon< T >private; begin() noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; begin() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; capacity() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; capacity_in_bytes() constROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; cbegin() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; cend() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; clear()ROOT::Detail::VecOps::RVecImpl< T >inline; const_iterator typedefROOT::Detail::VecOps::RVecImpl< T >; const_pointer typedefROOT::Internal::VecOps::SmallVectorTemplateCommon< T >; const_reference typedefROOT::VecOps::RVec< T >; const_reverse_iterator typedefROOT::Internal::VecOps::SmallVectorTemplateCommon< T >; crbegin() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; crend() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; data() noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; data() const noexceptROOT::Internal::VecOps::SmallVectorTemplateCommon< T >inline; destroy_range(T *S, T *E)ROOT::Internal::VecOps::SmallVectorTemplateBase< T, bool >inlineprotectedstatic; difference_type typedefROOT::Internal::VecOps::SmallVectorTemplateCommon< T >; emplace_back(ArgTypes &&.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec-members.html:1913,clear,clear,1913,doc/master/classROOT_1_1VecOps_1_1RVec-members.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec-members.html,1,['clear'],['clear']
Usability,"ntext &ctx) const override;  This function defines the analytical integral translation for the class. ;  ; TObject * clone (const char *newname) const override;  ; void generateEvent (Int_t code) override;  algorithm adapted from code example in: Marsaglia, G. ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGamma.html:2889,simpl,simple,2889,doc/master/classRooGamma.html,https://root.cern,https://root.cern/doc/master/classRooGamma.html,1,['simpl'],['simple']
Usability,"nticate the request as genuine. As an end user, you must know the Access Key and Secret Access Key; in order to access each S3 file. They are provided to you by your S3; service provider. Those two keys can be provided to ROOT when; initializing an object of this class by two means:; a) by using the environmental variables S3_ACCESS_KEY and; S3_SECRET_KEY, or; b) by specifying them when opening each file. The first method is convenient if all the S3 files you want to; access are hosted by a single provider. The second one is more; flexible as it allows you to specify which credentials to use; on a per-file basis. See the documentation of the constructor of; this class for details on the syntax. For generating and signing the HTTP request, this class uses; TS3HTTPRequest. For more information on the details of S3 protocol please refer to:; ""Amazon Simple Storage Service Developer Guide"":; http://docs.amazonwebservices.com/AmazonS3/latest/dev/Welcome.html. ""Amazon Simple Storage Service REST API Reference""; http://docs.amazonwebservices.com/AmazonS3/latest/API/APIRest.html. Function Members (Methods); public:. TS3WebFile(const char* url, Option_t* options = """"); virtual~TS3WebFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:2010,Simpl,Simple,2010,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,1,['Simpl'],['Simple']
Usability,"nticate the request as genuine. As an end user, you must know the Access Key and Secret Access Key; in order to access each S3 file. They are provided to you by your S3; service provider. Those two keys can be provided to ROOT when; initializing an object of this class by two means:; a) by using the environmental variables S3_ACCESS_KEY and; S3_SECRET_KEY, or; b) by specifying them when opening each file. The first method is convenient if all the S3 files you want to; access are hosted by a single provider. The second one is more; flexible as it allows you to specify which credentials to use; on a per-file basis. See the documentation of the constructor of; this class for details on the syntax. For generating and signing the HTTP request, this class uses; TS3HTTPRequest. For more information on the details of S3 protocol please refer to:; ""Amazon Simple Storage Service Developer Guide"":; http://docs.amazonwebservices.com/AmazonS3/latest/dev/Welcome.html. ""Amazon Simple Storage Service REST API Reference""; http://docs.amazonwebservices.com/AmazonS3/latest/API/APIRest.html. Function Members (Methods); public:. virtual~TS3WebFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:2034,Simpl,Simple,2034,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,2,['Simpl'],['Simple']
Usability,"ntribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this method returns the uncertainties on the unfolding result arising from the background source source and its normalisation uncertainty. See method SubtractBackground() how to set the normalisation uncertainty ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1144 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundUncorr(). void TUnfoldSys::GetEmatrixSysBackgroundUncorr ; (; TH2 * ; ematrix, . const char * ; source, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background uncorrelated uncertainty ; Parameters. [in]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:38694,clear,clearEmat,38694,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,2,['clear'],"['clear', 'clearEmat']"
Usability,"ntrolled by two parameters: the “Display modes groups” and the “Display Modes”. “Display modes groups” can take the following values:. 0 = Simple - simple display modes using one color only; 1 = Light - the shading is carried out according to the position of the fictive light source; 2 = Height - the shading is carried out according to the channel contents; 3 = LightHeight - combination of two previous shading algorithms (one can control the weight between both algorithms). “Display modes” can take the following values:. 1 = Points; 2 = Grid; 3 = Contours; 4 = Bars; 5 = LinesX; 6 = LinesY; 7 = BarsX; 8 = BarsY; 9 = Needles; 10 = Surface; 11 = Triangles. These parameters can be set by using the “dm” operator in the option.; h2->Draw(""SPEC dm(1,2)"");; The above example draws the histogram using the “Light Display mode group” and the “Grid Display mode”. The following tables summarize all the possible combinations of both groups:. Points; Grid; Contours; Bars; LinesX; LinesY. Simple; x; x; x; x; x; x. Light; x; x. x; x. Height; x; x; x; x; x; x. LightHeight; x; x. x; x. BarsX; BarsY; Needles; Surface; Triangles. Simple; x; x; x. x. Light. x; x. Height; x; x. x; x. LightHeight. x; x. The “Pen Attributes” can be changed using pa(color,style,width). Next example sets line color to 2, line type to 1 and line width to 2. Note that if pa() is not specified, the histogram line attributes are used:; h2->Draw(""SPEC dm(1,2) pa(2,1,2)"");; The number of “Nodes” can be changed with n(nodesx,nodesy). Example:; h2->Draw(""SPEC n(40,40)"");; Sometimes the displayed region is rather large. When displaying all channels the pictures become very dense and complicated. It is very difficult to understand the overall shape of data. “n(nx,ny)” allows to change the density of displayed channels. Only the channels coinciding with given nodes are displayed.; The visualization “Angles” can be changed with “a(alpha,beta,view)”: “alpha” is the angle between the bottom horizontal screen line and the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:102506,Simpl,Simple,102506,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simple']
Usability,"ntry, Int_t btn, Int_t x, Int_t y);  Emit Clicked() signal. ;  ; virtual void Clicked (TGListTreeItem *entry, Int_t btn, UInt_t mask, Int_t x, Int_t y);  Emit Clicked() signal. ;  ; void CloseItem (TGListTreeItem *item);  Close item in list tree (i.e. hide child items). ;  ; virtual void DataDropped (TGListTreeItem *item, TDNDData *data);  Emit DataDropped() signal. ;  ; Int_t DeleteChildren (TGListTreeItem *item);  Delete children of item from list. ;  ; Int_t DeleteItem (TGListTreeItem *item);  Delete item from list tree. ;  ; Int_t DeleteSelected ();  ; void DisableOpen (Bool_t disable=kTRUE);  ; virtual void DoubleClicked (TGListTreeItem *entry, Int_t btn);  Emit DoubleClicked() signal. ;  ; virtual void DoubleClicked (TGListTreeItem *entry, Int_t btn, Int_t x, Int_t y);  Emit DoubleClicked() signal. ;  ; virtual void DrawActive (Handle_t id, TGListTreeItem *item);  Draw active item with its active color. ;  ; virtual void DrawOutline (Handle_t id, TGListTreeItem *item, Pixel_t col=0xbbbbbb, Bool_t clear=kFALSE);  Draw a outline of color 'col' around an item. ;  ; void DrawRegion (Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Redraw list tree. ;  ; void End (Bool_t select=kFALSE) override;  Move content to the bottom. ;  ; TGListTreeItem * FindChildByData (TGListTreeItem *item, void *userData);  Find child of item by userData. ;  ; TGListTreeItem * FindChildByName (TGListTreeItem *item, const char *name);  Find child of item by name. ;  ; TGListTreeItem * FindItemByObj (TGListTreeItem *item, void *ptr);  Find item with fUserData == ptr. ;  ; TGListTreeItem * FindItemByPathname (const char *path);  Find item by pathname. ;  ; TGListTreeItem * FindSiblingByData (TGListTreeItem *item, void *userData);  Find sibling of item by userData. ;  ; TGListTreeItem * FindSiblingByName (TGListTreeItem *item, const char *name);  Find sibling of item by name. ;  ; Int_t FontAscent ();  Returns ascent of currently used font. ;  ; Int_t FontHeight ();  Returns height of current",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGListTree.html:4955,clear,clear,4955,doc/master/classTGListTree.html,https://root.cern,https://root.cern/doc/master/classTGListTree.html,1,['clear'],['clear']
Usability,"nts of the TGraph, do not need to form a closed polygon, since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point with the first one. It is clear that the order of the point is essential in defining the polygon. Also note that the segments should not intersect.; NB:; if last=-1 (default) last is set to the last point.; if (first <0) the first point (0) is taken. Method:; There are many ways to calculate the surface of a polygon. It all depends on what kind of data you have to deal with. The most evident solution would be to divide the polygon in triangles and calculate the surface of them. But this can quickly become complicated as you will have to test every segments of every triangles and check if they are intersecting with a current polygon's segment or if it goes outside the polygon. Many calculations that would lead to many problems... The solution (implemented by R.Brun); Fortunately for us, there is a simple way to solve this problem, as long as the polygon's segments don't intersect. It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area. Sources. http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon . Definition at line 1808 of file TGraph.cxx. ◆ IsA(). TClass * TGraph::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TGraphPolar, TGraphQQ, TGraphAsymmErrors, TGraphBentErrors, TGraphErrors, and TGraphMultiErrors.; Definition at line 203 of file TGraph.h. ◆ IsEditable(). virtual Bool_t TGraph::IsEditable ; (; ); const. inlinevirtual . Definition at line 166 of file TGraph.h. ◆ IsHighlight().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:62132,simpl,simple,62132,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['simpl'],['simple']
Usability,"nts the info about the layer. ;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; virtual void ReadWeightsFromXML (void *parent)=0;  Read the information and the weights about the layer from XML node. ;  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Protected Attributes; Tensor_t fActivationGradients;  Gradients w.r.t. the activations of this layer. ;  ; size_t fBatchSize;  Batch size used for trainin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:5303,learn,learningRate,5303,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"nts-kModeGroupHeight, modes of combination of shading according to light and to channels counts-kModeGroupLightHeight); Double_tfMxx; Double_tfMxy; Double_tfMyx; Double_tfMyy; TStringTNamed::fNameobject identifier; TColor*fNewColor!; Int_tfNewColorIndex; Int_tfNodesxnumber of nodes in x dimension of grid; Int_tfNodesynumber of nodes in y dimension of grid; Double_tfNuSli; Int_tfPenColorcolor of spectrum; Int_tfPenDashstyle of pen; Int_tfPenWidthwidth of line; Double_tfRainbow1Stepdetermines the first component step for neighbouring color levels, applies only for rainbowed display modes, it does not apply for simple display modes algorithm group; Double_tfRainbow2Stepdetermines the second component step for neighbouring color levels, applies only for rainbowed display modes, it does not apply for simple display modes algorithm group; Double_tfRainbow3Stepdetermines the third component step for neighbouring color levels, applies only for rainbowed display modes, it does not apply for simple display modes algorithm group; Int_tfShadingdetermines whether the picture will shaded, smoothed (no shading, shading), for rainbowed display modes only; Int_tfShadowdetermines whether shadow will be drawn (no shadow, shadow), for rainbowed display modes with shading according to light; TStringTNamed::fTitleobject title; Double_tfTxx; Double_tfTxy; Double_tfTyx; Double_tfTyy; Double_tfTyz; Int_tfViewAnglerotation angle of the view, it can be 0, 90, 180, 270 degrees; Double_tfVx; Double_tfVy; Int_tfXe; Int_tfXlightx position of fictive light source, applies only for rainbowed display modes with shading according to light; Int_tfXmaxx-end channel of spectrum; Int_tfXminx-starting channel of spectrum; Int_tfXs; Int_tfXt; Int_tfYe; Int_tfYlighty position of fictive light source, applies only for rainbowed display modes with shading according to light; Int_tfYmaxy-end channel of spectrum; Int_tfYminy-starting channel of spectrum; Int_tfYs; Int_tfYt; Double_tfZ; Double_tfZPresetValue; Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Painter.html:12342,simpl,simple,12342,root/html528/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Painter.html,10,['simpl'],['simple']
Usability,"nu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMultiLayerPerceptron ();  Default constructor. ;  ;  TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  ~TMultiLayerPerceptron () override;  Destructor. ;  ; void ComputeDEDw () const;  Compute the DEDw = sum on all training events of dedw for each weight normalized by the number of events. ;  ; void Draw (Option_t *option="""") override;  Draws the network structure. ;  ; void DrawResult (Int_t index=0, Option_t *option=""test"") const;  Draws the neural net output It produces an histogram with the output for the two datasets. ;  ; Bool_t DumpWeights (Option_t *filename=""-"") const;  Dumps t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:10982,simpl,simple,10982,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"nual for a detailed description.; Obtaining Tig; Tig is available as package from many Linux distributions. On Debian/Ubuntu it is available with the package name tig from the default repositories.; On RHEL-based systems it is available from the additional repository RepoForge.; On OS X it is easily installed via Homebrew:; brew install tig. Tig pager mode; Many git commands can be piped into tig. When tig is invoked this way, it is in pager mode: output will be colored according to the input format, and colored.; For instance it is possible to pipe the differences of one file like this:; git diff path/to/file.cxx | tig. or see the changes of one revision like this:; git show b204d4c87 | tig. The most important interactive tig commands are:. 'h': opens the help screen; 'q': closes current window; 'Q': closes all windows and exits. Log view; Tig invoked without any argument spawns a full log view with one line per commit including author, date and log message. Heads of the different branches are clearly indicated. To see a graph view indicating branching graphically (just like git log --oneline --graph), do:; tig --all. A log can be selected with Enter to see the revision changes.; An example of useful application of the log view is interactive cherry-picking: just press 'C' to cherry-pick currently selected commit into your current branch.; Blame view; Blame view is extremely useful to see which lines were committed by whom. It is an improved version of the standard git blame command with a much clearer and interactive output.; Each line can be selected to display the associated full commit log and diff. Usage:; tig blame path/to/file.cxx. Interactive staging and current status; tig status opens an interactive display to quickly select files to be staged. Move over the file and press 'u' to (un)stage it. The .gitconfig file; This file contains global (~/.gitconfig) or repository-local configuration settings. You can (eg):. Set user and email information to label comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:17285,clear,clearly,17285,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['clear'],['clearly']
Usability,"null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. RooAbsArg* findArg(const RooAbsArg* ) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. RooLinkedListIter iterator(Bool_t dir = kTRUE) const. RooFIter fwdIterator() const. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. TObject* Clone(const char* = 0) const. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Fri Dec 2 14:26:52 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinkedList.html:9437,simpl,simple,9437,root/html532/RooLinkedList.html,https://root.cern,https://root.cern/root/html532/RooLinkedList.html,2,['simpl'],['simple']
Usability,"nullptr;; 3821 while (lnk) {; 3822 auto obj = lnk->GetObject();; 3823 if (obj->InheritsFrom(TPad::Class())); 3824 ((TPad*)obj)->PaintModified();; 3825 lnk = lnk->Next();; 3826 }; 3827 return;; 3828 }; 3829 ; 3830 if (fCanvas) TColor::SetGrayscale(fCanvas->IsGrayscale());; 3831 ; 3832 TVirtualPS *saveps = gVirtualPS;; 3833 if (gVirtualPS) {; 3834 if (gVirtualPS->TestBit(kPrintingPS)); 3835 gVirtualPS = nullptr;; 3836 }; 3837 ; 3838 Bool_t began3DScene = kFALSE;; 3839 fPadPaint = 1;; 3840 {; 3841 TContext ctxt(this, kTRUE);; 3842 if (IsModified() || IsTransparent()) {; 3843 if ((fFillStyle < 3026) && (fFillStyle > 3000)) {; 3844 if (!gPad->IsBatch() && GetPainter()) GetPainter()->ClearDrawable();; 3845 }; 3846 PaintBorder(GetFillColor(), kTRUE);; 3847 }; 3848 ; 3849 PaintDate();; 3850 ; 3851 TList *pList = GetListOfPrimitives();; 3852 auto lnk = pList ? pList->FirstLink() : nullptr;; 3853 ; 3854 while (lnk) {; 3855 TObject *obj = lnk->GetObject();; 3856 if (obj->InheritsFrom(TPad::Class())) {; 3857 ((TPad*)obj)->PaintModified();; 3858 } else if (IsModified() || IsTransparent()) {; 3859 ; 3860 // Create a pad 3D viewer if none exists and we encounter a; 3861 // 3D shape; 3862 if (!fViewer3D && obj->InheritsFrom(TAtt3D::Class())) {; 3863 GetViewer3D(""pad"");; 3864 }; 3865 ; 3866 // Open a 3D scene if required; 3867 if (fViewer3D && !fViewer3D->BuildingScene()) {; 3868 fViewer3D->BeginScene();; 3869 began3DScene = kTRUE;; 3870 }; 3871 ; 3872 obj->Paint(lnk->GetOption());; 3873 }; 3874 lnk = lnk->Next();; 3875 }; 3876 }; 3877 ; 3878 fPadPaint = 0;; 3879 Modified(kFALSE);; 3880 ; 3881 // This must be done after modified flag is cleared, as some; 3882 // viewers will invoke another paint by marking pad modified again; 3883 if (began3DScene) {; 3884 if (fViewer3D) fViewer3D->EndScene();; 3885 }; 3886 ; 3887 gVirtualPS = saveps;; 3888}; 3889 ; 3890////////////////////////////////////////////////////////////////////////////////; 3891/// Paint box in CurrentPad World coordinates.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:123016,clear,cleared,123016,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['clear'],['cleared']
Usability,"num TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TCondor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCondor.html:6896,Resume,Resume,6896,root/html532/TCondor.html,https://root.cern,https://root.cern/root/html532/TCondor.html,2,['Resume'],['Resume']
Usability,"nup request for the session specified by tag. ;  ; virtual void ClearCache (const char *file=0);  Remove file from all file caches. ;  ; void ClearData (UInt_t what=kUnregistered, const char *dsname=0);  Remove files for the data directory. ;  ; virtual void ClearDataSetCache (const char *dataset=0);  Clear the content of the dataset cache, if any (matching 'dataset', if defined). ;  ; void ClearFeedback ();  Clear feedback list. ;  ; void ClearInput ();  Clear input object list. ;  ; void ClearInputData (const char *name);  Remove obj 'name' form the input data list;. ;  ; void ClearInputData (TObject *obj=0);  Remove obj form the input data list; if obj is null (default), clear the input data info. ;  ; Int_t ClearPackage (const char *package);  Remove a specific package. ;  ; Int_t ClearPackages ();  Remove all packages. ;  ; void Close (Option_t *option="""");  Close all open slave servers. ;  ; void CloseProgressDialog ();  Close progress dialog. ;  ; TDrawFeedback * CreateDrawFeedback ();  Draw feedback creation proxy. ;  ; void DataSetStatus (const char *msg, Bool_t status, Int_t done, Int_t total);  Send dataset preparation status. ;  ; Int_t DeactivateWorker (const char *ord, Bool_t save=kTRUE);  Remove the worker identified by the ordinal number 'ord' from the the active list. ;  ; void DeleteDrawFeedback (TDrawFeedback *f);  Delete draw feedback object. ;  ; void DeleteParameters (const char *wildcard);  Delete the input list parameters specified by a wildcard (e.g. ;  ; void Detach (Option_t *opt="""");  Detach this instance to its proofserv. ;  ; void DisableGoAsyn ();  Signal to disable related switches. ;  ; Int_t DownloadPackage (const char *par, const char *dstdir=0);  Download a PROOF archive (PAR file) from the master package repository. ;  ; Long64_t DrawSelect (const char *dsetname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Execute the specified drawing action on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:5178,feedback,feedback,5178,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['feedback'],['feedback']
Usability,"nvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:4425,clear,clearValueDirty,4425,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,1,['clear'],['clearValueDirty']
Usability,"nvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooResolutionModel.html:4425,clear,clearValueDirty,4425,root/html530/RooResolutionModel.html,https://root.cern,https://root.cern/root/html530/RooResolutionModel.html,1,['clear'],['clearValueDirty']
Usability,"nvas (RCanvas) and draw ROOT 7 boxes in it (RBox) ;  concurrentfill.cxx;  draw.cxx;  draw_mt.cxxThis macro demonstrate usage of ROOT7 graphics from many threads Three different canvases in three different threads are started and regularly updated ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172342,learn,learn,172342,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['learn'],['learn']
Usability,"nvas area, near the edges, with the right mouse button; and select the Print item. You can select the name of the Postscript; file. If the file name is xxx.ps, you will generate a Postscript file named; xxx.ps. If the file name is xxx.eps, you generate an encapsulated Postscript; file instead. In your program (or macro), you can type:. c1->Print(""xxx.ps"") or c1->Print(""xxx.eps""). This will generate a file corresponding to the picture in the canvas; pointed by c1.; pad1->Print(""xxx.ps""); prints only the picture in the pad pointed by pad1. The size; of the Postscript picture, by default, is computed to keep the aspect ratio; of the picture on the screen, where the size along x is always 20cm. You; can set the size of the PostScript picture before generating the picture; with a command such as:. TPostScript myps(""myfile.ps"",111); myps.Range(xsize,ysize);; object->Draw();; myps.Close();. You can set the default paper size with:. gStyle->SetPaperSize(xsize,ysize);. You can resume writing again in this file with myps.Open();.; Note that you may have several Postscript files opened simultaneously. Output type; The output type allows to define how the PostScript output will looks like.; It allows to define the page format (A4, Legal etc..), the orientation; (Portrait, Landscape) and the number of images (zones) per page.; The output type has the following form:. [Format][Nx][Ny][Type]. Where:. Format : Is an integer between 0 and 99 defining the page format.; Example:; Format = 3 the paper is in the standard A3 format.; Format = n (1 Format = 4 and Format=0 are the same and define an A4 page.; The A0 format is selected by Format=99.; The US format Letter is selected by Format = 100.; The US format Legal is selected by Format = 200.; The US format Ledger is selected by Format = 300.; Nx, Ny : Specify respectively the number of zones on the x and y axis.; Nx and Ny are integers between 1 and 9.; Type : Can be equal to:; ; 1 : Portrait mode with a small margin at the bottom of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPostScript.html:1747,resume,resume,1747,root/html528/TPostScript.html,https://root.cern,https://root.cern/root/html528/TPostScript.html,4,['resume'],['resume']
Usability,"nvas(); root[] myCanvas->Divide(2,2); We activate the first pad with the TCanvas::cd statement:; root[] myCanvas->cd(1); We then draw the variable Cost:; root[] MyTree->Draw(""C; As you can see, the last call TTree::Draw has only one parameter. It is a string containing the leaf name. A histogram is automatically created as a result of a TTree::Draw. The style of the histogram is inherited from the TTree attributes and the current style (gStyle) is ignored. The TTree gets its attributes from the current TStyle at the time it was created. You can call the method TTree::UseCurrentStyle to change to the current style rather than the TTree style. (See gStyle; see also “Graphics and the Graphical User Interface” ); In the next segment, we activate the second pad and draw a scatter plot variables:; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); This signature still only has one parameter, but it now has two dimensions separated by a colon (""x:y""). The item to be plotted can be an expression not just a simple variable. In general, this parameter is a string that contains up to three expressions, one for each dimension, separated by a colon (“e1:e2:e3”). A list of examples follows this introduction.; 12.20.1 Using Selection with TTree:Draw; Change the active pad to 3, and add a selection to the list of parameters of the draw command.; root[] myCanvas->cd(3); root[] MyTree->Draw(""Cost:Age"",""Nation == ""FR""""); This will draw the Costvs. Age for the entries where the nation is equal to “FR”. You can use any C++ operator, and some functions defined in TFormula, in the selection parameter. The value of the selection is used as a weight when filling the histogram. If the expression includes only Boolean operations as in the example above, the result is 0 or 1. If the result is 0, the histogram is not filled. In general, the expression is:; Selection = ""weight *(boolean expression)""; If the Boolean expression evaluates to true, the histogram is filled with a weight. If the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:586930,simpl,simple,586930,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"nymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCounternumber of times the stopwatch was started; Double_tfStartCpuTimecpu start time; Double_tfStartRealTimewall clock start time; TStopwatch::EStatefStatestopwatch state; Double_tfStopCpuTimecpu stop time; Double_tfStopRealTimewall clock stop time; Double_tfTotalCpuTimetotal cpu time; Double_tfTotalRealTimetotal real time; static TStopwatch::EStatekRunning; static TStopwatch::EStatekStopped; static TStopwatch::EStatekUndefined. Class Charts. Inheritance Chart:. TObject. ←; TStopwatch. ←. TMVA::Timer. Function documentation; TStopwatch(); Create a stopwatch and start it. void Start(Bool_t reset = kTRUE); Start the stopwatch. If reset is kTRUE reset the stopwatch before; starting it (including the stopwatch counter).; Use kFALSE to continue timing after a Stop() without; resetting the stopwatch. void Stop(); Stop the stopwatch. void Continue(); Resume a stopped stopwatch. The stopwatch continues counting from the last; Start() onwards (this is like the laptimer function). Double_t RealTime(); Stop the stopwatch (if it is running) and return the realtime (in; seconds) passed between the start and stop events. Double_t CpuTime(); Stop the stopwatch (if it is running) and return the cputime (in; seconds) passed between the start and stop events. Double_t GetRealTime(); Private static method returning system realtime. Double_t GetCPUTime(); Private static method returning system CPU time. void Print(Option_t* option = """") const; Print the real and cpu time passed between the start and stop events.; and the number of times (slices) this TStopwatch was called; (if this number > 1). If opt=""m"" print out realtime in milli second; precision. If opt=""u"" print out realtime in micro second precision. TStopwatch(). Int_t Counter() const; { return fCounter; }. void Reset(); { ResetCpuTime(); ResetRealTime(); }. void ResetCpuTime(Double_t time =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStopwatch.html:6868,Resume,Resume,6868,root/html602/TStopwatch.html,https://root.cern,https://root.cern/root/html602/TStopwatch.html,2,['Resume'],['Resume']
Usability,"o : [dataset] : Added class ""Background""; # : Add Tree bkg_tree of type Background with 10000 events; ; # signalTree.Print();; ; # Booking Methods; ; # Here we book the TMVA methods. We book a Boosted Decision Tree method (BDT); ; ; # Boosted Decision Trees; if useTMVABDT:; factory.BookMethod(; loader,; TMVA.Types.kBDT,; ""BDT"",; V=False,; NTrees=400,; MinNodeSize=""2.5%"",; MaxDepth=2,; BoostType=""AdaBoost"",; AdaBoostBeta=0.5,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; SeparationType=""GiniIndex"",; nCuts=20,; ); ; ; #### Booking Deep Neural Network; ; # Here we book the DNN of TMVA. See the example TMVA_Higgs_Classification.C for a detailed description of the; # options; ; if useTMVADNN:; layoutString = ROOT.TString(; ""DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR""; ); ; # Training strategies; # one can catenate several training strings with different parameters (e.g. learning rates or regularizations; # parameters) The training string must be concatenated with the `|` delimiter; trainingString1 = ROOT.TString(; ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.""; ) # + ""|"" + trainingString2 + ...; trainingString1 += "",MaxEpochs="" + str(max_epochs); ; # Build now the full DNN Option string; dnnMethodName = ""TMVA_DNN_CPU""; ; # use GPU if available; dnnOptions = ""CPU""; if hasGPU :; dnnOptions = ""GPU""; dnnMethodName = ""TMVA_DNN_GPU""; ; factory.BookMethod(; loader,; TMVA.Types.kDL,; dnnMethodName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=None,; WeightInitialization=""XAVIER"",; Layout=layoutString,; TrainingStrategy=trainingString1,; Architecture=dnnOptions; ); ; ; ### Book Convolutional Neural Network in TMVA; ; # For building a CNN one needs to define; ; # - Input Layout : number of channels (in this case = 1) | image height | image width; # - Batch Layout : batch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:10079,learn,learning,10079,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['learn'],['learning']
Usability,"o <= x <= xup; // what we want :; //; // maximize c^T x - k ( 1/2 ) x^T Q x; // subject to sum_x x_i = 1; // 0 <= x_i; ; // We have nrStocks weights to determine,; // 1 equality- and 0 inequality- equations (the simple square boundary; // condition (xlo <= x <= xup) does not count); ; const Int_t nrVar = nrStocks;; const Int_t nrEqual = 1;; const Int_t nrInEqual = 0;; ; // flip the sign of the objective function because we want to maximize; TVectorD c = -1.*r;; TMatrixDSym Q = riskFactor*Covar;; ; // equality equation; TMatrixD A(nrEqual,nrVar); A = 1;; TVectorD b(nrEqual); b = 1;; ; // inequality equation; //; // - although not applicable in the current situation since nrInEqual = 0, one; // has to specify not only clo and cup but also an index vector iclo and icup,; // whose values are either 0 or 1 . If iclo[j] = 1, the lower boundary condition; // is active on x[j], etc. ...; ; TMatrixD C (nrInEqual,nrVar);; TVectorD clo (nrInEqual);; TVectorD cup (nrInEqual);; TVectorD iclo(nrInEqual);; TVectorD icup(nrInEqual);; ; // simple square boundary condition : 0 <= x_i, so only xlo is relevant .; // Like for clo and cup above, we have to define an index vector ixlo and ixup .; // Since each variable has the lower boundary, we can set the whole vector; // ixlo = 1; ; TVectorD xlo (nrVar); xlo = 0;; TVectorD xup (nrVar); xup = 0;; TVectorD ixlo(nrVar); ixlo = 1;; TVectorD ixup(nrVar); ixup = 0;; ; // setup the quadratic programming problem . Since a small number of variables are; // involved and ""Q"" has everywhere entries, we chose the dense version ""TQpProbDens"" .; // In case of a sparse formulation, simply replace all ""Dens"" by ""Sparse"" below and; // use TMatrixDSparse instead of TMatrixDSym and TMatrixD; ; TQpProbDens *qp = new TQpProbDens(nrVar,nrEqual,nrInEqual);; ; // stuff all the matrices/vectors defined above in the proper places; ; TQpDataDens *prob = (TQpDataDens *)qp->MakeData(c,Q,xlo,ixlo,xup,ixup,A,b,C,clo,iclo,cup,icup);; ; // setup the nrStock variables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:8889,simpl,simple,8889,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['simpl'],['simple']
Usability,"o ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1116loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1117 ; 1118\anchor RDFCollections; 1119### Storing RDataFrame objects in collections; 1120 ; 1121ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1122 ; 1123~~~{.cpp}; 1124std::vector<ROOT::RDF::RNode> dfs;; 1125dfs.emplace_back(ROOT::RDataFrame(10));; 1126dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; 1127~~~; 1128 ; 1129\anchor callbacks; 1130### Executing callbacks every N events; 1131It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; 1132Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; 1133drawing a partially-filled histogram every time a certain number of new entries is processed, or; 1134displaying a progress bar while the event loop runs.; 1135 ; 1136For example one can draw an up-to-date version of a result histogram every 100 entries like this:; 1137~~~{.cpp}; 1138auto h = df.Histo1D(""x"");; 1139TCanvas c(""c"",""x hist"");; 1140h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 1141// event loop runs here, this final `Draw` is executed after the event loop is finished; 1142h->Draw();; 1143~~~; 1144 ; 1145Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument; 1146and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them; 1147(e.g. a histogram filled with a part of the selected events).; 1148 ; 1149Read more on ROOT::RDF::RResultPtr::OnPartialResult() and ROOT::RDF::RResultPtr::OnPartialResultSlot().; 1150 ; 1151\anchor default-branches; 1152### Default",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:66258,progress bar,progress bar,66258,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"o ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1156loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1157 ; 1158\anchor RDFCollections; 1159### Storing RDataFrame objects in collections; 1160 ; 1161ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1162 ; 1163~~~{.cpp}; 1164std::vector<ROOT::RDF::RNode> dfs;; 1165dfs.emplace_back(ROOT::RDataFrame(10));; 1166dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; 1167~~~; 1168 ; 1169\anchor callbacks; 1170### Executing callbacks every N events; 1171It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; 1172Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; 1173drawing a partially-filled histogram every time a certain number of new entries is processed, or; 1174displaying a progress bar while the event loop runs.; 1175 ; 1176For example one can draw an up-to-date version of a result histogram every 100 entries like this:; 1177~~~{.cpp}; 1178auto h = df.Histo1D(""x"");; 1179TCanvas c(""c"",""x hist"");; 1180h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 1181// event loop runs here, this final `Draw` is executed after the event loop is finished; 1182h->Draw();; 1183~~~; 1184 ; 1185Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument; 1186and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them; 1187(e.g. a histogram filled with a part of the selected events).; 1188 ; 1189Read more on ROOT::RDF::RResultPtr::OnPartialResult() and ROOT::RDF::RResultPtr::OnPartialResultSlot().; 1190 ; 1191\anchor default-branches; 1192### Default",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:67938,progress bar,progress bar,67938,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"o TClass object for; ""plain"" C_struture only !!!. ~TTableDescriptor(); class destructor. Int_t AddAt(const void* c); Append one row pointed by ""c"" to the descriptor. void AddAt(const void* c, Int_t i); Add one row pointed by ""c"" to the ""i""-th row of the descriptor. void AddAt(TDataSet* dataset, Int_t idx = 0); Add one dataset to the descriptor.; There is no new implementation here.; One needs it to avoid the ""hidden method"" compilation warning. void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx); Add the descriptor element followed by its commentText; at the indx-th position of the descriptor (counted from zero). TString CreateLeafList() const; Create a list of leaf to be useful for TBranch::TBranch ctor. void Init(TClass* classPtr); Create a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C_structure only !!!. void LearnTable(const TTable* parentTable); to be documented. void LearnTable(TClass* classPtr). LearnTable() creates an array of the descriptors for elements of the row. It creates a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C-structure only !!!. This is to introduce an artificial restriction demanded by STAR database group. 1. the name may be 31 symbols at most; 2. the number the dimension is 3 at most. To lift this restriction one has to provide -DNORESTRICTIONS CPP symbol and; recompile code (and debug code NOW!). TTableDescriptor * MakeDescriptor(const char* structName). MakeDescriptor(const char *structName) - static method; structName - the name of the C structure; to create descriptor of; return a new instance of the TTableDescriptor or 0; if the ""structName is not present with the dictionary. TDataSet * MakeCommentField(Bool_t createFlag = kTRUE); Instantiate a comment dataset if any. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor); ""Schema evolution""; Method updates ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableDescriptor.html:18529,Learn,LearnTable,18529,root/html602/TTableDescriptor.html,https://root.cern,https://root.cern/root/html602/TTableDescriptor.html,2,['Learn'],['LearnTable']
Usability,"o action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQComman",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18071,undo,undo,18071,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,12,['undo'],['undo']
Usability,"o be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure).; 12.8 Branches; The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called TBranch. If two variables are independent, and the designer knows the variables will not be used together, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with sam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:537240,simpl,simple,537240,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"o be overridden by all derived classes. ;  ; bool forceAnalyticalInt (const RooAbsArg &arg) const override;  ; const RooArgList & funcList () const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ;  ; bool getFloor () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealSumFunc to more intuitively reflect the contents of the product operator construction. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  ; void setFloor (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:2719,intuit,intuitively,2719,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,2,['intuit'],['intuitively']
Usability,"o discriminating variables collectively denoted  which are chosen within three possible variables denoted , and .; The variable which is not incorporated in  is used as the control variable . The six distributions of the three variables are assumed to be the ones depicted in Fig. 1. Figure 1:; Distributions of the three discriminating variables available to perform the Likelihood fit: ; , , .; Among the three variables, two are used to perform the fit while one is; kept out of the fit to serve the purpose of a control variable. The; three distributions on the top (resp. bottom) of the figure correspond; to the signal (resp. background). The unit of the vertical axis is; chosen such that it indicates the number of entries per bin, if one; slices the histograms in 25 bins. A data sample being built through a Monte Carlo simulation based on the distributions shown in Fig. 1, one obtains the three distributions of Fig. 2. Whereas the distribution of  clearly indicates the presence of the signal, the distribution of and are less obviously populated by signal. Figure 2:; Distributions of the three discriminating variables for signal plus; background. The three distributions are the ones obtained from a data; sample obtained through a Monte Carlo simulation based on the; distributions shown in Fig. 1. The data sample consists of 500 signal events and 5000 background events. Chosing and as discriminating variables to determine and through a maximum Likelihood fit, one builds, for the control variable which is unknown to the fit, the two ; for signal and background shown in Fig. 3. One observes that the . for signal reproduces correctly the PDF even where the latter vanishes,; although the error bars remain sizeable. This results from the almost; complete cancellation between positive and negative weights: the sum of; weights is close to zero while the sum of weights squared is not. The; occurence of negative weights occurs through the appearance of the; covariance matrix, an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSPlot.html:6231,clear,clearly,6231,root/html528/TSPlot.html,https://root.cern,https://root.cern/root/html528/TSPlot.html,6,['clear'],['clearly']
Usability,"o draw a graph ""graph"" it's enough to do:. graph->Draw(""AL"");. The option ""AL"" in the Draw() method means:. The axis should be drawn (option ""A""),; The graph should be drawn as a simple line (option ""L""). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; ""A"" must be specified. TGraphPainter offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call; Draw() again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage return on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. ""A""; Axis are drawn around the graph. ""L""; A simple polyline is drawn. ""F""; A fill area is drawn ('CF' draw a smoothed fill area). ""C""; A smooth Curve is drawn. ""*""; A Star is plotted at each point. ""P""; The current marker is plotted at each point. ""B""; A Bar chart is drawn. ""1""; When a graph is drawn as a bar chart, this option makes the bars start from; the bottom of the pad. By default they start at 0. ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Drawing options can be combined. In the following example the graph; is drawn as a smooth curve (option ""C"") with markers (option ""P"") and; with axes (option ""A""). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",200,10,600,400);. c1->SetFillColor(42);; c1->SetGrid();. const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; gr = new TGraph(n,x,y);; gr->SetLineColor(2);; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerSize(1.5);; gr->SetMarkerStyle(21);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphPainter.html:1709,simpl,simple,1709,root/html532/TGraphPainter.html,https://root.cern,https://root.cern/root/html532/TGraphPainter.html,8,['simpl'],['simple']
Usability,"o generate the corresponding header file using SOFIE. ;  ;  TMVA_SOFIE_RDataFrame.py;   Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ;  ;  TMVA_SOFIE_RDataFrame_JIT.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ;  TMVA_SOFIE_RSofieReader.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ;  ;  TMVAClassification.C;   This macro provides examples for the training and testing of the TMVA classifiers. ;  ;  TMVAClassificationApplication.C;   This macro provides a simple example on how to use the trained classifiers within an analysis module ;  ;  TMVAClassificationCategory.C;   This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ;  ;  TMVAClassificationCategoryApplication.C;   This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  ;  TMVACrossValidation.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ;  TMVACrossValidationApplication.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ;  ;  TMVACrossValidationRegression.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ;  TMVAGAexample.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA ;  ;  TMVAGAexample2.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA. ;  ;  TMVAMinimalClassification.C;   Minimal self-contain",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:5132,simpl,simple,5132,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['simpl'],['simple']
Usability,"o generates two views of the NA49 detector. ;  ;  na49visible.py;  Set visibility attributes for the NA49 geometry Set Shape attributes. ;  ;  ntuple1.py;   Ntuple drawing example. ;  ;  numberEntry.py;  Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ;  ;  parse_CSV_file_with_TTree_ReadStream.py;  This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ;  ;  pyroot001_arrayInterface.py;   This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ;  ;  pyroot002_pythonizationDecorator.py;   This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ;  ;  pyroot003_prettyPrinting.py;   This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement. ;  ;  pyroot004_NumbaDeclare.py;   This tutorial illustrates how PyROOT supports declaring C++ callables from Python callables making them, for example, usable with RDataFrame. ;  ;  pyroot005_tfile_context_manager.py;   This tutorial demonstrates the usage of the TFile class as a Python context manager. ;  ;  pyroot006_tcontext_context_manager.py;   This tutorial demonstrates the usage of the TContext class as a Python context manager. ;  ;  ratioplot.py;   Display two histograms and their ratio. ;  ;  shapes.py;   Draw the geometry using the x3d viewver. ;  ;  staff.py;   example of macro to read data from an ascii file and create a root file with a Tree. ;  ;  surfaces.py;   Surfaces example ;  ;  tornado.py;  Tornado example. ;  ;  zdemo.py;   This macro is an example of graphs in log scales with annotations. ;  . tutorialspyroot. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:2274,usab,usable,2274,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,1,['usab'],['usable']
Usability,"o implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std::vector<Matrix_t> &otherBiases);; 143 ; 144 /*! Copy all trainable weight and biases from another equivalent layer but with different architecture; 145 The function can copy also extra parameters in addition to weights and biases if they are return; 146 by the function GetExtraLayerParameters */; 147 template <typename Arch>; 148 void CopyParameters(const VGeneralLayer<Arch> &layer);; 149 ; 150 /*! Prints the info about the layer. */; 151 virtual void Print() const = 0;; 152 ; 153 /*! Writes the information and the weights about the layer in an XML node. */; 154 virtual void AddWeightsXMLTo(void *parent) = 0;; 155 ; 156 /*! Read the information and the weights about the layer from XML node. */; 157 virtual void ReadWeightsFromXML(void *parent) = 0;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:5908,learn,learningRate,5908,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,1,['learn'],['learningRate']
Usability,"o left and right half of the window. Note that mouse highlighting and selection will not work exactly right as image for each eye gets slightly shifted and there are two different directions through the mouse pointer, one for each eye. ; Definition at line 2034 of file TGLViewer.cxx. ◆ SetStereoEyeOffsetFac(). void TGLViewer::SetStereoEyeOffsetFac ; (; Float_t ; f). inline . Definition at line 295 of file TGLViewer.h. ◆ SetStereoFrustumAsymFac(). void TGLViewer::SetStereoFrustumAsymFac ; (; Float_t ; f). inline . Definition at line 296 of file TGLViewer.h. ◆ SetStereoZeroParallax(). void TGLViewer::SetStereoZeroParallax ; (; Float_t ; f). inline . Definition at line 294 of file TGLViewer.h. ◆ SetupCameras(). void TGLViewer::SetupCameras ; (; Bool_t ; reset). protected . Setup cameras for current bounding box. ; Definition at line 367 of file TGLViewer.cxx. ◆ SetupClipObject(). void TGLViewer::SetupClipObject ; (; ). overrideprotectedvirtual . allow simple guide axes labels to be scaled relative to scene units ; Setup clip-object. Protected virtual method. ; Reimplemented from TGLViewerBase.; Definition at line 468 of file TGLViewer.cxx. ◆ SetViewport() [1/2]. void TGLViewer::SetViewport ; (; const TGLRect & ; vp). protected . Definition at line 1750 of file TGLViewer.cxx. ◆ SetViewport() [2/2]. void TGLViewer::SetViewport ; (; Int_t ; x, . Int_t ; y, . Int_t ; width, . Int_t ; height . ). protected . Set viewer viewport (window area) with bottom/left at (x,y), with dimensions 'width'/'height'. ; Definition at line 1732 of file TGLViewer.cxx. ◆ Streamer(). void TGLViewer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGLViewer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 395 of file TGLViewer.h. ◆ SwapBuffers(). void TGLViewer::SwapBuffers ; (; ); const. protected . Swap GL buffers. ; Definition at line 1288 of file TGLViewer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:69082,simpl,simple,69082,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"o nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; void ls (Option_t *option="""") const override;  ls this command and merged commands ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void Redo (Option_t *option="""");  Execute command and then merge commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo parameters. ;  ; virtual void SetName (const char *name);  Sets name of the command. ;  ; virtual void SetRedoArgs (Int_t nargs,...);  Set redo parameters. ;  ; virtual void SetTitle (const char *title);  Sets description of the command. ;  ; virtual void SetUndoArgs (Int_t nargs,...);  Set undo parameters. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Undo (Option_t *option="""");  Un-execute all merged commands and the command. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void AddAfter (const TObject *after, TObject *obj) override;  Insert object after object after in the list. ;  ; virtual void AddAfter (TObjLink *after, TObject *obj);  Insert object after the specified ObjLink object. ;  ; void AddAt (TObject *obj, Int_t idx) override;  Insert object at position idx in the list. ;  ; void AddBefore (const TObject *before, TObject *obj) override;  Insert object before object before in the list. ;  ; virtual void AddBefore (TObjLink *before, TObject *obj);  Insert obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:7914,undo,undo,7914,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"o not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:34084,clear,clearCacheObject,34084,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,3,['clear'],['clearCacheObject']
Usability,"o obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. RooLinkedListIter iterator(Bool_t dir = kTRUE) const. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Mon Jul 4 15:23:14 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinkedList.html:8920,simpl,simple,8920,root/html530/RooLinkedList.html,https://root.cern,https://root.cern/root/html530/RooLinkedList.html,1,['simpl'],['simple']
Usability,"o run Minos; 107 if (result.HasMinosError(i) ) {; 108 if (fMinosParams.empty()) {; 109 fMinosErrors = true;; 110 fMinosParams.reserve(npar-i);; 111 }; 112 fMinosParams.push_back(i);; 113 }; 114 }; 115 }; 116 ; 117 // set information about errors; 118 SetNormErrors( result.NormalizedErrors() );; 119 ; 120 // set also minimizer type; 121 // algorithm is after "" / ""; 122 const std::string & minname = result.MinimizerType();; 123 size_t pos = minname.find("" / "");; 124 if (pos != std::string::npos) {; 125 std::string minimType = minname.substr(0,pos);; 126 std::string algoType = minname.substr(pos+3,minname.length() );; 127 SetMinimizer(minimType.c_str(), algoType.c_str() );; 128 }; 129 else {; 130 SetMinimizer(minname.c_str());; 131 }; 132}; 133 ; 134 ; 135void FitConfig::SetParamsSettings(unsigned int npar, const double *params, const double * vstep ) {; 136 // initialize FitConfig from given parameter values and step sizes; 137 // if npar different than existing one - clear old one and create new ones; 138 if (params == nullptr) {; 139 fSettings = std::vector<ParameterSettings>(npar);; 140 return;; 141 }; 142 // if a vector of parameters is given and parameters are not existing or are of different size; 143 bool createNew = false;; 144 if (npar != fSettings.size() ) {; 145 fSettings.clear();; 146 fSettings.reserve(npar);; 147 createNew = true;; 148 }; 149 unsigned int i = 0;; 150 const double * end = params+npar;; 151 for (const double * ipar = params; ipar != end; ++ipar) {; 152 double val = *ipar;; 153 double step = 0;; 154 if (vstep == nullptr) {; 155 step = 0.3*std::fabs(val); // step size is 30% of par value; 156 //double step = 2.0*std::fabs(val); // step size is 30% of par value; 157 if (val == 0) step = 0.3;; 158 }; 159 else; 160 step = vstep[i];; 161 ; 162 if (createNew); 163 fSettings.push_back( ParameterSettings(""Par_"" + ROOT::Math::Util::ToString(i), val, step ) );; 164 else {; 165 fSettings[i].SetValue(val);; 166 fSettings[i].SetStepSize(step);; 167 }; 16",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8cxx_source.html:4223,clear,clear,4223,doc/master/FitConfig_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html,1,['clear'],['clear']
Usability,"o study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A single Variable; This is the signature of TTree::Branch to create a branch with a list of variables:; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); The first parameter is the branch name. The second parameter is the address from which to read the value. The third parameter is the leaf list with the name and type of each leaf. In this example, each branch has only one leaf. In the box below, the branch is named px and has one floating point type leaf also call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552944,simpl,simple,552944,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['simpl'],['simple']
Usability,"o the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:6484,learn,learning,6484,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['learn'],['learning']
Usability,"o the result of this action (of type Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called before Initialize(), because the RResultPtr is constructed before the event loop is started.; void Initialize(): this method is called once before starting the event-loop. Useful for setup operations. It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper, or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; void InitTask(TTreeReader *, unsigned int slot): each working thread shall call this method during the event loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; void Exec(unsigned int slot, ColumnTypes...columnValues): each working thread shall call this method during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value: this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of the requested columns for the particular entry being processed.; void Finalize(): this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; std::string GetActionName(): it returns a string identifier for this type of action that RDataFrame will use in diagnostics, SaveGraph(), etc. Optional methods; If these methods are implemented they enable extra functionality as per the description below. Result_t &PartialUpdate(unsigned int slot): if present, it must return the value of the partial result of this action for the given 'slot'. Different threads might call this method concurrently, but will do so w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:39511,simpl,simple,39511,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['simpl'],['simple']
Usability,"o this dataset, even if it is not the first one added to the frame. By default only the 1st dataset added to a frame will update the normalization information . RooFit::Rescale(double f) Rescale drawn histogram by given factor. . RooFit::Cut(const char*) Only plot entries that pass the given cut. Apart from cutting in continuous variables Cut(""x>5""), this can also be used to plot a specific category state. Use something like Cut(""myCategory == myCategory::stateA""), where myCategory resolves to the state number for a given entry and myCategory::stateA resolves to the state number of the state named ""stateA"". RooFit::CutRange(const char*) Only plot data from given range. Separate multiple ranges with "","". NoteThis often requires passing the normalisation when plotting the PDF because RooFit does not save how many events were being plotted (it will only work for cutting slices out of uniformly distributed variables). data->plotOn(frame01, CutRange(""SB1""));; const double nData = data->sumEntries("""", ""SB1"");; // Make clear that the target normalisation is nData. The enumerator NumEvent; // is needed to switch between relative and absolute scaling.; model.plotOn(frame01, Normalization(nData, RooAbsReal::NumEvent),; ProjectionRange(""SB1""));; RooAbsReal::NumEvent@ NumEventDefinition RooAbsReal.h:276. Histogram drawing options . RooFit::DrawOption(const char* opt) Select ROOT draw option for resulting TGraph object . RooFit::LineStyle(Style_t style) Select line style by ROOT line style code, default is solid . RooFit::LineColor(Color_t color) Select line color by ROOT color code, default is black . RooFit::LineWidth(Width_t width) Select line with in pixels, default is 3 . RooFit::MarkerStyle(Style_t style) Select the ROOT marker style, default is 21 . RooFit::MarkerColor(Color_t color) Select the ROOT marker color, default is black . RooFit::MarkerSize(Size_t size) Select the ROOT marker size . RooFit::FillStyle(Style_t style) Select fill style, default is filled. . RooFit:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:58042,clear,clear,58042,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['clear'],['clear']
Usability,"o this dataset, even if it is not the first one added to the frame. By default only the 1st dataset added to a frame will update the normalization information . RooFit::Rescale(double f) Rescale drawn histogram by given factor. . RooFit::Cut(const char*) Only plot entries that pass the given cut. Apart from cutting in continuous variables Cut(""x>5""), this can also be used to plot a specific category state. Use something like Cut(""myCategory == myCategory::stateA""), where myCategory resolves to the state number for a given entry and myCategory::stateA resolves to the state number of the state named ""stateA"". RooFit::CutRange(const char*) Only plot data from given range. Separate multiple ranges with "","". NoteThis often requires passing the normalisation when plotting the PDF because RooFit does not save how many events were being plotted (it will only work for cutting slices out of uniformly distributed variables). data->plotOn(frame01, CutRange(""SB1""));; const double nData = data->sumEntries("""", ""SB1"");; // Make clear that the target normalisation is nData. The enumerator NumEvent; // is needed to switch between relative and absolute scaling.; model.plotOn(frame01, Normalization(nData, RooAbsReal::NumEvent),; ProjectionRange(""SB1""));; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooAbsReal::NumEvent@ NumEventDefinition RooAbsReal.h:276. Histogram drawing options . RooFit::DrawOption(const char* opt) Select ROOT draw option for resulting TGraph object . RooFit::LineStyle(Style_t style) Select line style by ROOT line style code, default is solid . RooFit::LineColor(Color_t color) Select line color by ROOT color code, default is black . RooFit::LineWidth(Width_t width) Select line with in pixels, default is 3 . RooFit::MarkerStyle(Style_t style) Select the ROOT marker style, default is 21 . RooFit::MarkerColor(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:69840,clear,clear,69840,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['clear'],['clear']
Usability,"o to be executed).Definition TRootBrowser.h:36; TBrowserPlugin::~TBrowserPlugin~TBrowserPlugin() overrideDefinition TRootBrowser.h:45; TBrowserPlugin::SetCommandvoid SetCommand(const char *cmd)Definition TRootBrowser.h:49; TBrowserPlugin::fCommandTString fCommandCommand to be executed.Definition TRootBrowser.h:40; TBrowserPlugin::fSubTabInt_t fSubTabTab element number.Definition TRootBrowser.h:39; TBrowserPlugin::fTabInt_t fTabTab number.Definition TRootBrowser.h:38; TBrowserPlugin::SetSubTabvoid SetSubTab(Int_t sub)Definition TRootBrowser.h:48; TBrowserPlugin::TBrowserPluginTBrowserPlugin(const char *name, const char *cmd="""", Int_t tab=1, Int_t sub=-1)Definition TRootBrowser.h:42; TBrowserPlugin::SetTabvoid SetTab(Int_t tab)Definition TRootBrowser.h:47; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGCompositeFrameThe base class for composite widgets (menu bars, list boxes, etc.).Definition TGFrame.h:287; TGFrameA subclasses of TGWindow, and is used as base class for some simple widgets (buttons,...Definition TGFrame.h:80; TGFrame::MapRaisedvoid MapRaised() overridemap raisedDefinition TGFrame.h:205; TGHSplitterDefinition TGSplitter.h:90; TGHorizontalFrameA composite frame that layout their children in horizontal way.Definition TGFrame.h:385; TGLayoutHintsThis class describes layout hints used by the layout classes.Definition TGLayout.h:50; TGMainFrameDefines top level windows that interact with the system Window Manager.Definition TGFrame.h:397; TGMenuBarThe TGMenu.h header contains all different menu classes.Definition TGMenu.h:282; TGPictureThe TGPicture class implements pictures and icons used in the different GUI elements and widgets.Definition TGPicture.h:25; TGPopupMenuThis class creates a popup menu object.Definition TGMenu.h:110; TGStatusBarProvides a StatusBar widget.Definition TGStatusBar.h:21; TGTabA tab widget contains a set of composite frames each with a little tab with a name (like a set of fol...Definition TGTab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRootBrowser_8h_source.html:9723,simpl,simple,9723,doc/master/TRootBrowser_8h_source.html,https://root.cern,https://root.cern/doc/master/TRootBrowser_8h_source.html,1,['simpl'],['simple']
Usability,"o vol = mgr->GetVolume(volname.c_str());; 450 RGeomBrowserIter iter(*this);; 451 if (vol && (vol != topnode->GetVolume()) && iter.Navigate(vol)); 452 fSelectedStack = MakeStackByIds(iter.CurrentIds());; 453 }; 454}; 455 ; 456/////////////////////////////////////////////////////////////////////; 457/// Collect information about geometry from single volume; 458/// like it done in JSROOT ClonedNodes.createClones; 459 ; 460void RGeomDescription::Build(TGeoVolume *vol); 461{; 462 ClearDescription();; 463 if (!vol); 464 return;; 465 ; 466 TLockGuard lock(fMutex);; 467 ; 468 fDrawVolume = vol;; 469 ; 470 fSelectedStack.clear();; 471 ; 472 BuildDescription(nullptr, fDrawVolume);; 473}; 474 ; 475/////////////////////////////////////////////////////////////////////; 476/// Clear geometry description; 477 ; 478void RGeomDescription::ClearDescription(); 479{; 480 TLockGuard lock(fMutex);; 481 ; 482 fDesc.clear();; 483 fNodes.clear();; 484 fSortMap.clear();; 485 ClearDrawData();; 486 fDrawIdCut = 0;; 487 fDrawVolume = nullptr;; 488 fSelectedStack.clear();; 489}; 490 ; 491/////////////////////////////////////////////////////////////////////; 492/// Build geometry description; 493 ; 494void RGeomDescription::BuildDescription(TGeoNode *topnode, TGeoVolume *topvolume); 495{; 496 // vector to remember numbers; 497 std::vector<int> numbers;; 498 int offset = 1000000000;; 499 ; 500 // try to build flat list of all nodes; 501 TGeoNode *snode = topnode;; 502 TGeoIterator iter(topvolume);; 503 do {; 504 if (!snode) {; 505 numbers.emplace_back(offset);; 506 fNodes.emplace_back(nullptr);; 507 } else if (snode->GetNumber() >= offset) {; 508 // artificial offset already applied, used as identifier; 509 iter.Skip(); // no need to look inside; 510 } else {; 511 numbers.emplace_back(snode->GetNumber());; 512 snode->SetNumber(offset + fNodes.size()); // use id with shift 1e9; 513 fNodes.emplace_back(snode);; 514 }; 515 } while ((snode = iter()) != nullptr);; 516 ; 517 fDesc.reserve(fNodes.size())",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:12542,clear,clear,12542,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"o your local repository on the master branch, and you realize (perhaps because your project is turning out to be a bit more involved than you thought, or because a slew of changes have just appeared upstream) that you might have been better using NoSY. It's actually quite easy to swap to using NoSY without any disruption to your already-committed changes. Starting from your current position on the master branch:; Stash your current changes if appropriate:; git stash. Create (but do not switch to) a branch which will contain all your local commits up to this point:; git branch <local-branch>. Download the latest metadata from the remote:; git fetch origin. Now, reset your local master branch directly to the current state of origin/master:; git reset --hard origin/master. Note that you have not lost your local commits: they are on your local branch already.; Switch to your local branch:; git checkout <local-branch>. Do an initial sync between your local branch and the remote, resolving conflicts if necessary:; git rebase origin/master. Apply your stash, again, resolving conflicts if necessary:; git stash pop. Pick up at step 2 of the NoSY workflow above.; Reproduced with permission from the following page: https://cdcvs.fnal.gov/redmine/projects/cet-is-public/wiki/GitTipsAndTricks by Chris Green. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-how-tos.html:5131,guid,guidelines,5131,d/git-how-tos.html,https://root.cern,https://root.cern/d/git-how-tos.html,1,['guid'],['guidelines']
Usability,"o, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; This is especially useful for static libraries. For shared ones you can also simply load them before trying to compile the script:; gSystem->Load(""mydir/mylib"");; ACLiC uses the directive fMakeSharedLibs to create the shared library. If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to TSystem::Exec(), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $ExeNameand$ObjectFiles. See SetMakeSharedLib() for more information on those variables. When the file being passed to ACLiC is on a read only file system, ACLiC warns the user and creates the library in a temporary directory:; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; To select the temporary directory ACLiC lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:272300,simpl,simply,272300,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"o; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:21824,progress bar,progress bar,21824,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,2,['progress bar'],['progress bar']
Usability,"oAbsArg &) const override;  ; void generateEvent (Int_t code) override;  This function should never be called as RooAddModel implements a custom generator context. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Return pseud-code that indicates if all components can do internal generation (1) or not (0) ;  ; TClass * IsA () const override;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Direct generation is safe if all components say so. ;  ; const RooArgList & pdfList () const;  Return list of component p.d.fs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the product operator construction. ;  ; void resetErrorCounters (Int_t resetValue=10) override;  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; bool selfNormalized () const override;  Model is self normalized when used as p.d.f. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooResolutionModel;  RooResolutionModel ()=default;  ;  RooResolutionModel (const char *name, const char *title, RooAbsRealLValue &x);  Constructor with convolution variable 'x'. ;  ;  RooResolutionModel (const RooResolutionModel &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooResolutionModel () override;  Destructor. ;  ; const RooFormulaVar & basis () const;  ; const RooRealVar & basisConvVar () const;  Return the convolution variabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:4462,intuit,intuitively,4462,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['intuit'],['intuitively']
Usability,"oAbsArg & ; server, . bool ; valueProp, . bool ; shapeProp . ). Change dirty flag propagation mask for specified server. ; Definition at line 438 of file RooAbsArg.cxx. ◆ checkObservables(). bool RooAbsArg::checkObservables ; (; const RooArgSet * ; nset); const. virtual . Overloadable function in which derived classes can implement consistency checks of the variables. ; If this function returns true, indicating an error, the fitter or generator will abort. ; Reimplemented in RooLagrangianMorphFunc, RooAddModel, RooAddPdf, RooRealSumFunc, and RooRealSumPdf.; Definition at line 817 of file RooAbsArg.cxx. ◆ cleanBranchName(). TString RooAbsArg::cleanBranchName ; (; ); const. protected . Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ; Definition at line 2075 of file RooAbsArg.cxx. ◆ clearShapeDirty(). void RooAbsArg::clearShapeDirty ; (; ); const. inlineprotected . Definition at line 579 of file RooAbsArg.h. ◆ clearValueAndShapeDirty(). void RooAbsArg::clearValueAndShapeDirty ; (; ); const. inlineprotected . Definition at line 571 of file RooAbsArg.h. ◆ clearValueDirty(). void RooAbsArg::clearValueDirty ; (; ); const. inlineprotected . Definition at line 576 of file RooAbsArg.h. ◆ clients(). const RefCountList_t & RooAbsArg::clients ; (; ); const. inline . List of all clients of this object. ; Definition at line 166 of file RooAbsArg.h. ◆ clone(). virtual TObject * RooAbsArg::clone ; (; const char * ; newname = nullptr); const. pure virtual . Implemented in RooStats::HistFactory::FlexibleInterpVar, RooStats::HistFactory::LinInterpVar, ParamHistFunc, PiecewiseInterpolation, RooStats::HistFactory::RooBarlowBeestonLL, Roo2DKeysPdf, RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1Binding< VO, VI >, RooCFunction1PdfBinding< VO, VI >, RooCFunction2Binding< VO, VI1, VI2 >, RooCFunction2PdfBinding< VO, VI1, V",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:50653,clear,clearValueAndShapeDirty,50653,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"oAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Deault constructor. RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); Constructor. The set trackSet contains the observables to be; tracked for changes. If checkValues is true an additional; validation step is activated where the numeric values of the; tracked arguments are compared with reference values ensuring; that values have actually changed. RooChangeTracker(const RooChangeTracker& other, const char* name = 0); Copy constructor. Bool_t hasChanged(Bool_t clearState); Returns true if state has changes since last call with clearState=kTRUE; If clearState is true, changeState flag will be cleared. ~RooChangeTracker(); Destructor. RooArgSet parameters() const. TObject* clone(const char* newname) const; { return new RooChangeTracker(*this, newname); }. Double_t evaluate() const; { return 1 ; }. » Last changed: Mon Dec 7 13:47:06 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:33717,clear,clearState,33717,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,4,['clear'],"['clearState', 'cleared']"
Usability,"oAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegralMorph.html:6377,clear,clearShapeDirty,6377,root/html526/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html526/RooIntegralMorph.html,1,['clear'],['clearShapeDirty']
Usability,"oAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:2946,clear,clearEvalErrorLog,2946,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,"oAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:6651,clear,clearShapeDirty,6651,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,6,['clear'],['clearShapeDirty']
Usability,"oAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DKeysPdf.html:2761,clear,clearValueAndShapeDirty,2761,root/html532/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html532/Roo2DKeysPdf.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"oAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:4014,clear,clearValueAndShapeDirty,4014,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,3,['clear'],['clearValueAndShapeDirty']
Usability,"oAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:4460,clear,clearValueAndShapeDirty,4460,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"oAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:4460,clear,clearValueAndShapeDirty,4460,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"oArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:3699,clear,clearEvalError,3699,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,2,['clear'],['clearEvalError']
Usability,"oArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:4145,clear,clearEvalError,4145,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['clear'],['clearEvalError']
Usability,"oArgSet& paramsOfInterest, Double_t size = 0.05, const RooArgSet* nullParams = 0); constructor from the data, a model pdf and the parameter of Interest.; If nuisance parameters are present they should be specified as part of the model; i.e. the model pdf is a combined pdf for the poi and the nuisance; The default test size used is 0.05 ( for a 95% interval); A set for the null parameters (it must be a copied set) can be specified which will be used for; performing the hypothesis test. ProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.05); construct from the data and a model configuration (ModelConfig class); If the model configuration contains a Prior pdf it will be included in the full model; used by the profile likelihood calculator.; The default test size used is 0.05 ( for a 95% interval). ~ProfileLikelihoodCalculator(); destructor (delete the contained result of the fit). void DoReset() const; private method to reset and clear fit results; to be called when a new model or data are set in the calculator. void DoGlobalFit() const; private method to perform a global fit of the likelihood letting with all parameter of interest and; nuisance parameters; keep the list of fitted parameters. LikelihoodInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a profile likelihood ratio and uses that to construct a RooStats::LikelihoodInterval. HypoTestResult* GetHypoTest() const; Main interface to get a HypoTestResult.; It does two fits:; the first lets the null parameters float, so it's a maximum likelihood estimate; the second is to the null (fixing null parameters to their specified values): eg. a conditional maximum likelihood; the ratio of the likelihood at the conditional MLE to the MLE is the profile likelihood ratio.; Wilks' theorem is used to get p-values. A RooArgSet contained a copied of the null parameters must be previously specified; (either in the constructor or by using SetNu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__ProfileLikelihoodCalculator.html:11261,clear,clear,11261,root/html526/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__ProfileLikelihoodCalculator.html,1,['clear'],['clear']
Usability,"oArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:6363,Clear,Clear,6363,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,1,['Clear'],['Clear']
Usability,"oCtub&); TGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual~TGeoCtub(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoTubeSeg::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTubeSeg::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:2083,Clear,ClearThreadData,2083,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,1,['Clear'],['ClearThreadData']
Usability,"oError(int level, const char* location, const char* fmt, va_list va) const; voidDoFlip(); voidDoLeftShift(UInt_t shift); voidDoOrEqual(const TBits& rhs); voidDoRightShift(UInt_t shift); voidDoXorEqual(const TBits& rhs); voidTObject::MakeZombie(); voidReserveBytes(UInt_t nbytes). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UChar_t*fAllBits[fNbytes] array of UChars; UInt_tfNbitsHighest bit set + 1; UInt_tfNbytesNumber of UChars in fAllBits. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits(UInt_t nbits = 8); TBits constructor. All bits set to 0. TBits(const TBits& ); TBits copy constructor. TBits& operator=(const TBits& ); TBits assignment operator. ~TBits(); TBits destructor. void Clear(Option_t* option = """"); Clear the value. void Compact(); Reduce the storage used by the object to a minimun. UInt_t CountBits(UInt_t startBit = 0) const; Return number of bits set to 1 starting at bit startBit. void DoAndEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoOrEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoXorEqual(const TBits& rhs); Execute (*this) ^= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoFlip(); Execute ~(*this). void DoLeftShift(UInt_t shift); Execute the left shift operation. void DoRightShift(UInt_t shift); Execute the left shift operation. UInt_t FirstNullBit(UInt_t startBit = 0) const; Return position of first null bit (starting from position 0 and up). UInt_t FirstSetBit(UInt_t startBit = 0) const; Return position of first non null bit (starting from position 0 and u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBits.html:7518,Clear,Clear,7518,root/html532/TBits.html,https://root.cern,https://root.cern/root/html532/TBits.html,2,['Clear'],['Clear']
Usability,"oError(int level, const char* location, const char* fmt, va_list va) const; voidDoFlip(); voidDoLeftShift(UInt_t shift); voidDoOrEqual(const TBits& rhs); voidDoRightShift(UInt_t shift); voidDoXorEqual(const TBits& rhs); voidTObject::MakeZombie(); voidReserveBytes(UInt_t nbytes). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UChar_t*fAllBits[fNbytes] array of UChars; UInt_tfNbitsHighest bit set + 1; UInt_tfNbytesNumber of UChars in fAllBits. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits(UInt_t nbits = 8); TBits constructor. All bits set to 0. TBits(const TBits& ); TBits copy constructor. TBits& operator=(const TBits& ); TBits assignment operator. ~TBits(); TBits destructor. void Clear(Option_t* option = """"); Clear the value. void Compact(); Reduce the storage used by the object to a minimun. UInt_t CountBits(UInt_t startBit = 0) const; Return number of bits set to 1 starting at bit startBit. void DoAndEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoOrEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoXorEqual(const TBits& rhs); Execute (*this) ^= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoFlip(); Execute ~(*this). void DoLeftShift(UInt_t shift); Execute the left shift operation. void DoRightShift(UInt_t shift); Execute the left shift operation. UInt_t FirstNullBit(UInt_t startBit = 0) const; Return position of first null bit (starting from position 0 and up). UInt_t LastNullBit(UInt_t startBit = 999999999) const; Return position of first null bit (starting from position 0 a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBits.html:7644,Clear,Clear,7644,root/html534/TBits.html,https://root.cern,https://root.cern/root/html534/TBits.html,2,['Clear'],['Clear']
Usability,"oFitResult*chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:3766,clear,clearValueAndShapeDirty,3766,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"oFitResult*chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:3702,clear,clearValueAndShapeDirty,3702,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"oPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:69727,clear,clearShapeDirty,69727,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,9,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"oVolume.h:43; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at rootgeom.C. You will notice that this is a bit more complex that just creating the ""world"" since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:7056,simpl,simple,7056,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"oat_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tTEveLine::CalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrack.html:2956,Clear,ClearIds,2956,root/html534/TEveTrack.html,https://root.cern,https://root.cern/root/html534/TEveTrack.html,3,['Clear'],['ClearIds']
Usability,"oat_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tTEveLine::CalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTEveTrack::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackProjected.html:2605,Clear,ClearIds,2605,root/html534/TEveTrackProjected.html,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html,3,['Clear'],['ClearIds']
Usability,"oat_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tTEveLine::CalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPointSet3D::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveLineProjected.html:2493,Clear,ClearIds,2493,root/html534/TEveLineProjected.html,https://root.cern,https://root.cern/root/html534/TEveLineProjected.html,3,['Clear'],['ClearIds']
Usability,"oat_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPointSet3D::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEvePointSet.html:3319,Clear,ClearProjectedList,3319,root/html532/TEvePointSet.html,https://root.cern,https://root.cern/root/html532/TEvePointSet.html,4,['Clear'],['ClearProjectedList']
Usability,"oat_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Conne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrack.html:2790,Clear,ClearProjectedList,2790,root/html532/TEveTrack.html,https://root.cern,https://root.cern/root/html532/TEveTrack.html,1,['Clear'],['ClearProjectedList']
Usability,"oat_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTEveTrack::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrackProjected.html:2600,Clear,ClearProjectedList,2600,root/html532/TEveTrackProjected.html,https://root.cern,https://root.cern/root/html532/TEveTrackProjected.html,1,['Clear'],['ClearProjectedList']
Usability,"oat_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPointSet3D::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveLine.html:2663,Clear,ClearProjectedList,2663,root/html532/TEveLine.html,https://root.cern,https://root.cern/root/html532/TEveLine.html,6,['Clear'],['ClearProjectedList']
Usability,"obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidAddAfter(TObjLink*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddBefore(TObjLink*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSortedList.html:1575,Clear,Clear,1575,root/html532/TSortedList.html,https://root.cern,https://root.cern/root/html532/TSortedList.html,2,['Clear'],['Clear']
Usability,"object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ======",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLeafL.html:8679,simpl,simple,8679,root/html534/TLeafL.html,https://root.cern,https://root.cern/root/html534/TLeafL.html,2,['simpl'],['simple']
Usability,"object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLeafL.html:9171,simpl,simple,9171,root/html602/TLeafL.html,https://root.cern,https://root.cern/root/html602/TLeafL.html,4,['simpl'],['simple']
Usability,"object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read a long integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafL(). Int_t GetMaximum() const; {return (Int_t)fMaximum;}. Int_t GetMinimum() const; {return (Int_t)fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Long64_t m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLeafL.html:8461,simpl,simple,8461,root/html528/TLeafL.html,https://root.cern,https://root.cern/root/html528/TLeafL.html,4,['simpl'],['simple']
Usability,"object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:19234,Clear,Clear,19234,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,8,['Clear'],['Clear']
Usability,"object is of CPPInstance derived type.; 169 if (!Initialize()); 170 return false;; 171 ; 172// detailed walk through inheritance hierarchy; 173 return CPPInstance_Check(pyobject);; 174}; 175 ; 176//-----------------------------------------------------------------------------; 177bool CPyCppyy::Instance_CheckExact(PyObject* pyobject); 178{; 179// Test if the given pyobject is of CPPInstance type.; 180 if (!Initialize()); 181 return false;; 182 ; 183// direct pointer comparison of type member; 184 return CPPInstance_CheckExact(pyobject);; 185}; 186 ; 187//-----------------------------------------------------------------------------; 188bool CPyCppyy::Sequence_Check(PyObject* pyobject); 189{; 190// Extends on PySequence_Check() to determine whether an object can be iterated; 191// over (technically, all objects can b/c of C++ pointer arithmetic, hence this; 192// check isn't 100% accurate, but neither is PySequence_Check()).; 193 ; 194// Note: simply having the iterator protocol does not constitute a sequence, bc; 195// PySequence_GetItem() would fail.; 196 ; 197// default to PySequence_Check() if called with a non-C++ object; 198 if (!CPPInstance_Check(pyobject)); 199 return (bool)PySequence_Check(pyobject);; 200 ; 201// all C++ objects should have sq_item defined, but a user-derived class may; 202// have deleted it, in which case this is not a sequence; 203 PyTypeObject* t = Py_TYPE(pyobject);; 204 if (!t->tp_as_sequence || !t->tp_as_sequence->sq_item); 205 return false;; 206 ; 207// if this is the default getitem, it is only a sequence if it's an array type; 208 if (t->tp_as_sequence->sq_item == CPPInstance_Type.tp_as_sequence->sq_item) {; 209 if (((CPPInstance*)pyobject)->fFlags & CPPInstance::kIsArray); 210 return true;; 211 return false;; 212 }; 213 ; 214// TODO: could additionally verify whether __len__ is supported and/or whether; 215// operator()[] takes an int argument type; 216 ; 217 return true;; 218}; 219 ; 220//--------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:6523,simpl,simply,6523,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['simpl'],['simply']
Usability,"object of class classname.; 2039/// IMPORTANT: classname must derive from TObject.; 2040/// The class dictionary must be available (ClassDef in class header).; 2041///; 2042/// This option requires access to the library where the corresponding class; 2043/// is defined. Accessing one single data member in the object implies; 2044/// reading the full object.; 2045/// See the next Branch constructor for a more efficient storage; 2046/// in case the entry consists of arrays of identical objects.; 2047///; 2048/// By default the branch buffers are stored in the same file as the Tree.; 2049/// use TBranch::SetFile to specify a different file; 2050///; 2051/// IMPORTANT NOTE about branch names:; 2052///; 2053/// And in general, in case two or more master branches contain subbranches; 2054/// with identical names, one must add a ""."" (dot) character at the end; 2055/// of the master branch name. This will force the name of the subbranches; 2056/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2057/// This situation happens when the top level object; 2058/// has two or more members referencing the same class.; 2059/// For example, if a Tree has two branches B1 and B2 corresponding; 2060/// to objects of the same class MyClass, one can do:; 2061/// ~~~ {.cpp}; 2062/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2063/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2064/// ~~~; 2065/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2066/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2067///; 2068/// bufsize is the buffer size in bytes for this branch; 2069/// The default value is 32000 bytes and should be ok for most cases.; 2070/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2071/// and each entry is large (Megabytes); 2072/// A small value for bufsize is optimum if you intend to access; 2073/// the entries in the Tree randomly and your Tree is in split mode.; 2074 ; 2075TBranch* TTree::BranchOl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:81846,simpl,simply,81846,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simply']
Usability,"object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TQCommand.h>. Inheritance diagram for TQCommand:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQCommand() [1/3]. TQCommand::TQCommand ; (; const char * ; clname = nullptr, . void * ; obj = nullptr, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; clname - class name.; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments:; if either clname or obj is NULL that means that redo/undo is function; to specify default arguments for redo/undo method/function '=' must precede to argument value. Example: TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case undo parameter can be omitted.; Example: TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. Definition at line 168 of file TQCommand.cxx. ◆ TQCommand() [2/3]. TQCommand::TQCommand ; (; TObject * ; obj, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments: to specify default arguments for redo/undo method/function '=' must precede to argument value.; Example: TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case ""undo"" can parameter be omitted.; Example: TQCommand(gPad, ""SetFillStyle(Style_t)"");. Definition at line 199 of file TQCommand.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:32210,undo,undo,32210,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,2,['undo'],['undo']
Usability,"objects with no lights (but lighting still enabled); are partially visible. void DrawSphere(const TGLVertex3& position, Double_t radius, const UChar_t* rgba); Draw sphere, centered on vertex 'position', with radius 'radius',; color 'rgba'. void DrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); Draw thick line (tube) defined by 'line', with head at end shape; 'head' - box/arrow/none, (head) size 'size', color 'rgba'. void DrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); Draw thick line (tube) running from 'start', length 'vector',; with head at end of shape 'head' - box/arrow/none,; (head) size 'size', color 'rgba'. void DrawRing(const TGLVertex3& center, const TGLVector3& normal, Double_t radius, const UChar_t* rgba); Draw ring, centered on 'center', lying on plane defined by 'center' & 'normal'; of outer radius 'radius', color 'rgba'. void DrawReferenceMarker(const TGLCamera& camera, const TGLVertex3& pos, Float_t radius = 3, const UChar_t* rgba = 0); Draw a sphere- marker on world-coordinate 'pos' with pixel; radius 'radius'. Color argument is optional. void DrawSimpleAxes(const TGLCamera& camera, const TGLBoundingBox& bbox, Int_t axesType); Draw simple xyz-axes for given bounding-box. void DrawNumber(const TString& num, const TGLVertex3& pos, Bool_t center = kFALSE); Draw number in string 'num' via internal 8x8-pixel bitmap on; vertex 'pos'. If 'center' is true, the number is centered on 'pos'.; Only numbers, '.', '-' and ' ' are supported. TGLColor& operator=(const TGLUtil& ). TGLUtil(const TGLUtil& ). virtual ~TGLUtil(); {}. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLUtil.html:12399,simpl,simple,12399,root/html534/TGLUtil.html,https://root.cern,https://root.cern/root/html534/TGLUtil.html,2,['simpl'],['simple']
Usability,"objects,; this function will create one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not poss",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:7099,simpl,simple,7099,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['simpl'],['simple']
Usability,"objects,; this function will create one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode. Ie. if it contains objects of; any types deriving from TTrack this function will sort the objects; basing on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not poss",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:6710,simpl,simple,6710,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simple']
Usability,"obusAuth_t func); Set Globus authorization function. Automatically called when; libGlobusAuth is loaded. Int_t SshError(const char* errfile); SSH error parsing: returns; 0 : no error or fatal; 1 : should retry (eg 'connection closed by remote host'). Int_t SshAuth(TString& user); SSH client authentication code. const char * GetSshUser(TString user) const; Method returning the user to be used for the ssh login.; Looks first at SSH.Login and finally at env USER.; If SSH.LoginPrompt is set to 'yes' it prompts for the 'login name'. Bool_t CheckHost(const char* Host, const char* host); Check if 'host' matches 'href':; this means either equal or ""containing"" it, even with wild cards *; in the first field (in the case 'href' is a name, ie not IP address); Returns kTRUE if the two matches. Int_t RfioAuth(TString& user); UidGid client authentication code.; Returns 0 in case authentication failed; 1 in case of success; <0 in case of system error. Int_t ClearAuth(TString& user, TString& passwd, Bool_t& pwhash); UsrPwd client authentication code.; Returns 0 in case authentication failed; 1 in case of success. THostAuth * GetHostAuth(const char* host, const char* user = """", Option_t* opt = ""R"", Int_t* Exact = 0); Sets fUser=user and search fgAuthInfo for the entry pertaining to; (host,user), setting fHostAuth accordingly.; If opt = ""P"" use fgProofAuthInfo list instead; If no entry is found fHostAuth is not changed. THostAuth * HasHostAuth(const char* host, const char* user, Option_t* opt = ""R""); Checks if a THostAuth with exact match for {host,user} exists; in the fgAuthInfo list; If opt = ""P"" use ProofAuthInfo list instead; Returns pointer to it or 0. void FileExpand(const char* fin, FILE* ftmp); Expands include directives found in fexp files; The expanded, temporary file, is pointed to by 'ftmp'; and should be already open. To be called recursively. char * GetDefaultDetails(Int_t method, Int_t opt, const char* user); Determine default authentication details for method 'sec' an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAuthenticate.html:17555,Clear,ClearAuth,17555,root/html532/TAuthenticate.html,https://root.cern,https://root.cern/root/html532/TAuthenticate.html,4,['Clear'],['ClearAuth']
Usability,"ocal machine. Then after making the commit, we pushed the change to origin. Optionally, we can pull down the last changes from upstream and rebase our branch onto the current master and force-push this to origin. After this, we create a pull request on GitHub from origin. It is important to note that it is not necessary to fork and clone for each contribution.; Merging a pull request locally; If the pull request does not have any conflicts with the master branch, it is possible to apply the changes locally by downloading a patch and piping it to git am with; wget -qO- https://github.com/root-project/root/pull/<PR#>.patch | git am; If you have conflicts, the preferred method is to rebase your branch onto master:; git remote update && git checkout master && git pull && git rebase master <your branch>; When a conflict exists with a commit, git will interrupt the rebase and let you resolve them by editing your files. Once the conflict is resolved, use; git add <conflicting files> && git rebase --continue; to continue the rebasing process. After all conflicts have been resolved, you can check that your changes are really what you want with git log -p master..<your branch> then push the result (without using --force).; Resources. Git How Tos; Git Tips and Tricks; GitHub and Git Foundations (YouTube). Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/creating-pull-request.html:6035,guid,guidelines,6035,d/creating-pull-request.html,https://root.cern,https://root.cern/d/creating-pull-request.html,1,['guid'],['guidelines']
Usability,"ocated it; returns kFALSE, otherwise kTRUE. The pixel value is set to default. Let system think we could allocate; color. cmap - the colormap; color - specifies and returns the values actually used in the cmap. void QueryColor(Colormap_t cmap, ColorStruct_t& color); Returns the current RGB value for the pixel in the ""color"" structure. The color components are set to default. cmap - the colormap; color - specifies and returns the RGB values for the pixel specified; in the structure. void NextEvent(Event_t& event); The ""event"" is set to default event.; This method however, should never be called. void GetPasteBuffer(Window_t id, Atom_t atom, TString& text, Int_t& nchar, Bool_t del); Gets contents of the paste buffer ""atom"" into the string ""text"".; (nchar = number of characters) If ""del"" is true deletes the paste; buffer afterwards. Bool_t Init(void* display = 0); Initializes the X system. Returns kFALSE in case of failure.; It is implementation dependent. void ClearWindow(); Clears the entire area of the current window. void CloseWindow(); Deletes current window. void ClosePixmap(); Deletes current pixmap. void CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); Copies the pixmap ""wid"" at the position [xpos,ypos] in the current window. Double_t GetOpenGLScalingFactor(); On a HiDPI resolution it can be > 1., this means glViewport should use; scaled width and height. void CreateOpenGLContext(Int_t wid = 0); Creates OpenGL context for window ""wid"". void DeleteOpenGLContext(Int_t wid = 0); Deletes OpenGL context for window ""wid"". Window_t CreateOpenGLWindow(Window_t parentID, UInt_t width, UInt_t height, const vector<pair<UInt_t,Int_t> >& format); Create window with special pixel format. Noop everywhere except Cocoa. Handle_t CreateOpenGLContext(Window_t windowID, Handle_t sharedContext); Creates OpenGL context for window ""windowID"". Bool_t MakeOpenGLContextCurrent(Handle_t ctx, Window_t windowID); Makes context ctx current OpenGL context. Handle_t GetCurrentOpenGLContext(); A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualX.html:25171,Clear,ClearWindow,25171,root/html602/TVirtualX.html,https://root.cern,https://root.cern/root/html602/TVirtualX.html,4,['Clear'],"['ClearWindow', 'Clears']"
Usability,"ocated it; returns kFALSE, otherwise kTRUE. The pixel value is set to default. Let system think we could allocate; color. cmap - the colormap; color - specifies and returns the values actually used in the cmap. void QueryColor(Colormap_t cmap, ColorStruct_t& color); Returns the current RGB value for the pixel in the ""color"" structure. The color components are set to default. cmap - the colormap; color - specifies and returns the RGB values for the pixel specified; in the structure. void NextEvent(Event_t& event); The ""event"" is set to default event.; This method however, should never be called. void GetPasteBuffer(Window_t id, Atom_t atom, TString& text, Int_t& nchar, Bool_t del); Gets contents of the paste buffer ""atom"" into the string ""text"".; (nchar = number of characters) If ""del"" is true deletes the paste; buffer afterwards. Bool_t Init(void* display = 0); Initializes the X system. Returns kFALSE in case of failure.; It is implementation dependent. void ClearWindow(); Clears the entire area of the current window. void CloseWindow(); Deletes current window. void ClosePixmap(); Deletes current pixmap. void CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); Copies the pixmap ""wid"" at the position [xpos,ypos] in the current window. Double_t GetOpenGLScalingFactor(); On a HiDPI resolution it can be > 1., this means glViewport should use; scaled width and height. void CreateOpenGLContext(Int_t wid = 0); Creates OpenGL context for window ""wid"". void DeleteOpenGLContext(Int_t wid = 0); Deletes OpenGL context for window ""wid"". Window_t CreateOpenGLWindow(Window_t parentID, UInt_t width, UInt_t height, const vector<std::pair<UInt_t,Int_t> >& format); Create window with special pixel format. Noop everywhere except Cocoa. Handle_t CreateOpenGLContext(Window_t windowID, Handle_t sharedContext); Creates OpenGL context for window ""windowID"". Bool_t MakeOpenGLContextCurrent(Handle_t ctx, Window_t windowID); Makes context ctx current OpenGL context. Handle_t GetCurrentOpenGLContext",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualX.html:24553,Clear,ClearWindow,24553,root/html534/TVirtualX.html,https://root.cern,https://root.cern/root/html534/TVirtualX.html,2,['Clear'],"['ClearWindow', 'Clears']"
Usability,"ocated it; returns kFALSE, otherwise kTRUE. The pixel value is set to default. Let system think we could allocate; color. cmap - the colormap; color - specifies and returns the values actually used in the cmap. void QueryColor(Colormap_t cmap, ColorStruct_t& color); Returns the current RGB value for the pixel in the ""color"" structure. The color components are set to default. cmap - the colormap; color - specifies and returns the RGB values for the pixel specified; in the structure. void NextEvent(Event_t& event); The ""event"" is set to default event.; This method however, should never be called. void GetPasteBuffer(Window_t id, Atom_t atom, TString& text, Int_t& nchar, Bool_t del); Gets contents of the paste buffer ""atom"" into the string ""text"".; (nchar = number of characters) If ""del"" is true deletes the paste; buffer afterwards. Bool_t Init(void* display = 0); Initializes the X system. Returns kFALSE in case of failure.; It is implementation dependent. void ClearWindow(); Clears the entire area of the current window. void CloseWindow(); Deletes current window. void ClosePixmap(); Deletes current pixmap. void CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); Copies the pixmap ""wid"" at the position [xpos,ypos] in the current window. void CreateOpenGLContext(Int_t wid = 0); Creates OpenGL context for window ""wid"". void DeleteOpenGLContext(Int_t wid = 0); Deletes OpenGL context for window ""wid"". void DrawBox(Int_t x1, Int_t y1, Int_t x2, Int_t y2, TVirtualX::EBoxMode mode); Draws a box between [x1,y1] and [x2,y2] according to the ""mode"". mode - drawing mode:; mode = 0 hollow (kHollow); mode = 1 solid (kSolid). void DrawCellArray(Int_t x1, Int_t y1, Int_t x2, Int_t y2, Int_t nx, Int_t ny, Int_t* ic); Draws a cell array. The drawing is done with the pixel presicion; if (x2-x1)/nx (or y) is not a exact pixel number the position of; the top rigth corner may be wrong. x1,y1 - left down corner; x2,y2 - right up corner; nx,ny - array size; ic - array. void DrawFillArea(Int_t n, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualX.html:23339,Clear,ClearWindow,23339,root/html532/TVirtualX.html,https://root.cern,https://root.cern/root/html532/TVirtualX.html,2,['Clear'],"['ClearWindow', 'Clears']"
Usability,"ocess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:5436,feedback,feedback,5436,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,2,['feedback'],['feedback']
Usability,"ocess the specified TSelector object 'nentries' times. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddOutput (TList *out) override;  Incorporate output list (may not be used in this class). ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate output object (may not be used in this class). ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:2261,feedback,feedback,2261,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,1,['feedback'],['feedback']
Usability,"ocessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLH2PolyPainter(const TGLH2PolyPainter&); TGLH2PolyPainter(TGLH2PolyPainter&&); TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. Bool_tBuildTesselation(Rgl::Pad::Tesselator& tess, const TGraph* g, Double_t z); Bool_tBuildTesselation(Rgl::Pad::Tesselator& tess, const TMultiGraph* mg, Double_t z); Bool_tCacheGeometry(); Bool_tClampZ(Double_t& zVal) const; virtual voidDeInitGL() const; voidDrawCap(TGLH2PolyPainter::CIter_t cap, Int_t bin) const; voidDrawCaps() const; voidDrawExtrusion() const; voidDrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; voidDrawExtrusion(const TMultiGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidFillTemporaryP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLH2PolyPainter.html:1750,Clear,ClearBuffers,1750,root/html602/TGLH2PolyPainter.html,https://root.cern,https://root.cern/root/html602/TGLH2PolyPainter.html,2,['Clear'],['ClearBuffers']
Usability,"ock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. TUUID(); TUUID(const char* uuid_str); TUUID(const TUUID&); virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t* uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUUID.html:2937,clear,cleared,2937,root/html528/TUUID.html,https://root.cern,https://root.cern/root/html528/TUUID.html,6,['clear'],['cleared']
Usability,"ock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t[16] uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(char*& buffer); voidSetUUID(const char* uuid_str); voidSetU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUUID.html:2961,clear,cleared,2961,root/html602/TUUID.html,https://root.cern,https://root.cern/root/html602/TUUID.html,4,['clear'],['cleared']
Usability,"ocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). const TObjArray * GetCachedBranches() const; { return fBranches; }. Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:23218,learn,learning,23218,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,2,['learn'],['learning']
Usability,"ocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT master - Ref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:56378,learn,learning,56378,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"ocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT v6-32 - Refe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:56308,learn,learning,56308,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"ocumentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if succesfull. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if succesfull. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if succesfull. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted by the user.; Example code of method usage:. TList* lst = serv->GetTablesList();; TIter next(lst);; TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLServer.html:8762,Clear,ClearError,8762,root/html532/TSQLServer.html,https://root.cern,https://root.cern/root/html532/TSQLServer.html,1,['Clear'],['ClearError']
Usability,"ocumentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted by the user.; Example code of method usage:. TList* lst = serv->GetTablesList();; TIter next(lst);; TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLServer.html:9069,Clear,ClearError,9069,root/html534/TSQLServer.html,https://root.cern,https://root.cern/root/html534/TSQLServer.html,3,['Clear'],['ClearError']
Usability,"ocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); voidCopyText() const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); Int_tGetCharacterIndex(Int_t xcoord); static const TGGC&GetDefaultSelectedBackgroundGC(); static const TGGC&GetDefaultSelectedGC(); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInit(); virtual Bool_tIsCursorOutOfFrame(); voidTObject::MakeZombie(); voidPaste(); virtual voidPastePrimary(Window_t wid, Atom_t property, Bool_t del); virtual voidScrollByChar(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); virtual voidUpdateOffset(). private:. TGTextEntry(const TGTextEntry&); TGTextEntry&operator=(const TGTextEntry&). Data Members; public:. enum EEchoMode { kNormal; kNoEcho; kPassword; };; enum EInsertMode { kInsert; kReplace; };; enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextEntry.html:20263,Clear,ClearFlags,20263,root/html532/TGTextEntry.html,https://root.cern,https://root.cern/root/html532/TGTextEntry.html,2,['Clear'],['ClearFlags']
Usability,"ocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAllocColors(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); voidCreateDitheredImage(Pixmap_t image, Int_t which); voidCreateImages(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawHScursor(Int_t onoff); voidDrawLcursor(Int_t onoff); voidFreeColors(); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidInitImages(); voidTObject::MakeZombie(); TGWindow&TGWindow::operator=(const TGWindow& tgw); Int_tTGWidget::SetFlags(Int_t flags); voidSetHScursor(Int_t x, Int_t y); voidSetLcursor(Int_t z); voidSetSliderColor(); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); voidUpdateCurrentColor(). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGColorPick.html:14412,Clear,ClearFlags,14412,root/html532/TGColorPick.html,https://root.cern,https://root.cern/root/html532/TGColorPick.html,2,['Clear'],['ClearFlags']
Usability,"od GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this method returns the uncertainties on the unfolding result arising from the background source source and its normalisation uncertainty. See method SubtractBackground() how to set the normalisation uncertainty ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1144 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundUncorr(). void TUnfoldSys::GetEmatrixSysBackgroundUncorr ; (; TH2 * ; ematrix, . const char * ; source, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background uncorrelated uncertainty ; Parameters. [in]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result arising from the background source source and the uncorrelated (background histogram uncertainties). Also see method SubtractBackground() ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1229 of file TUnfoldSys.cxx. ◆ GetEmatrixSysSo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:39081,clear,clearEmat,39081,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"od(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual TGVerticalFrame*TGedFrame::CreateEditorTabSubFrame(const char* name); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::Des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCurlyLineEditor.html:1647,Clear,Clear,1647,root/html532/TCurlyLineEditor.html,https://root.cern,https://root.cern/root/html532/TCurlyLineEditor.html,16,['Clear'],['Clear']
Usability,"od=3'when the conditions for igood=1 and igood=2 are satisfied'; For weighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 10 effective; number of events'; igood=2'There is a bin in the 2nd histogram with less then 10 effective; number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'. - chi2 - chisquare of the test; - ndf - number of degrees of freedom (important, when both histograms have the same; empty bins); - res - normalized residuals for further analysis. Double_t Chisquare(TF1* f1, Option_t* option = """") const; Compute and return the chisquare of this histogram with respect to a function; The chisquare is computed by weighting each histogram point by the bin error; By default the full range of the histogram is used.; Use option ""R"" for restricting the chisquare calculation to the given range of the function. void ClearUnderflowAndOverflow(); Remove all the content from the underflow and overflow bins, without changing the number of entries; After calling this method, every undeflow and overflow bins will have content 0.0; The Sumw2 is also cleared, since there is no more content in the bins. Double_t ComputeIntegral(Bool_t onlyPositive = false); Compute integral (cumulative sum of bins); The result stored in fIntegral is used by the GetRandom functions.; This function is automatically called by GetRandom when the fIntegral; array does not exist or when the number of entries in the histogram; has changed since the previous call to GetRandom.; The resulting integral is normalized to 1; If the routine is called with the onlyPositive flag set an error will; be produced in case of negative bin content and a NaN value returned. Double_t * GetIntegral(); Return a pointer to the array of bins integral.; if the pointer fIntegral is null, TH1::ComputeIntegral is called; The array dimension is the number of bins in the histograms; including underflow and overflow (fNCells); the last value integral[fNCells",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:60397,Clear,ClearUnderflowAndOverflow,60397,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"ode->GetVolume());; 447 ; 448 if (!volname.empty()) {; 449 auto vol = mgr->GetVolume(volname.c_str());; 450 RGeomBrowserIter iter(*this);; 451 if (vol && (vol != topnode->GetVolume()) && iter.Navigate(vol)); 452 fSelectedStack = MakeStackByIds(iter.CurrentIds());; 453 }; 454}; 455 ; 456/////////////////////////////////////////////////////////////////////; 457/// Collect information about geometry from single volume; 458/// like it done in JSROOT ClonedNodes.createClones; 459 ; 460void RGeomDescription::Build(TGeoVolume *vol); 461{; 462 ClearDescription();; 463 if (!vol); 464 return;; 465 ; 466 TLockGuard lock(fMutex);; 467 ; 468 fDrawVolume = vol;; 469 ; 470 fSelectedStack.clear();; 471 ; 472 BuildDescription(nullptr, fDrawVolume);; 473}; 474 ; 475/////////////////////////////////////////////////////////////////////; 476/// Clear geometry description; 477 ; 478void RGeomDescription::ClearDescription(); 479{; 480 TLockGuard lock(fMutex);; 481 ; 482 fDesc.clear();; 483 fNodes.clear();; 484 fSortMap.clear();; 485 ClearDrawData();; 486 fDrawIdCut = 0;; 487 fDrawVolume = nullptr;; 488 fSelectedStack.clear();; 489}; 490 ; 491/////////////////////////////////////////////////////////////////////; 492/// Build geometry description; 493 ; 494void RGeomDescription::BuildDescription(TGeoNode *topnode, TGeoVolume *topvolume); 495{; 496 // vector to remember numbers; 497 std::vector<int> numbers;; 498 int offset = 1000000000;; 499 ; 500 // try to build flat list of all nodes; 501 TGeoNode *snode = topnode;; 502 TGeoIterator iter(topvolume);; 503 do {; 504 if (!snode) {; 505 numbers.emplace_back(offset);; 506 fNodes.emplace_back(nullptr);; 507 } else if (snode->GetNumber() >= offset) {; 508 // artificial offset already applied, used as identifier; 509 iter.Skip(); // no need to look inside; 510 } else {; 511 numbers.emplace_back(snode->GetNumber());; 512 snode->SetNumber(offset + fNodes.size()); // use id with shift 1e9; 513 fNodes.emplace_back(snode);; 514 }; 515 } while ((snode =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:12519,clear,clear,12519,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"ode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:73214,simpl,simple,73214,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,2,['simpl'],['simple']
Usability,"odeorig->MakeCopyNode();; 2298 if (!newnode) {; 2299 Fatal(""ReplaceNode"", ""Cannot make copy node for %s"", nodeorig->GetName());; 2300 return nullptr;; 2301 }; 2302 // Change the volume for the new node; 2303 newnode->SetVolume(vol);; 2304 // Replace the matrix; 2305 if (newpos && !nodeorig->IsOffset()) {; 2306 TGeoNodeMatrix *nodemat = (TGeoNodeMatrix *)newnode;; 2307 nodemat->SetMatrix(newpos);; 2308 }; 2309 // Replace nodeorig with new one; 2310 fNodes->RemoveAt(ind);; 2311 fNodes->AddAt(newnode, ind);; 2312 if (fVoxels); 2313 fVoxels->SetNeedRebuild();; 2314 if (IsAssembly()); 2315 fShape->ComputeBBox();; 2316 return newnode;; 2317}; 2318 ; 2319////////////////////////////////////////////////////////////////////////////////; 2320/// Select this volume as matching an arbitrary criteria. The volume is added to; 2321/// a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; 2322/// to be reset at the end by calling the method with CLEAR=true. This will also clear; 2323/// the list.; 2324 ; 2325void TGeoVolume::SelectVolume(Bool_t clear); 2326{; 2327 static TObjArray array(256);; 2328 static Int_t len = 0;; 2329 Int_t i;; 2330 TObject *vol;; 2331 if (clear) {; 2332 for (i = 0; i < len; i++) {; 2333 vol = array.At(i);; 2334 vol->ResetBit(TGeoVolume::kVolumeSelected);; 2335 }; 2336 array.Clear();; 2337 len = 0;; 2338 return;; 2339 }; 2340 SetBit(TGeoVolume::kVolumeSelected);; 2341 array.AddAtAndExpand(this, len++);; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// set visibility of this volume; 2346 ; 2347void TGeoVolume::SetVisibility(Bool_t vis); 2348{; 2349 TGeoAtt::SetVisibility(vis);; 2350 if (fGeoManager->IsClosed()); 2351 SetVisTouched(kTRUE);; 2352 fGeoManager->SetVisOption(4);; 2353 TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 2354 TIter next(brlist);; 2355 TBrowser *browser = nullptr;; 2356 while ((browser = (TBrowser *)next())) {; 2357 browser->CheckObjectItem(this, v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:86270,clear,clear,86270,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['clear'],['clear']
Usability,"odes. ~DecisionTree(); destructor. void SetParentTreeInNodes(TMVA::Node* n = NULL); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. TMVA::DecisionTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); re-create a new tree (decision tree or search tree) from XML. UInt_t BuildTree(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node = NULL); building the decision tree by recursively calling the splitting of; one (root-) node into two daughter nodes (returns the number of nodes). void FillTree(TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(TMVA::DecisionTree::EventList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:10136,clear,clear,10136,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,5,"['Clear', 'clear']","['ClearTree', 'clear']"
Usability,odo: iteration counter for recursive MakeClassFromVarName; Pattern_tfPat[25][1024]array of patterns; ULong64_tfPrevInterpMarker; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance Chart:. TTabCom. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:7959,Clear,ClearGlobals,7959,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,2,['Clear'],['ClearGlobals']
Usability,"of * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Additional Inherited Members;  Public Types inherited from TProofPlayer; enum  EStat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:22052,feedback,feedback,22052,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['feedback'],['feedback']
Usability,"of * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Protected Attributes; TDSet * fDSet;  ; ErrorHandlerFunc_t fErrorHandler;  tdset for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:20345,feedback,feedback,20345,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.CClient program which allows the snooping of objects from a spyserv process ;  spyserv.CServer program which allows clients, ""spies"", to connect and snoop objects ;  TestAuth.CMacro test authentication methods stand alone ;  testTUDPSocket.CAs test echo server use udpserver.c in the same directory ;  treeClient.CClient program which creates and fills 2 histograms and a TTree ;  TUriTest.CRudimentary TUri test macro ;  udpserver.c;  ► physics;  PhaseSpace.C Example of use of TGenPhaseSpace ;  ► proof;  EmptyInclude.hEmpty file to test TProof::Load in run",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:134476,simpl,simple,134476,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability,"of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 34935 2010-08-23 09:13:37Z brun $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:20516,learn,learning,20516,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,2,['learn'],['learning']
Usability,"of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGDockableFrame.html:20961,Undo,UndockContainer,20961,root/html532/TGDockableFrame.html,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html,4,['Undo'],"['Undock', 'UndockContainer']"
Usability,"of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:50403,simpl,simply,50403,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['simpl'],['simply']
Usability,"of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2145 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2160 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2170 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2187 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:50473,simpl,simply,50473,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['simpl'],['simply']
Usability,"of file MethodDT.cxx. ◆ DeclareCompatibilityOptions(). void TMVA::MethodDT::DeclareCompatibilityOptions ; (; ). virtual . options that are used ONLY for the READER to ensure backward compatibility ; Reimplemented from TMVA::MethodBase.; Definition at line 245 of file MethodDT.cxx. ◆ DeclareOptions(). void TMVA::MethodDT::DeclareOptions ; (; ). virtual . Define the options (their key words) that can be set in the option string. . UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting. known:; GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB. nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine misclassification error rate); PruneMethod The Pruning method: known:; NoPruning // switch off pruning completely; ExpectedError; CostComplexity. PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided""); . Implements TMVA::MethodBase.; Definition at line 212 of file MethodDT.cxx. ◆ DeclFileName(). static const char * TMVA::MethodDT::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 139 of file MethodDT.h. ◆ GetHelpMessage(). void TMVA::MethodDT::GetHelpMessage ; (; ); const. virtual . Implements TMVA::IMethod.; Definition at line 561 of file MethodDT.cxx. ◆ GetMvaValue(). Double_t TMVA::MethodDT::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . returns MVA value ; Impleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDT.html:35219,simpl,simply,35219,doc/master/classTMVA_1_1MethodDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDT.html,1,['simpl'],['simply']
Usability,"of file RooVectorDataStore.cxx. ◆ forceCacheUpdate(). void RooVectorDataStore::forceCacheUpdate ; (; ). overrideprotectedvirtual . Reimplemented from RooAbsDataStore.; Definition at line 915 of file RooVectorDataStore.cxx. ◆ get() [1/3]. virtual const RooArgSet * RooAbsDataStore::get ; (; ); const. inlinevirtual . Reimplemented from RooAbsDataStore.; Definition at line 60 of file RooAbsDataStore.h. ◆ get() [2/3]. const RooArgSet * RooVectorDataStore::get ; (; Int_t ; index); const. overridevirtual . Load the n-th data point (n='index') into the variables of this dataset, and return a pointer to the RooArgSet that holds them. ; Implements RooAbsDataStore.; Definition at line 352 of file RooVectorDataStore.cxx. ◆ get() [3/3]. virtual const RooArgSet * RooAbsDataStore::get ; (; Int_t ; index); const. virtual . Implements RooAbsDataStore. ◆ getArrays(). RooVectorDataStore::ArraysStruct RooVectorDataStore::getArrays ; (; ); const. Exports all arrays in this RooVectorDataStore into a simple datastructure to be used by RooFit internal export functions. ; Definition at line 1366 of file RooVectorDataStore.cxx. ◆ getBatches(). RooAbsData::RealSpans RooVectorDataStore::getBatches ; (; std::size_t ; first, . std::size_t ; len . ); const. overridevirtual . Return batches of the data columns for the requested events. ; Parameters. [in]firstFirst event in the batches. ; [in]lenNumber of events in batches. . ReturnsSpans with the associated data. ; Implements RooAbsDataStore.; Definition at line 1137 of file RooVectorDataStore.cxx. ◆ getCategoryBatches(). RooAbsData::CategorySpans RooVectorDataStore::getCategoryBatches ; (; std::size_t ; first, . std::size_t ; len . ); const. overridevirtual . Reimplemented from RooAbsDataStore.; Definition at line 1176 of file RooVectorDataStore.cxx. ◆ getWeightBatch(). std::span< const double > RooVectorDataStore::getWeightBatch ; (; std::size_t ; first, . std::size_t ; len . ); const. overridevirtual . Return the weights of all events in the ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:30588,simpl,simple,30588,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['simpl'],['simple']
Usability,"of file TProof.cxx. ◆ Collect() [4/4]. Int_t TProof::Collect ; (; TMonitor * ; mon, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from the slave servers. ; Returns the number of messages received. Can be 0 if there are no active slaves. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. Collect also stops its execution from time to time to check for new workers in Dynamic Startup mode. ; Definition at line 2756 of file TProof.cxx. ◆ CollectInputFrom(). Int_t TProof::CollectInputFrom ; (; TSocket * ; s, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect and analyze available input from socket s. ; Returns 0 on success, -1 if any failure occurs. ; Definition at line 3060 of file TProof.cxx. ◆ CreateDrawFeedback(). TDrawFeedback * TProof::CreateDrawFeedback ; (; ). Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Definition at line 10094 of file TProof.cxx. ◆ CreateMerger(). Bool_t TProof::CreateMerger ; (; TSlave * ; sl, . Int_t ; port . ). private . Create a new merger. ; Definition at line 4454 of file TProof.cxx. ◆ CreateSlave(). TSlave * TProof::CreateSlave ; (; const char * ; url, . const char * ; ord, . Int_t ; perf, . const char * ; image, . const char * ; workdir . ). protected . Create a new TSlave of type TSlave::kSlave. ; Note: creation of TSlave is private with TProof as a friend. Derived classes must use this function to create slaves. ; Definition at line 1853 of file TProof.cxx. ◆ CreateSubmaster(). TSlave * TProof::CreateSubmaster ; (; const char * ; url, . const char * ; ord, . const char * ; image, . const char * ; msd, . Int_t ; nwk = 1 . ). protected . Create a new TSlave of type TSlave::kMaster. ; Note: creation of TSlave is private with TProof as a friend. Derived classes must use this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:79282,feedback,feedback,79282,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,"of file TRobustEstimator.cxx. ◆ CreateOrtSubset(). void TRobustEstimator::CreateOrtSubset ; (; TMatrixD & ; dat, . Int_t * ; index, . Int_t ; hmerged, . Int_t ; nmerged, . TMatrixD & ; sscp, . Double_t * ; ndist . ). protected . creates a subset of hmerged vectors with smallest orthogonal distances to the hyperplane hyp[1]*(x1-mean[1])+...+hyp[nvar]*(xnvar-mean[nvar])=0 This function is called in case when less than fH samples lie on a hyperplane. ; Definition at line 968 of file TRobustEstimator.cxx. ◆ CreateSubset(). void TRobustEstimator::CreateSubset ; (; Int_t ; ntotal, . Int_t ; htotal, . Int_t ; p, . Int_t * ; index, . TMatrixD & ; data, . TMatrixD & ; sscp, . Double_t * ; ndist . ). protected . creates a subset of htotal elements from ntotal elements first, p+1 elements are drawn randomly(without repetitions) if their covariance matrix is singular, more elements are added one by one, until their covariance matrix becomes regular or it becomes clear that htotal observations lie on a hyperplane If covariance matrix determinant!=0, distances of all ntotal elements are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where M is mean and S_inv is the inverse of the covariance matrix htotal points with smallest distances are included in the returned subset. ; Definition at line 878 of file TRobustEstimator.cxx. ◆ CStep(). Double_t TRobustEstimator::CStep ; (; Int_t ; ntotal, . Int_t ; htotal, . Int_t * ; index, . TMatrixD & ; data, . TMatrixD & ; sscp, . Double_t * ; ndist . ). protected . from the input htotal-subset constructs another htotal subset with lower determinant ; As proven by Peter J.Rousseeuw and Katrien Van Driessen, if distances for all elements are calculated, using the formula:d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where M is the mean of the input htotal-subset, and S_inv - the inverse of its covariance matrix, then htotal elements with smallest distances will have covariance matrix with determinant less or equal to the determinant of the inpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRobustEstimator.html:22631,clear,clear,22631,doc/master/classTRobustEstimator.html,https://root.cern,https://root.cern/doc/master/classTRobustEstimator.html,1,['clear'],['clear']
Usability,"of file TUnfold.cxx. ◆ DoUnfold() [2/3]. Double_t TUnfold::DoUnfold ; (; Double_t ; tau_reg, . const TH1 * ; input, . Double_t ; scaleBias = 0.0 . ). perform the unfolding for a given input and regularisation ; Parameters. [in]tau_regregularisation parameter ; [in]inputinput distribution with uncertainties ; [in]scaleBias(default=0.0) scale factor applied to the bias. This is a shortcut for { SetInput(input,scaleBias); DoUnfold(tau); } ; Definition at line 2235 of file TUnfold.cxx. ◆ DoUnfold() [3/3]. Double_t TUnfold::DoUnfold ; (; void ; ). protectedvirtual . core unfolding algorithm ; Definition at line 246 of file TUnfold.cxx. ◆ ErrorMatrixToHist(). void TUnfold::ErrorMatrixToHist ; (; TH2 * ; ematrix, . const TMatrixDSparse * ; emat, . const Int_t * ; binMap, . Bool_t ; doClear . ); const. protected . add up an error matrix, also respecting the bin mapping ; Parameters. [in,out]ematrixerror matrix histogram ; [in]ematerror matrix stored with internal mapping (member fXToHist) ; [in]binMapmapping of histogram bins ; [in]doClearif true, ematrix is cleared prior to adding elements of emat to it. the array binMap is explained with the method GetOutput(). The matrix emat must have dimension NxN where N=fXToHist.size() The flag doClear may be used to add covariance matrices from several uncertainty sources. ; Definition at line 3379 of file TUnfold.cxx. ◆ GetAx(). const TMatrixDSparse * TUnfold::GetAx ; (; void ; ); const. inlineprotected . vector of folded-back result ; Definition at line 248 of file TUnfold.h. ◆ GetBias(). void TUnfold::GetBias ; (; TH1 * ; out, . const Int_t * ; binMap = nullptr . ); const. get bias vector including bias scale ; Parameters. [out]outhistogram to store the scaled bias vector. The bin contents are overwritten ; [in]binMap(default=nullptr) array for mapping truth bins to histogram bins. This method returns the bias vector times scaling factor, f*x0; The use of binMap is explained with the documentation of the GetOutput() method ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:31556,clear,cleared,31556,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['clear'],['cleared']
Usability,"of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassName(ostream& os) const; Print class name of fit result. void printArgs(ostream& os) const; Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFitResult.html:15476,simpl,simple,15476,root/html532/RooFitResult.html,https://root.cern,https://root.cern/root/html532/RooFitResult.html,4,['simpl'],['simple']
Usability,"of point and max number of points (to pre-allocate vector)Definition UnBinData.h:54; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, unsigned int dim, Iterator dataItr, bool isWeighted=false)constructor for multi-dim external data (data are not copied inside) Uses as argument an iterator of ...Definition UnBinData.h:127; ROOT::Fit::UnBinData::Addvoid Add(const double *x)add multi-dim coordinate dataDefinition UnBinData.h:230; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const double *dataZ, const DataRange &range, bool isWeighted=false)constructor for 3D data and a range (data are copied inside according to the given range) or a 2D dat...Definition UnBinData.h:161; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const DataRange &range, bool isWeighted=false)constructor for 2D data and a range (data are copied inside according to the given range) or 1 1D dat...Definition UnBinData.h:150; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, const double *dataX, const double *dataY, bool isWeighted=false)constructor for 2D external data (data are not copied inside) or 1D data with a weight (if isWeighted...Definition UnBinData.h:101; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28. mathmathcoreincFitUnBinData.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/UnBinData_8h_source.html:14751,simpl,simple,14751,doc/master/UnBinData_8h_source.html,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html,1,['simpl'],['simple']
Usability,"of the analysis: select relevant; // tree entries, run algorithms on the tree entry and typically fill histograms.;  ; // *** 1. *** Tell the reader to load the data for this entry:; fReader.SetEntry(entry);;  ; // *** 2. *** Do the actual analysis; int tagMuon = gRandom->Integer(fRaPt.GetSize());;  ; if (fRaTriggered[tagMuon]) {; for (int iMuon = 0, nMuons = fRaPt.GetSize(); iMuon < nMuons; ++iMuon) {; // All but the tag muon can be probe muons; if (iMuon != tagMuon) {; 	 // Fill the efficiency object with; 	 // - whether this muon has triggered; 	 // - the pT of this muon.; 	 fEff->Fill(fRaTriggered[iMuon], fRaPt[iMuon]);; }; }; };  ; return kTRUE;; };  ; void TutorialSelector::Terminate(); {; // The Terminate() function is the last function to be called during the; // analysis of a tree with a selector. It always runs on the client, it can; // be used to present the results graphically or save the results to file.;  ; fEff->Print();; }.  . . ‹ 10. Go Parallel!; up; 11. Done! ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorialselectorc.html:6370,guid,guidelines,6370,d/tutorialselectorc.html,https://root.cern,https://root.cern/d/tutorialselectorc.html,1,['guid'],['guidelines']
Usability,"of the class that was first created. To retrieve a later instance you can use GetListOfPrimitives(), which returns a list of all the objects on the pad. From the list you can select the object you need.; 9.3.1.2 Hiding an Object; Hiding an object in a pad can be made by removing it from the list of objects owned by that pad. This list is accessible by the GetListOfPrimitives() method of TPad. This method returns a pointer to a TList. Suppose we get the pointer to the object, we want to hide, call it obj (see paragraph above). We get the pointer to the list:; root[] li = gPad->GetListOfPrimitives(); Then remove the object from this list:; root[] li->Remove(obj); The object will disappear from the pad as soon as the pad is updated (try to resize it for example). If one wants to make the object reappear:; root[] obj->Draw(); Caution, this will not work with composed objects, for example many histograms drawn on the same plot (with the option “same”). There are other ways! Try to use the method described here for simple objects.; 9.3.2 The Coordinate Systems of a Pad; There are coordinate systems in a TPad: user coordinates, normalized coordinates (NDC), and pixel coordinates. Pad coordinate systems. 9.3.2.1 The User Coordinate System; The most common is the user coordinate system. Most methods of TPad use the user coordinates, and all graphic primitives have their parameters defined in terms of user coordinates. By default, when an empty pad is drawn, the user coordinates are set to a range from 0 to 1 starting at the lower left corner. At this point they are equivalent of the NDC coordinates (see below). If you draw a high level graphical object, such as a histogram or a function, the user coordinates are set to the coordinates of the histogram. Therefore, when you set a point it will be in the histogram coordinates.; For a newly created blank pad, one may use TPad::Range to set the user coordinate system. This function is defined as:; void Range(float x1,float y1,floa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:307442,simpl,simple,307442,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"of the distribution D (Max). A box plot describes a distribution with only five numbers. In ROOT Box Plots (Candle Plots) can be produced from a TTree using the “candle” option in TTree::Draw().; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; 12.20.9 Using TTree::Scan. TTree::Scan can be used to print the content of the tree’s entries optional passing a selection.; root[] MyTree->Scan();; will print the first 8 variables of the tree.; root[] MyTree->Scan(""*"");; will print all the variable of the tree.; Specific variables of the tree can be explicit selected by list them in column separated list:; root[] MyTree->Scan(""var1:var2:var3"");; will print the values of var1, var2 and var3. A selection can be applied in the second argument:; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; will print the values of var1, var2 and var3 for the entries where var1 is exactly 0.; TTree::Scan returns the number of entries passing the selection. By default 50 rows are shown before TTree::Scan pauses and ask you to press the Enter key to see the next 50 rows. You can change the default number of rows to be shown before <CR> via mytree->SetScanfield(maxrows) where maxrows is 50 by default. If maxrows is set to 0 all rows of the Tree are shown. This option is interesting when dumping the contents of a Tree to an ascii file, eg from the command line:; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; will create a file tree.log.; Arrays (within an entry) are printed in their linear forms. If several arrays with multiple dimensions are printed together, they will NOT be synchronized. For example, with a tree containing arr1[4][2]and arr2[2][3],; root[] MyTree(""arr1:arr2"");; will results in a printing similar to:; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:619345,pause,pauses,619345,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['pause'],['pauses']
Usability,"of these entries that pass the selection, and when you have a parametrization available for the efficiency as a function of the variable(s) under consideration.; A very common problem when estimating efficiencies is that of error estimation: when no other information is available than the total number of events N and the selected number n, the best estimate for the selection efficiency p is n/N. Standard binomial statistics dictates that the uncertainty (this presupposes sufficiently high statistics that an approximation by a normal distribution is reasonable) on p, given N, is ; \[; \sqrt{\frac{p(1-p)}{N}}; \]. However, when p is estimated as n/N, fluctuations from the true p to its estimate become important, especially for low numbers of events, and giving rise to biased results.; When fitting a parametrized efficiency, these problems can largely be overcome, as a hypothesized true efficiency is available by construction. Even so, simply using the corresponding uncertainty still presupposes that Gaussian errors yields a reasonable approximation. When using, instead of binned efficiency histograms, the original numerator and denominator histograms, a binned maximum likelihood can be constructed as the product of bin-by-bin binomial probabilities to select n out of N events. Assuming that a correct parametrization of the efficiency is provided, this construction in general yields less biased results (and is much less sensitive to binning details).; A generic use of this method is given below (note that the method works for 2D and 3D histograms as well):; {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status == 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html:1488,simpl,simply,1488,doc/master/classTBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html,1,['simpl'],['simply']
Usability,"ofServ::GetOptions(Int_t* argc, char** argv); const char*TProofServ::GetOrdinal() const; const char*TProofServ::GetPackageDir() const; const char*TProofServ::GetPrefix() const; TProof*TProofServ::GetProof() const; Int_tTProofServ::GetProtocol() const; Int_tTProofServ::GetQuerySeqNum() const; Float_tTProofServ::GetRealTime() const; static Long_tTProofServ::GetResMemMax(); const char*TProofServ::GetService() const; const char*TProofServ::GetSessionDir() const; const char*TProofServ::GetSessionTag() const; TSignalHandler*TApplication::GetSignalHandler() const; TSocket*TProofServ::GetSocket() const; virtual const char*TObject::GetTitle() const; const char*TProofServ::GetTopSessionTag() const; Int_tTProofServ::GetTotSessions() const; virtual UInt_tTObject::GetUniqueID() const; const char*TProofServ::GetUser() const; static Long_tTProofServ::GetVirtMemMax(); const char*TProofServ::GetWorkDir() const; virtual TProofServ::EQueryActionGetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); virtual Bool_tHandleError(const void* in = 0); virtual voidTProofServ::HandleException(Int_t sig); virtual voidTApplication::HandleIdleTimer()SIGNAL ; virtual Bool_tHandleInput(const void* in = 0); virtual voidHandleSigPipe(); virtual voidTProofServ::HandleSocketInput(); virtual Int_tTProofServ::HandleSocketInput(TMessage* mess, Bool_t all); virtual voidHandleTermination(); virtual Bool_tTApplication::HandleTermInput(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual voidHandleUrgentData(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTApplication::Hide(); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::Iconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofServ.html:7567,resume,resume,7567,root/html534/TXProofServ.html,https://root.cern,https://root.cern/root/html534/TXProofServ.html,6,['resume'],['resume']
Usability,"ogger &ml)Definition MsgLogger.h:148; Remark: in batch mode, the progress bar is quite ugly; you may want to use the text output then; Note that by default in TMVA::Config the drawing of the progress bar is switched off. To have the progress bar visible you need to enable it by calling TMVA::gConfig().SetDrawProgressBar(true) ; Definition at line 58 of file Timer.h. Public Member Functions;  Timer (const char *prefix="""", Bool_t colourfulOutput=kTRUE);  constructor ;  ;  Timer (Int_t ncounts, const char *prefix="""", Bool_t colourfulOutput=kTRUE);  standard constructor: ncounts gives the total number of counts that the loop will iterate through. ;  ; virtual ~Timer (void);  destructor ;  ; void DrawProgressBar (Int_t, const TString &comment="""");  draws progress bar in color or B&W caution: ;  ; void DrawProgressBar (TString);  draws a string in the progress bar ;  ; void DrawProgressBar (void);  draws the progressbar ;  ; Double_t ElapsedSeconds (void);  computes elapsed tim in seconds ;  ; TString GetElapsedTime (Bool_t Scientific=kTRUE);  returns pretty string with elapsed time ;  ; TString GetLeftTime (Int_t icounts);  returns pretty string with time left ;  ; void Init (Int_t ncounts);  ; virtual TClass * IsA () const;  ; void Reset (void);  resets timer ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TStopwatch;  TStopwatch ();  Create a stopwatch and start it. ;  ; void Continue ();  Resume a stopped stopwatch. ;  ; Int_t Counter () const;  ; Double_t CpuTime ();  Stop the stopwatch (if it is running) and return the cputime (in seconds) passed between the start and stop events. ;  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print the real and cpu time passed between the start and stop events. ;  ; Double_t RealTime ();  Stop the stopwatch (if it is running) and return the realtime (in s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Timer.html:1912,progress bar,progress bar,1912,doc/master/classTMVA_1_1Timer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Timer.html,2,['progress bar'],['progress bar']
Usability,"ogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefinition Tools.cxx:1140; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::HistoHasEquidistantBinsBool_t HistoHasEquidistantBins(const TH1 &h)Definition Tools.cxx:1486; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::NormVariableDouble_t NormVariable(Double_t x, Double_t xmin, Double_t xmax)normalise to output range: [-1, 1]Definition Tools.cxx:110; TMVA::Tools::WriteFloatArbitraryPrecisionvoid WriteFloatArbitraryPrecision(Float_t val, std::ostream &os)writes a float value with the available precision to a streamDefinition Tools.cxx:1058; TMVA::Tools::GetYTitleWithUnitTString GetYTitleWithUnit(const TH1 &h, const TString &unit, Bool_t normalised)histogramming utilityDefinition Tools.cxx:1048; TMVA::Tools::GetSeparationDouble_t GetSeparation(TH1 *S, TH1 *B) constcompute ""separation"" defined asDefinition Tools.cxx:121; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:72806,simpl,simple,72806,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['simpl'],['simple']
Usability,"ogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:21978,undo,undo,21978,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,10,['undo'],['undo']
Usability,"ogram are only updated, when the Slider is released. This should be activated if the redrawing of the histogram is too time consuming. // ; Definition at line 33 of file TH1Editor.h. Public Member Functions;  TH1Editor (const TGWindow *p=nullptr, Int_t width=140, Int_t height=30, UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());  Constructor of histogram attribute GUI. ;  ;  ~TH1Editor () override;  Destructor of TH1 editor. ;  ; Bool_t AcceptModel (TObject *model) override;  Check if object is able to configure with this editor. ;  ; Int_t * Dividers (Int_t n);  Return an array of dividers of n (without the trivial divider n). ;  ; virtual void DoAddB (Bool_t);  Slot connected to the bar Add check box. ;  ; virtual void DoAddBar (Bool_t);  Slot connected to the bar Add check box. ;  ; virtual void DoAddMarker (Bool_t on);  Slot connected to the show markers check box. ;  ; virtual void DoAddSimple (Bool_t on);  Slot connected to fAddSimple check box for drawing a simple histogram without errors (== HIST draw option) in combination with some other draw options. ;  ; virtual void DoApply ();  Slot connected to the Apply button of the Binning tab. ;  ; virtual void DoAxisRange ();  Slot connected to the number entry fields containing the Max/Min value of the x-axis. ;  ; virtual void DoBarOffset ();  Slot connected to the Bar Offset of the Bar Charts. ;  ; virtual void DoBarWidth ();  Slot connected to the Bar Width of the Bar Charts. ;  ; virtual void DoBinLabel ();  Slot connected to the Bin number entry of the Rebinning tab. ;  ; virtual void DoBinLabel1 ();  Slot connected to the Bin number entry of the Rebinning tab. ;  ; virtual void DoBinMoved (Int_t number);  Slot connected to the rebin slider in case of a not ntuple histogram (does the Rebinning of the histogram). ;  ; virtual void DoBinMoved1 ();  Slot connected to the rebin slider in case of an ntuple histogram. ;  ; virtual void DoBinOffset ();  Slot connected to the OffSetNumberEntry ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:4769,simpl,simple,4769,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,1,['simpl'],['simple']
Usability,"ogram fitting option, WIDTH to fit directly density. The bin content in this case is scaled by the histogram bin width. TFormula. Fix several bugs in the new TFormula class.; Add as new pre-defined functions: crystalball, breitwigner and cheb0,cheb1,...cheb10 for the Chebyshev polynomials. Math Libraries; Random numbers. Move from MathMore to MathCore the class ROOT::Math::Random. Make it a new interface class for random number generation. Add interfaces for standard ROOT random engines, GSL random engines and random engines provided by the C++ standard library (std::random).; Add a new randomengine, MIXMAX based on matrix-recursive random number generator from Kostas and George Savvidy. See this paper. R Interface; Apply several improvements in the interface to R, allowing to use R functions within ROOT. See more at the ROOT-R User Guide.; TMVA; Add new TMVA plug-in based on R and Python (using Scikit-Learn) * See the RMVA Web page for a detailed description of the new TMVA method based on R * See the PyMVA Web page for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package.; RooFit Libraries; 2D Graphics Libraries; THistPainter; Improve the algorithm to compute the lower limit of an axis in log scale when its real lower limit is 0. The problem was reported in ROOT-7414.; Using the COL option with histograms having some negative bins; the empty bins (containing 0) are drawn. In some cases one wants to not draw empty bins (containing 0) of histograms having a negative minimum. The option 1, used with the option COL, allows to do that.; Implement the Log option for CANDLE plots as requested here.; TTeXDump; From Dmitry Kalinkin (via github): Fix file corruption in TTeXDump::DrawPolyMarker The current implementation of TTeXDump uses TVirtualPS::PrintFast based methods to output TeX markup with automatic line-wraps. Yet these methods are optimized for PostScript format where there are a lot of space characters th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:14329,learn,learning,14329,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['learn'],['learning']
Usability,"ogram from a parametric function ;  FirstContour.C Make a contour plot and get the first contour in a TPolyMarker ;  h1draw.C 1-D histogram drawing options ;  h2proj.C;  hbars.C Example of bar charts with 1-d histograms ;  histpalettecolor.C Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  hksimple.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplot6.py Exa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:123265,simpl,simple,123265,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"ogram->GetYaxis()->GetNdivisions();; 3634 ; 3635 delete fHistogram;; 3636 fHistogram = nullptr;; 3637 GetHistogram();; 3638 ; 3639 fHistogram->GetXaxis()->SetTitle(XAxisTitle.Data());; 3640 fHistogram->GetYaxis()->SetTitle(YAxisTitle.Data());; 3641 fHistogram->GetXaxis()->SetLabelColor(XLabCol);; 3642 fHistogram->GetYaxis()->SetLabelColor(YLabCol);; 3643 fHistogram->GetXaxis()->SetLabelFont(XLabFont);; 3644 fHistogram->GetYaxis()->SetLabelFont(YLabFont);; 3645 fHistogram->GetXaxis()->SetLabelOffset(XLabOffset);; 3646 fHistogram->GetYaxis()->SetLabelOffset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be set by a user in a fitting function.; 3681/// The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions.; 3682 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:139378,clear,clear,139378,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['clear'],['clear']
Usability,"ogress bar for clear data. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProof.html:61161,Clear,ClearPackages,61161,root/html532/TProof.html,https://root.cern,https://root.cern/root/html532/TProof.html,1,['Clear'],['ClearPackages']
Usability,"ogress bar for clear data. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:70413,Clear,ClearPackages,70413,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['Clear'],['ClearPackages']
Usability,"ogress bar for clear data. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuild",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:72571,Clear,ClearPackages,72571,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,1,['Clear'],['ClearPackages']
