quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Safety,"unction defines the Minuit fitting function as being H1FitChisquare or H1FitLikelihood depending on the options selected. H1FitChisquare calculates the chisquare between the user fitting function (gaussian, polynomial, user defined,etc) and the data for given values of the parameters. It is the task of MINUIT to find those values of the parameters which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits.; For variable parameters with limits, MINUIT uses the following transformation:. \[; P_{\mathrm{int}} = \arcsin; \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); \]. so that the internal value \(P_{\mathrm{int}}\) can take on any value, while the external value \(P_{\mathrm{ext}}\) can take on values only between the lower limit \(a\) and the upper limit \(b\). Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical roundoff both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if he puts limits of \((0,10^{10})\) on a parameter, then the values \(0.0\) and \(1.0\) will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the `‘parabolic’' parameter errors) when there are parameter limits. U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:3233,avoid,avoided,3233,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['avoid'],['avoided']
Safety,"unction. ; Parameters. xThe Landau parameter \(x = \lambda_L\) . Reimplemented from ROOT::Math::IParametricFunctionOneDim.; Definition at line 89 of file VavilovAccurateCdf.cxx. ◆ DoEvalPar(). double ROOT::Math::VavilovAccurateCdf::DoEvalPar ; (; double ; x, . const double * ; p . ); const. overridevirtual . Evaluate the function, using parameters p. ; Parameters. xThe Landau parameter \(x = \lambda_L\) ; pvector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). . Implements ROOT::Math::IParametricFunctionOneDim.; Definition at line 94 of file VavilovAccurateCdf.cxx. ◆ NPar(). unsigned int ROOT::Math::VavilovAccurateCdf::NPar ; (; ); const. overridevirtual . Return the number of Parameters. ; Implements ROOT::Math::IBaseParam.; Definition at line 74 of file VavilovAccurateCdf.cxx. ◆ ParameterName(). std::string ROOT::Math::VavilovAccurateCdf::ParameterName ; (; unsigned int ; i); const. overridevirtual . Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ; Reimplemented from ROOT::Math::IBaseParam.; Definition at line 78 of file VavilovAccurateCdf.cxx. ◆ Parameters(). const double * ROOT::Math::VavilovAccurateCdf::Parameters ; (; ); const. overridevirtual . Access the parameter values. ; Implements ROOT::Math::IBaseParam.; Definition at line 64 of file VavilovAccurateCdf.cxx. ◆ SetParameters(). void ROOT::Math::VavilovAccurateCdf::SetParameters ; (; const double * ; p). overridevirtual . Set the parameter values. ; Parameters. pvector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). . Implements ROOT::Math::IBaseParam.; Definition at line 68 of file VavilovAccurateCdf.cxx. Member Data Documentation. ◆ fP. double ROOT::Math::VavilovAccurateCdf::fP[5]. private . Definition at line 136 of file VavilovAccurateCdf.h. Libraries for ROOT::Math::VavilovAccurateCdf:. [legend]; The documentation for this class was generated from the following files:; math/ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovAccurateCdf.html:5352,avoid,avoid,5352,doc/master/classROOT_1_1Math_1_1VavilovAccurateCdf.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety,"unctions; static std::string GenerateKey (int keylen=32);  Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in bytes Output string will be hex formatted and includes ""-"" separator after every 4 bytes Example for 16 bytes: ""fca45856-41bee066-ff74cc96-9154d405"". ;  . Private Attributes; std::string fAddr;  ! HTTP address of the server ;  ; std::unique_ptr< TExec > fAssgnExec;  ! special exec to assign thread id via ProcessEvents ;  ; bool fExternalProcessEvents {false};  ! indicate that there are external process events engine ;  ; unsigned fIdCnt {0};  ! counter for identifiers ;  ; float fLaunchTmout {30.};  ! timeout in seconds to start browser process, default 30s ;  ; std::recursive_mutex fMutex;  ! main mutex, used for window creations ;  ; std::unique_ptr< THttpServer > fServer;  ! central communication with the all used displays ;  ; std::string fSessionKey;  ! secret session key used on client to code connections keys ;  ; WebWindowShowCallback_t fShowCallback;  ! function called for each RWebWindow::Show call ;  ; bool fUseHttpThrd {false};  ! use special thread for THttpServer ;  ; bool fUseSenderThreads {false};  ! use extra threads for sending data from RWebWindow to clients ;  ; bool fUseSessionKey {false};  ! is session key has to be used for data signing ;  . Friends; class RWebWindow;  . #include <ROOT/RWebWindowsManager.hxx>; Constructor & Destructor Documentation. ◆ RWebWindowsManager(). RWebWindowsManager::RWebWindowsManager ; (; ). window manager constructor Required here for correct usage of unique_ptr<THttpServer> ; Definition at line 201 of file RWebWindowsManager.cxx. ◆ ~RWebWindowsManager(). RWebWindowsManager::~RWebWindowsManager ; (; ). window manager destructor Required here for correct usage of unique_ptr<THttpServer> ; Definition at line 215 of file RWebWindowsManager.cxx. Member Function Documentation. ◆ AssignMainThrd(). void RWebWindowsManager::AssignMainThrd ; (; ). static . Re-assigns m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:5527,timeout,timeout,5527,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['timeout'],['timeout']
Safety,"und vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& vars1, TVectorD& vars2, TVectorD& vars3, TVectorD& vars); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. TQpLinSolverBase & operator=(const TQpLinSolverBase& source); Assignment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpLinSolverBase.html:7330,recover,recovers,7330,root/html528/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html,4,['recover'],['recovers']
Safety,"undaryErrors (Int_t ntracks=1000000, Double_t radius=-1.) override;  Check pushes and pulls needed to cross the next boundary with respect to the position given by FindNextBoundary. ;  ; void CheckBoundaryReference (Int_t icheck=-1) override;  Check the boundary errors reference file created by CheckBoundaryErrors method. ;  ; void CheckEdit ();  Check if Ged library is loaded and load geometry editor classe. ;  ; void CheckGeometry (Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const override;  Geometry checking method (see TGeoChecker). ;  ; void CheckGeometryFull (Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr) override;  Geometry checking method (see: TGeoManager::CheckGeometry()) ;  ; void CheckOverlaps (const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const override;  Check overlaps for the top volume of the geometry, within a limit OVLP. ;  ; void CheckPoint (Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.) override;  Check current point in the geometry. ;  ; void CheckShape (TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) override;  Test for shape navigation methods. ;  ; Int_t CountNodes (TGeoVolume *vol, Int_t level) const;  Count number of visible nodes down to a given level. ;  ; Int_t CountVisibleNodes () override;  Count total number of visible nodes. ;  ; void DefaultAngles () override;  Set default angles for the current view. ;  ; void DefaultColors () override;  Set default volume colors according to tracking media. ;  ; Int_t DistanceToPrimitiveVol (TGeoVolume *vol, Int_t px, Int_t py) override;  Compute the closest distance of approach from point px,py to a volume. ;  ; void Draw (Option_t *option="""") override;  Draw method. ;  ; void DrawBatemanSol (TGeoBatemanSol *sol, Option_t *option="""") override;  Draw the time evolution of a radionuclide. ;  ; void DrawCurrentPoint (Int_t color) override;  Draw curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPainter.html:2236,safe,safety,2236,doc/master/classTGeoPainter.html,https://root.cern,https://root.cern/doc/master/classTGeoPainter.html,1,['safe'],['safety']
Safety,"unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. map<TString,ClassRelInfo>_c2fmapList of contained classes; Bool_t_compiledOK! Flag indicating that classes compiled OK; map<TString,ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& b); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last change",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooWorkspace__CodeRepo.html:7091,abort,abort,7091,root/html528/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html528/RooWorkspace__CodeRepo.html,3,['abort'],['abort']
Safety,"unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. map<TString,ClassRelInfo>_c2fmapList of contained classes; Bool_t_compiledOK! Flag indicating that classes compiled OK; map<TString,ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& b); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace=0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last changed:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooWorkspace__CodeRepo.html:7105,abort,abort,7105,root/html526/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html526/RooWorkspace__CodeRepo.html,1,['abort'],['abort']
Safety,"unning this macro create an instance of Det and Event; Det d;; Event e;; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; EventDefinition collection_proxies.C:172; now you can see the effect of the ClassDef() and ClassImp() macros. (for the Det class these commands are commented!) For instance 'e' now knows who it is:; cout<<e.Class_Name()<<endl;; whereas d does not.; The methods that are added by the ClassDef()/Imp() macro can be listed with; .class; .class Event; .class Det; ; #include <TRandom.h>; #include <TTree.h>; #include <TCanvas.h>; #include <TStyle.h>; ; #include <Riostream.h>; ; //class Det : public TObject {; class Det { // each detector gives an energy and time signal; public:; Double_t e; //energy; Double_t t; //time; ; // ClassDef(Det,1); };; ; //ClassImp(Det); ; //class Event { //TObject is not required by this example; class Event : public TObject {; public:; ; Det a; // say there are two detectors (a and b) in the experiment; Det b;; ClassDefOverride(Event,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree0_8C.html:1110,detect,detector,1110,doc/master/tree0_8C.html,https://root.cern,https://root.cern/doc/master/tree0_8C.html,2,['detect'],"['detector', 'detectors']"
Safety,"untercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TStyleDialog. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window mana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStyleDialog.html:23649,avoid,avoid,23649,root/html602/TStyleDialog.html,https://root.cern,https://root.cern/root/html602/TStyleDialog.html,4,['avoid'],['avoid']
Safety,"up in a; previous time slot, as recorded in TPerfStats::WriteQueryLog()). Currently the group priority is obtained by a query in a SQL DB; table proofpriority, which has the format:; CREATE TABLE proofpriority (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; group VARCHAR(32) NOT NULL,; priority INT; ). Int_t SendAsynMessage(const char* msg, Bool_t lf = kTRUE); Send an asychronous message to the master / client .; Masters will forward up the message to the client.; The client prints 'msg' of stderr and adds a '\n'/'\r' depending on; 'lf' being kTRUE (default) or kFALSE.; Returns the return value from TSocket::Send(TMessage &) . void FlushLogFile(); Reposition the read pointer in the log file to the very end.; This allows to ""hide"" useful debug messages during normal operations; while preserving the possibility to have them in case of problems. void TruncateLogFile(); Truncate the log file to the 80% of the required max size if this; is set. void HandleException(Int_t sig); Exception handler: we do not try to recover here, just exit. Int_t HandleDataSets(TMessage* mess, TString* slb = 0); Handle here requests about datasets. void HandleSubmerger(TMessage* mess); Handle a message of type kPROOF_SUBMERGER. void HandleFork(TMessage* mess); Cloning itself via fork. Not implemented. Int_t Fork(); Fork a child.; If successful, return 0 in the child process and the child pid in the parent; process. The child pid is registered for reaping.; Return <0 in the parent process in case of failure. void ResolveKeywords(TString& fname, const char* path = 0); Replace <ord>, <user>, <u>, <group>, <stag>, <qnum> and <file> placeholders in fname. Int_t GetSessionStatus(); Return the status of this session:; 0 idle; 1 running; 2 being terminated (currently unused); 3 queued; 4 idle timed-out (not set in here but in TIdleTOTimer::Notify); This is typically run in the reader thread, so access needs to be protected. Int_t UpdateSessionStatus(Int_t xst = -1); Update the session status in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:29147,recover,recover,29147,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['recover'],['recover']
Safety,"up in a; previous time slot, as recorded in TPerfStats::WriteQueryLog()). Currently the group priority is obtained by a query in a SQL DB; table proofpriority, which has the format:; CREATE TABLE proofpriority (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; group VARCHAR(32) NOT NULL,; priority INT; ). Int_t SendAsynMessage(const char* msg, Bool_t lf = kTRUE); Send an asychronous message to the master / client .; Masters will forward up the message to the client.; The client prints 'msg' of stderr and adds a '\n'/'\r' depending on; 'lf' being kTRUE (default) or kFALSE.; Returns the return value from TSocket::Send(TMessage &) . void FlushLogFile(); Reposition the read pointer in the log file to the very end.; This allows to ""hide"" useful debug messages during normal operations; while preserving the possibility to have them in case of problems. void TruncateLogFile(); Truncate the log file to the 80% of the required max size if this; is set. void HandleException(Int_t sig); Exception handler: we do not try to recover here, just exit. Int_t HandleDataSets(TMessage* mess, TString* slb = 0); Handle here requests about datasets. void HandleSubmerger(TMessage* mess); Handle a message of type kPROOF_SUBMERGER. void HandleFork(TMessage* mess); Cloning itself via fork. Not implemented. Int_t Fork(); Fork a child.; If successful, return 0 in the child process and the child pid in the parent; process. The child pid is registered for reaping.; Return <0 in the parent process in case of failure. void ResolveKeywords(TString& fname, const char* path = 0); Replace <ord>, <user>, <u>, <group>, <stag>, <qnum>, <file>, <rver> and; <build> placeholders in fname.; Here, <rver> is the root version in integer form, e.g. 53403, and <build> a; string includign version, architecture and compiler version, e.g.; '53403_linuxx8664gcc_gcc46' . Int_t GetSessionStatus(); Return the status of this session:; 0 idle; 1 running; 2 being terminated (currently unused); 3 queued; 4 idle timed-out (not se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:30119,recover,recover,30119,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,3,['recover'],['recover']
Safety,"up the calling thread. void AfterCancel(TThread* th); Static method which is called after the thread has been canceled. Int_t Exit(void* ret = 0); Static method which terminates the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TThread.html:12885,safe,safe,12885,root/html528/TThread.html,https://root.cern,https://root.cern/root/html528/TThread.html,2,['safe'],['safe']
Safety,"uration {; 911 // Configuration object for the Float16/Double32 where a factor has been specified.; 912 public:; 913 Int_t fNbits;; 914 TConfNoFactor(TVirtualStreamerInfo *info, UInt_t id, TCompInfo_t *compinfo, Int_t offset, Int_t nbits) : TConfiguration(info,id,compinfo,offset),fNbits(nbits) {};; 915 TConfiguration *Copy() override { return new TConfNoFactor(*this); }; 916 };; 917 ; 918 template <typename T>; 919 INLINE_TEMPLATE_ARGS Int_t ReadBasicType_NoFactor(TBuffer &buf, void *addr, const TConfiguration *config); 920 {; 921 // Stream a Float16 or Double32 where a factor has not been specified.; 922 ; 923 TConfNoFactor *conf = (TConfNoFactor *)config;; 924 Int_t nbits = conf->fNbits;; 925 ; 926 buf.ReadWithNbits( (T*)( ((char*)addr) + config->fOffset ), nbits );; 927 return 0;; 928 }; 929 ; 930 INLINE_TEMPLATE_ARGS Int_t ReadTString(TBuffer &buf, void *addr, const TConfiguration *config); 931 {; 932 // Read in a TString object.; 933 ; 934 // Idea: We could separate the TString Streamer in its two parts and; 935 // avoid the if (buf.IsReading()) and try having it inlined.; 936 ((TString*)(((char*)addr)+config->fOffset))->TString::Streamer(buf);; 937 return 0;; 938 }; 939 ; 940 INLINE_TEMPLATE_ARGS Int_t ReadTObject(TBuffer &buf, void *addr, const TConfiguration *config); 941 {; 942 // Read in a TObject object part.; 943 ; 944 // Idea: We could separate the TObject Streamer in its two parts and; 945 // avoid the if (buf.IsReading()).; 946 ((TObject*)(((char*)addr)+config->fOffset))->TObject::Streamer(buf);; 947 return 0;; 948 }; 949 ; 950 INLINE_TEMPLATE_ARGS Int_t ReadTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 951 {; 952 // Read in a TNamed object part.; 953 // Since the TNamed streamer is solely delegating back to the StreamerInfo we; 954 // can skip the streamer.; 955 ; 956 // Idea: We could extract the code from ReadClassBuffer and avoid one function; 957 // code.; 958 static const TClass *TNamed_cl = TNamed::Class();; 959 return buf.Read",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:37991,avoid,avoid,37991,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"urce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolume. class TGeoVolume: public TNamed, public TGeoAtt, public TAttLine, public TAttFill, public TAtt3D. TGeoVolume - the base class representing solids. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put togeather a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:1134,avoid,avoid,1134,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,3,['avoid'],['avoid']
Safety,"ure).; 14.6.2 Condition number; The numerical accuracy of the solution x in Ax = b can be accurately estimated by calculating the condition number k of matrix \(A\), which is defined as:; \(k = ||A||_{1}||A^{-1}||_{1}\) where \(||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)\); A good rule of thumb is that if the matrix condition number is 10n, the accuracy in x is 15 - n digits for double precision.; Hager devised an iterative method (W.W. Hager, Condition estimators, SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to determine \(||A^{-1}||_{1}\) without actually having to calculate \(A^{-1}\). It is used when calling Condition().; A code example below shows the usage of the condition number. The matrix \(A\) is a (10x10) Hilbert matrix that is badly conditioned as its determinant shows. We construct a vector b by summing the matrix rows. Therefore, the components of the solution vector x should be exactly 1. Our rule of thumb to the 2.1012 condition number predicts that the solution accuracy should be around; 15 - 12 = 3; digits. Indeed, the largest deviation is 0.00055 in component 6.; TMatrixDSym H = THilbertMatrixDSym(10);; TVectorD rowsum(10);; for (Int_t irow = 0; irow < 10; irow++); for (Int_t icol = 0; icol < 10; icol++); rowsum(irow) += H(irow,icol);; TDecompLU lu(H);; Bool_t ok;; TVectorD x = lu.Solve(rowsum,ok);; Double_t d1,d2;; lu.Det(d1,d2);; cout << ""cond:"" << lu.Condition() << endl;; cout << ""det :"" << d1*TMath:Power(2.,d2) << endl;; cout << ""tol :"" << lu.GetTol() << endl;; x.Print();; cond:3.9569e+12; det :2.16439e-53; tol :2.22045e-16; Vector 10 is as follows; | 1 |; ------------------; 0 |1; 1 |1; 2 |0.999997; 3 |1.00003; 4 |0.999878; 5 |1.00033; 6 |0.999452; 7 |1.00053; 8 |0.999723; 9 |1.00006; 14.6.3 LU; Decompose an nxn matrix \(A\).; PA = LU; P permutation matrix stored in the index array fIndex: j=fIndex[i] indicates that row j and rowishould be swapped. Sign of the permutation, \(-1^n\), where n is the number of interchanges in the permuta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:795486,predict,predicts,795486,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['predict'],['predicts']
Safety,"urn TTime(0);; 466}; 467 ; 468////////////////////////////////////////////////////////////////////////////////; 469/// Add timer to list of system timers.; 470 ; 471void TSystem::AddTimer(TTimer *ti); 472{; 473 if (ti && fTimers && (fTimers->FindObject(ti) == nullptr)); 474 fTimers->Add(ti);; 475}; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Remove timer from list of system timers. Returns removed timer or 0; 479/// if timer was not active.; 480 ; 481TTimer *TSystem::RemoveTimer(TTimer *ti); 482{; 483 if (fTimers) {; 484 TTimer *tr = (TTimer*) fTimers->Remove(ti);; 485 return tr;; 486 }; 487 return nullptr;; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Time when next timer of mode (synchronous=kTRUE or; 492/// asynchronous=kFALSE) will time-out (in ms).; 493 ; 494Long_t TSystem::NextTimeOut(Bool_t mode); 495{; 496 if (!fTimers) return -1;; 497 ; 498 TListIter it(fTimers);; 499 TTimer *t, *to = nullptr;; 500 Long64_t tt, tnow = Now();; 501 Long_t timeout = -1;; 502 ; 503 while ((t = (TTimer *) it.Next())) {; 504 if (t->IsSync() == mode) {; 505 tt = (Long64_t)t->GetAbsTime() - tnow;; 506 if (tt < 0) tt = 0;; 507 if (timeout == -1) {; 508 timeout = (Long_t)tt;; 509 to = t;; 510 }; 511 if (tt < timeout) {; 512 timeout = (Long_t)tt;; 513 to = t;; 514 }; 515 }; 516 }; 517 ; 518 if (to && to->IsAsync() && timeout > 0) {; 519 if (to->IsInterruptingSyscalls()); 520 SigAlarmInterruptsSyscalls(kTRUE);; 521 else; 522 SigAlarmInterruptsSyscalls(kFALSE);; 523 }; 524 ; 525 return timeout;; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Add a signal handler to list of system signal handlers. Only adds; 530/// the handler if it is not already in the list of signal handlers.; 531 ; 532void TSystem::AddSignalHandler(TSignalHandler *h); 533{; 534 if (h && fSignalHandler && (fSignalHandler->FindObject(h) == nullptr)); 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:15059,timeout,timeout,15059,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"urrent label. Use getCurrentLabel() for more clarity. ;  ; virtual bool isValid (const RooCatType &value) const;  Check if given state is defined for this object. ;  ; const RooCatType * defineType (const char *label);  ; const RooCatType * defineType (const char *label, int index);  ; const RooCatType * defineTypeUnchecked (const char *label, value_type index);  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsCategory.h>. Inheritance diagram for RooAbsCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ value_type. using RooAbsCategory::value_type = int. The type used to denote a specific category state. ; Definition at line 36 of file RooAbsCategory.h. Constructor & Destructor Documentation. ◆ RooAbsCategory() [1/3]. RooAbsCategory::RooAbsCategory ; (; ). Definition at line 76 of file RooAbsCategory.cxx. ◆ RooAbsCategory() [2/3]. RooAbsCategory::RooAbsCategory ; (; const char * ; name, . const char * ; title . ). Constructor. ; Definition at line 82 of file RooAbsCategory.cxx. ◆ RooAbsCategory() [3/3]. RooAbsCategory::RooAbsCategory ; (; const RooAbsCategory & ; other, . const char * ; name = nullptr . ). Copy constructor, copies the registered category states from the original. ; Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:45397,Avoid,Avoids,45397,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['Avoid'],['Avoids']
Safety,"urrent message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:361307,timeout,timeout,361307,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"urrent message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:361340,timeout,timeout,361340,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"urrentNode->GetVolume();}. const Double_t * GetCldirChecked() const; {return fCldirChecked;}. const Double_t * GetCldir() const; {return fCldir;}. TGeoHMatrix * GetDivMatrix() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fDivMatrix;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return fCache->P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigator.html:22600,safe,safe,22600,root/html532/TGeoNavigator.html,https://root.cern,https://root.cern/root/html532/TGeoNavigator.html,2,['safe'],['safe']
Safety,"urrentNode->GetVolume();}. const Double_t * GetCldirChecked() const; {return fCldirChecked;}. const Double_t * GetCldir() const; {return fCldir;}. TGeoHMatrix * GetDivMatrix() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fDivMatrix;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); {fLastSafety=safe; fLastPoint[0]=x; fLastPoint[1]=y, fLastPoint[2]=z;}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNavigator.html:22990,safe,safe,22990,root/html534/TGeoNavigator.html,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html,6,['safe'],['safe']
Safety,"urve's x-coordinates as a function of log10(tau) ; [out]logTauYif nonzero, a new TSpline is returned, to parameterize the L-curve's y-coordinates as a function of log10(tau) ; [out]logTauCurvatureif nonzero, a new TSpline is returned of the L-curve curvature as a function of log10(tau). return value: the coordinate number in the logTauX,logTauY graphs corresponding to the ""final"" choice of tau; Recommendation: always check logTauCurvature, it should be a peaked function (similar to a Gaussian), the maximum corresponding to the final choice of tau. Also, check the lCurve it should be approximately L-shaped. If in doubt, adjust tauMin and tauMax until the results are satisfactory. ; Definition at line 2558 of file TUnfold.cxx. ◆ ScanSURE(). Int_t TUnfold::ScanSURE ; (; Int_t ; nPoint, . Double_t ; tauMin, . Double_t ; tauMax, . TGraph ** ; logTauSURE = nullptr, . TGraph ** ; df_chi2A = nullptr, . TGraph ** ; lCurve = nullptr . ). virtual . minimize Stein's unbiased risk estimator ""SURE"" using successive calls to DoUnfold at various tau. ; Optionally, also the L-curve and its curvature are calculated for comparison. See description of GetSURE() See e.g. arXiv:1612.09415 for the definition of SURE; Parameters. [in]nPoint: number of points ; [in]tauMin: lower end of scan-range ; [in]tauMax: upper end of scan-range ; [out]logTauSURE: scan result, SURE as a function of log(tau) ; [out]df_chi2A: parametric plot of DF against chi2A ; [out]lCurve: parametric plot (lCurve). return value: index of the ""best"" point; if tauMin is less than zero of if tauMin is not loer than tauMax, then the scan range is determined automatically if tau=nullptr is included in the scan, then the first x-coordinate ; Definition at line 3785 of file TUnfold.cxx. ◆ SetBias(). void TUnfold::SetBias ; (; const TH1 * ; bias). set bias vector ; Parameters. [in]biashistogram with new bias vector. the initial bias vector is determined from the response matrix but may be changed by using this method ; Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:55965,risk,risk,55965,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['risk'],['risk']
Safety,"us. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The interpreter will execute command from Notify(). Bool_t CheckTimer(const TTime& now); Check if timer timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:13524,timeout,timeout,13524,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,3,['timeout'],['timeout']
Safety,"us::GetRmin ; (; ); const. inline . Definition at line 74 of file TGeoTorus.h. ◆ InspectShape(). void TGeoTorus::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoTorus::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 91 of file TGeoTorus.h. ◆ IsCylType(). Bool_t TGeoTorus::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 79 of file TGeoTorus.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoTorus::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoTorus & TGeoTorus::operator= ; (; const TGeoTorus & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTorus::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoTorus::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoTorus::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoTorus::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoTorus::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoTorus::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetSegsAndPols(). void TGeoTorus::SetSegsAndPols ; (; TBuffer3D & ; buff); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetTorusDimensions(). void TGeoTorus::SetTorusDimensions ; (; Double_t ; r, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; phi1, . Double_t ; dphi . ). ◆ Sizeof3D(). void TGeoTorus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:29731,safe,safe,29731,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,1,['safe'],['safe']
Safety,"usQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVirtualProofPlayer(); TVirtualProofPlayer(const TVirtualProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:10253,abort,abort,10253,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"ushPath(Int_t startlevel = 0); Int_tPushPoint(Int_t startlevel = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAll(); voidTObject::ResetBit(UInt_t f); voidResetState(); Double_tSafety(Bool_t inside = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetCurrentDirection(const Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); voidSetCurrentPoint(const Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLastPoint(Double_t x, Double_t y, Double_t z); voidSetLastSafetyForPoint(Double_t safe, const Double_t* point); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutside(Bool_t flag = kTRUE); voidSetStartSafe(Bool_t flag = kTRUE); voidSetStep(Double_t step); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); TGeoNode*Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTopToMaster(const Double_t* top, Double_t* master) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoNavigator.html:8192,safe,safe,8192,root/html530/TGeoNavigator.html,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html,2,['safe'],['safe']
Safety,"ush_back(""-D__CINT__"");; 4496 clingArgs.push_back(""-D__MAKECINT__"");; 4497 ; 4498 AddPlatformDefines(clingArgs);; 4499 ; 4500 std::string currentDirectory = ROOT::FoundationUtils::GetCurrentDir();; 4501 ; 4502 std::string interpPragmaSource;; 4503 std::string includeForSource;; 4504 std::string interpreterDeclarations;; 4505 std::string linkdef;; 4506 ; 4507 for (size_t i = 0, e = gOptDictionaryHeaderFiles.size(); i < e; ++i) {; 4508 const std::string& optHeaderFileName = gOptDictionaryHeaderFiles[i];; 4509 bool isSelectionFile = IsSelectionFile(optHeaderFileName.c_str());; 4510 ; 4511 if (isSelectionFile) {; 4512 if (i == e - 1) {; 4513 linkdef = optHeaderFileName;; 4514 } else { // if the linkdef was not last, issue an error.; 4515 ROOT::TMetaUtils::Error(nullptr, ""%s: %s must be last file on command line\n"",; 4516 executableFileName, optHeaderFileName.c_str());; 4517 return 1;; 4518 }; 4519 }; 4520 ; 4521 // coverity[tainted_data] The OS should already limit the argument size, so we are safe here; 4522 std::string fullheader(optHeaderFileName);; 4523 // Strip any trailing + which is only used by GeneratedLinkdef.h which currently; 4524 // use directly argv.; 4525 if (fullheader[fullheader.length() - 1] == '+') {; 4526 fullheader.erase(fullheader.length() - 1);; 4527 }; 4528 std::string header(; 4529 isSelectionFile ? fullheader : ROOT::FoundationUtils::MakePathRelative(fullheader, currentDirectory, gBuildingROOT));; 4530 ; 4531 interpPragmaSource += std::string(""#include \"""") + header + ""\""\n"";; 4532 if (!isSelectionFile) {; 4533 // In order to not have to add the equivalent to -I${PWD} to the; 4534 // command line, include the complete file name, even if it is a; 4535 // full pathname, when we write it down in the dictionary.; 4536 // Note: have -I${PWD} means in that (at least in the case of; 4537 // ACLiC) we inadvertently pick local file that have the same; 4538 // name as system header (e.g. new or list) and -iquote has not; 4539 // equivalent on some platfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:185582,safe,safe,185582,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['safe'],['safe']
Safety,"using any generic model function; 134 If data set is binned a least square fit is performed; 135 If data set is unbinned a maximum likelihood fit (not extended) is done; 136 Pre-requisite on the function:; 137 it must implement the 1D or multidimensional parametric function interface.; 138 Note that both the input data and the function object are copied by the Fitter.; 139 */; 140 template <class Data, class Function,; 141 class cond = typename std::enable_if<!(std::is_same<Function, ROOT::EExecutionPolicy>::value ||; 142 std::is_same<Function, int>::value),; 143 Function>::type>; 144 bool Fit(const Data &data, const Function &func,; 145 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential); 146 {; 147 SetFunction(func);; 148 return Fit(data, executionPolicy);; 149 }; 150 ; 151 /**; 152 Fit a binned data set using a least square fit.; 153 Note that the provided input data are copied in the Fitter class.; 154 Use the next function (passing a `shared_ptr` to the BinData class if you want to avoid; 155 copying.; 156 */; 157 bool Fit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 158 return LeastSquareFit(data, executionPolicy);; 159 }; 160 ; 161 /**; 162 Fit a binned data set using a least square fit.; 163 Pass the input data using a `shared_ptr` for NOT copying the input data.; 164 */; 165 bool Fit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 166 return LeastSquareFit(data, executionPolicy);; 167 }; 168 ; 169 /**; 170 Fit a binned data set using a least square fit copying the input data.; 171 */; 172 bool LeastSquareFit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 173 SetData(data);; 174 return DoLeastSquareFit(executionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:5338,avoid,avoid,5338,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['avoid'],['avoid']
Safety,"ussian.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; gROOT#define gROOTDefinition TROOT.h:406; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TStringBasic string class.Definition TString.h:139; TString::AppendTString & Append(const char *cs)Definition TString.h:572; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf505_asciicfgDefinition rf505_asciicfg.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 1) 0x7ffc52bb96d8 RooRealVar:: f = 0.50733 +/- 0.020971 L(0 - 1) ""f""; 2) 0x7ffc52bb8b20 RooRealVar:: m = 0.0064018 +/- 0.053686 L(-10 - 10) ""m""; 3) 0x7ffc52bb92f0 RooRealVar:: p0 = 0.0073509 +/- 0.0078312 L(0 - 1) ""p0""; 4) 0x7ffc52bb8f08 RooRealVar:: s = 0.96516 +/- 0.047052 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf505__asciicfg_8C.html:3740,safe,safe,3740,doc/master/rf505__asciicfg_8C.html,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8C.html,1,['safe'],['safe']
Safety,"ute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWithinTolerance(Double_t a, Double_t b); Check if two numbers differ with less than a tolerance. Bool_t IsSegCrossing(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4); Check if segments (A,B) and (C,D) are crossing,; where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4). Double_t DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); compute distance from point (inside phi) to both phi planes. Return minimum. void NormalPhi(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. Double_t SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2). void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:19012,Safe,SafetyPhi,19012,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,6,"['Safe', 'safe']","['SafetyPhi', 'safety']"
Safety,"uteTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGFont.html:14920,sanity check,sanity check,14920,root/html604/TGFont.html,https://root.cern,https://root.cern/root/html604/TGFont.html,1,['sanity check'],['sanity check']
Safety,"uteTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGFont.html:14455,sanity check,sanity check,14455,root/html534/TGFont.html,https://root.cern,https://root.cern/root/html534/TGFont.html,1,['sanity check'],['sanity check']
Safety,"uteTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGFont.html:14920,sanity check,sanity check,14920,root/html602/TGFont.html,https://root.cern,https://root.cern/root/html602/TGFont.html,1,['sanity check'],['sanity check']
Safety,"utes; static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;  . Protected Types; enum  ELockStatusBits { ;   kFindBranch = (1ULL << ( 0 )); , kFindLeaf = (1ULL << ( 1 )); , kGetAlias = (1ULL << ( 2 )); , kGetBranch = (1ULL << ( 3 )); , ;   kGetEntry = (1ULL << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ;   kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRemoveFriend = (1ULL << ( 11 )); , ;   kSetBranchStatus = (1ULL << ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:57393,detect,detection,57393,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['detect'],['detection']
Safety,"utex is a pointer to a TMutex object. //; 104// When guard goes out of scope the mutex is unlocked in the TLockGuard //; 105// destructor. The exception mechanism takes care of calling the dtors //; 106// of local objects so it is exception safe. //; 107// In contrast to std::lock_guard, TLockGuard constructor expects a //; 108// pointer, not the mutex object itself. //; 109// //; 110//////////////////////////////////////////////////////////////////////////; 111 ; 112class TReadLockGuard {; 113 ; 114private:; 115 TVirtualRWMutex *const fMutex;; 116 TVirtualRWMutex::Hint_t *fHint;; 117 ; 118 TReadLockGuard(const TReadLockGuard&) = delete;; 119 TReadLockGuard& operator=(const TReadLockGuard&) = delete;; 120 ; 121public:; 122 TReadLockGuard(TVirtualRWMutex *mutex) : fMutex(mutex), fHint(nullptr) {; 123 if (fMutex) fHint = fMutex->ReadLock();; 124 }; 125 ; 126 ~TReadLockGuard() { if (fMutex) fMutex->ReadUnLock(fHint); }; 127 ; 128 ClassDefNV(TReadLockGuard,0) // Exception safe read locking/unlocking of mutex; 129};; 130 ; 131class TWriteLockGuard {; 132 ; 133private:; 134 TVirtualRWMutex *const fMutex;; 135 TVirtualRWMutex::Hint_t *fHint;; 136 ; 137 TWriteLockGuard(const TWriteLockGuard&) = delete;; 138 TWriteLockGuard& operator=(const TWriteLockGuard&) = delete;; 139 ; 140public:; 141 TWriteLockGuard(TVirtualRWMutex *mutex) : fMutex(mutex), fHint(nullptr) {; 142 if (fMutex) fHint = fMutex->WriteLock();; 143 }; 144 ; 145 ~TWriteLockGuard() { if (fMutex) fMutex->WriteUnLock(fHint); }; 146 ; 147 ClassDefNV(TWriteLockGuard,0) // Exception safe read locking/unlocking of mutex; 148};; 149 ; 150} // namespace ROOT.; 151 ; 152// Use with a trailing semicolon and pass a pointer as argument, e.g.:; 153// TMutex m; R__READ_LOCKGUARD(&m);; 154#define R__READ_LOCKGUARD(mutex) ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(mutex); 155#define R__READ_LOCKGUARD_NAMED(name,mutex) ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(mutex); 156 ; 157#define R__WRITE_LOCKGUARD(mutex) ::ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:4738,safe,safe,4738,doc/master/TVirtualRWMutex_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html,4,['safe'],['safe']
Safety,"uthenticate::SetRSAInit ; (; Int_t ; init = 1). static . Static method setting RSA initialization flag. ; Definition at line 1228 of file TAuthenticate.cxx. ◆ SetRSAKeyType(). void TAuthenticate::SetRSAKeyType ; (; Int_t ; key). inline . Definition at line 148 of file TAuthenticate.h. ◆ SetRSAPublic(). Int_t TAuthenticate::SetRSAPublic ; (; const char * ; rsaPubExport, . Int_t ; klen . ). static . Store RSA public keys from export string rsaPubExport. ; Returns type of stored key, or -1 is not recognized ; Definition at line 3039 of file TAuthenticate.cxx. ◆ SetSecContext(). void TAuthenticate::SetSecContext ; (; TRootSecContext * ; ctx). inline . Definition at line 149 of file TAuthenticate.h. ◆ SetSecureAuthHook(). void TAuthenticate::SetSecureAuthHook ; (; SecureAuth_t ; func). static . Set secure authorization function. ; Definition at line 1393 of file TAuthenticate.cxx. ◆ SetTimeOut(). void TAuthenticate::SetTimeOut ; (; Int_t ; to). static . Set timeout (active if > 0) ; Definition at line 1369 of file TAuthenticate.cxx. ◆ Show(). void TAuthenticate::Show ; (; Option_t * ; opt = ""S""). static . Print info about the authentication sector. ; If 'opt' contains 's' or 'S' prints information about established TSecContext, else prints information about THostAuth (if 'opt' is 'p' or 'P', prints Proof related information) ; Definition at line 2219 of file TAuthenticate.cxx. ◆ SshAuth(). Int_t TAuthenticate::SshAuth ; (; TString & ; user). private . SSH client authentication code (no longer supported) ; Definition at line 1419 of file TAuthenticate.cxx. ◆ SshError(). Int_t TAuthenticate::SshError ; (; const char * ; errfile). private . ◆ Streamer(). void TAuthenticate::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TAuthenticate::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 207 of file TAuthenticate.h. Friends And Related Symbol ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:41150,timeout,timeout,41150,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['timeout'],['timeout']
Safety,"utoRotator&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfADolly; Double_tfATheta; TGLCamera*fCamera; Double_tfDollyA0; Double_tfDt; Double_tfThetaA0; TTimer*fTimer; Bool_tfTimerRunning; TGLViewer*fViewer; Double_tfWDolly; Double_tfWPhi; Double_tfWTheta; TStopwatch*fWatch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAutoRotator(TGLViewer* v); Constructor. ~TGLAutoRotator(); Destructor. void SetDt(Double_t dt); Set time between two redraws in seconds.; Range: 0.001 -> 1. void SetATheta(Double_t a); Set relative amplitude of theta oscilation.; Value range: 0.01 -> 1. void SetADolly(Double_t a); Set relative amplitude of forward/backward oscilation.; Value range: 0.01 -> 1. void Start(). void Stop(). void Timeout(). TGLAutoRotator(const TGLAutoRotator& ). TGLAutoRotator& operator=(const TGLAutoRotator& ). TGLCamera* GetCamera() const; { return fCamera; }. Bool_t IsRunning() const. { return fTimerRunning; }. Double_t GetDt() const; { return fDt; }. Double_t GetWPhi() const; { return fWPhi; }. void SetWPhi(Double_t w); { fWPhi = w; }. Double_t GetWTheta() const; { return fWTheta; }. void SetWTheta(Double_t w); { fWTheta = w; }. Double_t GetATheta() const; { return fATheta; }. Double_t GetWDolly() const; { return fWDolly; }. void SetWDolly(Double_t w); { fWDolly = w; }. Double_t GetADolly() const; { return fADolly; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TGLAutoRotator.h 36373 2010-10-19 17:43:35Z matevz $ » Last generated: 2010-10-20 08:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLAutoRotator.html:6338,Timeout,Timeout,6338,root/html528/TGLAutoRotator.html,https://root.cern,https://root.cern/root/html528/TGLAutoRotator.html,1,['Timeout'],['Timeout']
Safety,"utorial3.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial4.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:108806,detect,detector,108806,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['detect'],['detector']
Safety,"utorials » Histograms tutorials. Detailed Description; Example displaying two histograms and their ratio. ; This macro does not use the class TRatioPlot. For ROOT version >= 6.08 TRatioPlot should be used. See the other ratio plots examples in this folder. ; void ratioplotOld( ) {; // Define two gaussian histograms. Note the X and Y title are defined; // at booking time using the convention ""Hist_title ; X_title ; Y_title""; TH1F *h1 = new TH1F(""h1"", ""Two gaussian plots and their ratio;x title; h1 and h2 gaussian histograms"", 100, -5, 5);; TH1F *h2 = new TH1F(""h2"", ""h2"", 100, -5, 5);; h1->FillRandom(""gaus"");; h2->FillRandom(""gaus"");; ; // Define the Canvas; TCanvas *c = new TCanvas(""c"", ""canvas"", 800, 800);; ; // Upper plot will be in pad1; TPad *pad1 = new TPad(""pad1"", ""pad1"", 0, 0.3, 1, 1.0);; pad1->SetBottomMargin(0); // Upper and lower plot are joined; pad1->SetGridx(); // Vertical grid; pad1->Draw(); // Draw the upper pad: pad1; pad1->cd(); // pad1 becomes the current pad; h1->SetStats(0); // No statistics on upper plot; h1->Draw(); // Draw h1; h2->Draw(""same""); // Draw h2 on top of h1; ; #if ROOT_VERSION_CODE >= ROOT_VERSION(6,8,0); // Avoid the first label (0) to be clipped.; TAxis *axis = h1->GetYaxis();; axis->ChangeLabel(1, -1, -1, -1, -1, -1, "" "");; axis->SetLabelFont(43); // Absolute font size in pixel (precision 3); axis->SetLabelSize(15);; #else; // Do not draw the Y axis label on the upper plot and redraw a small; // axis instead, in order to avoid the first label (0) to be clipped.; h1->GetYaxis()->SetLabelSize(0.);; TGaxis *axis = new TGaxis( -5, 20, -5, 220, 20,220,510,"""");; axis->SetLabelFont(43); // Absolute font size in pixel (precision 3); axis->SetLabelSize(15);; axis->Draw();; #endif; ; // lower plot will be in pad; c->cd(); // Go back to the main canvas before defining pad2; TPad *pad2 = new TPad(""pad2"", ""pad2"", 0, 0.05, 1, 0.3);; pad2->SetTopMargin(0);; pad2->SetBottomMargin(0.2);; pad2->SetGridx(); // vertical grid; pad2->Draw();; pad2->cd(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplotOld_8C.html:1324,Avoid,Avoid,1324,doc/master/ratioplotOld_8C.html,https://root.cern,https://root.cern/doc/master/ratioplotOld_8C.html,1,['Avoid'],['Avoid']
Safety,"utside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoCtub::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Divide(). TGeoVolume * TGeoCtub::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoCtub::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoCtub::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. ◆ GetByteCount(). Int_t TGeoCtub::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 208 of file TGeoTube.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoCtub::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetMeshNumbers(). void TGeoCtub::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetNhigh(). const Double_t * TGeoCtub::GetNhigh ; (; ); const. inline . Definition at line 214 of file TGeoTube.h. ◆ GetNlow(). const Double_t * TGeoCtub::GetNlow ; (; ); const. inline . Definition at line 213 of file TGeoTube.h. ◆ GetNmeshVertices(). Int_t TGeoCtub::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetPointsOnSegments(). Bool_t TGeoCtub::GetPointsOnSegments ; (; Int_t ; npoints, .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:31967,avoid,avoid,31967,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,1,['avoid'],['avoid']
Safety,"v, RooExponential, RooGamma, RooGaussian, RooLandau, RooPolynomial, RooUniform, RooEfficiency, and RooPolyVar.; Definition at line 4425 of file RooAbsReal.cxx. ◆ chi2FitTo() [1/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Perform a \( \chi^2 \) fit to given histogram. ; By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession; The following named arguments are supported. Options to control construction of chi2 . Extended(bool flag) Only applicable when fitting a RooAbsPdf. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight. This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events (in RooFit jargon, ""if the pdf can be extended"").; Passing Extended(true) when the the pdf makes no prediction on the expected number of events will result in error messages, and the chi2 will fall back to the total data weight to scale the normalized pdf.; There are cases where the fit must be done in extended mode. This happens for example when you have a RooAddPdf where the coefficients represent component yields. If the fit is not extended, these coefficients will not be well-defined, as the RooAddPdf always normalizes itself. If you pass Extended(false) in such a case, an error will be printed and you'll most likely get garbage results. . Range(const char* name) Fit only data inside range with given name . Range(double lo, double hi) Fit only data inside given range. A range named ""fit"" is created on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:68354,predict,predicted,68354,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['predict'],['predicted']
Safety,"v, RooExponential, RooGamma, RooGaussian, RooLandau, RooPolynomial, RooUniform, RooEfficiency, and RooPolyVar.; Definition at line 4501 of file RooAbsReal.cxx. ◆ chi2FitTo() [1/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Perform a \( \chi^2 \) fit to given histogram. ; By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession; The following named arguments are supported. Options to control construction of chi2 . Extended(bool flag) Only applicable when fitting a RooAbsPdf. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight. This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events (in RooFit jargon, ""if the pdf can be extended"").; Passing Extended(true) when the the pdf makes no prediction on the expected number of events will result in error messages, and the chi2 will fall back to the total data weight to scale the normalized pdf.; There are cases where the fit must be done in extended mode. This happens for example when you have a RooAddPdf where the coefficients represent component yields. If the fit is not extended, these coefficients will not be well-defined, as the RooAddPdf always normalizes itself. If you pass Extended(false) in such a case, an error will be printed and you'll most likely get garbage results. . Range(const char* name) Fit only data inside range with given name . Range(double lo, double hi) Fit only data inside given range. A range named ""fit"" is created on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:69622,predict,predicted,69622,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['predict'],['predicted']
Safety,"v.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TFolder.h; idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; TObjectHolder.hxx; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; ROOT::Browsable::RElement::ExtractItemIndexstatic int ExtractItemIndex(std::string &name)Extract index from name Index coded by client with ###<indx>$$$ suffix Such coding used by browser to...Definition RElement.cxx:178; ROOT::Browsable::RElement::ComparePathsstatic int ComparePaths(const RElementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Browsable::RItemRepresentation of single item in the browser.Definition RItem.hxx:23; ROOT::Browsable::RProvider::Browsestatic std::shared_ptr< RElement > Browse(std::unique_ptr< RHolder > &obj)Create browsable element for the object Created element may take ownership over the object.Definition RProvider.cxx:273; ROOT::Browsable::RSysFile::ProvideTopEntriesstatic RElementPath_t ProvideTopEntries(std::shared_ptr< RGroup > &comp, const std::string &workdir="""")Provide top entries for file system On windows it is list of existing drivers, on Linux it is ""File s...Definition RSysFile.cxx:533; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RBrowserDataCleanupDefinition RBrowserData.cxx:43; ROOT::RBrowserDataCleanup::fDataRBrowserData & fDataDefinition RBrowserData.cxx:45; ROOT::RBrowserDataCleanup::R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:14125,avoid,avoid,14125,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['avoid'],['avoid']
Safety,"v0.end(), v1.begin(), v0.begin(), op); \; 1704 return v0; \; 1705} \; 1706 ; 1707RVEC_ASSIGNMENT_OPERATOR(+=); 1708RVEC_ASSIGNMENT_OPERATOR(-=); 1709RVEC_ASSIGNMENT_OPERATOR(*=); 1710RVEC_ASSIGNMENT_OPERATOR(/=); 1711RVEC_ASSIGNMENT_OPERATOR(%=); 1712RVEC_ASSIGNMENT_OPERATOR(^=); 1713RVEC_ASSIGNMENT_OPERATOR(|=); 1714RVEC_ASSIGNMENT_OPERATOR(&=); 1715RVEC_ASSIGNMENT_OPERATOR(>>=); 1716RVEC_ASSIGNMENT_OPERATOR(<<=); 1717#undef RVEC_ASSIGNMENT_OPERATOR; 1718 ; 1719///@}; 1720///@name RVec Comparison and Logical Operators; 1721///@{; 1722 ; 1723#define RVEC_LOGICAL_OPERATOR(OP) \; 1724template <typename T0, typename T1> \; 1725auto operator OP(const RVec<T0> &v, const T1 &y) \; 1726 -> RVec<int> /* avoid std::vector<bool> */ \; 1727{ \; 1728 RVec<int> ret(v.size()); \; 1729 auto op = [y](const T0 &x) -> int { return x OP y; }; \; 1730 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1731 return ret; \; 1732} \; 1733 \; 1734template <typename T0, typename T1> \; 1735auto operator OP(const T0 &x, const RVec<T1> &v) \; 1736 -> RVec<int> /* avoid std::vector<bool> */ \; 1737{ \; 1738 RVec<int> ret(v.size()); \; 1739 auto op = [x](const T1 &y) -> int { return x OP y; }; \; 1740 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1741 return ret; \; 1742} \; 1743 \; 1744template <typename T0, typename T1> \; 1745auto operator OP(const RVec<T0> &v0, const RVec<T1> &v1) \; 1746 -> RVec<int> /* avoid std::vector<bool> */ \; 1747{ \; 1748 if (v0.size() != v1.size()) \; 1749 throw std::runtime_error(ERROR_MESSAGE(OP)); \; 1750 \; 1751 RVec<int> ret(v0.size()); \; 1752 auto op = [](const T0 &x, const T1 &y) -> int { return x OP y; }; \; 1753 std::transform(v0.begin(), v0.end(), v1.begin(), ret.begin(), op); \; 1754 return ret; \; 1755} \; 1756 ; 1757RVEC_LOGICAL_OPERATOR(<); 1758RVEC_LOGICAL_OPERATOR(>); 1759RVEC_LOGICAL_OPERATOR(==); 1760RVEC_LOGICAL_OPERATOR(!=); 1761RVEC_LOGICAL_OPERATOR(<=); 1762RVEC_LOGICAL_OPERATOR(>=); 1763RVEC_LOGICAL_OPERATOR(&&); 1764RVEC_LOGI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:60858,avoid,avoid,60858,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoid']
Safety,"v_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- directories -------------------------------------------------------------; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Returns the user's home directory.; 3934 ; 3935const char *TUnixSystem::UnixHomedirectory(const char *name); 3936{; 3937 static char path[kMAXPATHLEN], mydir[kMAXPATHLEN] =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:125151,timeout,timeout,125151,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,['timeout'],['timeout']
Safety,"var=y, Binning=20),; ZVar=dict(var=z, Binning=20),; ); hh_pdf3.SetFillColor(ROOT.kBlue); ; c1 = ROOT.TCanvas(""rf309_2dimplot"", ""rf309_2dimplot"", 800, 800); c1.Divide(2, 2); c1.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data.GetZaxis().SetTitleOffset(1.4); hh_data.Draw(""lego""); c1.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_pdf.GetZaxis().SetTitleOffset(2.5); hh_pdf.Draw(""surf""); c1.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_data.GetZaxis().SetTitleOffset(1.4); hh_data.Draw(""box""); c1.cd(4); ROOT.gPad.SetLeftMargin(0.15); hh_pdf.GetZaxis().SetTitleOffset(2.5); hh_pdf.Draw(""cont3""); c1.SaveAs(""rf309_2dimplot.png""); ; c2 = ROOT.TCanvas(""rf309_3dimplot"", ""rf309_3dimplot"", 800, 400); c2.Divide(2); c2.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data3.GetZaxis().SetTitleOffset(1.4); hh_data3.Draw(""lego""); c2.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_pdf3.GetZaxis().SetTitleOffset(1.4); hh_pdf3.Draw(""iso""); c2.SaveAs(""rf309_3dimplot.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf309__ndimplot_8py.html:3444,safe,safe,3444,doc/master/rf309__ndimplot_8py.html,https://root.cern,https://root.cern/doc/master/rf309__ndimplot_8py.html,1,['safe'],['safe']
Safety,"variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while the external value \(P_{\mathrm{ext}}\) can take on values only between the lower limit \(a\) and the upper limit \(b\). Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the \(\mbox{FCN}\) value. The effects of non-linearity and numerical roundoff both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if he puts limits of \((0,10^{10})\) on a parameter, then the values \(0.0\) and \(1.0\) will be indistinguishable to the accuracy of most machines.; For this purpose single sided limits on parameters are provided by M , with their transformation being:; Lower bound \(a\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathrm{e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:14304,avoid,avoided,14304,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['avoid'],['avoided']
Safety,"variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while the external value \(P_{\mathrm{ext}}\) can take on values only between the lower limit \(a\) and the upper limit \(b\). Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the \(\mbox{FCN}\) value. The effects of non-linearity and numerical roundoff both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of \((0,10^{10})\) on a parameter, then the values \(0.0\) and \(1.0\) will be indistinguishable to the accuracy of most machines.; For this purpose single sided limits on parameters are provided by M , with their transformation being:; Lower bound \(a\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathrm{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:10273,avoid,avoided,10273,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['avoid'],['avoided']
Safety,"vas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf302_utilfuncsDefinition rf302_utilfuncs.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf302_utilfuncs.C. tutorialsroofitrf302_utilfuncs.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8C.html:6028,safe,safe,6028,doc/master/rf302__utilfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8C.html,1,['safe'],['safe']
Safety,"vas(""rf302_utilfuncs"", ""rf302_utilfuncs"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_model_1.GetZaxis().SetTitleOffset(2.5); hh_model_1.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_model_2.GetZaxis().SetTitleOffset(2.5); hh_model_2.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model_3.GetZaxis().SetTitleOffset(2.5); hh_model_3.Draw(""surf""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_model_4.GetZaxis().SetTitleOffset(2.5); hh_model_4.Draw(""surf""); ; c.SaveAs(""rf302_utilfuncs.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf302_utilfuncs.py. tutorialsroofitrf302_utilfuncs.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8py.html:3915,safe,safe,3915,doc/master/rf302__utilfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html,1,['safe'],['safe']
Safety,"vas, i.e. a canvas that is in a TGCanvas widget; 218/// which is placed in a TGFrame. This ctor is only called via the; 219/// TRootEmbeddedCanvas class.; 220///; 221/// If ""name"" starts with ""gl"" the canvas is ready to receive GL output.; 222 ; 223TCanvas::TCanvas(const char *name, Int_t ww, Int_t wh, Int_t winid) : TPad(), fDoubleBuffer(0); 224{; 225 fCanvasImp = nullptr;; 226 fPainter = nullptr;; 227 Init();; 228 ; 229 fCanvasID = winid;; 230 fWindowTopX = 0;; 231 fWindowTopY = 0;; 232 fWindowWidth = ww;; 233 fWindowHeight = wh;; 234 fCw = ww + 4;; 235 fCh = wh +28;; 236 fBatch = kFALSE;; 237 fUpdating = kFALSE;; 238 ; 239 //This is a very special ctor. A window exists already!; 240 //Can create painter now.; 241 fUseGL = gStyle->GetCanvasPreferGL();; 242 ; 243 if (fUseGL) {; 244 fGLDevice = gGLManager->CreateGLContext(winid);; 245 if (fGLDevice == -1); 246 fUseGL = kFALSE;; 247 }; 248 ; 249 fCanvasImp = gBatchGuiFactory->CreateCanvasImp(this, name, fCw, fCh);; 250 if (!fCanvasImp) return;; 251 ; 252 CreatePainter();; 253 fName = GetNewCanvasName(name); // avoid Modified() signal from SetName; 254 Build();; 255}; 256 ; 257////////////////////////////////////////////////////////////////////////////////; 258/// Create a new canvas with a predefined size form.; 259/// If form < 0 the menubar is not shown.; 260///; 261/// - form = 1 700x500 at 10,10 (set by TStyle::SetCanvasDefH,W,X,Y); 262/// - form = 2 500x500 at 20,20; 263/// - form = 3 500x500 at 30,30; 264/// - form = 4 500x500 at 40,40; 265/// - form = 5 500x500 at 50,50; 266///; 267/// If ""name"" starts with ""gl"" the canvas is ready to receive GL output.; 268 ; 269TCanvas::TCanvas(const char *name, const char *title, Int_t form) : TPad(), fDoubleBuffer(0); 270{; 271 fPainter = nullptr;; 272 fUseGL = gStyle->GetCanvasPreferGL();; 273 ; 274 Constructor(name, title, form);; 275}; 276 ; 277////////////////////////////////////////////////////////////////////////////////; 278/// Create a new canvas with a predefined ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:7609,avoid,avoid,7609,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['avoid'],['avoid']
Safety,"vas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 9.9999999999999995E-7) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or nul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHelix.html:8391,safe,safe,8391,root/html602/TGeoHelix.html,https://root.cern,https://root.cern/root/html602/TGeoHelix.html,2,['safe'],['safe']
Safety,"vate Member Functions |; Private Attributes |; List of all members ; TRolke Class ReferenceMath » Legacy Physics Classes. ; Legacy Code TRolke is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TRolke might still be a valid solution. Consider switching to RooStats.; This class computes confidence intervals for the rate of a Poisson process in the presence of uncertain background and/or efficiency. ; The treatment and the resulting limits are fully frequentist. The limit calculations make use of the profile likelihood method.; AuthorJan Conrad (CERN) 2004, Updated: Johan Lundberg (CERN) 2009; For a full list of methods and their syntax, and build instructions, consult the header file TRolke.h.; Examples/tutorials are found in the separate file Rolke.C. TRolke implements the following Models; The signal is always assumed to be Poisson, with the following combinations of models of background and detection efficiency:; If unsure, first consider model 3, 4 or 5.; 1: SetPoissonBkgBinomEff(x,y,z,tau,m) Background: Poisson; Efficiency: Binomial; when the background is simultaneously measured from sidebands (or MC), and the signal efficiency was determined from Monte Carlo; 2: SetPoissonBkgGaussEff(x,y,em,tau,sde) Background: Poisson; Efficiency: Gaussian; when the background is simultaneously measured from sidebands (or MC), and the efficiency is modeled as Gaussian; 3: SetGaussBkgGaussEff(x,bm,em,sde,sdb) Background: Gaussian; Efficiency: Gaussian; when background and efficiency can both be modeled as Gaussian.; 4: SetPoissonBkgKnownEff(x,y,tau,e) Background: Poisson; Efficiency: Known; when the background is simultaneously measured from sidebands (or MC).; 5: SetGaussBkgKnownEff(x,bm,sdb,e) Background: Gaussian; Efficiency: Known; when background is Gaussian; 6: SetKnownBkgBinomEff(x,z,b,m) Background: Known; Efficiency: Binomial; when sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRolke.html:1275,detect,detection,1275,doc/master/classTRolke.html,https://root.cern,https://root.cern/doc/master/classTRolke.html,1,['detect'],['detection']
Safety,"vate:. TSelector(const TSelector&); TSelector&operator=(const TSelector&). Data Members; public:. enum EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortAbort status; TList*fInputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:9215,abort,aborted,9215,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,1,['abort'],['aborted']
Safety,"ve to be defined . Our example will only use \( xlo \), \( A \) and \( b \) Still, this could be handled by a general non-linear minimizer like Minuit by introducing so-called ""slack"" variables . However, quadp is tailored to objective functions not more complex than being quadratic . This allows usage of solving techniques which are even stable for problems involving for instance 500 variables, 100 inequality conditions and 50 equality conditions .; Enough said about quadratic programming, let's return to our example . Suppose, after a long day of doing physics, you have a look at your investments and realize that an early retirement is not possible, given the returns of your stocks . So what now ? ROOT to the rescue ...; In 1990 Harry Markowitz was awarded the Nobel prize for economics: "" his work provided new tools; for weighing the risks and rewards of different investments and for valuing corporate stocks and bonds"" . In plain English, he developed the tools to balance greed and fear, we want the maximum return with the minimum amount of risk. Our stock portfolio should be at the ""Efficient Frontier"". To quantify better the risk we are willing to take, we define a utility function \( U(x) \). It describes as a function of our total assets \( x \), our ""satisfaction"" . A common choice is \( 1-exp(-k*x) \) (the reason for the exponent will be clear later) . The parameter \( k \) is the risk-aversion factor . For small values of \( k \) the satisfaction is small for small values of \( x \); by increasing \( x \) the satisfaction can still be increased significantly . For large values of \( k \), \( U(x) \) increases rapidly to 1, there is no increase in satisfaction for additional dollars earned .; In summary :; small \( k \) ==> risk-loving investor; large \( k \) ==> risk-averse investor. Suppose we have for nrStocks the historical daily returns \( r = closing_price(n) - closing_price(n-1) \). Define a vector \( x \) of length of \( nrStocks \), which contains t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:2281,risk,risk,2281,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['risk'],['risk']
Safety,"ve tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The follo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:42059,recover,recovered,42059,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['recover'],['recovered']
Safety,"ve's user id; TStringfWorkDirslave's working directory (info obtained from slave). private:. static TSlave_tfgTXSlaveHook. Class Charts. Inheritance Chart:. TObject. ←; TSlave. ←. TSlaveLite. TXSlave. Function documentation; TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1); Create a PROOF slave object. Called via the TProof ctor. TSlave(); Default constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. void Init(TSocket* s, Int_t stype); Init a PROOF slave object using the connection opened via s. Used to; avoid double opening when an attempt via TXSlave found a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void Stop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlave.html:9846,avoid,avoid,9846,root/html602/TSlave.html,https://root.cern,https://root.cern/root/html602/TSlave.html,2,['avoid'],['avoid']
Safety,"veListTreeItemSpecial list-tree-item for Eve ;  CTEveMacroSub-class of TMacro, overriding Exec to unload the previous version and cleanup after the execution ;  CTEveMagFieldAbstract base-class for interfacing to magnetic field needed by the TEveTrackPropagator ;  CTEveMagFieldConstImplements constant magnetic field, given by a vector fB ;  CTEveMagFieldDuoImplements constant magnetic filed that switches on given axial radius fR2 from vector fBIn to fBOut ;  ►CTEveManagerCentral application manager for Eve ;  CTExceptionHandlerException handler for Eve exceptions ;  CTRedrawDisabler;  CTEveMCRecCrossRef;  CTEveMCTrack;  CTEventIterSpecial iterator class used in TProofPlayer to iterate over events or objects in the packets ;  CTEventIterObj;  ►CTEventIterTree;  CTFileTree;  CTEventIterUnit;  CTEventListA TEventList object is a list of selected events (entries) in a TTree ;  CTEvePadThis was intended as a TPad wrapper to allow smart updates of groups of pads ;  CTEvePadHolderException safe wrapper for setting gPad ;  ►CTEveParamListCollection of named parameters ;  CBoolConfig_t;  CFloatConfig_t;  CIntConfig_t;  CTEveParamListEditorGUI editor for TEveParamList ;  CTEvePathMarkTSpecial-point on track: ;  CTEvePlot3DDescription of TEvePlot3D ;  CTEvePlot3DGLOpenGL renderer class for TEvePlot3D ;  CTEvePointSelectorTEvePointSelector is a sub-class of TSelectorDraw for direct extraction of point-like data from a Tree ;  CTEvePointSelectorConsumerTEvePointSelectorConsumer is a virtual base for classes that can be filled from TTree data via the TEvePointSelector class ;  CTEvePointSetTEvePointSet is a render-element holding a collection of 3D points with optional per-point TRef and an arbitrary number of integer ids (to be used for signal, volume-id, track-id, etc) ;  CTEvePointSetArrayAn array of point-sets with each point-set playing a role of a bin in a histogram ;  CTEvePointSetArrayEditorEditor for TEvePointSetArray class ;  CTEvePointSetProjectedProjected copy of a TEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:128284,safe,safe,128284,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,5,['safe'],['safe']
Safety,"vePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLite(TProof* proof = 0); TProofPlayerLite(const TProofPlayerLite&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerLite.html:11115,abort,abort,11115,root/html604/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html604/TProofPlayerLite.html,1,['abort'],['abort']
Safety,"vePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerSuperMaster.html:11525,abort,abort,11525,root/html604/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html604/TProofPlayerSuperMaster.html,1,['abort'],['abort']
Safety,"vePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerLite.html:11188,abort,abort,11188,root/html534/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html534/TProofPlayerLite.html,1,['abort'],['abort']
Safety,"vePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerSuperMaster.html:11615,abort,abort,11615,root/html534/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofPlayerSuperMaster.html,1,['abort'],['abort']
Safety,"vePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLite(TProof* proof = 0); TProofPlayerLite(const TProofPlayerLite&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLite.html:11211,abort,abort,11211,root/html602/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLite.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"vePrimitive(std::ostream &out, Option_t *option = """") override;; 176 ; 177 ClassDefOverride(TGeoGtra, 1) // G3 GTRA shape; 178};; 179 ; 180#endif; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148; namechar name[80]Definition TGX11.cxx:110; TGeoBBox.h; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoArb8::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoArb8.h:63; TGeoArb8::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoArb8::GetDzDouble_t GetDz() constDefinition TGeoArb8.h:66; TGeoArb8::GetClosestEdgeDouble_t GetClosestEdge(const Double_t *point, Double_t *vert, Int_t &isegment) const; TGeoArb8::fXYDouble_t fXY[8][2][4] tangents of twist anglesDefinition TGeoArb8.h:28; TGeoArb8::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoArb8::SetPointsvoid SetPoints(Double_t *points) const override; TGeoArb8::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override; TGeoArb8::TGeoArb8TGeoArb8(const char *name, Double_t dz, Double_t *vertices=nullptr); TGeoArb8::SetVertexvirtual void SetVertex(Int_t vn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:10474,safe,safe,10474,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"veVolumes()Definition TGeoManager.h:363; TGeoManager::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoManager.cxx:1698; TGeoManager::CdTopvoid CdTop()Make top level node the current node.Definition TGeoManager.cxx:1672; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; TGeoManager::fKeyPNEIdInt_t * fKeyPNEIdDefinition TGeoManager.h:142; TGeoManager::DefaultAnglesvoid DefaultAngles()Set default angles for a given view.Definition TGeoManager.cxx:1818; TGeoManager::MixtureTGeoMaterial * Mixture(const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid)Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,...Definition TGeoManager.cxx:1296; TGeoManager::ThreadsMap_tstd::map< std::thread::id, Int_t > ThreadsMap_tDefinition TGeoManager.h:114; TGeoManager::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Classify a given point. See TGeoChecker::CheckPoint().Definition TGeoManager.cxx:3770; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManager.cxx:4288; TGeoManager::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoManager.h:389; TGeoManager::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:538; TGeoManager::GetPhysicalNodeTGeoPhysicalNode * GetPhysicalNode(Int_t i) constDefinition TGeoManager.h:514; TGeoManager::GetLastTrackTVirtualGeoTrack * GetLastTrack()Definition TGeoManager.h:368; TGeoManager::Browsevoid Browse(TBrowser *b) overrideDescribe how to browse this object.Definition TGeoManager.cxx:1023; TGeoManager::GetCldirCheckedconst Double_t * GetCldirChecked() constDefinition TGeoManager.h:504; TGeoManager::Testvoid Test(Int_t npoints=1000000, Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:85396,safe,safety,85396,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['safe'],['safety']
Safety,"vector from mother reference to local reference system. ; Definition at line 576 of file TGeoNode.cxx. ◆ MayOverlap(). Bool_t TGeoNode::MayOverlap ; (; Int_t ; iother); const. Check the overlab between the bounding box of the node overlaps with the one the brother with index IOTHER. ; Definition at line 555 of file TGeoNode.cxx. ◆ operator=(). TGeoNode & TGeoNode::operator= ; (; const TGeoNode & ; ). privatedelete . ◆ Paint(). void TGeoNode::Paint ; (; Option_t * ; option = """"). overridevirtual . Paint this node and its content according to visualization settings. ; Reimplemented from TObject.; Definition at line 605 of file TGeoNode.cxx. ◆ PrintCandidates(). void TGeoNode::PrintCandidates ; (; ); const. print daughters candidates for containing current point ; Definition at line 616 of file TGeoNode.cxx. ◆ PrintOverlaps(). void TGeoNode::PrintOverlaps ; (; ); const. print possible overlapping nodes ; Definition at line 667 of file TGeoNode.cxx. ◆ Safety(). Double_t TGeoNode::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. computes the closest distance from given point to this shape ; Definition at line 684 of file TGeoNode.cxx. ◆ SaveAttributes(). void TGeoNode::SaveAttributes ; (; std::ostream & ; out). save attributes for this node ; Definition at line 439 of file TGeoNode.cxx. ◆ SetAllInvisible(). void TGeoNode::SetAllInvisible ; (; ). inline . Definition at line 124 of file TGeoNode.h. ◆ SetCloned(). void TGeoNode::SetCloned ; (; Bool_t ; flag = kTRUE). inline . Definition at line 119 of file TGeoNode.h. ◆ SetCurrentPoint(). void TGeoNode::SetCurrentPoint ; (; Double_t ; x, . Double_t ; y, . Double_t ; z . ). inline . Definition at line 116 of file TGeoNode.h. ◆ SetFWExtension(). void TGeoNode::SetFWExtension ; (; TGeoExtension * ; ext). Connect framework defined extension to the node. ; The node ""grabs"" a copy, so the original object can be released by the producer. Release the previously connected extension if any.; NOTE: This interface",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNode.html:32946,Safe,Safety,32946,doc/master/classTGeoNode.html,https://root.cern,https://root.cern/doc/master/classTGeoNode.html,1,['Safe'],['Safety']
Safety,"vel p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denomi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:12646,recover,recover,12646,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"vel);; 373 }; 374 ; 375 virtual Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """");; 376 virtual Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99);; 377 virtual Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99);; 378 virtual TBranch *Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000);; 379 TBranch *Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); 380 {; 381 // Overload to avoid confusion between this signature and the template instance.; 382 return Branch(name,(void*)address,leaflist,bufsize);; 383 }; 384 TBranch *Branch(const char* name, Longptr_t address, const char* leaflist, Int_t bufsize = 32000); 385 {; 386 // Overload to avoid confusion between this signature and the template instance.; 387 return Branch(name,(void*)address,leaflist,bufsize);; 388 }; 389 TBranch *Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); 390 {; 391 // Overload to avoid confusion between this signature and the template instance.; 392 return Branch(name,(void*)(Longptr_t)address,leaflist,bufsize);; 393 }; 394 virtual TBranch *Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99);; 395 template <class T> TBranch *Branch(const char* name, const char* classname, T* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); 396 {; 397 // See BranchImpRed for details. Here we __ignore; 398 return BranchImpRef(name, classname, TClass::GetClass<T>(), obj, bufsize, splitlevel);; 399 }; 400 template <class T> TBranch *Branch(const char* name, const char* classname, T** addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); 401 {; 402 // See BranchImp for details; 403 return BranchImp(name, classname, TClass::GetClass<T>(), addobj, bufsize, splitlevel);; 404 }; 405 template <typename T, std::size_t N> TBranch *Branch(const char* name, std::array<T, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:19877,avoid,avoid,19877,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['avoid'],['avoid']
Safety,"velength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  FITS_tutorial7.COpen a FITS file that contains a catalog of astronomical objects and dump some of its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:107399,detect,detector,107399,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['detect'],['detector']
Safety,"vent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _printScientific;  ; static Int_t _printSigDigits;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:70896,Avoid,Avoids,70896,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['Avoid'],['Avoids']
Safety,"vents, . std::function< void(unsigned int, T &)> ; callback . ). inline . Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result. ; Parameters. [in]everyNEventsFrequency at which the callback will be called by each thread, as a number of events processed ; [in]callbackA callable with signature void(unsigned int, Value_t&) where Value_t is the type of the value contained in this RResultPtr . Returnsthis RResultPtr, to allow chaining of OnPartialResultSlot with other calls; See OnPartialResult for a generic explanation of the callback mechanism. Compared to OnPartialResult, this method has two major differences:; all worker threads invoke the callback once every specified number of events. The event count is per-thread, and callback invocation might happen concurrently (i.e. the callback must be thread-safe); the callable must take an extra unsigned int parameter corresponding to a multi-thread ""processing slot"": this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the callback concurrently but always with different slot numbers.; a value of 0 for everyNEvents indicates the callback must be executed once per slot. For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; std::string progress;; std::mutex bar_mutex;; c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; std::lock_guard<std::mutex> lg(bar_mutex);; progress.push_back('#');; std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; });; std::cout << ""Analysis running..."" << std::endl;; *c; // trigger the event loop by accessing an action's result; std::cout << ""\nDone!"" << std::endl;; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70. Definition at line 364 of file RResultPtr.hxx. ◆ o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:12742,safe,safe,12742,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,2,['safe'],['safe']
Safety,"verlaps(). Bool_t TGeoParallelWorld::IsUsingOverlaps ; (; ); const. inline . Definition at line 81 of file TGeoParallelWorld.h. ◆ operator=(). TGeoParallelWorld & TGeoParallelWorld::operator= ; (; const TGeoParallelWorld & ; ). protecteddelete . ◆ PrintBVH(). void TGeoParallelWorld::PrintBVH ; (; ); const. Prints the BVH. ; Definition at line 374 of file TGeoParallelWorld.cxx. ◆ PrintDetectedOverlaps(). Int_t TGeoParallelWorld::PrintDetectedOverlaps ; (; ); const. Print the overlaps which were detected during real tracking. ; Definition at line 135 of file TGeoParallelWorld.cxx. ◆ RefreshPhysicalNodes(). void TGeoParallelWorld::RefreshPhysicalNodes ; (; ). Refresh the node pointers and re-voxelize. ; To be called mandatory in case re-alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. ◆ ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. ◆ Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). inline . Definition at line 118 of file TGeoParallelWorld.h. ◆ SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. ◆ SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. ◆ SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:25677,Safe,Safety,25677,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['Safe'],['Safety']
Safety,"verride;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Double_t GetPhi1 () const;  ; Double_t GetPhi2 () const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetConsDimensions (Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2);  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buffer) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:2861,Safe,Safety,2861,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"verride;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Double_t GetPhi1 () const;  ; Double_t GetPhi2 () const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void SetTubsDimensions (Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2);  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoTube;  TGeoTube ();  ;  TGeoTube (cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:5989,Safe,Safety,5989,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,4,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"verridevirtual . Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. ; Implements TGeoBoolNode.; Definition at line 554 of file TGeoBoolNode.cxx. ◆ Contains(). Bool_t TGeoUnion::Contains ; (; const Double_t * ; point); const. overridevirtual . Find if a union of two shapes contains a given point. ; Implements TGeoBoolNode.; Definition at line 539 of file TGeoBoolNode.cxx. ◆ DeclFileName(). static const char * TGeoUnion::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 128 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). Int_t TGeoUnion::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute minimum distance to shape vertices. ; Implements TGeoBoolNode.; Definition at line 607 of file TGeoBoolNode.cxx. ◆ DistFromInside(). Double_t TGeoUnion::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Computes distance from a given point inside the shape to its boundary. ; Implements TGeoBoolNode.; Definition at line 616 of file TGeoBoolNode.cxx. ◆ DistFromOutside(). Double_t TGeoUnion::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given outside point to the shape. ; Implements TGeoBoolNode.; Definition at line 746 of file TGeoBoolNode.cxx. ◆ GetBooleanOperator(). EGeoBoolType TGeoUnion::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 118 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoUnion::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this union. ; Implements TGeoBoolNode.; Definition at line 778 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoUnion::IsA ; (; ); const. inline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoUnion.html:16524,safe,safe,16524,doc/master/classTGeoUnion.html,https://root.cern,https://root.cern/doc/master/classTGeoUnion.html,1,['safe'],['safe']
Safety,"very specification document. Short overview:. If the BEARER_TOKEN environment variable is set, then the value is taken to be the token contents.; If the BEARER_TOKEN_FILE environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; If the XDG_RUNTIME_DIR environment variable is set, then take the token from the contents of $XDG_RUNTIME_DIR/bt_u$ID(this additional location is intended to provide improved security for shared login environments as $XDG_RUNTIME_DIR is defined to be user-specific as opposed to a system-wide directory.).; Otherwise, take the token from /tmp/bt_u$ID. Xrootd client support; ROOT can now be built with Xrootd 5 client libraries.; GUI Libraries; RBrowser improvements. central factory methods to handle browsing, editing and drawing of different classes; simple possibility to extend RBrowser on user-defined classes; support of web-based geometry viewer; better support of TTree drawing; server-side handling of code editor and image viewer widgets; rbrowser content is fully recovered when web-browser is reloaded; load of widgets code only when really required (shorter startup time for RBrowser). JavaScript ROOT; Major JSROOT update to version 6. update all used libraries d3.js, three.js, MathJax.js, openui5; change to Promise based interface for all async methods, remove call-back arguments; change scripts names, core scripts name now JSRoot.core.js; unify function/methods naming conventions, many changes in method names; provide central code loader via JSROOT.require, supporting 4 different loading engines; many nice features and many bug fixes; see JSROOT v6 release notes. Class Reference Guide; One can now select a class’s documentation for a specific version. If a class does not exist in a given version, that version is grayed out, see for instance the documentation for ROOT::Experimental::RNTupleReader.; Build, Configuration and Testing Infrastructure. a new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:28448,recover,recovered,28448,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['recover'],['recovered']
Safety,"very.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:4286,recover,recovery,4286,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,2,['recover'],['recovery']
Safety,"virtual Bool_t CompileVariables ();  Compiles each variable from fTreeDrawArgsParser for the tree fTree. ;  ; void FillWeight ();  Get weight from input list, if any. ;  ; virtual Bool_t ProcessSingle (Long64_t, Int_t);  Processes a single variable from an entry. ;  ; void SetCanvas (const char *objname);  Move to a canvas named <name>_canvas; create the canvas if not existing. ;  ; void SetDrawAtt (TObject *o);  Set the drawing attributes from the input list. ;  ; void SetError (const char *sub, const char *mesg);  Sets the error status. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TEntryList * fElist;  ;  Protected Attributes inherited from TProofDraw; Int_t fDimension;  ; TString fInitialExp;  ; TTreeFormulaManager * fManager;  ; Int_t fMultiplicity;  ; Bool_t fObjEval;  ; TTreeFormula * fSelect;  ; TString fSelection;  ; TStatus * fStatus;  ; TTree * fTree;  ; TTreeDrawArgsParser fTreeDrawArgsParser;  ; TTreeFormula * fVar [4];  ; Double_t fWeight;  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawEntryList.html:13052,Abort,Abort,13052,doc/master/classTProofDrawEntryList.html,https://root.cern,https://root.cern/doc/master/classTProofDrawEntryList.html,1,['Abort'],['Abort']
Safety,"virtual Bool_t CompileVariables ();  Compiles each variable from fTreeDrawArgsParser for the tree fTree. ;  ; void FillWeight ();  Get weight from input list, if any. ;  ; virtual Bool_t ProcessSingle (Long64_t, Int_t);  Processes a single variable from an entry. ;  ; void SetCanvas (const char *objname);  Move to a canvas named <name>_canvas; create the canvas if not existing. ;  ; void SetDrawAtt (TObject *o);  Set the drawing attributes from the input list. ;  ; void SetError (const char *sub, const char *mesg);  Sets the error status. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TProfile * fProfile;  ;  Protected Attributes inherited from TProofDraw; Int_t fDimension;  ; TString fInitialExp;  ; TTreeFormulaManager * fManager;  ; Int_t fMultiplicity;  ; Bool_t fObjEval;  ; TTreeFormula * fSelect;  ; TString fSelection;  ; TStatus * fStatus;  ; TTree * fTree;  ; TTreeDrawArgsParser fTreeDrawArgsParser;  ; TTreeFormula * fVar [4];  ; Double_t fWeight;  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawProfile.html:13102,Abort,Abort,13102,doc/master/classTProofDrawProfile.html,https://root.cern,https://root.cern/doc/master/classTProofDrawProfile.html,1,['Abort'],['Abort']
Safety,"virtual void GetBoundingCylinder(Double_t *param) const =0; TGeoShape::InspectShapevirtual void InspectShape() const =0; TGeoShape::IsValidBoxvirtual Bool_t IsValidBox() const =0; TGeoShape::IsReflectedvirtual Bool_t IsReflected() constDefinition TGeoShape.h:140; TGeoShape::ShapeDistancetoPrimitiveInt_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) constReturns distance to shape primitive mesh.Definition TGeoShape.cxx:261; TGeoShape::GetFittingBoxvirtual Int_t GetFittingBox(const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const =0; TGeoShape::fgEpsMchstatic Double_t fgEpsMchDefinition TGeoShape.h:28; TGeoShape::NormalPhistatic void NormalPhi(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2)Static method to compute normal to phi planes.Definition TGeoShape.cxx:464; TGeoShape::SafetySegstatic Double_t SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer)Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2)Definition TGeoShape.cxx:528; TGeoShape::IsCrossingSemiplanestatic Bool_t IsCrossingSemiplane(const Double_t *point, const Double_t *dir, Double_t cphi, Double_t sphi, Double_t &snext, Double_t &rxy)Compute distance from POINT to semiplane defined by PHI angle along DIR.Definition TGeoShape.cxx:306; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::GetByteCountvirtual Int_t GetByteCount() const =0; TGeoShape::IsVecGeomvirtual Bool_t IsVecGeom() constDefinition TGeoShape.h:141; TGeoShape::GetNameconst char * GetName() const overrideGet the shape name.Definition TGeoShape.cxx:250; TGeoShape::ComputeBBoxvirtual void ComputeBBox()=0; TGeoShape::AfterStreamervirtual void AfterStreamer()Definition TGeoShape.h:93; TGeoShape::CouldBeCrossedvirtual Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoShape_8h_source.html:17517,Safe,SafetySegstatic,17517,doc/master/TGeoShape_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html,2,['Safe'],"['SafetySeg', 'SafetySegstatic']"
Safety,"virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:2672,safe,safe,2672,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,3,['safe'],['safe']
Safety,"virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMemberInspector&operator=(const TMemberInspector&). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name); Routine driving the visiting of the class information/data members. void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); Routine driving the visiting of the class information/data members. void InspectMember(TClass* cl, void* pobj, const char* name); Routine driving the visiting of the class information/data members. TMemberInspector & operator=(const TMemberInspector& ). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& ). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMemberInspector.html:2331,avoid,avoid,2331,root/html534/TMemberInspector.html,https://root.cern,https://root.cern/root/html534/TMemberInspector.html,1,['avoid'],['avoid']
Safety,"virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TSlave(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidFlushSocket(); voidInit(TSocket* s, Int_t stype); virtual voidInterrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tPing(); virtual TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tSendGroupPriority(const char*, Int_t); virtual voidSetAlias(const char* alias); voidSetSocket(TSocket* s); virtual voidSetStatus(Int_t st); virtual voidStopProcess(Bool_t abort, Int_t timeout). private:. TSlave(const TSlave& s); TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); static TSlave*Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); voidInit(const char* host, Int_t port, Int_t stype); Int_tOldAuthSetup(Bool_t master, TString wconf); voidoperator=(const TSlave&). Data Members; public:. enum ESlaveType { kMaster; kSlave; };; enum ESlaveStatus { kInvalid; kActive; kInactive; };; enum EStatusBits { kOutputRequested; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSlave.html:6308,abort,abort,6308,root/html534/TSlave.html,https://root.cern,https://root.cern/root/html534/TSlave.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleCheckFile(TMessage* mess); virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. voidExecLogon(); Int_tSendCanvases(); Int_tSetup(). Data Members; public:. static TApplication::EExitOnExceptionTApplication::kAbort; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TApplication::EStatusBits",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplicationServer.html:11234,abort,abort,11234,root/html602/TApplicationServer.html,https://root.cern,https://root.cern/root/html602/TApplicationServer.html,2,['abort'],['abort']
Safety,"virtual; AddToTObjectTable(TObject *)TObjectprivatestatic; AddTrack(Int_t id, Int_t pdgcode, TObject *part) overrideTGeoPaintervirtual; AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset=kFALSE) overrideTGeoPaintervirtual; AppendPad(Option_t *option="""")TObjectvirtual; BombTranslation(const Double_t *tr, Double_t *bombtr) overrideTGeoPaintervirtual; Browse(TBrowser *b)TObjectvirtual; CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.) overrideTGeoPaintervirtual; CheckBoundaryReference(Int_t icheck=-1) overrideTGeoPaintervirtual; CheckedHash()TObjectinline; CheckEdit()TGeoPainter; CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideTGeoPaintervirtual; CheckGeometryFull(Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr) overrideTGeoPaintervirtual; CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideTGeoPaintervirtual; CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.) overrideTGeoPaintervirtual; CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) overrideTGeoPaintervirtual; Class()TVirtualGeoPainterstatic; Class_Name()TVirtualGeoPainterstatic; Class_Version()TVirtualGeoPainterinlinestatic; ClassName() constTObjectvirtual; Clear(Option_t *="""")TObjectinlinevirtual; ClearVisibleVolumes()TGeoPainterprotected; Clone(const char *newname="""") constTObjectvirtual; Compare(const TObject *obj) constTObjectvirtual; Copy(TObject &object) constTObjectvirtual; CountNodes(TGeoVolume *vol, Int_t level) constTGeoPainter; CountVisibleNodes() overrideTGeoPaintervirtual; DeclFileName()TVirtualGeoPainterinlinestatic; DefaultAngles() overrideTGeoPaintervirtual; DefaultColors() overrideTGeoPaintervirtual; DefineColors() constTGeoPainterprivate; Delete(Option_t *option="""")TObjectvirtual; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; DistanceToPrimitiveVol(TGeoVolum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPainter-members.html:1406,safe,safety,1406,doc/master/classTGeoPainter-members.html,https://root.cern,https://root.cern/doc/master/classTGeoPainter-members.html,1,['safe'],['safety']
Safety,"void *buf, Int_t len) overrideReturn cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TUnixSystem.cxx:740; TUnixSystem::OpenDirectoryvoid * OpenDirectory(const char *name) overrideOpen a Unix file system directory. Returns 0 if directory does not exist.Definition TUnixSystem.cxx:1392; TUnixSystem::Renameint Rename(const char *from, const char *to) overrideRename a file. Returns 0 when successful, -1 in case of failure.Definition TUnixSystem.cxx:1632; TUnixSystem::Getenvconst char * Getenv(const char *name) overrideGet environment variable.Definition TUnixSystem.cxx:2137; TUnixSystem::GetPathInfoint GetPathInfo(const char *path, FileStat_t &buf) overrideGet info about a file.Definition TUnixSystem.cxx:1658; TUnixSystem::GetEffectiveGidInt_t GetEffectiveGid() overrideReturns the effective group id.Definition TUnixSystem.cxx:2045; TUnixSystem::UnixSelectstatic int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout)Wait for events on the file descriptors specified in the readready and writeready masks or for timeou...Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:216050,timeout,timeout,216050,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,['timeout'],['timeout']
Safety,"void Add(TObject *obj) overrideDefinition TObjArray.h:68. Reimplemented in TTreeSQL.; Definition at line 1833 of file TTree.cxx. ◆ Branch() [13/13]. Int_t TTree::Branch ; (; TList * ; list, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). virtual . Deprecated function. Use next function instead. ; Reimplemented in TTreeSQL.; Definition at line 1749 of file TTree.cxx. ◆ BranchImp() [1/2]. TBranch * TTree::BranchImp ; (; const char * ; branchname, . const char * ; classname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch() with added check that addobj matches className. ; See alsoTTree::Branch() for other details. ; Reimplemented in TTreeSQL.; Definition at line 1554 of file TTree.cxx. ◆ BranchImp() [2/2]. TBranch * TTree::BranchImp ; (; const char * ; branchname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Reimplemented in TTreeSQL.; Definition at line 1602 of file TTree.cxx. ◆ BranchImpArr(). TBranch * TTree::BranchImpArr ; (; const char * ; branchname, . EDataType ; datatype, . std::size_t ; N, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Definition at line 1731 of file TTree.cxx. ◆ BranchImpRef() [1/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . const char * ; classname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1635 of file TTree.cxx. ◆ BranchImpRef() [2/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:91413,detect,detection,91413,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['detect'],['detection']
Safety,"void Build(TSelector* iselector, ClassInfo_t* cl, Bool_t isowner = kTRUE); Initialize the CallFunc objects when selector is interpreted. int Version() const; Invoke the Version function via the interpreter. void Init(TTree* ); Invoke the Init function via the interpreter. void Begin(TTree* tree); Invoke the Begin function via the interpreter. void SlaveBegin(TTree* ); Invoke the SlaveBegin function via the interpreter if available. Bool_t Notify(); Invoke the Notify function via the interpreter. Bool_t ProcessCut(Long64_t entry); Invoke the ProcessCut function via the interpreter. void ProcessFill(Long64_t entry); Invoke the ProcessFill function via the interpreter. Bool_t Process(Long64_t entry); Invoke the ProcessCut function via the interpreter. void SetOption(const char* option); Set the selector option. void SetObject(TObject* obj); Set the current object. void SetInputList(TList* input); Set the selector list of input objects. TList * GetOutputList() const; Return the list of output object. void SlaveTerminate(); Invoke the SlaveTerminate function via the interpreter if available. void Terminate(); Invoke the Terminate function via the interpreter. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Invoke the GetAbort function via the interpreter. TSelector::EAbort GetAbort() const; Invoke the GetAbort function via the interpreter. void ResetAbort(); Invoke the GetAbort function via the interpreter. Long64_t GetStatus() const; Invoke the GetStatus function via the interpreter. TClass * GetInterpretedClass() const; Retrieve the TClass object for the interpreted class. TSelector * GetInterpretedSelector() const; { return fIntSelector; }. » Author: Rene Brun 05/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelectorCint.html:8920,Abort,Abort,8920,root/html534/TSelectorCint.html,https://root.cern,https://root.cern/root/html534/TSelectorCint.html,1,['Abort'],['Abort']
Safety,"void Initialize(): this method is called once before starting the event-loop. Useful for setup operations. It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper, or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; void InitTask(TTreeReader *, unsigned int slot): each working thread shall call this method during the event loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; void Exec(unsigned int slot, ColumnTypes...columnValues): each working thread shall call this method during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value: this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of the requested columns for the particular entry being processed.; void Finalize(): this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; std::string GetActionName(): it returns a string identifier for this type of action that RDataFrame will use in diagnostics, SaveGraph(), etc. Optional methods; If these methods are implemented they enable extra functionality as per the description below. Result_t &PartialUpdate(unsigned int slot): if present, it must return the value of the partial result of this action for the given 'slot'. Different threads might call this method concurrently, but will do so with different 'slot' numbers. RDataFrame leverages this method to implement RResultPtr::OnPartialResult().; ROOT::RDF::SampleCallback_t GetSampleCallback(): if present, it must return a callable with the appropriate signature (see ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:39791,safe,safe,39791,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['safe'],['safe']
Safety,"void ROOT::Internal::VecOps::SmallVectorBase::report_at_maximum_capacity ; (; ). staticprotected . Report that this vector is already at maximum capacity. ; Throws std::length_error or calls report_fatal_error. ; Definition at line 44 of file RVec.cxx. ◆ report_size_overflow(). void ROOT::Internal::VecOps::SmallVectorBase::report_size_overflow ; (; size_t ; MinSize). staticprotected . Report that MinSize doesn't fit into this vector's size type. ; Throws std::length_error or calls report_fatal_error. ; Definition at line 37 of file RVec.cxx. ◆ set_size(). void ROOT::Internal::VecOps::SmallVectorBase::set_size ; (; size_t ; N). inline . Set the array size to N, which the current array must have enough capacity for. ; This does not construct or destroy any elements in the vector.; Clients can use this in conjunction with capacity() to write past the end of the buffer when they know that more elements are available, and only update the size later. This avoids the cost of value initializing elements which will only be overwritten. ; Definition at line 188 of file RVec.hxx. ◆ size(). size_t ROOT::Internal::VecOps::SmallVectorBase::size ; (; ); const. inline . Definition at line 174 of file RVec.hxx. ◆ SizeTypeMax(). static constexpr size_t ROOT::Internal::VecOps::SmallVectorBase::SizeTypeMax ; (; ). inlinestaticconstexprprotected . The maximum value of the Size_T used. ; Definition at line 153 of file RVec.hxx. Member Data Documentation. ◆ fBeginX. void* ROOT::Internal::VecOps::SmallVectorBase::fBeginX. protected . Definition at line 145 of file RVec.hxx. ◆ fCapacity. Size_T ROOT::Internal::VecOps::SmallVectorBase::fCapacity. protected . Always >= -1. fCapacity == -1 indicates the RVec is in ""memory adoption"" mode. ; Definition at line 150 of file RVec.hxx. ◆ fSize. Size_T ROOT::Internal::VecOps::SmallVectorBase::fSize = 0. protected . Always >= 0. ; Definition at line 148 of file RVec.hxx. Libraries for ROOT::Internal::VecOps::SmallVectorBase:. [legend]; The documentati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorBase.html:4349,avoid,avoids,4349,doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorBase.html,1,['avoid'],['avoids']
Safety,"void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; Bool_tProcessEvents(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTTimer::Remove(); virtual voidTSysEvtHandler::Removed()SIGNAL ; voidTTimer::Reset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTTimer::SetCommand(const char* command); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTTimer::SetInterruptSyscalls(Bool_t set = kTRUE); voidTTimer::SetObject(TObject* object); static voidTObject::SetObjectStat(Bool_t stat); voidTTimer::SetTime(Long_t milliSec); voidTTimer::SetTimerID(UInt_t id = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); static voidTTimer::SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); virtual voidTTimer::Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); virtual voidTTimer::Stop(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTTimer::Timeout()SIGNAL ; virtual voidTTimer::TurnOff()SIGNAL ; virtual voidTTimer::TurnOn()SIGNAL ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProcessEventTimer.html:8721,Timeout,Timeout,8721,root/html530/TProcessEventTimer.html,https://root.cern,https://root.cern/root/html530/TProcessEventTimer.html,2,['Timeout'],['Timeout']
Safety,"void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tTFile::ReadBuffer(char* buf, Int_t len); virtual Bool_tTFile::ReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRFIOFile.html:11815,Recover,Recover,11815,root/html532/TRFIOFile.html,https://root.cern,https://root.cern/root/html532/TRFIOFile.html,1,['Recover'],['Recover']
Safety,"void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tTFile::ReadBuffer(char* buf, Int_t len); virtual Bool_tTFile::ReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRFIOFile.html:11588,Recover,Recover,11588,root/html530/TRFIOFile.html,https://root.cern,https://root.cern/root/html530/TRFIOFile.html,1,['Recover'],['Recover']
Safety,"voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t*, const Double_t*, Double_t*, Int_t); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t*, Bool_t*, Int_t) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; static Double_tDistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ms",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:8314,safe,safe,8314,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,3,['safe'],['safe']
Safety,"voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:10769,abort,abort,10769,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); static voidTXMLSetup::SetNameSpaceBase(const char* namespacebase); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidSetStoreStreamerInfos(Bool_t iConvert = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUsedDtd(Bool_t use = kTRUE); virtual voidSetUseNamespaces(Bool_t iUseNamespaces = kTRUE); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidSetXmlLayout(TXMLSetup::EXMLLayout layout); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer&); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLFile.html:15360,timeout,timeout,15360,root/html602/TXMLFile.html,https://root.cern,https://root.cern/root/html602/TXMLFile.html,2,['timeout'],['timeout']
Safety,"voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); static voidTXMLSetup::SetNameSpaceBase(const char* namespacebase); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidSetStoreStreamerInfos(Bool_t iConvert = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUsedDtd(Bool_t use = kTRUE); virtual voidSetUseNamespaces(Bool_t iUseNamespaces = kTRUE); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidSetXmlLayout(TXMLSetup::EXMLLayout layout); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXMLFile.html:15077,timeout,timeout,15077,root/html530/TXMLFile.html,https://root.cern,https://root.cern/root/html530/TXMLFile.html,2,['timeout'],['timeout']
Safety,"voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); static voidTXMLSetup::SetNameSpaceBase(const char* namespacebase); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidSetStoreStreamerInfos(Bool_t iConvert = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUsedDtd(Bool_t use = kTRUE); virtual voidSetUseNamespaces(Bool_t iUseNamespaces = kTRUE); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidSetXmlLayout(TXMLSetup::EXMLLayout layout); virtual voidShowMembers(TMemberInspector&); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer&); voidStreamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXMLFile.html:15506,timeout,timeout,15506,root/html534/TXMLFile.html,https://root.cern,https://root.cern/root/html534/TXMLFile.html,1,['timeout'],['timeout']
Safety,"voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&TGeoPcon::Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&TGeoPcon::Rmax(Int_t ipl); Double_t&TGeoPcon::Rmin(Int_t ipl); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Double_tSafetyToSegment(Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNedges(Int_t ne); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPgon.html:8490,Safe,SafetyPhi,8490,root/html530/TGeoPgon.html,https://root.cern,https://root.cern/root/html530/TGeoPgon.html,2,['Safe'],['SafetyPhi']
Safety,"void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:4589,safe,safe,4589,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,6,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"void Init (TTree *myTree) override;  ; TClass * IsA () const override;  ; Bool_t Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; Bool_t Process (Long64_t entry) override;  The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ;  ; void Reset ();  ; void SetInputList (TList *input) override;  ; void SetObject (TObject *obj) override;  ; void SetOption (const char *option) override;  ; void SlaveBegin (TTree *) override;  ; void SlaveTerminate () override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetStatus (Long64_t status);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysisTreeReader.html:1509,Abort,Abort,1509,doc/master/classh1analysisTreeReader.html,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html,2,['Abort'],['Abort']
Safety,"void SetWKSize (unsigned int size);  set workspace size ;  ; unsigned int WKSize () const;  size of the workspace ;  . Protected Member Functions;  BaseIntegratorOptions ();  protected constructor to avoid user creating this class ;  ; void ClearExtra ();  . Protected Attributes; double fAbsTolerance;  absolute tolerance ;  ; ROOT::Math::IOptions * fExtraOptions;  ; int fIntegType;  Integrator type (value converted from enum) ;  ; unsigned int fNCalls;  (max) function calls ;  ; double fRelTolerance;  relative tolerance ;  ; unsigned int fWKSize;  workspace size ;  . #include <Math/IntegratorOptions.h>. Inheritance diagram for ROOT::Math::BaseIntegratorOptions:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ BaseIntegratorOptions() [1/2]. ROOT::Math::BaseIntegratorOptions::BaseIntegratorOptions ; (; ). protected . protected constructor to avoid user creating this class ; constructor (protected) to avoid user creating this class ; Definition at line 125 of file IntegratorOptions.cxx. ◆ BaseIntegratorOptions() [2/2]. ROOT::Math::BaseIntegratorOptions::BaseIntegratorOptions ; (; const BaseIntegratorOptions & ; opt). Definition at line 132 of file IntegratorOptions.cxx. ◆ ~BaseIntegratorOptions(). virtual ROOT::Math::BaseIntegratorOptions::~BaseIntegratorOptions ; (; ). inlinevirtual . protected constructor to avoid user creating this class ; Definition at line 52 of file IntegratorOptions.h. Member Function Documentation. ◆ AbsTolerance(). double ROOT::Math::BaseIntegratorOptions::AbsTolerance ; (; ); const. inline . non-static methods for retrieving options ; absolute tolerance ; Definition at line 61 of file IntegratorOptions.h. ◆ ClearExtra(). void ROOT::Math::BaseIntegratorOptions::ClearExtra ; (; ). protected . Definition at line 161 of file IntegratorOptions.cxx. ◆ ExtraOptions(). IOptions * ROOT::Math::BaseIntegratorOptions::ExtraOptions ; (; ); const. inline . return extr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html:2354,avoid,avoid,2354,doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,2,['avoid'],['avoid']
Safety,"void fixCoefNormalization (const RooArgSet &refCoefNorm);  By default the interpretation of the fraction coefficients is performed in the contextual choice of observables. ;  ; void fixCoefRange (const char *rangeName);  By default the interpretation of the fraction coefficients is performed in the default range. ;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; void generateEvent (Int_t code) override;  This function should never be called as RooAddModel implements a custom generator context. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Return pseud-code that indicates if all components can do internal generation (1) or not (0) ;  ; TClass * IsA () const override;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Direct generation is safe if all components say so. ;  ; const RooArgList & pdfList () const;  Return list of component p.d.fs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the product operator construction. ;  ; void resetErrorCounters (Int_t resetValue=10) override;  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; bool selfNormalized () const override;  Model is self normalized when used as p.d.f. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooResolutionModel;  RooResolutionModel ()=default;  ;  RooResolutionModel (const char *name, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:4237,safe,safe,4237,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['safe'],['safe']
Safety,"vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCtub&operator=(const TGeoCtub&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTubeSeg::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:10590,Safe,SafetySeg,10590,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,3,['Safe'],['SafetySeg']
Safety,"vt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; TList*fFileNodesnodes with files; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Long64_t GetEntrie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizer.html:9916,avoid,avoid,9916,root/html528/TPacketizer.html,https://root.cern,https://root.cern/root/html528/TPacketizer.html,3,['avoid'],['avoid']
Safety,"w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We may have unresolved symbols. Use dyld to resolve the dependent; 3789 // libraries and relink.; 3790 // FIXME: We will likely have duplicated libraries as we are appending; 3791 // FIXME: This likely makes rootcling --lib-list-prefix redundant.; 3792 TString depLibsFullPaths;; 3793 std::function<bool(const char *)> CollectF = [&depLibsFullPaths](const char *dep) {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3817 k->SetUniqueID(lib_time);; 3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:129174,abort,abort,129174,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['abort'],['abort']
Safety,"w TList;; 4435 fgAsyncOpenRequests->Add(fh);; 4436 }; 4437 ; 4438 // We are done; 4439 return fh;; 4440}; 4441 ; 4442////////////////////////////////////////////////////////////////////////////////; 4443/// Waits for the completion of an asynchronous open request.; 4444///; 4445/// Returns the pointer to the associated TFile, transferring ownership of the; 4446/// handle to the TFile instance.; 4447 ; 4448TFile *TFile::Open(TFileOpenHandle *fh); 4449{; 4450 TFile *f = nullptr;; 4451 ; 4452 // Note that the request may have failed; 4453 if (fh && fgAsyncOpenRequests) {; 4454 // Remove it from the pending list: we need to do it at this level to avoid; 4455 // recursive calls in the standard TFile::Open; 4456 fgAsyncOpenRequests->Remove(fh);; 4457 // Was asynchronous open functionality implemented?; 4458 if ((f = fh->GetFile()) && !(f->IsZombie())) {; 4459 // Yes: wait for the completion of the open phase, if needed; 4460 Bool_t cr = (!strcmp(f->GetOption(),""CREATE"") ||; 4461 !strcmp(f->GetOption(),""RECREATE"") ||; 4462 !strcmp(f->GetOption(),""NEW"")) ? kTRUE : kFALSE;; 4463 f->Init(cr);; 4464 } else {; 4465 // No: process a standard open; 4466 f = TFile::Open(fh->GetName(), fh->GetOpt(), fh->GetTitle(),; 4467 fh->GetCompress(), fh->GetNetOpt());; 4468 }; 4469 ; 4470 // Adopt the handle instance in the TFile instance so that it gets; 4471 // automatically cleaned up; 4472 if (f) f->fAsyncHandle = fh;; 4473 }; 4474 ; 4475 // We are done; 4476 return f;; 4477}; 4478 ; 4479////////////////////////////////////////////////////////////////////////////////; 4480/// Interface to system open. All arguments like in POSIX open().; 4481 ; 4482Int_t TFile::SysOpen(const char *pathname, Int_t flags, UInt_t mode); 4483{; 4484#if defined(R__WINGCC); 4485 // ALWAYS use binary mode - even cygwin text should be in unix format; 4486 // although this is posix default it has to be set explicitly; 4487 return ::open(pathname, flags | O_BINARY, mode);; 4488#elif defined(R__SEEK64); 4489 return :",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:162723,avoid,avoid,162723,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"w TList;; 699 return gPad;; 700 }; 701 ; 702 if (!fPrimitives) fPrimitives = new TList;; 703 TIter next(fPrimitives);; 704 while (auto obj = next()) {; 705 if (obj->InheritsFrom(TPad::Class())) {; 706 Int_t n = ((TPad*)obj)->GetNumber();; 707 if (n == subpadnumber) {; 708 return ((TPad*)obj)->cd();; 709 }; 710 }; 711 }; 712 return nullptr;; 713}; 714 ; 715////////////////////////////////////////////////////////////////////////////////; 716/// Delete all pad primitives.; 717///; 718/// If the bit kClearAfterCR has been set for this pad, the Clear function; 719/// will execute only after having pressed a CarriageReturn; 720/// Set the bit with `mypad->SetBit(TPad::kClearAfterCR)`; 721 ; 722void TPad::Clear(Option_t *option); 723{; 724 if (!IsEditable()) return;; 725 ; 726 R__LOCKGUARD(gROOTMutex);; 727 ; 728 if (!fPadPaint) {; 729 SafeDelete(fView);; 730 if (fPrimitives) fPrimitives->Clear(option);; 731 if (fFrame) {; 732 if (! ROOT::Detail::HasBeenDeleted(fFrame)) delete fFrame;; 733 fFrame = nullptr;; 734 }; 735 }; 736 if (fCanvas) fCanvas->Cleared(this);; 737 ; 738 cd();; 739 ; 740 if (TestBit(kClearAfterCR)) {; 741 // Intentional do not use the return value of getchar,; 742 // we just want to get it and forget it; 743 getchar();; 744 }; 745 ; 746 if (!gPad->IsBatch() && GetPainter()) GetPainter()->ClearDrawable();; 747 if (gVirtualPS && gPad == gPad->GetCanvas()) gVirtualPS->NewPage();; 748 ; 749 PaintBorder(GetFillColor(), kTRUE);; 750 fCrosshairPos = 0;; 751 fNumPaletteColor = 0;; 752 fCollideGrid.clear();; 753 fCGnx = 0;; 754 fCGny = 0;; 755 ResetBit(TGraph::kClipFrame);; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Clipping routine: Cohen Sutherland algorithm.; 760///; 761/// - If Clip ==2 the segment is outside the boundary.; 762/// - If Clip ==1 the segment has one point outside the boundary.; 763/// - If Clip ==0 the segment is inside the boundary.; 764///; 765/// \param[inout] x[],y[] Segment coord",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:22545,Safe,SafeDelete,22545,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"w examples. We will designate non-overlapping nodes as ONLY and the others; MANY as in GEANT3, where this concept was introduced:; 1. The part of a MANY node B extruding its container A will never be ""seen""; during navigation, as if B was in fact the result of the intersection of A and B.; 2. If we have two nodes A (ONLY) and B (MANY) inside the same container, all; points in the overlapping region of A and B will be designated as belonging to A.; 3. If A an B in the above case were both MANY, points in the overlapping; part will be designated to the one defined first. Both nodes must have the; same medium.; 4. The slices of a divided MANY will be as well MANY. One needs to know that navigation inside geometry parts MANY nodes is much; slower. Any overlapping part can be defined based on composite shapes - this; is always recommended. Replicating volumes. What can we do if our chamber contains two identical wires instead of one ?; What if then we would need 1000 chambers in our detector ? Should we create; 2000 wires and 1000 chamber volumes ? No, we will just need to replicate the; ones that we have already created. chamber->AddNode(wire_co, 1, new TGeoTranslation(-0.2,0,0));; chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));. The 2 nodes that we have created inside chamber will both point to a wire_co; object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; want now to place symetrically 1000 chambers on a pad, following a pattern; of 20 rows and 50 columns. One way to do this will be to replicate our chamber; by positioning it 1000 times in different positions of the pad. Unfortunatelly,; this is far from being the optimal way of doing what we want.; Imagine that we would like to find out which of the 1000 chambers is containing; a (x,y,z) point defined in the pad reference. You will never have to do that,; since the modeller will take care of it for you, but let's guess what it has; to do. The most simple algorithm will just loop ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:8455,detect,detector,8455,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,9,['detect'],['detector']
Safety,"w method.Definition TGeoPainter.cxx:718; TGeoPainter::CountVisibleNodesInt_t CountVisibleNodes() overrideCount total number of visible nodes.Definition TGeoPainter.cxx:636; TGeoPainter::DefineColorsvoid DefineColors() constDefine 100 colors with increasing light intensities for each basic color (1-7) Register these colors ...Definition TGeoPainter.cxx:279; TGeoPainter::SetExplodedViewvoid SetExplodedView(Int_t iopt=0) overrideSet type of exploding view.Definition TGeoPainter.cxx:1962; TGeoPainter::ExecuteManagerEventvoid ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given volume.Definition TGeoPainter.cxx:1074; TGeoPainter::fLastVolumeTGeoVolume * fLastVolumeDefinition TGeoPainter.h:67; TGeoPainter::SetNmeshPointsvoid SetNmeshPoints(Int_t npoints) overrideSet number of points to be generated on the shape outline when checking for overlaps.Definition TGeoPainter.cxx:2007; TGeoPainter::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.) overrideCheck current point in the geometry.Definition TGeoPainter.cxx:242; TGeoPainter::DistanceToPrimitiveVolInt_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) overrideCompute the closest distance of approach from point px,py to a volume.Definition TGeoPainter.cxx:348; TGeoPainter::UnbombTranslationvoid UnbombTranslation(const Double_t *tr, Double_t *bombtr) overrideGet the new 'unbombed' translation vector according current exploded view mode.Definition TGeoPainter.cxx:2194; TGeoPainter::fVisLockBool_t fVisLockDefinition TGeoPainter.h:52; TGeoPainter::PaintNodevoid PaintNode(TGeoNode *node, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1376; TGeoPainter::DefaultAnglesvoid DefaultAngles() overrideSet default angles for the current view.Definition TGeoPainter.cxx:555; TGeoPainter::fClippingSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:98590,safe,safety,98590,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['safe'],['safety']
Safety,"w object; 2710/// created by the default constructor, then read from disk by the streamer.; 2711///; 2712/// If autodel is false, the existing object is not deleted. Root assumes; 2713/// that the user is taking care of deleting any internal object or array; 2714/// (this can be done in the streamer).; 2715 ; 2716void TBranch::SetAutoDelete(bool autodel); 2717{; 2718 if (autodel) {; 2719 SetBit(kAutoDelete, true);; 2720 } else {; 2721 SetBit(kAutoDelete, false);; 2722 }; 2723}; 2724 ; 2725////////////////////////////////////////////////////////////////////////////////; 2726/// Set the basket size; 2727/// The function makes sure that the basket size is greater than fEntryOffsetlen; 2728 ; 2729void TBranch::SetBasketSize(Int_t buffsize); 2730{; 2731 Int_t minsize = 100 + fName.Length();; 2732 if (buffsize < minsize+fEntryOffsetLen) buffsize = minsize+fEntryOffsetLen;; 2733 fBasketSize = buffsize;; 2734 TBasket *basket = (TBasket*)fBaskets[fWriteBasket];; 2735 if (basket) {; 2736 basket->AdjustSize(fBasketSize);; 2737 }; 2738}; 2739 ; 2740////////////////////////////////////////////////////////////////////////////////; 2741/// Set address of this branch directly from a TBuffer to avoid streaming.; 2742///; 2743/// Note: We do not take ownership of the buffer.; 2744 ; 2745void TBranch::SetBufferAddress(TBuffer* buf); 2746{; 2747 // Check this is possible; 2748 if ( (fNleaves != 1); 2749 || (strcmp(""TLeafObject"",fLeaves.UncheckedAt(0)->ClassName())!=0) ) {; 2750 Error(""TBranch::SetAddress"",""Filling from a TBuffer can only be done with a not split object branch. Request ignored."");; 2751 } else {; 2752 fReadEntry = -1;; 2753 fNextBasketEntry = -1;; 2754 fFirstBasketEntry = -1;; 2755 // Note: We do not take ownership of the buffer.; 2756 fEntryBuffer = buf;; 2757 }; 2758}; 2759 ; 2760////////////////////////////////////////////////////////////////////////////////; 2761/// Set compression algorithm.; 2762 ; 2763void TBranch::SetCompressionAlgorithm(Int_t algorithm); 2764{;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:97537,avoid,avoid,97537,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['avoid'],['avoid']
Safety,"w();; }; The angle of a TLatex object was set to 0 if the GetYsize method was called.; TColor; New palette kViridis. It was presented at SciPy2015 by Stéfan van der Walt and Nathaniel Smith. It is now matplotlib’s current default color map. Viridis. TMultiGraph; Ignore empty graphs when computing the multi-graph range at painting time.; TASImage; A left click on a image produced a one pixel zoom.; TCreatePrimitives; The ending of a polyline creation is based on the closeness of the two last entered points. The previous algorithm was based on user coordinates. It is now based on pixel to avoid the problem reported here.; TCanvas; When the first canvas created by ROOT was in batch mode, it was note possible to come back in interactive mode for the next canvases. this problem was reported here.; Cocoa Backend; Sometimes the mouse cursor did not change back to the window manager arrow when exiting a TCanvas.; freetype library; Updates builtin_freetype to 2.6.1 (current upstream version), which can detect PPC64LE machine. This was compiled and tested on SLC6 + ICC + x86_64, F21 + GCC + ppc64le, MacOSX 10.11.1 + Xcode 7.1 and Windows (ROOT 5.34). $ROOTSYS/graf2d/freetype/src/README was removed, because no issues were noticed with ICC compiler and -Wall -pedantic -ansi flags. Additionally --with-png=no --with-bzip2=no flags are passed to freetype configuration script. Default values for these options are auto. freetype finds libpng and libbzip2 on the system and builds extra modules. Then attempting to link against freetype one would need to link -lpng -lbzip2 explicitly otherwise linking will returns in undefined references. Otherwise we would need to check for libpng and libbzip2 on the system and adjust FREETYPE_LIBRARIES to include -lpng and -lbzip2. The current solution goes for the minimal configuration. The original request for this update was posted here.; 3D Graphics Libraries; Geometry Libraries; Database Libraries; Networking Libraries; THttpServer; Support of PO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:17228,detect,detect,17228,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['detect'],['detect']
Safety,"w, Double_t high);  Constrain the values of parameter number <parm> (the parameter numbering follows that of the input template vector). ;  ; void ErrorAnalysis (Double_t UP);  Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. ;  ; Double_t EvaluateFCN (const Double_t *par);  ; void ExcludeBin (Int_t bin);  Exclude the given bin from the fit. ;  ; TFitResultPtr Fit ();  Perform the fit with the default UP value. ;  ; Double_t GetChisquare () const;  Return the likelihood ratio Chi-squared (chi2) for the fit. ;  ; ROOT::Fit::Fitter * GetFitter () const;  Give direct access to the underlying fitter class. ;  ; TH1 * GetMCPrediction (Int_t parm) const;  Return the adjusted MC template (Aji) for template (parm). ;  ; Int_t GetNDF () const;  return the number of degrees of freedom in the fit the fNDF parameter has been previously computed during a fit. ;  ; TH1 * GetPlot ();  Return the ""template prediction"" corresponding to the fit result (this is not the same as the weighted sum of template distributions, as template statistical uncertainties are taken into account). ;  ; Double_t GetProb () const;  return the fit probability ;  ; void GetResult (Int_t parm, Double_t &value, Double_t &error) const;  Obtain the fit result for parameter <parm> (the parameter numbering follows that of the input template vector). ;  ; void IncludeBin (Int_t bin);  Include the given bin in the fit, if it was excluded before using ExcludeBin(). ;  ; TClass * IsA () const override;  ; void ReleaseRangeX ();  Release restrictions on the X range of the histogram to be used in the fit. ;  ; void ReleaseRangeY ();  Release restrictions on the Y range of the histogram to be used in the fit. ;  ; void ReleaseRangeZ ();  Release restrictions on the Z range of the histogram to be used in the fit. ;  ; void SetData (TH1 *data);  Change the histogram to be fitted to. ;  ; void SetMC (Int_t parm, TH1 *MC);  Change the histogram for template number <parm>. ;  ; void SetRange",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:7740,predict,prediction,7740,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['predict'],['prediction']
Safety,"w2 if h1 or h2 have Sumw2 set; 1148 if (fSumw2.fN == 0 && (h1->GetSumw2N() != 0 || h2->GetSumw2N() != 0)) Sumw2();; 1149 ; 1150 // - Add statistics; 1151 Double_t nEntries = TMath::Abs( c1*h1->GetEntries() + c2*h2->GetEntries() );; 1152 ; 1153 // TODO remove; 1154 // statistics can be preserved only in case of positive coefficients; 1155 // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; 1156 // also in case of scaling with the width we cannot preserve the statistics; 1157 Double_t s1[kNstat] = {0};; 1158 Double_t s2[kNstat] = {0};; 1159 Double_t s3[kNstat];; 1160 ; 1161 ; 1162 Bool_t resetStats = (c1*c2 < 0) || normWidth;; 1163 if (!resetStats) {; 1164 // need to initialize to zero s1 and s2 since; 1165 // GetStats fills only used elements depending on dimension and type; 1166 h1->GetStats(s1);; 1167 h2->GetStats(s2);; 1168 for (Int_t i=0;i<kNstat;i++) {; 1169 if (i == 1) s3[i] = c1*c1*s1[i] + c2*c2*s2[i];; 1170 //else s3[i] = TMath::Abs(c1)*s1[i] + TMath::Abs(c2)*s2[i];; 1171 else s3[i] = c1*s1[i] + c2*s2[i];; 1172 }; 1173 }; 1174 ; 1175 SetMinimum();; 1176 SetMaximum();; 1177 ; 1178 if (normWidth) { // DEPRECATED CASE: belongs to fitting / drawing modules; 1179 ; 1180 Int_t nbinsx = GetNbinsX() + 2; // normal bins + underflow, overflow; 1181 Int_t nbinsy = GetNbinsY() + 2;; 1182 Int_t nbinsz = GetNbinsZ() + 2;; 1183 ; 1184 if (fDimension < 2) nbinsy = 1;; 1185 if (fDimension < 3) nbinsz = 1;; 1186 ; 1187 Int_t bin, binx, biny, binz;; 1188 for (binz = 0; binz < nbinsz; ++binz) {; 1189 Double_t wz = h1->GetZaxis()->GetBinWidth(binz);; 1190 for (biny = 0; biny < nbinsy; ++biny) {; 1191 Double_t wy = h1->GetYaxis()->GetBinWidth(biny);; 1192 for (binx = 0; binx < nbinsx; ++binx) {; 1193 Double_t wx = h1->GetXaxis()->GetBinWidth(binx);; 1194 bin = GetBin(binx, biny, binz);; 1195 Double_t w = wx*wy*wz;; 1196 UpdateBinContent(bin, c1 * h1->RetrieveBinContent(bin) / w);; 1197 if (fSumw2.fN) {; 1198 Double_t e1 = h1->GetBinError(bin)/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:46123,risk,risks,46123,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['risk'],['risks']
Safety,"w2(Bool_t flag); 1380{; 1381 TProfileHelper::Sumw2(this, flag);; 1382}; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; THashList.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfile3D.h; TProfileHelper.h; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefinition TProfile.h:28; kERRORSPREADI@ kERRORSPREADIDefinition TProfile.h:28; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Copyvoid Copy(TArrayD &array) constDefinition TArrayD.h:42; TArrayD::Setvoid Set(Int_t n) overrideSet size of this array to n doubles.Definition TArrayD.cxx:106; TArrayD::TArrayDTArrayD()Default TArrayD ctor.Definition TArrayD.cxx:26; TArr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:53542,abort,abort,53542,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['abort'],['abort']
Safety,"wBin; doublefLumiError; doublefNomLumi; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactory(). ~HistoToWorkspaceFactory(). HistoToWorkspaceFactory(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1F* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1F* nominal, vector<TH1F*> lowHist, vector<TH1F*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; make list of abstract parameters that interpolate in space of variations; range is set using defined macro (see top of the page). string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactory.html:8720,predict,predictions,8720,root/html530/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['predict'],['predictions']
Safety,"w[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TS3WebFile&operator=(const TS3WebFile&); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tTWebFile::ReadBuffer(char* buf, Int_t len); virtual Bool_tTWebFile::ReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTWebFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTWebFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:12786,Recover,Recover,12786,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,2,['Recover'],['Recover']
Safety,"wards from exiting point and compare boundary crossing points. ; Definition at line 809 of file TGeoChecker.cxx. ◆ CheckGeometryFull(). void TGeoChecker::CheckGeometryFull ; (; Bool_t ; checkoverlaps = kTRUE, . Bool_t ; checkcrossings = kTRUE, . Int_t ; ntracks = 10000, . const Double_t * ; vertex = nullptr . ). Geometry checking. ; Optional overlap checkings (by sampling and by mesh). Optional boundary crossing check + timing per volume.; STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can be called for the suspicious volumes.; STAGE 2: normal overlap checking using the shapes mesh - fills the list of overlaps.; STAGE 3: shooting NRAYS rays from VERTEX and counting the total number of crossings per volume (rays propagated from boundary to boundary until geometry exit). Timing computed and results stored in a histo.; STAGE 4: shooting 1 mil. random rays inside EACH volume and calling FindNextBoundary() + Safety() for each call. The timing is normalized by the number of crossings computed at stage 2 and presented as percentage. One can get a picture on which are the most ""burned"" volumes during transportation from geometry point of view. Another plot of the timing per volume vs. number of daughters is produced.; All histos are saved in the file statistics.root ; Definition at line 503 of file TGeoChecker.cxx. ◆ CheckOverlaps(). void TGeoChecker::CheckOverlaps ; (; const TGeoVolume * ; vol, . Double_t ; ovlp = 0.1, . Option_t * ; option = """" . ). Check illegal overlaps for volume VOL within a limit OVLP. ; Definition at line 1427 of file TGeoChecker.cxx. ◆ CheckOverlapsBySampling(). void TGeoChecker::CheckOverlapsBySampling ; (; TGeoVolume * ; vol, . Double_t ; ovlp = 0.1, . Int_t ; npoints = 1000000 . ); const. Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints inside the volume shape. ; Definition at line 1196 of file TGeoChecker.cxx. ◆ C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:19956,Safe,Safety,19956,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['Safe'],['Safety']
Safety,"ware Foundation.; ; 14. If you wish to incorporate parts of the Library into other free; programs whose distribution conditions are incompatible with these,; write to the author to ask for permission. For software which is; copyrighted by the Free Software Foundation, write to the Free; Software Foundation; we sometimes make exceptions for this. Our; decision will be guided by the two goals of preserving the free status; of all derivatives of our free software and of promoting the sharing; and reuse of software generally. NO WARRANTY. 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO; WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.; EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR; OTHER PARTIES PROVIDE THE LIBRARY ""AS IS"" WITHOUT WARRANTY OF ANY; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR; PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE; LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME; THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN; WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY; AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU; FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR; CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE; LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING; RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A; FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF; SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH; DAMAGES. END OF TERMS AND CONDITIONS; ; How to Apply These Terms to Your New Libraries. If you develop a new library, and you want it to be of the greatest; possible use to the public, we recommend making it free software that; everyone c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:25805,RISK,RISK,25805,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['RISK'],['RISK']
Safety,"was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void ResetSignals(); Reset signals handlers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:22342,timeout,timeout,22342,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,2,['timeout'],['timeout']
Safety,"we decided against it, and I believe that we have good reasons for that :-); GCCXML's future is limited; there is a re-write based on GCC's plugin mechanism, but both suffer from the same problems: we cannot influence what the GCC parser does. And reading headers, writing XML, parsing XML, writing (huge files of) C++, compiling, linking, loading - that's really, really inefficient and error prone.; Python is much simpler than C++. But it's still a horrible language in our environment, unless it's used as bash++. Not a single algorithm should be written in Python: it's terribly hard to convert it into C++, and it's incredibly slow in Python (ask the Google developers about youtube).; So C++ is not a good interpreted language, mainly due to its syntactic verbosity and its lack of dynamic interfaces and reflection capabilities - think; const std::type_info& ti = std::type_info::lookup(""MyClass"");; MyBase* ptr = ti.default_construct();; And Python is not appropriate for many use cases due to its lack of type safety and speed, and its lack of native binding to C++. Then which other language should we use?; Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Hi Alex, . Hi Alex,; Very good points but let me try to defend python. I have found that a following approach (used by ATLAS that I also adopted in my private code) works fantastically well:; -- Use python to read configuration, find input files, etc;; -- Write performance critical code in C++;; -- Create C++ objects in python (relying on ROOT for dictionary support);; -- Pass configuration from python to C++;; -- Do calculations in C++;; -- Return results to python for processing, ploting, etc;; -- Run entire plot making code in python for stacking, labeling, etc.; Granted, this is probably a more complex approach than most of us in physics are willing to tolerate. I suspect that you do not have much choice since the user community wants CINT-like functionality from ROOT (and one",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:17394,safe,safety,17394,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['safe'],['safety']
Safety,"we will consider few examples. We will designate non-overlapping nodes as ONLY and the others MANY as in GEANT3, where this concept was introduced:. The part of a MANY node B extruding its container A will never be ""seen"" during navigation, as if B was in fact the result of the intersection of A and B.; If we have two nodes A (ONLY) and B (MANY) inside the same container, all points in the overlapping region of A and B will be designated as belonging to A.; If A an B in the above case were both MANY, points in the overlapping part will be designated to the one defined first. Both nodes must have the same medium.; The slices of a divided MANY will be as well MANY. One needs to know that navigation inside geometry parts MANY nodes is much slower. Any overlapping part can be defined based on composite shapes - might be in some cases a better way out.; Replicating Volumes; What can we do if our chamber contains two identical wires instead of one? What if then we would need 1000 chambers in our detector? Should we create 2000 wires and 1000 chamber volumes? No, we will just need to replicate the ones that we have already created.; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:40837,detect,detector,40837,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,"webviewer/inc/ROOT/RGeomData.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RGeomData.hxx. Go to the documentation of this file. 1// Author: Sergey Linev, 14.12.2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2023, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT7_RGeomData; 12#define ROOT7_RGeomData; 13 ; 14#include <vector>; 15#include <string>; 16#include <functional>; 17#include <memory>; 18 ; 19#include <ROOT/Browsable/RItem.hxx>; 20 ; 21#include ""TVirtualMutex.h""; 22 ; 23class TGeoNode;; 24class TGeoManager;; 25class TGeoShape;; 26class TGeoMatrix;; 27class TGeoVolume;; 28 ; 29// do not use namespace to avoid too long JSON; 30 ; 31namespace ROOT {; 32 ; 33class RGeomBrowserIter;; 34 ; 35namespace Experimental {; 36class RLogChannel;; 37} // namespace Experimental; 38 ; 39/// Log channel for Geomviewer diagnostics.; 40Experimental::RLogChannel &RGeomLog();; 41 ; 42/** Base description of geometry node, required only to build hierarchy */; 43 ; 44class RGeomNodeBase {; 45public:; 46 int id{0}; ///< node id, index in array; 47 std::string name; ///< node name; 48 std::vector<int> chlds; ///< list of childs id; 49 int vis{0}; ///< visibility flag, 0 - off, 1 - only when level==0, 99 - always; 50 bool nochlds{false}; ///< how far in hierarchy depth should be scanned; 51 ; 52 std::string color; ///< rgb code in hex format; 53 std::string material; ///< name of the material; 54 int sortid{0}; ///<! place in sorted array, to check cuts, or id of original node when used search structures; 55 ; 56 RGeomNodeBase(int _id = 0) : id(_id) {}; 57 ; 58 bool IsVisible() const { return vis > 0; }; 59 ; 60 /** Returns argument for regexp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8hxx_source.html:979,avoid,avoid,979,doc/master/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html,1,['avoid'],['avoid']
Safety,"weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 214/// In the case of Profile filled weights and with TProfile::Sumw2() called,; 215/// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; 216/// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); 217///; 218/// If a bin has N data points all with the same value Y (especially; 219/// possible when dealing with integers), the spread in Y for that bin; 220/// is zero, and the uncertainty assigned is also zero, and the bin is; 221/// ignored in making subsequent fits.; 222/// To avoid this problem one can use an approximation for the standard deviation S(Y),; 223/// by using the average of all the S(Y) of the other Profile bins. To use this approximation; 224/// one must call before TProfile::Approximate; 225/// This approximation applies only for the default and the 's' options; 226 ; 227void TProfile::BuildOptions(Double_t ymin, Double_t ymax, Option_t *option); 228{; 229 SetErrorOption(option);; 230 ; 231 // create extra profile data structure (bin entries/ y^2 and sum of weight square); 232 TProfileHelper::BuildArray(this);; 233 ; 234 fYmin = ymin;; 235 fYmax = ymax;; 236 fScaling = kFALSE;; 237 fTsumwy = fTsumwy2 = 0;; 238 ; 239}; 240 ; 241////////////////////////////////////////////////////////////////////////////////; 242/// Copy constructor.; 243 ; 244TProfile::TProfile(const TProfile &profile) : TH1D(); 245{; 246 profile.TProfile::Copy(*this);; 247}; 248 ; 249TProfile &TProfile::operator=(const TProfile &profile); 250{; 251 if (this != &profile); 252 profile.TProfile::Copy(*this);; 253 return *this;; 254}; 255 ; 256////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:10297,avoid,avoid,10297,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"wer::MenuHidingTimeout ; (; ). Action for menu-hiding timeout. ; Definition at line 638 of file TGLSAViewer.cxx. ◆ operator=(). TGLSAViewer & TGLSAViewer::operator= ; (; const TGLSAViewer & ; ). private . ◆ ProcessFrameMessage(). Bool_t TGLSAViewer::ProcessFrameMessage ; (; Long_t ; msg, . Long_t ; parm1, . Long_t ;  . ). Process GUI message capture by the main GUI frame (TGLSAFrame). ; Definition at line 663 of file TGLSAViewer.cxx. ◆ ResetMenuHidingTimer(). void TGLSAViewer::ResetMenuHidingTimer ; (; Bool_t ; show_menu). private . Reset the timer for menu-bar hiding. ; Definition at line 620 of file TGLSAViewer.cxx. ◆ SelectionChanged(). void TGLSAViewer::SelectionChanged ; (; ). overridevirtual . Update GUI components for embedded viewer selection change. ; Override from TGLViewer. ; Reimplemented from TGLViewer.; Definition at line 481 of file TGLSAViewer.cxx. ◆ SetMenuHidingTimeout(). void TGLSAViewer::SetMenuHidingTimeout ; (; Long_t ; timeout). static . Set global timeout for menu-hiding in mili-seconds. ; Static function. ; Definition at line 655 of file TGLSAViewer.cxx. ◆ Show(). void TGLSAViewer::Show ; (; ). Show the viewer. ; Definition at line 500 of file TGLSAViewer.cxx. ◆ Streamer(). void TGLSAViewer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGLSAViewer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 132 of file TGLSAViewer.h. ◆ ToggleEditObject(). void TGLSAViewer::ToggleEditObject ; (; ). Toggle state of the 'Edit Object' menu entry. ; Definition at line 820 of file TGLSAViewer.cxx. ◆ ToggleOrthoDolly(). void TGLSAViewer::ToggleOrthoDolly ; (; ). Toggle state of the 'Ortho allow dolly' menu entry. ; Definition at line 850 of file TGLSAViewer.cxx. ◆ ToggleOrthoRotate(). void TGLSAViewer::ToggleOrthoRotate ; (; ). Toggle state of the 'Ortho allow rotate' menu entry. ; Definition at line 832 of file TGLSAVie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLSAViewer.html:46397,timeout,timeout,46397,doc/master/classTGLSAViewer.html,https://root.cern,https://root.cern/doc/master/classTGLSAViewer.html,1,['timeout'],['timeout']
Safety,"were encountered"" << Endl;; 845 Log() << Form(""Dataset[%s] : "",dsi.GetName())<< "" location of error: event "" << evtIdx; 846 << "" in tree "" << currentInfo.GetTree()->GetName(); 847 << "" of file "" << currentInfo.GetTree()->GetCurrentFile()->GetName() << Endl;; 848 Log() << Form(""Dataset[%s] : "",dsi.GetName())<< "" expression "" << inputFormula->GetTitle() << "" has ""; 849 << Form(""Dataset[%s] : "",dsi.GetName()) << ndata << "" entries, while"" << Endl;; 850 Log() << Form(""Dataset[%s] : "",dsi.GetName())<< "" expression "" << fInputTableFormulas[prevArrExpr].first->GetTitle() << "" has ""; 851 << Form(""Dataset[%s] : "",dsi.GetName())<< fInputTableFormulas[prevArrExpr].first->GetNdata() << "" entries"" << Endl;; 852 Log() << kFATAL << Form(""Dataset[%s] : "",dsi.GetName())<< ""Need to abort"" << Endl;; 853 }; 854 }; 855 ; 856 // now we read the information; 857 for (Int_t idata = 0; idata<sizeOfArrays; idata++) {; 858 Bool_t contains_NaN_or_inf = kFALSE;; 859 ; 860 auto checkNanInf = [&](std::map<TString, int> &msgMap, Float_t value, const char *what, const char *formulaTitle) {; 861 if (TMath::IsNaN(value)) {; 862 contains_NaN_or_inf = kTRUE;; 863 ++msgMap[TString::Format(""Dataset[%s] : %s expression resolves to indeterminate value (NaN): %s"", dsi.GetName(), what, formulaTitle)];; 864 } else if (!TMath::Finite(value)) {; 865 contains_NaN_or_inf = kTRUE;; 866 ++msgMap[TString::Format(""Dataset[%s] : %s expression resolves to infinite value (+inf or -inf): %s"", dsi.GetName(), what, formulaTitle)];; 867 }; 868 };; 869 ; 870 TTreeFormula* formula = 0;; 871 ; 872 // the cut expression; 873 Double_t cutVal = 1.;; 874 formula = fCutFormulas[cl];; 875 if (formula) {; 876 Int_t ndata = formula->GetNdata();; 877 cutVal = (ndata==1 ?; 878 formula->EvalInstance(0) :; 879 formula->EvalInstance(idata));; 880 checkNanInf(nanInfErrors, cutVal, ""Cut"", formula->GetTitle());; 881 }; 882 ; 883 // if event is cut out, add to warnings, else add to errors.; 884 auto &nanMessages = cutVal < 0.5 ? nanInfWarnings",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:36566,abort,abort,36566,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['abort'],['abort']
Safety,"will be restarted. ; Definition at line 199 of file TTimer.cxx. ◆ SetObject(). void TTimer::SetObject ; (; TObject * ; object). Set the object to be notified at time out. ; Removes the command to be executed (if it was set). ; Definition at line 186 of file TTimer.cxx. ◆ SetTime(). void TTimer::SetTime ; (; Long_t ; milliSec). inline . Definition at line 91 of file TTimer.h. ◆ SetTimerID(). void TTimer::SetTimerID ; (; UInt_t ; id = 0). inline . Definition at line 92 of file TTimer.h. ◆ SingleShot(). void TTimer::SingleShot ; (; Int_t ; milliSec, . const char * ; receiver_class, . void * ; receiver, . const char * ; method . ). static . This static function calls a slot after a given time interval. ; Created internal timer will be deleted after that. ; Definition at line 258 of file TTimer.cxx. ◆ Start(). void TTimer::Start ; (; Long_t ; milliSec = -1, . Bool_t ; singleShot = kFALSE . ). virtual . Starts the timer with a milliSec timeout. ; If milliSec is 0 then the timeout will be the minimum timeout (see TSystem::ESysConstants, i.e. 10 ms), if milliSec is -1 then the time interval as previously specified (in ctor or SetTime()) will be used. If singleShot is kTRUE, the timer will be activated only once, otherwise it will continue until it is stopped. See also TurnOn(), Stop(), TurnOff(). ; Definition at line 213 of file TTimer.cxx. ◆ Stop(). virtual void TTimer::Stop ; (; ). inlinevirtual . Reimplemented in TGLRedrawTimer.; Definition at line 94 of file TTimer.h. ◆ Streamer(). void TTimer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TSysEvtHandler. ◆ StreamerNVirtual(). void TTimer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 102 of file TTimer.h. ◆ Timeout(). virtual void TTimer::Timeout ; (; ). inlinevirtual . Reimplemented in ROOT::RBrowserTimer, TCefTimer, TQt5Timer, TQt6Timer, TWebCanvasTimer, THttpTimer, and ROOT::RTreeDrawInvokeTimer.; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:24971,timeout,timeout,24971,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,2,['timeout'],['timeout']
Safety,"wind Cling dictionary to the point where it was before executing the current macro. ; This function is typically called after SEGV or ctlr-C after doing a longjmp back to the prompt. ; Implements TInterpreter.; Definition at line 3769 of file TCling.cxx. ◆ RewindInterpreterMutex(). void * TCling::RewindInterpreterMutex ; (; ). Reset the interpreter lock to the state it had before interpreter-related calls happened. ; Definition at line 9664 of file TCling.cxx. ◆ SaveContext(). void TCling::SaveContext ; (; ). finalvirtual . Save the current Cling state. ; Implements TInterpreter.; Definition at line 3859 of file TCling.cxx. ◆ SaveGlobalsContext(). void TCling::SaveGlobalsContext ; (; ). finalvirtual . Save the current Cling state of global objects. ; Implements TInterpreter.; Definition at line 3872 of file TCling.cxx. ◆ SetAlloclockfunc(). void TCling::SetAlloclockfunc ; (; void(*)() ; ); const. finalvirtual . [Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect critical section of its code (non-thread safe parts). ; Reimplemented from TInterpreter.; Definition at line 7536 of file TCling.cxx. ◆ SetAllocunlockfunc(). void TCling::SetAllocunlockfunc ; (; void(*)() ; ); const. finalvirtual . [Place holder for Mutex Unlock] Provide the interpreter with a way to release a lock used to protect critical section of its code (non-thread safe parts). ; Reimplemented from TInterpreter.; Definition at line 7546 of file TCling.cxx. ◆ SetAutoLoadCallBack(). void * TCling::SetAutoLoadCallBack ; (; void * ; cb). inlinefinalvirtual . Reimplemented from TInterpreter.; Definition at line 199 of file TCling.h. ◆ SetClassAutoLoading(). int TCling::SetClassAutoLoading ; (; int ; autoload); const. finalvirtual . Enable/Disable the AutoLoading of libraries. ; Returns the old value, i.e whether it was enabled or not. ; Reimplemented from TInterpreter.; Definition at line 7567 of file TCling.cxx. ◆ SetClassAutoparsing(). int TCling::SetClassAuto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:130305,safe,safe,130305,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['safe'],['safe']
Safety,"with ""_1_1"" and all ""_"" with ""__"" in the; 692 // classes definitions, due to Doxygen syntax requirements.; 693 scopeName.ReplaceAll(""_"", ""__"");; 694 scopeName.ReplaceAll(""::"", ""_1_1"");; 695 // We build the URL for the correct scope type and name.; 696 if (scopeType == kURLforClass) {; 697 url.Append(""class"");; 698 } else if (scopeType == kURLforStruct) {; 699 url.Append(""struct"");; 700 } else {; 701 url.Append(""namespace"");; 702 }; 703 url.Append(scopeName);; 704 url.Append("".html"");; 705 return url;; 706}; 707} // namespace; 708 ; 709namespace {; 710////////////////////////////////////////////////////////////////////////////////; 711/// The function returns a TString with the arguments of a method from the; 712/// scope (scopeName), but modified with respect to Doxygen syntax - spacing; 713/// around special symbols and adding the missing scopes (""std::"").; 714/// ""FormatMethodArgsForDoxygen"" works for functions defined inside namespaces; 715/// as well. We avoid looking up twice for the TFunction by passing ""func"".; 716///; 717/// \param[in] scopeName the name of the class/namespace/struct; 718/// \param[in] func pointer to the method; 719 ; 720static TString FormatMethodArgsForDoxygen(const TString &scopeName, TFunction *func); 721{; 722 // With ""GetSignature"" we get the arguments of the method and put them in a TString.; 723 TString methodArguments = func->GetSignature();; 724 // ""methodArguments"" is modified with respect of Doxygen requirements.; 725 methodArguments.ReplaceAll("" = "", ""="");; 726 methodArguments.ReplaceAll(""* "", "" *"");; 727 methodArguments.ReplaceAll(""*="", "" *="");; 728 methodArguments.ReplaceAll(""*)"", "" *)"");; 729 methodArguments.ReplaceAll(""*,"", "" *,"");; 730 methodArguments.ReplaceAll(""*& "", "" *&"");; 731 methodArguments.ReplaceAll(""& "", "" &"");; 732 // TODO: prepend ""std::"" to all stdlib classes!; 733 methodArguments.ReplaceAll(""ostream"", ""std::ostream"");; 734 methodArguments.ReplaceAll(""istream"", ""std::istream"");; 735 methodArguments.ReplaceAll(""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:25316,avoid,avoid,25316,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['avoid'],['avoid']
Safety,"with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(treename, filename);; auto df2 = df.Define(""y"", Compute<4, float>(model), variables);; return df2.Histo1D({treename.c_str(), "";BDT score;N_{Ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:2333,predict,prediction,2333,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,1,['predict'],['prediction']
Safety,"with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t* point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t* point, Double_t safmax = 1.E30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. void SetUseOverlaps(Bool_t flag); Activate/deactivate overlap usage. {fUseOverlaps = flag;}. Bool_t IsUsingOverlaps() const; {return fUseOverlaps;}. TGeoManager * GetGeometry() const; Getters. {return fGeoManager;}. Bool_t IsClosed() const; {return fIsClosed;}. TGeoVolume * GetVolume() const; {return fVolume;}. » Author: Andrei Gheata 30/06/14 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Sat Mar 14 16:39:38 2015 » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParallelWorld.html:8458,Safe,Safety,8458,root/html534/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html,2,"['Safe', 'safe']","['Safety', 'safety']"
Safety,"wname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:2592,safe,safe,2592,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,3,['safe'],['safe']
Safety,"words) that can be set in the option string. . UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting. known:; GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB. nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine misclassification error rate); PruneMethod The Pruning method: known:; NoPruning // switch off pruning completely; ExpectedError; CostComplexity. PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided""); . Implements TMVA::MethodBase.; Definition at line 212 of file MethodDT.cxx. ◆ DeclFileName(). static const char * TMVA::MethodDT::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 139 of file MethodDT.h. ◆ GetHelpMessage(). void TMVA::MethodDT::GetHelpMessage ; (; ); const. virtual . Implements TMVA::IMethod.; Definition at line 561 of file MethodDT.cxx. ◆ GetMvaValue(). Double_t TMVA::MethodDT::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . returns MVA value ; Implements TMVA::MethodBase.; Definition at line 551 of file MethodDT.cxx. ◆ GetNNodes(). Int_t TMVA::MethodDT::GetNNodes ; (; ). inline . Definition at line 97 of file MethodDT.h. ◆ GetNNodesBeforePruning(). Int_t TMVA::MethodDT::GetNNodesBeforePruning ; (; ). inline . Definition at line 96 of file MethodDT.h. ◆ GetPruneStrength(). Double_t TMVA::MethodDT::GetPruneStrength ; (; ). inline ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDT.html:35661,avoid,avoided,35661,doc/master/classTMVA_1_1MethodDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDT.html,1,['avoid'],['avoided']
Safety,"write access of vector elements. Index starts from 0. ;  ; T & At (unsigned int i);  read/write access of vector elements with check on index. Index starts from 0. ;  ; SVector< T, D > & operator+= (const T &rhs);  self addition with a scalar ;  ; SVector< T, D > & operator-= (const T &rhs);  self subtraction with a scalar ;  ; SVector< T, D > & operator*= (const T &rhs);  self multiplication with a scalar ;  ; SVector< T, D > & operator/= (const T &rhs);  self division with a scalar ;  ; SVector< T, D > & operator+= (const SVector< T, D > &rhs);  self addition with another vector ;  ; SVector< T, D > & operator-= (const SVector< T, D > &rhs);  self subtraction with another vector ;  ; template<class A > ; SVector< T, D > & operator+= (const VecExpr< A, T, D > &rhs);  self addition with a vector expression ;  ; template<class A > ; SVector< T, D > & operator-= (const VecExpr< A, T, D > &rhs);  self subtraction with a vector expression ;  ; — Expert functions —; SVector< T, D > & Unit ();  transform vector into a vector of length 1 ;  ; template<unsigned int D2> ; SVector< T, D > & Place_at (const SVector< T, D2 > &rhs, unsigned int row);  place a sub-vector starting from the given position ;  ; template<class A , unsigned int D2> ; SVector< T, D > & Place_at (const VecExpr< A, T, D2 > &rhs, unsigned int row);  place a sub-vector expression starting from the given position ;  ; template<class SubVector > ; SubVector Sub (unsigned int row) const;  return a subvector of size N starting at the value row where N is the size of the returned vector (SubVector::kSize) Condition row+N <= D ;  ; bool IsInUse (const T *p) const;  Function to check if a vector is sharing same memory location of the passed pointer This function is used by the expression templates to avoid the alias problem during expression evaluation. ;  ; std::ostream & Print (std::ostream &os) const;  used by operator<<() ;  . Private Attributes; — Data member —; T fArray [D];  SVector data. ;  . — Access fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:6985,avoid,avoid,6985,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['avoid'],['avoid']
Safety,"wser *b); 524{; 525 cd();; 526 if (fPrimitives) fPrimitives->Browse(b);; 527}; 528 ; 529////////////////////////////////////////////////////////////////////////////////; 530/// Build a legend from the graphical objects in the pad.; 531///; 532/// A simple method to build automatically a TLegend from the primitives in a TPad.; 533///; 534/// Only those deriving from TAttLine, TAttMarker and TAttFill are added, excluding; 535/// TPave and TFrame derived classes.; 536///; 537/// \return The built TLegend; 538///; 539/// \param[in] x1, y1, x2, y2 The TLegend coordinates; 540/// \param[in] title The legend title. By default it is "" ""; 541/// \param[in] option The TLegend option; 542///; 543/// The caller program owns the returned TLegend.; 544///; 545/// If the pad contains some TMultiGraph or THStack the individual; 546/// graphs or histograms in them are added to the TLegend.; 547///; 548/// ### Automatic placement of the legend; 549/// If `x1` is equal to `x2` and `y1` is equal to `y2` the legend will be automatically; 550/// placed to avoid overlapping with the existing primitives already displayed.; 551/// `x1` is considered as the width of the legend and `y1` the height. By default; 552/// the legend is automatically placed with width = `x1`= `x2` = 0.3 and; 553/// height = `y1`= `y2` = 0.21.; 554 ; 555TLegend *TPad::BuildLegend(Double_t x1, Double_t y1, Double_t x2, Double_t y2,; 556 const char* title, Option_t *option); 557{; 558 TList *lop = GetListOfPrimitives();; 559 if (!lop) return nullptr;; 560 TList *lof = nullptr;; 561 TLegend *leg = nullptr;; 562 TObject *obj = nullptr;; 563 TIter next(lop);; 564 TString mes;; 565 TString opt;; 566 ; 567 auto AddEntryFromListOfFunctions = [&]() {; 568 TIter nextobj(lof);; 569 while ((obj = nextobj())) {; 570 if (obj->InheritsFrom(TNamed::Class())) {; 571 if (strlen(obj->GetTitle())); 572 mes = obj->GetTitle();; 573 else; 574 mes = obj->GetName();; 575 } else {; 576 mes = obj->ClassName();; 577 }; 578 leg->AddEntry(obj, m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:16928,avoid,avoid,16928,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['avoid'],['avoid']
Safety,"wser to...Definition RElement.cxx:178; ROOT::Browsable::RElement::GetTitlevirtual std::string GetTitle() constTitle of browsable (optional)Definition RElement.hxx:71; ROOT::Browsable::RElement::ComparePathsstatic int ComparePaths(const RElementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::GetPathAsStringstatic std::string GetPathAsString(const RElementPath_t &path)Converts element path back to string.Definition RElement.cxx:160; ROOT::Browsable::RElement::GetSubElementstatic std::shared_ptr< RElement > GetSubElement(std::shared_ptr< RElement > &elem, const RElementPath_t &path)Returns sub element.Definition RElement.cxx:69; ROOT::Browsable::RElement::CreateItemvirtual std::unique_ptr< RItem > CreateItem() constReturns item with element description.Definition RElement.cxx:105; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; TBufferJSON::ConvertToJSONstatic TString ConvertToJSON(const TObject *obj, Int_t compact=0, const char *member_name=nullptr)Converts object, inherited from TObject class, to JSON string Lower digit of compact parameter define...Definition TBufferJSON.cxx:522; TString::Dataconst char * Data() constDefinition TString.h:376; nconst Int_t nDefinition legend1.C:16; ROOT::BrowsableDefinition RAnyObjectHolder.hxx:15; ROOT::Browsable::RElementPath_tstd::vector< std::string > RElementPath_tDefinition RElement.hxx:20; ROOT::BrowsableLogROOT::Experimental::RLogChannel & BrowsableLog()Log channel for Browsable diagnostics.Definition RElement.cxx:20; slashTCanvas * slash()Definition slash.C:1. guibrowsablesrcRElement.cxx. ROOT master - Reference Guide Generated on Tue Nov ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RElement_8cxx_source.html:8972,avoid,avoid,8972,doc/master/RElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RElement_8cxx_source.html,1,['avoid'],['avoid']
Safety,"wser to...Definition RElement.cxx:178; ROOT::Browsable::RElement::GetTitlevirtual std::string GetTitle() constTitle of browsable (optional)Definition RElement.hxx:71; ROOT::Browsable::RElement::ComparePathsstatic int ComparePaths(const RElementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::GetPathAsStringstatic std::string GetPathAsString(const RElementPath_t &path)Converts element path back to string.Definition RElement.cxx:160; ROOT::Browsable::RElement::GetSubElementstatic std::shared_ptr< RElement > GetSubElement(std::shared_ptr< RElement > &elem, const RElementPath_t &path)Returns sub element.Definition RElement.cxx:69; ROOT::Browsable::RElement::CreateItemvirtual std::unique_ptr< RItem > CreateItem() constReturns item with element description.Definition RElement.cxx:105; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; TBufferJSON::ConvertToJSONstatic TString ConvertToJSON(const TObject *obj, Int_t compact=0, const char *member_name=nullptr)Converts object, inherited from TObject class, to JSON string Lower digit of compact parameter define...Definition TBufferJSON.cxx:522; TString::Dataconst char * Data() constDefinition TString.h:376; nconst Int_t nDefinition legend1.C:16; ROOT::BrowsableDefinition RAnyObjectHolder.hxx:15; ROOT::Browsable::RElementPath_tstd::vector< std::string > RElementPath_tDefinition RElement.hxx:20; ROOT::BrowsableLogROOT::Experimental::RLogChannel & BrowsableLog()Log channel for Browsable diagnostics.Definition RElement.cxx:20; slashTCanvas * slash()Definition slash.C:1. guibrowsablesrcRElement.cxx. ROOT v6-32 - Reference Guide Generated on Fri Nov 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RElement_8cxx_source.html:8971,avoid,avoid,8971,doc/v632/RElement_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RElement_8cxx_source.html,1,['avoid'],['avoid']
Safety,"wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& ); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. CodeRepo(const RooWorkspace::CodeRepo& other, RooWorkspace* wspace = 0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last changed: Sat Jun 20 17:31:19 2015 » Last generated: 2015-06-20 17:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooWorkspace__CodeRepo.html:8680,recover,recover,8680,root/html604/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html604/RooWorkspace__CodeRepo.html,2,"['abort', 'recover']","['abort', 'recover']"
Safety,"wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& ); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. CodeRepo(const RooWorkspace::CodeRepo& other, RooWorkspace* wspace = 0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last changed: Tue Jun 30 14:38:14 2015 » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooWorkspace__CodeRepo.html:8680,recover,recover,8680,root/html602/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html602/RooWorkspace__CodeRepo.html,2,"['abort', 'recover']","['abort', 'recover']"
Safety,"wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& ); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. CodeRepo(const RooWorkspace::CodeRepo& other, RooWorkspace* wspace = 0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last changed: Tue Mar 10 17:21:16 2015 » Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooWorkspace__CodeRepo.html:8147,recover,recover,8147,root/html534/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html534/RooWorkspace__CodeRepo.html,2,"['abort', 'recover']","['abort', 'recover']"
Safety,"x < 0. || integrandMax < integrandMin) {; 592 return 0;; 593 }; 594 const double delta = 100.0 * std::sqrt(mu);; 595 // If the limits are more than many standard deviations away from the mean,; 596 // we might as well return the integral of the full Poisson distribution to; 597 // save computing time.; 598 if (integrandMin < std::max(mu - delta, 0.0) && integrandMax > mu + delta) {; 599 return 1.;; 600 }; 601 ; 602 // The range as integers. ixMin is included, ixMax outside.; 603 const unsigned int ixMin = integrandMin;; 604 const unsigned int ixMax = std::min(integrandMax + 1, (double)std::numeric_limits<unsigned int>::max());; 605 ; 606 // Sum from 0 to just before the bin outside of the range.; 607 if (ixMin == 0) {; 608 return ROOT::Math::inc_gamma_c(ixMax, mu);; 609 } else {; 610 // If necessary, subtract from 0 to the beginning of the range; 611 if (ixMin <= mu) {; 612 return ROOT::Math::inc_gamma_c(ixMax, mu) - ROOT::Math::inc_gamma_c(ixMin, mu);; 613 } else {; 614 // Avoid catastrophic cancellation in the high tails:; 615 return ROOT::Math::inc_gamma(ixMin, mu) - ROOT::Math::inc_gamma(ixMax, mu);; 616 }; 617 }; 618 }; 619 ; 620 // the integral with respect to the mean is the integral of a gamma distribution; 621 // negative ix does not need protection (gamma returns 0.0); 622 const double ix = 1 + x;; 623 ; 624 return ROOT::Math::inc_gamma(ix, integrandMax) - ROOT::Math::inc_gamma(ix, integrandMin);; 625}; 626 ; 627inline double logNormalIntegral(double xMin, double xMax, double m0, double k); 628{; 629 const double root2 = std::sqrt(2.);; 630 ; 631 double ln_k = std::abs(std::log(k));; 632 double ret =; 633 0.5 * (TMath::Erf(std::log(xMax / m0) / (root2 * ln_k)) - TMath::Erf(std::log(xMin / m0) / (root2 * ln_k)));; 634 ; 635 return ret;; 636}; 637 ; 638inline double logNormalIntegralStandard(double xMin, double xMax, double mu, double sigma); 639{; 640 const double root2 = std::sqrt(2.);; 641 ; 642 double ln_k = std::abs(sigma);; 643 double ret =; 644 0.5 * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MathFuncs_8h_source.html:20432,Avoid,Avoid,20432,doc/master/MathFuncs_8h_source.html,https://root.cern,https://root.cern/doc/master/MathFuncs_8h_source.html,1,['Avoid'],['Avoid']
Safety,"x == 0) return;; 8482 dz = zmax - zmin;; 8483 scale = 100/dz;; 8484 if (ncells > 10000) scale /= 5;; 8485 ltest = kTRUE;; 8486 } else {; 8487 dz = zmax - zmin;; 8488 if (dz >= kNMAX || zmax < 1) {; 8489 scale = (kNMAX-1)/dz;; 8490 if (ncells > 10000) scale /= 5;; 8491 ltest = kTRUE;; 8492 }; 8493 }; 8494 if (fH->GetMinimumStored() == -1111) {; 8495 Double_t yMARGIN = gStyle->GetHistTopMargin();; 8496 if (Hoption.MinimumZero) {; 8497 if (zmin >= 0) zmin = 0;; 8498 else zmin -= yMARGIN*(zmax-zmin);; 8499 } else {; 8500 Double_t dzmin = yMARGIN*(zmax-zmin);; 8501 if (zmin >= 0 && (zmin-dzmin <= 0)) zmin = 0;; 8502 else zmin -= dzmin;; 8503 }; 8504 }; 8505 ; 8506 TString opt = option;; 8507 opt.ToLower();; 8508 if (opt.Contains(""scat="")) {; 8509 char optscat[100];; 8510 strlcpy(optscat,opt.Data(),100);; 8511 char *oscat = strstr(optscat,""scat="");; 8512 char *blank = strstr(oscat,"" ""); if (blank) *blank = 0;; 8513 sscanf(oscat+5,""%lg"",&scale);; 8514 }; 8515 // use an independent instance of a random generator; 8516 // instead of gRandom to avoid conflicts and; 8517 // to get same random numbers when drawing the same histogram; 8518 TRandom2 random;; 8519 marker=0;; 8520 for (Int_t j=Hparam.yfirst; j<=Hparam.ylast;j++) {; 8521 yk = fYaxis->GetBinLowEdge(j);; 8522 ystep = fYaxis->GetBinWidth(j);; 8523 for (Int_t i=Hparam.xfirst; i<=Hparam.xlast;i++) {; 8524 Int_t bin = j*(fXaxis->GetNbins()+2) + i;; 8525 xk = fXaxis->GetBinLowEdge(i);; 8526 xstep = fXaxis->GetBinWidth(i);; 8527 if (!IsInside(xk+0.5*xstep,yk+0.5*ystep)) continue;; 8528 z = fH->GetBinContent(bin);; 8529 if (z < zmin) z = zmin;; 8530 if (z > zmax) z = zmax;; 8531 if (Hoption.Logz) {; 8532 if (z > 0) z = TMath::Log10(z) - zmin;; 8533 } else {; 8534 z -= zmin;; 8535 }; 8536 if (z <= 0) continue;; 8537 k = Int_t(z*scale);; 8538 if (ltest) k++;; 8539 if (k > 0) {; 8540 for (Int_t loop=0; loop<k; loop++) {; 8541 if (k+marker >= kNMAX) {; 8542 gPad->PaintPolyMarker(marker, fXbuf.data(), fYbuf.data());; 8543 marker=0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:304900,avoid,avoid,304900,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"x access(2) function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. XrdClientAdmin * GetClientAdmin(const char* url); Checks if an admin for 'url' exists already.; Avoid duplications. TString GetKey(const char* url); Build from uu a unique ID key used in hash tables. void * GetDirPtr() const; { return fDirp; }. TXNetSystem(Bool_t owner = kTRUE). virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXNetSystem.html:23867,avoid,avoid,23867,root/html604/TXNetSystem.html,https://root.cern,https://root.cern/root/html604/TXNetSystem.html,2,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,"x access(2) function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. XrdClientAdmin * GetClientAdmin(const char* url); Checks if an admin for 'url' exists already.; Avoid duplications. TString GetKey(const char* url); Build from uu a unique ID key used in hash tables. void * GetDirPtr() const; { return fDirp; }. TXNetSystem(Bool_t owner = kTRUE). virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetSystem.html:23867,avoid,avoid,23867,root/html602/TXNetSystem.html,https://root.cern,https://root.cern/root/html602/TXNetSystem.html,2,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,"x* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoParaboloid.html:2401,safe,safe,2401,root/html530/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html,1,['safe'],['safe']
Safety,"x* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoSphere.html:2187,safe,safe,2187,root/html530/TGeoSphere.html,https://root.cern,https://root.cern/root/html530/TGeoSphere.html,1,['safe'],['safe']
Safety,"x* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCompositeShape.html:7879,safe,safe,7879,root/html530/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html,3,['safe'],['safe']
Safety,"x, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz=0); TGeoTubeSeg::TGeoTubeSegTGeoTubeSeg(Double_t *params); TGeoTubeSeg::fSmDouble_t fSmDefinition TGeoTube.h:104; TGeoTubeSeg::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoTubeSeg::SetSegsAndPolsvoid SetSegsAndPols(TBuffer3D &buff) const override; TGeoTubeSeg::GetPhi1Double_t GetPhi1() constDefinition TGeoTube.h:154; TGeoTubeDefinition TGeoTube.h:17; TGeoTube::GetNmeshVerticesInt_t GetNmeshVertices() const override; TGeoTube::DistToTubestatic void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t &b, Double_t &delta); TGeoTube::GetBoundingCylindervoid GetBoundingCylinder(Double_t *param) const override; TGeoTube::GetRminvirtual Double_t GetRmin() constDefinition TGeoTube.h:72; TGeoTube::TGeoTubeTGeoTube(Double_t *params); TGeoTube::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoTube::GetMeshNumbersvoid GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; TGeoTube::IsCylTypeBool_t IsCylType() const overrideDefinition TGeoTube.h:77; TGeoTube::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:67; TGeoTube::GetAxisRangeDouble_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; TGeoTube::SetTubeDimensionsvoid SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::MakeBuffer3DTBuffer3D * MakeBuffer3D() const override; TGeoTube::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point (px,py) to the object.; TGeoTube::DistFromInsideSstatic Double_t DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::GetDzvirtual Double_t GetDz() constDefinition TGeoTube.h:74; TGeoTube::SetPointsvoid SetPoints(Float_t *points) const override; TGeoTube::DistFromOutsideDouble_t DistFromOutside(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:23683,safe,safe,23683,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety,"x, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t RadiusHypeSq(Double_t z, Bool_t inner) const; Compute r^2 = x^2 + y^2 at a given z coordinate, for either inner or outer hyperbolas. Double_t ZHypeSq(Double_t r, Bool_t inner) const; Compute z^2 at a given r^2, for either inner or outer hyperbolas. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyToHype(Double_t* point, Bool_t inner, Bool_t in) const; Compute an underestimate of the closest distance from a point to inner or; outer infinite hyperbolas. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Set dimensions of the hyperboloid. void SetDimensions(Double_t* param); Set dimensions of the hyperboloid starting from an array.; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. void SetPoints(Double_t* points) const; create tube mesh points. void SetPoints(Float_t* points) const; create tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHype.html:16530,Safe,SafetyToHype,16530,root/html528/TGeoHype.html,https://root.cern,https://root.cern/root/html528/TGeoHype.html,3,['Safe'],['SafetyToHype']
Safety,"x. . static void ActivationFunctionForward (Tensor_t &X, EActivationFunction activFunct, const ActivationDescriptor_t activationDescr, const double coef=0.0, const Scalar_t alpha=1, const Scalar_t beta=0);  ; static void ActivationFunctionBackward (Tensor_t &dX, const Tensor_t &Y, const Tensor_t &dY, const Tensor_t &X, EActivationFunction activFunct, const ActivationDescriptor_t activationDescr, const Scalar_t alpha=1, const Scalar_t beta=0);  Computes the gradient of the activation function. ;  ; static void IdentityDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Relu (Tensor_t &B);  ; static void ReluDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Sigmoid (Tensor_t &B);  ; static void SigmoidDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Tanh (Tensor_t &B);  ; static void TanhDerivative (Tensor_t &B, const Tensor_t &A);  ; static void FastTanh (Tensor_t &B);  ; static void FastTanhDerivative (Tensor_t &B, const Tensor_t &A);  ; static void SymmetricRelu (Tensor_t &B);  ; static void SymmetricReluDerivative (Tensor_t &B, const Tensor_t &A);  ; static void SoftSign (Tensor_t &B);  ; static void SoftSignDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Gauss (Tensor_t &B);  ; static void GaussDerivative (Tensor_t &B, const Tensor_t &A);  ; Loss Functions; Loss functions compute a scalar value given the output of the network for a given training input and the expected network prediction Y that quantifies the quality of the prediction.; For each function also a routing that computes the gradients (suffixed by Gradients) must be provided for the starting of the backpropagation algorithm. . static Scalar_t MeanSquaredError (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static void MeanSquaredErrorGradients (Matrix_t &dY, const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static Scalar_t CrossEntropy (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  Sigmoid t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpu.html:8574,predict,prediction,8574,doc/master/classTMVA_1_1DNN_1_1TCpu.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpu.html,2,['predict'],['prediction']
Safety,"x::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoBBox::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static TEveGeoPolyShape*Construct(TGeoCompositeShape* cshp, Int_t n_seg); virtual Bool_tTGeoBBox::Contains(const Double_t* point) const; static Bool_tTGeoBBox::Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTGeoBBox::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTGeoBBox::DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidTGeoBBox::DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tTGeoBBox::DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidTGeoBBox::DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveGeoPolyShape.html:2301,safe,safe,2301,root/html534/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html534/TEveGeoPolyShape.html,3,['safe'],['safe']
Safety,"xSystem()TUnixSystem; Umask(Int_t mask) overrideTUnixSystemvirtual; UnixFilestat(const char *path, FileStat_t &buf)TUnixSystemprotectedstatic; UnixFSstat(const char *path, Long_t *id, Long_t *bsize, Long_t *blocks, Long_t *bfree)TUnixSystemprotectedstatic; UnixGetdirentry(void *dir)TUnixSystemprotectedstatic; UnixHomedirectory(const char *user=nullptr)TUnixSystemprotectedstatic; UnixHomedirectory(const char *user, char *path, char *mydir)TUnixSystemprotectedstatic; UnixIgnoreSignal(ESignals sig, Bool_t ignore)TUnixSystemprotectedstatic; UnixMakedir(const char *name)TUnixSystemprotectedstatic; UnixNow()TUnixSystemprotectedstatic; UnixOpendir(const char *name)TUnixSystemprotectedstatic; UnixPathName(const char *unixpathname)TSystemvirtual; UnixRecv(int sock, void *buf, int len, int flag)TUnixSystemprotectedstatic; UnixResetSignal(ESignals sig)TUnixSystemprotectedstatic; UnixResetSignals()TUnixSystemprotectedstatic; UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout)TUnixSystemprotectedstatic; UnixSend(int sock, const void *buf, int len, int flag)TUnixSystemprotectedstatic; UnixSetitimer(Long_t ms)TUnixSystemprotectedstatic; UnixSigAlarmInterruptsSyscalls(Bool_t set)TUnixSystemprotectedstatic; UnixSignal(ESignals sig, SigHandler_t h)TUnixSystemprotectedstatic; UnixSigname(ESignals sig)TUnixSystemprotectedstatic; UnixTcpConnect(const char *hostname, int port, int tcpwindowsize)TUnixSystemprotectedstatic; UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize)TUnixSystemprotectedstatic; UnixUdpConnect(const char *hostname, int port)TUnixSystemprotectedstatic; UnixUdpService(int port, int backlog)TUnixSystemprotectedstatic; UnixUnixConnect(int port)TUnixSystemprotectedstatic; UnixUnixConnect(const char *path)TUnixSystemprotectedstatic; UnixUnixService(int port, int backlog)TUnixSystemprotectedstatic; UnixUnixService(const char *sockpath, int backlog)TUnixSystemprotectedstatic; UnixWaitchild()TUnixSystemprotectedstatic; Unlink(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem-members.html:18912,timeout,timeout,18912,doc/master/classTUnixSystem-members.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem-members.html,1,['timeout'],['timeout']
Safety,"xTcpService(int port, Bool_t reuse, int backlog,; 65 int tcpwindowsize);; 66 static int UnixUdpService(int port, int backlog);; 67 static int UnixUnixService(int port, int backlog);; 68 static int UnixUnixService(const char *sockpath, int backlog);; 69 static int UnixRecv(int sock, void *buf, int len, int flag);; 70 static int UnixSend(int sock, const void *buf, int len, int flag);; 71 ; 72public:; 73 TUnixSystem();; 74 virtual ~TUnixSystem();; 75 ; 76 //---- Misc -------------------------------------------------; 77 Bool_t Init() override;; 78 void SetProgname(const char *name) override;; 79 void SetDisplay() override;; 80 const char *GetError() override;; 81 Int_t GetCryptoRandom(void *buf, Int_t len) override;; 82 const char *HostName() override;; 83 ; 84 //---- EventLoop --------------------------------------------; 85 void DispatchOneEvent(Bool_t pendingOnly = kFALSE) override;; 86 Int_t Select(TList *active, Long_t timeout) override;; 87 Int_t Select(TFileHandler *fh, Long_t timeout) override;; 88 ; 89 //---- Handling of system events ----------------------------; 90 void CheckChilds();; 91 Bool_t CheckSignals(Bool_t sync);; 92 Bool_t CheckDescriptors();; 93 void DispatchSignals(ESignals sig);; 94 void AddSignalHandler(TSignalHandler *sh) override;; 95 TSignalHandler *RemoveSignalHandler(TSignalHandler *sh) override;; 96 void ResetSignal(ESignals sig, Bool_t reset = kTRUE) override;; 97 void ResetSignals() override;; 98 void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE) override;; 99 void SigAlarmInterruptsSyscalls(Bool_t set) override;; 100 void AddFileHandler(TFileHandler *fh) override;; 101 TFileHandler *RemoveFileHandler(TFileHandler *fh) override;; 102 ; 103 //---- Floating Point Exceptions Control --------------------; 104 Int_t GetFPEMask() override;; 105 Int_t SetFPEMask(Int_t mask = kDefaultMask) override;; 106 ; 107 //---- Time & Date ------------------------------------------; 108 TTime Now() override;; 109 void AddTimer(TTimer *ti) override;; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8h_source.html:3601,timeout,timeout,3601,doc/master/TUnixSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html,1,['timeout'],['timeout']
Safety,"xample ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ;  RadioNuclides.CMacro that demonstrates usage of radioactive elements/materials/mixtures with TGeo package ;  robot.CDrawing a famous Korean robot, TaekwonV, using ROOT geometry class ;  rootgeom.CDefinition of a simple geometry (the 4 ROOT characters) ;  runplugin.CCreates and runs a simple iterator plugin connected to TGeoPainter iterator ;  shapes.CThe old geometry shapes (see script geodemo.C) ;  shapesAnim.CMacro illustrating how to animate a geometry picture using a Timer ;  south_gate.CDrawing a famous Korean gate, the South gate, called Namdeamoon in Korean, using ROOT geometry class ;  station1.CDrawing a space station, using ROOT geometry class ;  station2.CDrawing a space station (version 2), using ROOT geometry class ;  tank.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:109714,detect,detector,109714,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,4,['detect'],['detector']
Safety,"xit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of statements like in the multi command line example given above, but also arbitrarily complex class and function definitions.; The most frequent interaction with the ROOT prompt uses .x to “run” a file:; root [] .x myScript.C; This loads myScript.C into the interpreter and calls the function myScript(). You can pass arguments using .x myScript.C(12, ""A String"").; Alternatively you can load the script and then run a function explicitly:; root [] .L myScript.C; root [] myScript(); The above is equivalent to .x myScript.C.; In a named script, the objects created on the stack are deleted when the function exits. In a common scenario you create a histogram in a named script on the stack. You draw the histogram, but when the function exits the canvas is empty and the histogram has disappeared. To avoid the histogram from disappearing you can create it on the heap (by using new). This will leave the histogram object intact, but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; In addition, histograms and trees are automatically deleted when the current directory is closed. This will automatically take care of the clean up. See “Input/Output”.; 7.2.1 Executing a Script From a Script; You may want to execute a script conditionally inside another script. To do it you need to call the interpreter and you can do that with TROOT::ProcessLine(). The example $ROOTSYS/tutorials/tree/cernstaff.C calls a script to build the root file if it does not exist:; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:264013,avoid,avoid,264013,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"xpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* masterSignalName = ""masterSignal""); static TClass*Class(); virtual TClass*IsA() const; RooStats::NumberCountingPdfFactoryNumberCountingPdfFactory(); RooStats::NumberCountingPdfFactoryNumberCountingPdfFactory(const RooStats::NumberCountingPdfFactory&); RooStats::NumberCountingPdfFactory&operator=(const RooStats::NumberCountingPdfFactory&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooRealVar*SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value); RooRealVar*SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value, Double_t maximum). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NumberCountingPdfFactory(); constructor. ~NumberCountingPdfFactory(); destructor. void AddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* masterSignalName = ""masterSignal""); This method produces a PDF for N channels with uncorrelated background; uncertainty. It relates the signal in each channel to a master signal strength times the; expected signal in each channel. For the future, perhaps this method should be extended to include the efficiency terms automatically. void AddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); Arguements are an array of expected signal, expected background, and relative; background uncertainty (eg. 0.1 for 10% uncertainty), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__NumberCountingPdfFactory.html:2510,Safe,SafeObservableCreation,2510,root/html602/RooStats__NumberCountingPdfFactory.html,https://root.cern,https://root.cern/root/html602/RooStats__NumberCountingPdfFactory.html,4,['Safe'],['SafeObservableCreation']
Safety,"xpression is evaluated once before the processing of the sample even starts, so column values are not accessible. ; Definition at line 796 of file RInterface.hxx. ◆ DefineSlot(). template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::DefineSlot ; (; std::string_view ; name, . F ; expression, . const ColumnNames_t & ; columns = {} . ). inline . Define a new column with a value dependent on the processing slot. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionFunction, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column. ; [in]columnsNames of the columns/branches in input to the producer function (excluding the slot number). . Returnsthe first node of the computation graph for which the new quantity is defined.; This alternative implementation of Define is meant as a helper to evaluate new column values in a thread-safe manner. The expression must be a callable of signature R(unsigned int, T1, T2, ...) where T1, T2... are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1.; The following two calls are equivalent, although DefineSlot is slightly more performant: int function(unsigned int, double, double);; df.Define(""x"", function, {""rdfslot_"", ""column1"", ""column2""}); df.DefineSlot(""x"", function, {""column1"", ""column2""}); See Define() for more information. ; Definition at line 470 of file RInterface.hxx. ◆ DefineSlotEntry(). template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::DefineSlotEntry ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:58577,safe,safe,58577,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['safe'],['safe']
Safety,"xtended unbinned maximum likelihood fits to use the asymptotically correct method when using the RooFit::AsymptoticError() command argument in RooAbsPdf::fitTo(). See also this writeup on extended weighted fits that is also linked from the reference guide. The pull request that introduced this feature might also be a good reference.; Compile your code with memory safe interfaces; If you define the ROOFIT_MEMORY_SAFE_INTERFACES preprocessor macro, the RooFit interface changes in a way such that memory leaks are avoided.; The most prominent effect of this change is that many functions that used to return an owning pointer (e.g., a pointer to an object that you need to manually delete) are then returning a std::unique_pt for automatic memory management.; For example this code would not compile anymore, because there is the risk that the caller forgets to delete params:; RooArgSet * params = pdf.getParameters(nullptr);; If you wrap such return values in a std::unique_ptr, then your code will compile both with and without memory safe interfaces:; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; Also some virtual RooFit functions like RooAbsReal::createIntegral() are returning a different type conditional on ROOFIT_MEMORY_SAFE_INTERFACES. If you are overriding such a function, you need to use the RooFit::OwningPtr return type, which is an alias for std::unique_ptr in memory-safe mode or an alias for a raw pointer otherwise.; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; The biggest application of the memory-safe interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:9865,safe,safe,9865,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['safe'],['safe']
Safety,"xx. ◆ FitLikelihood(). void TFumili::FitLikelihood ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Likelihood method. ; Basically, it forms the likelihood by determining the Poisson probability that given a number of entries in a particular bin, the fit would predict it's value. This is then done for each bin, and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin) for each point the cache contains the following info; 1D : bc,e,xc (bin content, error, x of center of bin); 2D : bc,e,xc,yc; 3D : bc,e,xc,yc,zc . Definition at line 1884 of file TFumili.cxx. ◆ FitLikelihoodI(). void TFumili::FitLikelihoodI ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Likelihood method. ; Basically, it forms the likelihood by determining the Poisson probability that given a number of entries in a particular bin, the fit would predict it's value. This is then done for each bin, and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used for each point the cache contains the following info; 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 2D : bc,e,xc,xw,yc,yw; 3D : bc,e,xc,xw,yc,yw,zc,zw . Definition at line 1972 of file TFumili.cxx. ◆ FixParameter(). void TFumili::FixParameter ; (; Int_t ; ipar). overridevirtual . Fixes parameter number ipar. ; Implements TVirtualFitter.; Definition at line 774 of file TFumili.cxx. ◆ GetCovarianceMatrix(). Double_t * TFumili::GetCovarianceMatrix ; (; ); const. overridevirtual . Return a pointer to the covariance matrix. ; Implements TVirtualFitter.; Definition at line 784 of file TFumili.cxx. ◆ GetCovarianceMatrixElement(). Double_t TFumili::GetCovarianceMatrixElement ; (; Int_t ; i, . Int_t ; j . ); const. overridevirtual . Return element i,j from the covarianc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:31633,predict,predict,31633,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,1,['predict'],['predict']
Safety,xx. ◆ GetAbsLast(). Int_t TObjArray::GetAbsLast ; (; ); const. protected . Return absolute index to last object in array. ; Returns -1 in case array is empty. ; Definition at line 539 of file TObjArray.cxx. ◆ GetEntries(). Int_t TObjArray::GetEntries ; (; ); const. overridevirtual . Return the number of objects in array (i.e. ; number of non-empty slots). Attention: use this method ONLY if you want to know the number of non-empty slots. This function loops over the complete array and is therefore very slow when applied in a loop. Most of the time you better use GetEntriesFast() (only in case when there are no empty slots). ; Reimplemented from TCollection.; Definition at line 523 of file TObjArray.cxx. ◆ GetEntriesFast(). Int_t TObjArray::GetEntriesFast ; (; ); const. inline . Definition at line 58 of file TObjArray.h. ◆ GetEntriesUnsafe(). Int_t TObjArray::GetEntriesUnsafe ; (; ); const. Return the number of objects in array (i.e. ; number of non-empty slots). This is a thread-unsafe version of GetEntriesFast. Use it only if sure it will not be invoked concurrently. ; Definition at line 565 of file TObjArray.cxx. ◆ GetLast(). Int_t TObjArray::GetLast ; (; ); const. overridevirtual . Return index of last object in array. ; Returns lowerBound-1 in case array is empty. ; Reimplemented from TSeqCollection.; Definition at line 577 of file TObjArray.cxx. ◆ GetObjectRef() [1/2]. TObject ** TObjArray::GetObjectRef ; (; ); const. inline . Definition at line 63 of file TObjArray.h. ◆ GetObjectRef() [2/2]. TObject ** TObjArray::GetObjectRef ; (; const TObject * ; obj); const. overridevirtual . Return address of pointer obj. If obj is 0 returns address of container. ; Implements TCollection.; Definition at line 587 of file TObjArray.cxx. ◆ IndexOf(). Int_t TObjArray::IndexOf ; (; const TObject * ; obj); const. overridevirtual . obj != 0 Return index of object in array. Returns lowerBound-1 in case array doesn't contain the obj.; obj == 0 Return the index of the first empty slot,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjArray.html:28179,unsafe,unsafe,28179,doc/master/classTObjArray.html,https://root.cern,https://root.cern/doc/master/classTObjArray.html,1,['unsafe'],['unsafe']
Safety,"y apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read correctly.; 332///; 333/// In case the name of the file is not reproducible either (in case of; 334/// creating tempora",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:13291,Recover,Recover,13291,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Recover'],['Recover']
Safety,"y calling TTree::SetAutoSave with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TRandom::RndmDouble_t Rndm() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:76294,safe,safer,76294,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['safe'],['safer']
Safety,"y constructor (and assignment) for a matrix with the same representation, or from a different one when possible, for example from a symmetric to a general matrix.; Constructor (and assignment) from a matrix expression, like D=A*B+C. Due to the expression template technique, no temporary objects are created in this operation. In the case of an operation like A=A*B+C, a temporary object is needed and it is created automatically to store the intermediary result in order to preserve the validity of this operation.; Constructor from a generic STL-like iterator copying the data referred by the iterator, following its order. It is both possible to specify the begin and end of the iterator or the begin and the size. In case of a symmetric matrix, it is required only the triangular block and the user can specify whether giving a block representing the lower (default case) or the upper diagonal part. Here are some examples on how to create a matrix. We use typedef’s in the following examples to avoid the full C++ names for the matrix classes. Notice that for a general matrix the representation has the default value, ROOT::Math::MatRepStd, and it is not needed to be specified. Furthermore, for a general square matrix, the number of column may be as well omitted.; // typedef definitions used in the following declarations; typedef ROOT::Math::SMatrix<double,3> SMatrix33;; typedef ROOT::Math::SMatrix<double,2> SMatrix22;; typedef ROOT::Math::SMatrix<double,3,3,; ROOT::Math::MatRepSym<double,3>> SMatrixSym3;; typedef ROOT::Math::SVector>double,2> SVector2;; typedef ROOT::Math::SVector>double,3> SVector3;; typedef ROOT::Math::SVector>double,6> SVector6;; SMatrix33 m0; // create a zero 3x3 matrix; // create an 3x3 identity matrix; SMatrix33 i = ROOT::Math::SMatrixIdentity();; double a[9] = {1,2,3,4,5,6,7,8,9}; // input matrix data; // create a matrix using the a[] data; SMatrix33 m(a,9); // this will produce the 3x3 matrix; // ( 1 2 3 ); // ( 4 5 6 ); // ( 7 8 9 ); Example to fill a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:755923,avoid,avoid,755923,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"y in the map; 610 {; 611 R__LOCKGUARD(gROOTMutex);; 612 ; 613 auto funcit = gClingFunctions.find(lambdaExpression);; 614 if (funcit != gClingFunctions.end() ) {; 615 fLambdaPtr = funcit->second;; 616 fClingInitialized = true;; 617 return true;; 618 }; 619 }; 620 ; 621 // to be sure the interpreter is initialized; 622 ROOT::GetROOT();; 623 R__ASSERT(gInterpreter);; 624 ; 625 // set the cling name using hash of the static formulae map; 626 auto hasher = gClingFunctions.hash_function();; 627 TString lambdaName = TString::Format(""lambda__id%zu"", hasher(lambdaExpression) );; 628 ; 629 //lambdaExpression = TString::Format(""[&](double * x, double *){ return %s ;}"",formula);; 630 //TString lambdaName = TString::Format(""mylambda_%s"",GetName() );; 631 TString lineExpr = TString::Format(""std::function<double(double*,double*)> %s = %s ;"",lambdaName.Data(), lambdaExpression.c_str() );; 632 gInterpreter->ProcessLine(lineExpr);; 633 fLambdaPtr = (void*) gInterpreter->ProcessLine(TString(lambdaName)+TString("";"")); // add ; to avoid printing; 634 if (fLambdaPtr != nullptr) {; 635 R__LOCKGUARD(gROOTMutex);; 636 gClingFunctions.insert ( std::make_pair ( lambdaExpression, fLambdaPtr) );; 637 fClingInitialized = true;; 638 return true;; 639 }; 640 fClingInitialized = false;; 641 return false;; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Compile the given expression with Cling; 646/// backward compatibility method to be used in combination with the empty constructor; 647/// if no expression is given , the current stored formula (retrieved with GetExpFormula()) or the title is used.; 648/// return 0 if the formula compilation is successful; 649 ; 650Int_t TFormula::Compile(const char *expression); 651{; 652 TString formula = expression;; 653 if (formula.IsNull() ) {; 654 formula = fFormula;; 655 if (formula.IsNull() ) formula = GetTitle();; 656 }; 657 ; 658 if (formula.IsNull() ) return -1;; 659 ; 660 // do not re-process if it wa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:23541,avoid,avoid,23541,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['avoid'],['avoid']
Safety,"y name; model.plotOn(xframe2, Components=""bkg1,sig2"", LineStyle="":"", LineColor=""c""); ; # Plot multiple background components specified by regular expression on; # name; model.plotOn(xframe2, Components=""sig*"", LineStyle=""--"", LineColor=""c""); ; # Plot multiple background components specified by multiple regular; # expressions on name; model.plotOn(xframe2, Invisible=True, Components=""bkg1,sig*"", LineStyle=""--"", LineColor=""y""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf205_compplot"", ""rf205_compplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.4); xframe2.Draw(); ; c.SaveAs(""rf205_compplot.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2,sig); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg1,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf205__compplot_8py.html:4334,safe,safe,4334,doc/master/rf205__compplot_8py.html,https://root.cern,https://root.cern/doc/master/rf205__compplot_8py.html,1,['safe'],['safe']
Safety,"y of Float_t to buffer. ;  ; void WriteFastArray (const Int_t *i, Long64_t n) final;  Write array of Int_t to buffer. ;  ; void WriteFastArray (const Long64_t *l, Long64_t n) final;  Write array of Long64_t to buffer. ;  ; void WriteFastArray (const Long_t *l, Long64_t n) final;  Write array of Long_t to buffer. ;  ; void WriteFastArray (const Short_t *h, Long64_t n) final;  Write array of Short_t to buffer. ;  ; void WriteFastArray (const UChar_t *c, Long64_t n) final;  Write array of UChar_t to buffer. ;  ; void WriteFastArray (const UInt_t *i, Long64_t n) final;  Write array of UInt_t to buffer. ;  ; void WriteFastArray (const ULong64_t *l, Long64_t n) final;  Write array of ULong64_t to buffer. ;  ; void WriteFastArray (const ULong_t *l, Long64_t n) final;  Write array of ULong_t to buffer. ;  ; void WriteFastArray (const UShort_t *h, Long64_t n) final;  Write array of UShort_t to buffer. ;  ; Int_t WriteFastArray (void **startp, const TClass *cl, Long64_t n=1, Bool_t isPreAlloc=kFALSE, TMemberStreamer *s=nullptr) final;  Recall TBuffer function to avoid gcc warning message. ;  ; void WriteFastArray (void *start, const TClass *cl, Long64_t n=1, TMemberStreamer *s=nullptr) final;  Recall TBuffer function to avoid gcc warning message. ;  ; void WriteFastArrayString (const Char_t *c, Long64_t n) final;  Write array of Char_t to buffer. ;  ; void WriteFloat (Float_t f) final;  Writes Float_t value to buffer. ;  ; void WriteInt (Int_t i) final;  Writes Int_t value to buffer. ;  ; void WriteLong (Long_t l) final;  Writes Long_t value to buffer. ;  ; void WriteLong64 (Long64_t l) final;  Writes Long64_t value to buffer. ;  ; void WriteShort (Short_t s) final;  Writes Short_t value to buffer. ;  ; void WriteStdString (const std::string *s) final;  Writes a std::string. ;  ; virtual void WriteStdString (const std::string *s)=0;  ; virtual void WriteStdString (std::string &s);  ; void WriteTString (const TString &s) final;  Writes a TString. ;  ; void WriteUChar (UChar_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:17577,avoid,avoid,17577,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['avoid'],['avoid']
Safety,"y to do this would be to create as many different volumes and shapes. The modeller allows however the definition of a single volume having undefined shape parameters.; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);. name: the name of the newly created volume;; shape:the type of the associated shape. This has to contain the case-insensitive first 4 letters of the corresponding class name (e.g. “tubs” will match TGeoTubeSeg, “bbox” will match TGeoBBox); nmed: the medium number. This will create a special volume that will not be directly used in the geometry, but whenever positioned will require a list of actual parameters for the current shape that will be created in this process. Such volumes having shape parameters known only when used have to be positioned only with TGeoManager::Node() method (see ‘Creating and Positioning Volumes’).; Other case when shape parameterizations are quite useful is scaling geometry structures. Imagine that we would like to enlarge/shrink a detector structure on one or more axes. This happens quite often in real life and is handled by “fitting mother” parameters. This is accomplished by defining shapes with one or more invalid (negative) parameters. For instance, defining a box having dx=10., dy=10., and dz=-1 will not generate an error but will be interpreted in a different way: A special volume TGeoVolumeMulti will be created. Whenever positioned inside a mother volume, this will create a normal TGeoVolume object having as shape a box with dz fitting the corresponding dzof the mother shape. Generally, this type of parameterization is used when positioning volumes in containers having a matching shape, but it works also for most reasonable combinations.; 18.4 Geometry Creation; A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, here are few general rules:. Volumes need media and shapes in order to be created.; Both c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:927220,detect,detector,927220,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety,"y track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Gdopt(const char* , const char* ). Geant3 specific methods; !!! to be removed with move to TGeo. Set/modify the drawing options.; Deprecated - G3 only. void SetClipBox(const char* , Double_t = -9999, Double_t = 0, Double_t = -9999, Double_t = 0, Double_t = -9999, Double_t = 0); This function allows subtractions (via boolean operation) of BOX shape; from any part of the detector, therefore showing its inner contents; Deprecated - G3 only. void Gdhead(Int_t , const char* , Double_t = 0); Deprecated - G3 only; Deprecated - G3 only. void Gdman(Double_t , Double_t , const char* ); Deprecated - G3 only. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void InitLego(); Set switches for lego transport. TVirtualMCStack* GetStack() const. Get methods. Return the particle stack. { return fStack; }. TVirtualMCDecayer* GetDecayer() const; Return the external decayer. { return fDecayer; }. TRandom* GetRandom() const; Return the random number generator. { return fRandom; }. TVirtualMagField* GetMagField() const; Return the magnetic field. { return fMagField; }. TVirtualMC & operator=(const TVirtualMC& ). » Last changed: root/vmc:$Name: $:$Id: TVirtualMC.h 34836 2010-08-18 09:52:27Z ivana $ » Last generated: 2010-11-10 17:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:37162,abort,aborted,37162,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,1,['abort'],['aborted']
Safety,"y() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCtub.html:2687,safe,safe,2687,root/html528/TGeoCtub.html,https://root.cern,https://root.cern/root/html528/TGeoCtub.html,1,['safe'],['safe']
Safety,"y(y); model = ROOT.RooProdPdf(""model"", ""gaussx(x|y)*gaussy(y)"", {gaussy}, Conditional=({gaussx}, {x})); ; # Sample, fit and plot product pdf; # ---------------------------------------------------------------; ; # Generate 1000 events in x and y from model; data = model.generate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, ROOT.RooFit.Binning(50), ROOT.RooFit.YVar(y, ROOT.RooFit.Binning(50))); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf305_condcorrprod"", ""rf05_condcorrprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.6); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf305_condcorrprod.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf305_condcorrprod.py. tutorialsroofitrf305_condcorrprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf305__condcorrprod_8py.html:2631,safe,safe,2631,doc/master/rf305__condcorrprod_8py.html,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8py.html,1,['safe'],['safe']
Safety,"y); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTubeSeg.html:15318,safe,safe,15318,root/html528/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html,3,['safe'],['safe']
Safety,"y, Double_t dz);  ;  TGeoTrd1 (Double_t *params);  ;  TGeoTrd1 (Double_t dx1, Double_t dx2, Double_t dy, Double_t dz);  ;  ~TGeoTrd1 () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetDx1 () const;  ; Double_t GetDx2 () const;  ; Double_t GetDy () const;  ; Double_t GetDz () const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetOppositeCorner (const Double_t *point, Int_t inorm, Double_t *vertex, Double_t *normals) const;  ; void GetVisibleCorner (const Double_t *point, Double_t *vertex, Double_t *normal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:1452,safe,safe,1452,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['safe'],['safe']
Safety,"y, Double_t tz);; 186 TGeoCtub(Double_t *params);; 187 // destructor; 188 ~TGeoCtub() override;; 189 // methods; 190 Double_t Capacity() const override;; 191 void ComputeBBox() override;; 192 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 193 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 194 Bool_t Contains(const Double_t *point) const override;; 195 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 196 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 197 Double_t *safe = nullptr) const override;; 198 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 199 Double_t *step) const override;; 200 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 201 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 202 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 203 Double_t *step) const override;; 204 TGeoVolume *; 205 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 206 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 207 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 208 Int_t GetByteCount() const override { return 98; }; 209 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 210 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 211 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 212 Int_t GetNmeshVertices() const override;; 213 const Double_t *GetNlow() const { return &fNlow[0]; }; 214 const Double_t *GetNhigh() const { return &fNhigh[0]; }; 215 Double_t GetZcoord(Double_t xc, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:11021,safe,safe,11021,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety,"y. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the volume specified by; the volumeName. void DrawOneSpec(const char* name); Return the medium parameters for the volume specified by the; volumeName. functions for drawing; to be removed with complete move to TGeo. Deprecated - Geant3. void Gsatt(const char* name, const char* att, Int_t val); Deprecated - Geant3. void Gdraw(const char* , Double_t theta = 30, Double_t phi = 30, Double_t psi = 0, Double_t u0 = 10, Double_t v0 = 10, Double_t ul = 0.01, Double_t vl = 0.01); Deprecated - Geant3. void SetRootGeometry(); Write out the geometry of the detector in EUCLID file format; filnam file name - will be with the extension .euc *; topvol volume name of the starting node; number copy number of topvol (relevant for gsposp); nlevel number of levels in the tree structure; to be written out, starting from topvol; (Geant3 only); Set geometry from Root (built via TGeo). void SetUserParameters(Bool_t isUserParameters); Activate the parameters defined in tracking media; (DEEMAX, STMIN, STEMAX), which are, be default, ignored.; In Geant4 case, only STEMAX is taken into account.; In FLUKA, all tracking media parameters are ignored. Int_t VolId(const char* volName) const. get methods. Return the unique numeric identifier for volume name volName. const char* VolName(Int_t id) const; Return the volume name for a given volume identifier id. Int_t MediumId(const char* mediumName) const; Return the unique numeric identifier for medium name mediumName. Int_t NofVolumes() const; Return total number of volumes in the geometry. Int_t VolId2Mate(Int_t id) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:26406,detect,detector,26406,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,1,['detect'],['detector']
Safety,"y. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:14502,safe,safety,14502,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,6,['safe'],['safety']
Safety,"y. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUDPSocket.html:13149,timeout,timeout,13149,root/html532/TUDPSocket.html,https://root.cern,https://root.cern/root/html532/TUDPSocket.html,1,['timeout'],['timeout']
Safety,"y2, UInt_t col, UInt_t thick);  Internal line drawing. ;  ; void DrawTextTTF (Int_t x, Int_t y, const char *text, Int_t size, UInt_t color, const char *font_name, Float_t angle);  Draw text using TrueType fonts. ;  ; void DrawVLine (UInt_t x, UInt_t y1, UInt_t y2, UInt_t col, UInt_t thick);  Draw a vertical line. ;  ; void DrawWideLine (UInt_t x1, UInt_t y1, UInt_t x2, UInt_t y2, UInt_t col, UInt_t thick);  Draw wide line. ;  ; void FillRectangleInternal (UInt_t col, Int_t x, Int_t y, UInt_t width, UInt_t height);  Fill rectangle of size (width, height) at position (x,y) within the existing image with specified color. ;  ; void GetFillAreaSpans (UInt_t npt, TPoint *ppt, UInt_t *nspans, TPoint **firstPoint, UInt_t **firstWidth);  ; Bool_t GetPolygonSpans (UInt_t npt, TPoint *ppt, UInt_t *nspans, TPoint **firstPoint, UInt_t **firstWidth);  The code is based on Xserver/mi/mipolycon.c ""Copyright 1987, 1998 The Open Group"". ;  ; Int_t Idx (Int_t idx);  Return a valid index in fImage tables to avoid seg-fault by accessing out of indices out of array's ranges. ;  ; void SetDefaults ();  Set default parameters. ;  ; const char * TypeFromMagicNumber (const char *file);  Guess the file type from the first byte of file. ;  . Additional Inherited Members;  Public Types inherited from TImage; enum  ECharType { kUTF8 = 0; , kChar = 1; , kUnicode = 4; };  ; enum  EColorChan { ;   kRedChan = (1ULL << ( 0 )); , kGreenChan = (1ULL << ( 1 )); , kBlueChan = (1ULL << ( 2 )); , kAlphaChan = (1ULL << ( 3 )); , ;   kAllChan = kRedChan | kGreenChan | kBlueChan | kAlphaChan. };  ; enum  ECoordMode { kCoordModeOrigin = 0; , kCoordModePrevious; };  ; enum  EImageFileTypes { ;   kXpm = 0; , kZCompressedXpm; , kGZCompressedXpm; , kPng; , ;   kJpeg; , kXcf; , kPpm; , kPnm; , ;   kBmp; , kIco; , kCur; , kGif; , ;   kTiff; , kXbm; , kFits; , kTga; , ;   kXml; , kUnknown; , kAnimGif. };  ; enum  EText3DType { ;   kPlain = 0; , kEmbossed; , kSunken; , kShadeAbove; , ;   kShadeBelow; , kEmbossedThick; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:31223,avoid,avoid,31223,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['avoid'],['avoid']
Safety,"y::operator=(const TDirectory &)=deleteTDirectoryprotected; TNamed::operator=(const TNamed &rhs)TNamed; TObject::operator=(const TObject &rhs)TObjectinline; Paint(Option_t *option="""") overrideTFilevirtual; Pop()TObjectvirtual; Print(Option_t *option="""") const overrideTFilevirtual; Purge(Short_t nkeep=1) overrideTDirectoryFilevirtual; pwd() constTDirectoryvirtual; Read(const char *name)TObjectvirtual; ReadAll(Option_t *option="""") overrideTDirectoryFilevirtual; ReadBuffer(char *buf, Int_t len)TFilevirtual; ReadBuffer(char *buf, Long64_t pos, Int_t len)TFilevirtual; ReadBufferAsync(Long64_t offs, Int_t len)TFilevirtual; ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf)TFilevirtual; ReadBufferViaCache(char *buf, Int_t len)TFileprotected; ReadFree()TFilevirtual; ReadKeys(Bool_t forceRead=kTRUE) overrideTDirectoryFilevirtual; ReadProcessID(UShort_t pidf)TFilevirtual; ReadStreamerInfo()TFilevirtual; ReadTObject(TObject *obj, const char *keyname) overrideTDirectoryFilevirtual; Recover()TFilevirtual; RecursiveRemove(TObject *obj) overrideTDirectoryvirtual; RegisterContext(TContext *ctxt)TDirectoryprotected; RegisterGDirectory(SharedGDirectory_t &ptr)TDirectoryprotected; Remove(TObject *)TDirectoryvirtual; ReOpen(Option_t *mode)TFilevirtual; ResetAfterMerge(TFileMergeInfo *)TDirectoryFilevirtual; ResetBit(UInt_t f)TObjectinline; ResetErrno() constTFilevirtual; rmdir(const char *name) overrideTDirectoryFilevirtual; Save() overrideTDirectoryFilevirtual; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SaveObjectAs(const TObject *obj, const char *filename="""", Option_t *option="""") const overrideTDirectoryFilevirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; SaveSelf(Bool_t force=kFALSE) overrideTDirectoryFilevirtual; Seek(Long64_t offset, ERelativeTo pos=kBeg)TFilevirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetBufferSize(Int_t bufsize) overrideTDirectoryFilevirtual; SetCacheFileDir(s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile-members.html:15765,Recover,Recover,15765,doc/master/classTFile-members.html,https://root.cern,https://root.cern/doc/master/classTFile-members.html,1,['Recover'],['Recover']
Safety,"y=true) constUse RooAbsCollection::snapshot(), but return as RooArgSet.Definition RooArgSet.h:154; RooArgSet::selectByNameRooArgSet * selectByName(const char *nameList, bool verbose=false) constUse RooAbsCollection::selectByName(), but return as RooArgSet.Definition RooArgSet.h:144; RooArgSet::selectCommonRooArgSet * selectCommon(const RooAbsCollection &refColl) constUse RooAbsCollection::selecCommon(), but return as RooArgSet.Definition RooArgSet.h:149; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::cloneTObject * clone(const char *newname) const overrideDefinition RooRealVar.h:48; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf508_listsetmanipDefinition rf508_listsetmanip.py:1; lTLine lDefinition textangle.C:4; ; [#0] WARNING:InputArguments -- The parameter 'b' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; sclone = (a,b,c,d,e,g); RooArgSet::sclone = (a,b,c,d,e,g); 1) RooRealVar:: a = 1; 2) RooRealVar:: b = 2; 3) RooRealVar:: c = 3 +/- 0.5; 4) RooRealVar:: d = 4; 5) RooCategory:: e = sig(idx = 0); ; 6) RooGaussian:: g = 0.882497; 1) 0x5569466c3940 RooRealVar:: a = 1 C L(-10 - 10) ""a""; 2) 0x556948df5f70 RooRealVar:: b = 2 C L(-10 - 10) ""b""; 3) 0x556946cacdc0 RooRealVar:: c = 3 +/- 0.5 L(-10 - 10) ""c""; 4) 0x5569492af150 RooRealVar:: d = 4 L(-10 - 10) ""d""; 5) 0x5569468860e0 RooCategory:: e = sig(idx = 0); ""e""; 6) 0x5569458db0b0 RooGaussian:: g[ x=x mean=a sigma=b ] = 0.882497 ""g""; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf508_listsetmanip.C. tutorialsroofitrf508_listsetmanip.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf508__listsetmanip_8C.html:7253,safe,safe,7253,doc/master/rf508__listsetmanip_8C.html,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html,1,['safe'],['safe']
Safety,"yFilePath(const char *fname); 563{; 564 if (!fname || (*fname == 0)); 565 return kFALSE;; 566 ; 567 Int_t level = 0;; 568 ; 569 while (*fname) {; 570 ; 571 // find next slash or backslash; 572 const char *next = strpbrk(fname, ""/\\"");; 573 if (next == 0); 574 return kTRUE;; 575 ; 576 // most important - change to parent dir; 577 if ((next == fname + 2) && (*fname == '.') && (*(fname + 1) == '.')) {; 578 fname += 3;; 579 level--;; 580 if (level < 0); 581 return kFALSE;; 582 continue;; 583 }; 584 ; 585 // ignore current directory; 586 if ((next == fname + 1) && (*fname == '.')) {; 587 fname += 2;; 588 continue;; 589 }; 590 ; 591 // ignore slash at the front; 592 if (next == fname) {; 593 fname++;; 594 continue;; 595 }; 596 ; 597 fname = next + 1;; 598 level++;; 599 }; 600 ; 601 return kTRUE;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// Verifies that request is just file name; 606///; 607/// File names typically contains prefix like ""jsrootsys/""; 608/// If true, method returns real name of the file,; 609/// which should be delivered to the client; 610/// Method is thread safe and can be called from any thread; 611 ; 612Bool_t THttpServer::IsFileRequested(const char *uri, TString &res) const; 613{; 614 if (!uri || (*uri == 0)); 615 return kFALSE;; 616 ; 617 TString fname(uri);; 618 ; 619 for (auto &entry : fLocations) {; 620 Ssiz_t pos = fname.Index(entry.first.c_str());; 621 if (pos == kNPOS); 622 continue;; 623 fname.Remove(0, pos + (entry.first.length() - 1));; 624 if (!VerifyFilePath(fname.Data())); 625 return kFALSE;; 626 res = entry.second.c_str();; 627 if ((fname[0] == '/') && (res[res.Length() - 1] == '/')); 628 res.Resize(res.Length() - 1);; 629 res.Append(fname);; 630 return kTRUE;; 631 }; 632 ; 633 return kFALSE;; 634}; 635 ; 636////////////////////////////////////////////////////////////////////////////////; 637/// Executes http request, specified in THttpCallArg structure; 638///; 639/// Method can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:19510,safe,safe,19510,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['safe'],['safe']
Safety,"yLegacyIterator ; Legacy class to iterate through legacy RooAbsCategory states. Use RooAbsCategory::begin(), RooAbsCategory::end() or range-based for loops instead. Member RooAbsData::statOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}); Classing parameter formatting options, provided for backward compatibility ; Member RooCategoryProxy ; Use RooTemplateProxy<RooAbsCategory> or more appropriate template parameters. ; Member RooDataHist::binVolume () const; Use binVolume(std::size_t) const. ; Member RooDataHist::calcTreeIndex () const; Use calcTreeIndex(const RooArgSet&,bool) const. ; Member RooDataHist::set (double wgt, double wgtErr=-1); Use set(std::size_t,double,double) ; Member RooDataHist::weight () const override; Use the safer weight(std::size_t) const. ; Member RooDataHist::weightSquared () const override; Use the safer weightSquared(std::size_t) const. ; Member RooRealProxy ; Use RooTemplateProxy<RooAbsReal> or more appropriate template parameters. ; Member RooStats::HistFactory::FitModel (RooWorkspace *, std::string data_name=""obsData"") R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FitModelAndPlot (const std::string &measurementName, const std::string &fileNamePrefix, RooWorkspace &, std::string, std::string, TFile &, std::ostream &) R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FormatFrameForLikelihood (RooPlot *frame, std::string xTitle=std::string(""#sigma / #sigma_{SM}""), std::string yTitle=std::string(""-log likelihood"")) R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::Measurement::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/deprecated.html:3226,safe,safer,3226,doc/master/deprecated.html,https://root.cern,https://root.cern/doc/master/deprecated.html,1,['safe'],['safer']
Safety,"yObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupPySelf(); Install the python side identity of the TPySelector. PyObject* CallSelf(const char* method, PyObject* pyobject = 0); Forward <method> to python. TPySelector(TTree* = 0, PyObject* self = 0); Construct a TSelector derived with <self> as the underlying, which is; generally 0 to start out with in the current PROOF framework. ~TPySelector(); Destructor. Only deref if still holding on to Py_None (circular otherwise). Int_t Version() const; Return version number of this selector. First forward; if not overridden, then; yield an obvious ""undefined"" number,. Int_t GetEntry(Long64_t entry, Int_t getall = 0); Boilerplate get entry; same as for generated code; not forwarded. void Init(TTree* tree); Initialize with the current tree to be used; not forwarded (may be called; multiple times, and is called from Begin() and SlaveBegin() ). Bool_t Notify(); Forward call to derived Notify() if available. void Begin(TTree* tree = 0); First function called, and used to setup the python self; forward call. void SlaveBegin(TTree* tree); First function called on worker node, needs to make sure python self is setup,; then store the tree to be used, initialize client, and forward call. Bool_t Process(Long64_t entry); Actual processing; call is forwarded to python self. void SlaveTerminate(); End of client; call is forwarded to python self. void Terminate(); End of job; call is forwarded to python self. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); If no 'why' given, read from python error. TPySelector(TTree* = 0, PyObject* self = 0); ctor/dtor ... cctor and assignment are private in base class. » Last changed: Tue Jun 30 15:28:43 2015 » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPySelector.html:10075,Abort,Abort,10075,root/html602/TPySelector.html,https://root.cern,https://root.cern/root/html602/TPySelector.html,1,['Abort'],['Abort']
Safety,"yReference ; (; Int_t ; icheck = -1). pure virtual . Implemented in TGeoPainter, and ROOT::RGeoPainter. ◆ CheckGeometry(). virtual void TVirtualGeoPainter::CheckGeometry ; (; Int_t ; nrays, . Double_t ; startx, . Double_t ; starty, . Double_t ; startz . ); const. pure virtual . Implemented in TGeoPainter, and ROOT::RGeoPainter. ◆ CheckGeometryFull(). virtual void TVirtualGeoPainter::CheckGeometryFull ; (; Bool_t ; checkoverlaps = kTRUE, . Bool_t ; checkcrossings = kTRUE, . Int_t ; nrays = 10000, . const Double_t * ; vertex = nullptr . ). pure virtual . Implemented in TGeoPainter, and ROOT::RGeoPainter. ◆ CheckOverlaps(). virtual void TVirtualGeoPainter::CheckOverlaps ; (; const TGeoVolume * ; vol, . Double_t ; ovlp = 0.1, . Option_t * ; option = """" . ); const. pure virtual . Implemented in ROOT::RGeoPainter, and TGeoPainter. ◆ CheckPoint(). virtual void TVirtualGeoPainter::CheckPoint ; (; Double_t ; x = 0, . Double_t ; y = 0, . Double_t ; z = 0, . Option_t * ; option = """", . Double_t ; safety = 0. . ). pure virtual . Implemented in TGeoPainter, and ROOT::RGeoPainter. ◆ CheckShape(). virtual void TVirtualGeoPainter::CheckShape ; (; TGeoShape * ; shape, . Int_t ; testNo, . Int_t ; nsamples, . Option_t * ; option . ). pure virtual . Implemented in ROOT::RGeoPainter, and TGeoPainter. ◆ Class(). static TClass * TVirtualGeoPainter::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TVirtualGeoPainter::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TVirtualGeoPainter::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 143 of file TVirtualGeoPainter.h. ◆ CountVisibleNodes(). virtual Int_t TVirtualGeoPainter::CountVisibleNodes ; (; ). pure virtual . Implemented in TGeoPainter, and ROOT::RGeoPainter. ◆ DeclFileName(). static const char * TVirtualGeoPainter::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualGeoPainter.html:19355,safe,safety,19355,doc/master/classTVirtualGeoPainter.html,https://root.cern,https://root.cern/doc/master/classTVirtualGeoPainter.html,1,['safe'],['safety']
Safety,"yResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVirtualProofPlayer(); TVirtualProofPlayer(const TVirtualProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualProofPlayer.html:10051,abort,abort,10051,root/html602/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualProofPlayer.html,1,['abort'],['abort']
Safety,"ydir);; 1495 if (res) return std::string(res);; 1496 else return std::string();; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// Return a user configured or systemwide directory to create; 1501/// temporary files in.; 1502 ; 1503const char *TUnixSystem::TempDirectory() const; 1504{; 1505 const char *dir = gSystem->Getenv(""TMPDIR"");; 1506 if (!dir || gSystem->AccessPathName(dir, kWritePermission)); 1507 dir = ""/tmp"";; 1508 ; 1509 return dir;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Create a secure temporary file by appending a unique; 1514/// 6 letter string to base. The file will be created in; 1515/// a standard (system) directory or in the directory; 1516/// provided in dir. Optionally one can provide suffix; 1517/// append to the final name - like extension "".txt"" or "".html"".; 1518/// The full filename is returned in base; 1519/// and a filepointer is returned for safely writing to the file; 1520/// (this avoids certain security problems). Returns 0 in case; 1521/// of error.; 1522 ; 1523FILE *TUnixSystem::TempFileName(TString &base, const char *dir, const char *suffix); 1524{; 1525 char *b = ConcatFileName(dir ? dir : TempDirectory(), base);; 1526 base = b;; 1527 base += ""XXXXXX"";; 1528 const bool hasSuffix = suffix && *suffix;; 1529 if (hasSuffix); 1530 base.Append(suffix);; 1531 delete [] b;; 1532 ; 1533 char *arg = StrDup(base);; 1534 int fd = hasSuffix ? mkstemps(arg, strlen(suffix)) : mkstemp(arg);; 1535 base = arg;; 1536 delete [] arg;; 1537 ; 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:46407,safe,safely,46407,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"yer. ◆ SetExitStatus(). virtual void TVirtualProofPlayer::SetExitStatus ; (; EExitStatus ; ). pure virtual . Implemented in TProofPlayer. ◆ SetInitTime(). virtual void TVirtualProofPlayer::SetInitTime ; (; ). pure virtual . Implemented in TProofPlayer, and TProofPlayerRemote. ◆ SetMaxDrawQueries(). virtual void TVirtualProofPlayer::SetMaxDrawQueries ; (; Int_t ; max). pure virtual . Implemented in TProofPlayer. ◆ SetMerging(). virtual void TVirtualProofPlayer::SetMerging ; (; Bool_t ; on = kTRUE). pure virtual . Implemented in TProofPlayerRemote, and TProofPlayer. ◆ SetOutputFilePath(). virtual void TVirtualProofPlayer::SetOutputFilePath ; (; const char * ; fp). pure virtual . Implemented in TProofPlayer. ◆ SetStopTimer(). virtual void TVirtualProofPlayer::SetStopTimer ; (; Bool_t ; on = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). pure virtual . Implemented in TProofPlayer. ◆ StopProcess(). virtual void TVirtualProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). pure virtual . Implemented in TProofPlayer, and TProofPlayerRemote. ◆ StoreFeedback(). virtual void TVirtualProofPlayer::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). pure virtual . Implemented in TProofPlayer, TProofPlayerRemote, and TProofPlayerLite. ◆ StoreOutput(). virtual void TVirtualProofPlayer::StoreOutput ; (; TList * ; out). pure virtual . Implemented in TProofPlayer, and TProofPlayerRemote. ◆ Streamer(). void TVirtualProofPlayer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TVirtualProofPlayer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 142 of file TVirtualProofPlayer.h. ◆ UpdateAutoBin(). virtual void TVirtualProofPlayer::UpdateAutoBin ; (; const char * ; name, . Double_t & ; xmin, . Double_t & ; xmax, . Double_t & ; ymin, . Double_t & ; ymax, . Double_t & ; zmin, . Double_t & ; zmax . ). pure virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualProofPlayer.html:29380,timeout,timeout,29380,doc/master/classTVirtualProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTVirtualProofPlayer.html,1,['timeout'],['timeout']
Safety,"yer::ReinitSelector(TQueryResult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerLite.html:10652,abort,abort,10652,root/html530/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html530/TProofPlayerLite.html,8,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"yer_t >::Loss ; (; const Matrix_t & ; Y, . const Matrix_t & ; weights, . bool ; includeRegularization = true . ); const. inline . Evaluate the loss function of the net using the activations that are currently stored in the output layer. ; Definition at line 305 of file Net.h. ◆ Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TNet< Architecture_t, Layer_t >::Loss ; (; Matrix_t & ; X, . const Matrix_t & ; Y, . const Matrix_t & ; weights, . bool ; applyDropout = false, . bool ; includeRegularization = true . ). inline . Propagate the input batch X through the net and evaluate the error function for the resulting activations of the output layer. ; Definition at line 320 of file Net.h. ◆ Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; Y_hat, . EOutputFunction ; f . ); const. inline . Compute the neural network prediction obtained from applying the output function f to the activation of the last layer in the network. ; Definition at line 339 of file Net.h. ◆ Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; Y_hat, . Matrix_t & ; X, . EOutputFunction ; f . ). inline . Compute the neural network prediction obtained from forwarding the batch X through the neural network and applying the output function f to the activation of the last layer in the network. ; Definition at line 329 of file Net.h. ◆ Print(). template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Print. Definition at line 392 of file Net.h. ◆ SetBatchSize(). template<typename Architecture_t , typename Layer_t = TLayer<Architecture_t>> . void TMVA::DNN::TNet< Architecture_t, Layer_t >::SetBatchSize ; (; size_t ; batchSize). inline . Definition at line 148 of file Net.h. ◆ SetDropoutProbabilities(). template<typename Archi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html:13945,predict,prediction,13945,doc/master/classTMVA_1_1DNN_1_1TNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html,1,['predict'],['prediction']
Safety,"ying minimum and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(Double_t* point, Double_t* dir) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, acco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoParaboloid.html:13197,safe,safe,13197,root/html528/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html528/TGeoParaboloid.html,2,['safe'],['safe']
Safety,"yle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf502_wspacewriteDefinition rf502_wspacewrite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf502__wspacewrite_8C.html:3944,safe,safe,3944,doc/master/rf502__wspacewrite_8C.html,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8C.html,1,['safe'],['safe']
Safety,"you build a class that you want to use in the ROOT environment, you use rootcling that builds the so-called stub functions and the dictionary. These functions and the dictionary contain the knowledge of the used classes. To do this, rootcling parses all the header files. ROOT has defined some special syntax to inform Cling of certain things, this is done in the comments so that the code still compiles with a C++ compiler.; For example, you have a class with a Draw() method, which will display itself. You would like a context menu to appear when on clicks on the image of an object of this class. The recipe is the following:. The class has to contain the ClassDef/ClassImp macros; For each method you want to appear in the context menu, put a comment after the declaration containing *MENU* or *TOGGLE* depending on the behavior you expect. One usually uses Set methods (setters). The *TOGGLE* comment is used to toggle a boolean data field. In that case, it is safe to call the data field fMyBool where MyBool is the name of the setter SetMyBool. Replace MyBool with your own boolean variable.; You can specify arguments and the data members in which to store the arguments. For example:; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; To specify arguments:; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; This statement is in the comment field, after the *MENU*. If there is more than one argument, these arguments are separated by commas, where fX1 and fY2 are data fields in the same class.; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; If the arguments statement is present, the option dialog displayed when selecting SetXXX field will show the values of vari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:297102,safe,safe,297102,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"ysical file representation (fD) if the data is in this TFile's cache. ; Reimplemented from TFile.; Definition at line 238 of file TSQLFile.h. ◆ ReadConfigurations(). Bool_t TSQLFile::ReadConfigurations ; (; ). protected . read table configurations as special table ; Definition at line 1054 of file TSQLFile.cxx. ◆ ReadFree(). void TSQLFile::ReadFree ; (; ). inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84383,Recover,Recover,84383,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['Recover'],['Recover']
Safety,"ystem::GetWorkingDirectory() const; 880{; 881 return std::string();; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Return the user's home directory.; 886 ; 887const char *TSystem::HomeDirectory(const char *); 888{; 889 return nullptr;; 890}; 891 ; 892//////////////////////////////////////////////////////////////////////////////; 893/// Return the user's home directory.; 894 ; 895std::string TSystem::GetHomeDirectory(const char *) const; 896{; 897 return std::string();; 898}; 899 ; 900////////////////////////////////////////////////////////////////////////////////; 901/// Make a file system directory. Returns 0 in case of success and; 902/// -1 if the directory could not be created (either already exists or; 903/// illegal path name).; 904/// If 'recursive' is true, makes parent directories as needed.; 905 ; 906int TSystem::mkdir(const char *name, Bool_t recursive); 907{; 908 if (recursive) {; 909 TString safeName = name; // local copy in case 'name' is output from; 910 // TSystem::DirName as it uses static buffers; 911 TString dirname = GetDirName(safeName.Data());; 912 if (dirname.IsNull()) {; 913 // well we should not have to make the root of the file system!; 914 // (and this avoid infinite recursions!); 915 return -1;; 916 }; 917 if (AccessPathName(dirname.Data(), kFileExists)) {; 918 int res = mkdir(dirname.Data(), kTRUE);; 919 if (res) return res;; 920 }; 921 if (!AccessPathName(safeName.Data(), kFileExists)) {; 922 return -1;; 923 }; 924 }; 925 ; 926 return MakeDirectory(name);; 927}; 928 ; 929//---- Paths & Files -----------------------------------------------------------; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Base name of a file name. Base name of /user/root is root.; 933 ; 934const char *TSystem::BaseName(const char *name); 935{; 936 if (name) {; 937 if (name[0] == '/' && name[1] == '\0'); 938 return name;; 939 char *cp;; 940 if ((cp = (cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:27363,safe,safeName,27363,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['safe'],['safeName']
Safety,"ystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::SetLinkedLibsvirtual void SetLinkedLibs(const char *linkedLibs)LinkedLibs should contain the library directory and list of libraries needed to recreate the current ...Definition TSystem.cxx:4205; TSystem::GetErrorStrconst char * GetErrorStr() constDefinition TSystem.h:350; TSystem::GetWorkingDirectoryvirtual std::string GetWorkingDirectory() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual void SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)Set the location where ACLiC will create libraries and use as a scratch area.Definition TSystem.cxx:4043; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::Utimevirtual int Utime(const char *file, Long_t modtime, Long_t actime)Set the a files modification and access times.Definition TSystem.cxx:1527; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:62122,Abort,Abortvirtual,62122,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,3,['Abort'],"['Abort', 'Abortvirtual']"
Safety,"zation clash with std::uint64_t. More...;  ; class  RCollectionField;  The collection field is only used for writing; when reading, untyped collections are projected to an std::vector. More...;  ; class  RColor;  The color class. More...;  ; class  RColumnDescriptor;  Meta-data stored for every column of an ntuple. More...;  ; class  RColumnGroupDescriptor;  Meta-data for a sets of columns; non-trivial column groups are used for sharded clusters. More...;  ; class  RColumnModel;  Holds the static meta-data of an RNTuple column. More...;  ; class  RColumnSwitch;  Holds the index and the tag of a kSwitch column. More...;  ; class  RDirectory;  Key/value store of objects. More...;  ; class  RDirectoryTypeMismatch;  Objects of this class are thrown to signal that the value known under the given name . More...;  ; class  RDirectoryUnknownKey;  Objects of this class are thrown to signal that no key with that name exists. More...;  ; class  RDisplayHistStat;  Object send to client for display of RHistStat, required to avoid sending histogram to the client. More...;  ; class  RDisplayItem;  Base class for painting data for JS. More...;  ; class  RDrawable;  Base class for drawable entities: objects that can be painted on a RPad. More...;  ; class  RDrawableDisplayItem;  Generic display item for RDrawable, just reference drawable itself. More...;  ; class  RDrawableExecRequest;  Request execution of method of referenced drawable, no reply. More...;  ; class  RDrawableMenuRequest;  Request menu items for the drawable object. More...;  ; class  RDrawableReply;  Base class for replies on RDrawableRequest. More...;  ; class  RDrawableRequest;  Base class for requests which can be submitted from the clients. More...;  ; class  REntry;  The REntry is a collection of values in an ntuple corresponding to a complete row in the data set. More...;  ; class  REnumField;  The field for an unscoped or scoped enum with dictionary. More...;  ; class  RError;  Captures diagnostics related to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:4717,avoid,avoid,4717,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['avoid'],['avoid']
Safety,"ze is "" << dv.Size() << std::endl;; 260#endif; 261 ; 262}; 263 ; 264////////////////////////////////////////////////////////////////////////////////; 265/// Compute rough values of parameters for an exponential; 266 ; 267void InitExpo(const ROOT::Fit::BinData & data, TF1 * f1); 268{; 269 unsigned int n = data.Size();; 270 if (n == 0) return;; 271 ; 272 // find xmin and xmax of the data; 273 double valxmin;; 274 double xmin = *(data.GetPoint(0,valxmin));; 275 double xmax = xmin;; 276 double valxmax = valxmin;; 277 ; 278 for (unsigned int i = 1; i < n; ++ i) {; 279 double val;; 280 double x = *(data.GetPoint(i,val) );; 281 if (x < xmin) {; 282 xmin = x;; 283 valxmin = val;; 284 }; 285 else if (x > xmax) {; 286 xmax = x;; 287 valxmax = val;; 288 }; 289 }; 290 ; 291 // avoid negative values of valxmin/valxmax; 292 if (valxmin <= 0 && valxmax > 0 ) valxmin = valxmax;; 293 else if (valxmax <=0 && valxmin > 0) valxmax = valxmin;; 294 else if (valxmin <=0 && valxmax <= 0) { valxmin = 1; valxmax = 1; }; 295 ; 296 double slope = std::log( valxmax/valxmin) / (xmax - xmin);; 297 double constant = std::log(valxmin) - slope * xmin;; 298 f1->SetParameters(constant, slope);; 299}; 300 ; 301 ; 302////////////////////////////////////////////////////////////////////////////////; 303/// Compute Initial values of parameters for a gaussian; 304/// derived from function H1InitGaus defined in TH1.cxx; 305 ; 306void InitGaus(const ROOT::Fit::BinData & data, TF1 * f1); 307{; 308 ; 309 static const double sqrtpi = 2.506628;; 310 ; 311 // - Compute mean value and RMS of the data; 312 unsigned int n = data.Size();; 313 if (n == 0) return;; 314 double sumx = 0;; 315 double sumx2 = 0;; 316 double allcha = 0;; 317 double valmax = 0;; 318 double rangex = data.Coords(n-1)[0] - data.Coords(0)[0];; 319 // to avoid binwidth = 0 set arbitrarly to 1; 320 double binwidth = 1;; 321 if ( rangex > 0) binwidth = rangex;; 322 double x0 = 0;; 323 for (unsigned int i = 0; i < n; ++ i) {; 324 double val;; 325 doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:9588,avoid,avoid,9588,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ze=32000, Int_t splitlevel=0, Int_t compress=ROOT::RCompressionSetting::EAlgorithm::kInherit);  Init when the branch object is a TClonesArray. ;  ; void Init (TTree *tree, TBranch *parent, const char *name, TStreamerInfo *sinfo, Int_t id, char *pointer, Int_t basketsize=32000, Int_t splitlevel=0, Int_t btype=0);  Init when the branch object is not a TClonesArray nor an STL container. ;  ; void Init (TTree *tree, TBranch *parent, const char *name, TVirtualCollectionProxy *cont, Int_t basketsize=32000, Int_t splitlevel=0, Int_t compress=ROOT::RCompressionSetting::EAlgorithm::kInherit);  Init when the branch object is an STL collection. ;  ; virtual void InitializeOffsets ();  Initialize the base class subobjects offsets of our sub-branches and set fOffset if we are a container sub-branch. ;  ; virtual void InitInfo ();  Init the streamer info for the branch class, try to compensate for class code unload/reload and schema evolution. ;  ; bool IsMissingCollection () const;  Detect a collection written using a zero pointer in old versions of root. ;  ; void ReadLeavesClones (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesClonesMember (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesCollection (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesCollectionMember (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesCollectionSplitPtrMember (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesCollectionSplitVectorPtrMember (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesCustomStreamer (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesImpl (TBuffer &b);  Unconfiguration Read Leave function. ;  ; void ReadLeavesMakeClass (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesMember (TBuffer &b);  Read leaves into i/o buffers for this branch. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:29189,Detect,Detect,29189,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['Detect'],['Detect']
Safety,"zed function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denomi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:12884,recover,recover,12884,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"zed when both content and errors are zero, are excluded. ; Definition at line 317 of file TGraph2D.cxx. ◆ TGraph2D() [7/9]. TGraph2D::TGraph2D ; (; const char * ; name, . const char * ; title, . Int_t ; n, . Double_t * ; x, . Double_t * ; y, . Double_t * ; z . ). Graph2D constructor with name, title and three vectors of doubles as input. ; name : name of 2D graph (avoid blanks) title : 2D graph title if title is of the form ""stringt;stringx;stringy;stringz"" the 2D graph title is set to stringt, the x axis title to stringx, the y axis title to stringy,etc ; Definition at line 363 of file TGraph2D.cxx. ◆ TGraph2D() [8/9]. TGraph2D::TGraph2D ; (; const char * ; filename, . const char * ; format = ""%lg %lg %lg"", . Option_t * ; option = """" . ). Graph2D constructor reading input from filename filename is assumed to contain at least three columns of numbers. ; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files) you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument, e.g. option="" \\t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';') used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1""). Note in that case, the instantiation is about 2 times slower. ; Definition at line 403 of file TGraph2D.cxx. ◆ TGraph2D() [9/9]. TGraph2D::TGraph2D ; (; const TGraph2D & ; g). Graph2D copy constructor. ; copy everything apart from the list of contained functions ; Definition at line 522 of file TGraph2D.cxx. ◆ ~TGraph2D(). TGraph2D::~TGraph2D ; (; ). override . TGraph2D destructor. ; Definition at line 548 of file TGraph2D.cxx. Member Function Documentation. ◆ Add(). void TGraph2D::Add ; (; TF2 * ; f, . Double_t ; c1 = 1 . ). virtual . Performs the operation: z = z + c1*f(x,y,z) Errors are not recalculated. ; Parameters. fmay be a 2-D function TF2 or 3-d function TF3 ; c1a scaling factor, 1 by default . Definition at line 642 of file TGraph2D.cxx. ◆ AddPoint(). virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2D.html:37098,avoid,avoid,37098,doc/master/classTGraph2D.html,https://root.cern,https://root.cern/doc/master/classTGraph2D.html,1,['avoid'],['avoid']
Safety,"zer * GetPacketizer () const override;  ; TObject * HandleHistogram (TObject *obj, Bool_t &merged);  Low statistic histograms need a special treatment when using autobin. ;  ; Bool_t HistoSameAxis (TH1 *h0, TH1 *h1);  Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges on the axis (i.e. ;  ; Int_t Incorporate (TObject *obj, TList *out, Bool_t &merged);  Incorporate object 'newobj' in the list 'outlist'. ;  ; Bool_t IsClient () const override;  Is the player running on the client? ;  ; Bool_t JoinProcess (TList *workers) override;  Prepares the given list of new workers to join a progressing process. ;  ; void MergeOutput (Bool_t savememvalues=kFALSE) override;  Merge objects in output the lists. ;  ; void RedirectOutput (Bool_t on=kTRUE);  Control output redirection to TProof::fLogFileW. ;  ; void SetInitTime () override;  Set init time. ;  ; void SetMerging (Bool_t on=kTRUE) override;  Switch on/off merge timer. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Cre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:3698,abort,abort,3698,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"{ kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortAbort status; TList*fInputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). Bool_t ProcessCut(Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:9485,abort,abort,9485,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,1,['abort'],['abort']
Safety,"{; 1204 Int_t rc = -4;; 1205 ; 1206 TFdSet rd, wr;; 1207 Int_t mxfd = -1;; 1208 TIter next(act);; 1209 TFileHandler *h = nullptr;; 1210 while ((h = (TFileHandler *) next())) {; 1211 Int_t fd = h->GetFd();; 1212 if (fd > -1) {; 1213 if (h->HasReadInterest()) {; 1214 rd.Set(fd);; 1215 mxfd = TMath::Max(mxfd, fd);; 1216 }; 1217 if (h->HasWriteInterest()) {; 1218 wr.Set(fd);; 1219 mxfd = TMath::Max(mxfd, fd);; 1220 }; 1221 h->ResetReadyMask();; 1222 }; 1223 }; 1224 if (mxfd > -1); 1225 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1226 ; 1227 // Set readiness bits; 1228 if (rc > 0) {; 1229 next.Reset();; 1230 while ((h = (TFileHandler *) next())) {; 1231 Int_t fd = h->GetFd();; 1232 if (rd.IsSet(fd)); 1233 h->SetReadReady();; 1234 if (wr.IsSet(fd)); 1235 h->SetWriteReady();; 1236 }; 1237 }; 1238 ; 1239 return rc;; 1240}; 1241 ; 1242////////////////////////////////////////////////////////////////////////////////; 1243/// Select on the file descriptor related to file handler h.; 1244/// The timeout to is in millisec. Returns the number of ready descriptors,; 1245/// or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; 1246/// and -3 EBADF. In case of EINTR the errno has been reset and the method; 1247/// can be called again. Returns -4 in case the file handler is 0 or does; 1248/// not have a file descriptor >= 0.; 1249 ; 1250Int_t TUnixSystem::Select(TFileHandler *h, Long_t to); 1251{; 1252 Int_t rc = -4;; 1253 ; 1254 TFdSet rd, wr;; 1255 Int_t mxfd = -1;; 1256 Int_t fd = -1;; 1257 if (h) {; 1258 fd = h->GetFd();; 1259 if (fd > -1) {; 1260 if (h->HasReadInterest()); 1261 rd.Set(fd);; 1262 if (h->HasWriteInterest()); 1263 wr.Set(fd);; 1264 h->ResetReadyMask();; 1265 mxfd = fd;; 1266 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1267 }; 1268 }; 1269 ; 1270 // Fill output lists, if required; 1271 if (rc > 0) {; 1272 if (rd.IsSet(fd)); 1273 h->SetReadReady();; 1274 if (wr.IsSet(fd)); 1275 h->SetWriteReady();; 1276 }; 1277 ; 1278 return rc;; 1279}; 1280 ; 1281//---- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:38036,timeout,timeout,38036,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"{; 339 // Register in the repository that an object has moved.; 340 ; 341 // Move not only the object itself but also any base classes or sub-objects.; 342 size_t objsize = what->Size();; 343 long delta = (char*)newadd - (char*)oldadd;; 344 R__LOCKGUARD2(fOVRMutex);; 345 RepoCont_t::iterator cur = fObjectVersionRepository.find(oldadd);; 346 for (; cur != fObjectVersionRepository.end();) {; 347 RepoCont_t::iterator tmp = cur++;; 348 if (oldadd <= tmp->first && tmp->first < ( ((char*)oldadd) + objsize) ) {; 349 // The location is within the object, let's move it.; 350 ; 351 fObjectVersionRepository.insert(RepoCont_t::value_type(((char*)tmp->first)+delta, tmp->second));; 352 fObjectVersionRepository.erase(tmp);; 353 ; 354 } else {; 355 // -- No address, version match, we've reached the end.; 356 break;; 357 }; 358 }; 359}; 360 ; 361//______________________________________________________________________________; 362//______________________________________________________________________________; 363namespace ROOT {; 364#define R__USE_STD_MAP; 365 class TMapTypeToTClass {; 366#if defined R__USE_STD_MAP; 367 // This wrapper class allow to avoid putting #include <map> in the; 368 // TROOT.h header file.; 369 public:; 370 typedef std::map<std::string,TClass*> IdMap_t;; 371 typedef IdMap_t::key_type key_type;; 372 typedef IdMap_t::const_iterator const_iterator;; 373 typedef IdMap_t::size_type size_type;; 374#ifdef R__WIN32; 375 // Window's std::map does NOT defined mapped_type; 376 typedef TClass* mapped_type;; 377#else; 378 typedef IdMap_t::mapped_type mapped_type;; 379#endif; 380 ; 381 private:; 382 IdMap_t fMap;; 383 ; 384 public:; 385 void Add(const key_type &key, mapped_type &obj); 386 {; 387 // Add the <key,obj> pair to the map.; 388 fMap[key] = obj;; 389 }; 390 mapped_type Find(const key_type &key) const; 391 {; 392 // Find the type corresponding to the key.; 393 IdMap_t::const_iterator iter = fMap.find(key);; 394 mapped_type cl = nullptr;; 395 if (iter != fMap.end()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:13782,avoid,avoid,13782,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['avoid'],['avoid']
Safety,"{; 4111 ssize_t len = getxattr(fileurl.GetFile(), ""eos.url.xroot"", nullptr, 0);; 4112 if (len > 0) {; 4113 std::string xurl(len, 0);; 4114 if (getxattr(fileurl.GetFile(), ""eos.url.xroot"", &xurl[0], len) == len) {; 4115 if ((f = TFile::Open(xurl.c_str(), options, ftitle, compress, netopt))) {; 4116 if (!f->IsZombie()) {; 4117 return f;; 4118 } else {; 4119 delete f;; 4120 f = nullptr;; 4121 }; 4122 }; 4123 }; 4124 }; 4125 }; 4126 }; 4127#endif; 4128 ; 4129 // If a timeout has been specified extract the value and try to apply it (it requires; 4130 // support for asynchronous open, though; the following is completely transparent if; 4131 // such support if not available for the required protocol); 4132 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus(fh);; 4149 Int_t xtms = toms;; 4150 while (aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);; 4158 if (gDebug > 0) {; 4159 if (aos == TFile::kAOSSuccess); 4160 ::Info(""TFile::Open"", ""waited %d millisec for asynchronous open"", toms - xtms);; 4161 else; 4162 ::Info(""TFile::Open"", ""timeou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:151439,Timeout,Timeout,151439,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Timeout'],['Timeout']
Safety,"{c}(x|\mu)}\Bigg]^{-1}, \end{align*} where mu is the signal strength, and a value of 0 corresponds to the background hypothesis. Using this decomposition, one is able to use the pairwise likelihood ratios.; Since the only free parameter in our case is mu, the distributions are independent of this parameter and the dependence on the signal strength can be encoded into the weights. Thus, the subratios simplify dramatically since they are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # Loop over each sample category; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; ; weight_sum = weights_dict[sample_category]; ; mask = data_dict[""sample_category""] == sample_category; # Normalize each weight; weights = data_dict[""weight""][mask]; # Extract the weight_modified; weight_modified = weights / weight_sum; ; count = np.sum(mask); ; # Store the count and weight sum in the dictionary; results[sample_category] = {; ""weight_sum"": weight_sum,; ""weight_modified"": weight_modified,; ""count"": count,; ""weight"": weights,; }; ; ; # Extract the mass for higgs and zz; higgs_data = data_dict[""m4l""][data_dict[""sample_category""] == [""higgs""]]; zz_data = data_dict[""m4l""][data_dict[""sample_category",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf618__mixture__models_8py.html:2324,avoid,avoid,2324,doc/master/rf618__mixture__models_8py.html,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html,1,['avoid'],['avoid']
Safety,"|kWrite then we monitor both read and write readiness. ; Definition at line 168 of file TMonitor.cxx. ◆ Class(). static TClass * TMonitor::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMonitor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMonitor::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TMonitor.h. ◆ DeActivate(). void TMonitor::DeActivate ; (; TSocket * ; sock). virtual . De-activate a socket. ; Definition at line 284 of file TMonitor.cxx. ◆ DeActivateAll(). void TMonitor::DeActivateAll ; (; ). virtual . De-activate all activated sockets. ; Definition at line 302 of file TMonitor.cxx. ◆ DeclFileName(). static const char * TMonitor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMonitor.h. ◆ GetActive(). Int_t TMonitor::GetActive ; (; Long_t ; timeout = -1); const. Return number of sockets in the active list. ; If timeout > 0, remove from the list those sockets which did not have any activity since timeout millisecs. If timeout = 0, then reset activity timestamp on all active sockets. This time out is typically used if GetActive() is used to see how many remotes still need to send something. If they pass the timeout they will be skipped and GetActive() will return 0 and the loop can be exited. ; Definition at line 438 of file TMonitor.cxx. ◆ GetDeActive(). Int_t TMonitor::GetDeActive ; (; ); const. Return number of sockets in the de-active list. ; Definition at line 473 of file TMonitor.cxx. ◆ GetListOfActives(). TList * TMonitor::GetListOfActives ; (; ); const. Returns a list with all active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 498 of file TMonitor.cxx. ◆ GetListOfDeActives().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:18951,timeout,timeout,18951,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"},; {(char*)""__reshape__"", (PyCFunction)op_reshape, METH_O,; (char*)""cast pointer to 1D array type""},; {(char*)nullptr, nullptr, 0, nullptr}; }; CPyCppyy::op_reshapestatic PyObject * op_reshape(CPPInstance *self, PyObject *shape)Definition CPPInstance.cxx:330; CPyCppyy::op_dispatchstatic PyObject * op_dispatch(PyObject *self, PyObject *args, PyObject *)Definition CPPInstance.cxx:277; CPyCppyy::op_destructstatic PyObject * op_destruct(CPPInstance *self)Definition CPPInstance.cxx:266. Definition at line 405 of file CPPInstance.cxx. ◆ RefFloat_Type. PyTypeObject CPyCppyy::RefFloat_Type. Initial value:= { ; PyObject_HEAD_INIT( &PyType_Type ) 0 ,; (char*)""cppyy.Double"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,; Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |; Py_TPFLAGS_BASETYPE, ; (char*)""CPyCppyy float object for pass by reference"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0,; &PyFloat_Type, ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; ; ; ; ; ; ; ; ; ; }. Custom ""builtins,"" detectable by type, for pass by ref and improved performance. ; Definition at line 27 of file CustomPyTypes.cxx. ◆ RefInt_Type. PyTypeObject CPyCppyy::RefInt_Type. Initial value:= { ; PyObject_HEAD_INIT( &PyType_Type ) 0 ,; (char*)""cppyy.Long"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,; Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |; Py_TPFLAGS_BASETYPE; ; ; ; , ; (char*)""CPyCppyy long object for pass by reference"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0,; &PyInt_Type, ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; ; ; ; ; ; ; ; ; ; }. Definition at line 49 of file CustomPyTypes.cxx. ◆ SMALL_ARGS_N. const int CPyCppyy::SMALL_ARGS_N = 8. Definition at line 13 of file CallContext.h. ◆ TemplateProxy_Type. PyTypeObject CPyCppyy::TemplateProxy_Type. Definition at line 890 of file TemplateProxy.cxx. ◆ tpp_as_mapping. PyMappingMethods CPyCppyy::tpp_as_mapping. static . Initial value:= {; nullptr, (binaryfunc)tpp_subscript, nullptr; }. Definition at line 754 of file TemplateProxy.cxx. ◆ tpp_getset. PyGetSetDef CPyCppyy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceCPyCppyy.html:68336,detect,detectable,68336,doc/master/namespaceCPyCppyy.html,https://root.cern,https://root.cern/doc/master/namespaceCPyCppyy.html,1,['detect'],['detectable']
Safety,"}; ///<! counter for identifiers; 47 bool fUseHttpThrd{false}; ///<! use special thread for THttpServer; 48 bool fUseSenderThreads{false}; ///<! use extra threads for sending data from RWebWindow to clients; 49 float fLaunchTmout{30.}; ///<! timeout in seconds to start browser process, default 30s; 50 bool fExternalProcessEvents{false}; ///<! indicate that there are external process events engine; 51 std::unique_ptr<TExec> fAssgnExec; ///<! special exec to assign thread id via ProcessEvents; 52 WebWindowShowCallback_t fShowCallback; ///<! function called for each RWebWindow::Show call; 53 ; 54 /// Returns true if http server use special thread for requests processing (default off); 55 bool IsUseHttpThread() const { return fUseHttpThrd; }; 56 ; 57 /// Returns true if extra threads to send data via websockets will be used (default off); 58 bool IsUseSenderThreads() const { return fUseSenderThreads; }; 59 ; 60 /// Returns timeout for launching new browser process; 61 float GetLaunchTmout() const { return fLaunchTmout; }; 62 ; 63 void Unregister(RWebWindow &win);; 64 ; 65 /// Show window in specified location, see Show() method for more details; 66 unsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args);; 67 ; 68 int WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed = false, double tm = -1);; 69 ; 70 std::string GetUrl(RWebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 71 ; 72 bool CreateServer(bool with_http = false);; 73 ; 74 bool InformListener(const std::string &msg);; 75 ; 76 static std::string GenerateKey(int keylen = 32);; 77 ; 78public:; 79 RWebWindowsManager();; 80 ; 81 ~RWebWindowsManager();; 82 ; 83 /// Returns THttpServer instance; 84 THttpServer *GetServer() const { return fServer.get(); }; 85 ; 86 /// Returns http address of the server, empty string when not available; 87 std::string GetServerAddr() const { return fAddr; }; 88 ; 89 /// Assign show callback which can catch window showing, used by RBrowser; 90 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:2138,timeout,timeout,2138,doc/v632/RWebWindowsManager_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html,2,['timeout'],['timeout']
Safety,"}; 1794 }; 1795 Int_t n1 = (nelements > 100) ? (Int_t) nelements / 100 : 1;; 1796 if (stg->Locate(eurl.Data(), eurl) == 0) {; 1797 if (nlook > 0 && !(nlook % n1)) {; 1798 printf(""Lookup | %3d %% finished\r"", 100 * nlook / nelements);; 1799 fflush(stdout);; 1800 }; 1801 // Get the effective end-point Url; 1802 elemurl.SetUrl(eurl);; 1803 // Restore original options and anchor, if any; 1804 elemurl.SetOptions(options);; 1805 elemurl.SetAnchor(anchor);; 1806 // Save it into the element; 1807 element->SetTitle(elemurl.GetUrl());; 1808 // Remember; 1809 element->SetLookedUp();; 1810 } else {; 1811 // Failure: remove; 1812 fFiles->Remove(element);; 1813 if (gSystem->AccessPathName(eurl)); 1814 Error(""Lookup"", ""file %s does not exist\n"", eurl.Data());; 1815 else; 1816 Error(""Lookup"", ""file %s cannot be read\n"", eurl.Data());; 1817 }; 1818 }; 1819 if (nelements > 0); 1820 printf(""Lookup | %3d %% finished\n"", 100 * nlook / nelements);; 1821 else; 1822 printf(""\n"");; 1823 fflush(stdout);; 1824 SafeDelete(stg);; 1825}; 1826 ; 1827////////////////////////////////////////////////////////////////////////////////; 1828/// Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED); 1829 ; 1830void TChain::Loop(Option_t* option, Long64_t nentries, Long64_t firstentry); 1831{; 1832 Error(""Loop"", ""Function not yet implemented"");; 1833 ; 1834 if (option || nentries || firstentry) { } // keep warnings away; 1835 ; 1836#if 0; 1837 if (LoadTree(firstentry) < 0) return;; 1838 ; 1839 if (firstentry < 0) firstentry = 0;; 1840 Long64_t lastentry = firstentry + nentries -1;; 1841 if (lastentry > fEntries-1) {; 1842 lastentry = fEntries -1;; 1843 }; 1844 ; 1845 GetPlayer();; 1846 GetSelector();; 1847 fSelector->Start(option);; 1848 ; 1849 Long64_t entry = firstentry;; 1850 Int_t tree,e0,en;; 1851 for (tree=0;tree<fNtrees;tree++) {; 1852 e0 = fTreeOffset[tree];; 1853 en = fTreeOffset[tree+1] - 1;; 1854 if (en > lastentry) en = lastentry;; 1855 if (entry > en) continue;; 1856 ; 1857",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:65320,Safe,SafeDelete,65320,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"};; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfActivetrue if task is active; Int_tfBreakin=1 if a break point set at task extry; Int_tfBreakout=1 if a break point set at task exit; Bool_tfHasExecutedTrue if task has executed; TStringTNamed::fNameobject identifier; TStringfOptionOption specified in ExecuteTask; TList*fTasksList of Tasks; TStringTNamed::fTitleobject title; static TTask*fgBeginTaskpointer to task initiator; static TTask*fgBreakPointpointer to current break point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTask(); Default constructor invoked when reading a TTask object from a file. TTask(const char* name, const char* title); Standard constructor. TTask& operator=(const TTask& tt); assignment operator (PLEASE DO NOT USE THIS IS WRONG). TTask(const TTask& task); Copy constructor. ~TTask(); Delete a task and its subtasks. void Abort(); Abort current tree of tasks.; After this call, the tree of tasks is ready to be executed again.; The application must take care of cleaning data structures created; by previous executions. void Browse(TBrowser* b); Browse the list of tasks.; It is recommended to add the top level task to the list of; ROOT browsables by:; gROOT->GetListOfBrowsables()->Add(myTopLevelTask). void CleanTasks(); Reset tasks state: breakpoints and execute flags; also invokes the Clear function of each task to clear all data; structures created by a previous execution of a task. void Clear(Option_t* option = """"); Recursively call the Clear function of this task and its subtasks.; The Clear function must be implemented for each derived class; to clear all data structures created by a previous execution of a task.; This function is automatically called by the CleanTasks function. void Continue(); Resume execution at the current break point. void Exec(Option_t* option); Dummy Execute.; This function must be redefined in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTask.html:9389,Abort,Abort,9389,root/html528/TTask.html,https://root.cern,https://root.cern/root/html528/TTask.html,8,['Abort'],['Abort']
Safety,"~TGeoTubeSeg(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTubeSeg.html:14653,safe,safe,14653,root/html528/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html,3,['safe'],['safe']
Safety," . Loading...; Searching...; No Matches. pyroot Directory Reference. Directory dependency graph for pyroot:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files;  demo.py;  To run, do ""python <path-to>/demo.py"". ;  ;  demoshelp.py;   Display demo help. ;  ;  DynamicSlice.py;   Example of function called when a mouse event occurs in a pad. ;  ;  fit1.py;   Fit example. ;  ;  fit1_py.py;  ;  formula1.py;   TF1 example. ;  ;  geometry.py;   Geometry ;  ;  gerrors.py;   A Simple Graph with error bars ;  ;  graph.py;   A Simple Graph Example ;  ;  gui_ex.py;  A Simple GUI Example. ;  ;  h1ReadAndDraw.py;   A Simple histogram drawing example ;  ;  hsimple.py;   This program creates : ;  ;  hsum.py;   Simple example illustrating how to use the C++ interpreter ;  ;  mrt.py;   Build ROOT Ntuple from other source. ;  ;  na49geomfile.py;  Before executing this macro, the file makegeometry.C must have been executed. ;  ;  na49view.py;  This macro generates two views of the NA49 detector. ;  ;  na49visible.py;  Set visibility attributes for the NA49 geometry Set Shape attributes. ;  ;  ntuple1.py;   Ntuple drawing example. ;  ;  numberEntry.py;  Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ;  ;  parse_CSV_file_with_TTree_ReadStream.py;  This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ;  ;  pyroot001_arrayInterface.py;   This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ;  ;  pyroot002_pythonizationDecorator.py;   This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ;  ;  pyroot003_prettyPrinting.py;   This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:1106,detect,detector,1106,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,1,['detect'],['detector']
Safety," ; ). inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 411 of file RooTemplateProxy.h. ◆ lvptr() [4/4]. template<class T > . LValue_t * RooTemplateProxy< T >::lvptr ; (; RooAbsArg * ; ). inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 426 of file RooTemplateProxy.h. ◆ R__DEPRECATED(). template<class T > . template<typename Bool = bool, typename = std::enable_if_t<std::is_same<Bool,bool>::value>> . RooTemplateProxy< T >::R__DEPRECATED ; (; 6 ; , . 36 ; , . ""Use RooTemplateProxy< T >(const char*, const char*, RooAbsArg*, bool, bool) and transfer the ownership with RooTemplateProxy< T >::putOwnedArg()."" ;  . ); cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTemplateProxy.html:26110,safe,safe,26110,doc/master/classRooTemplateProxy.html,https://root.cern,https://root.cern/doc/master/classRooTemplateProxy.html,1,['safe'],['safe']
Safety," ; Int_t SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE) override;  Save the partial results of this query to a dedicated file under the user data directory. ;  ; void SetCurrentQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetInitTime () override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetMerging (Bool_t=kTRUE) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop the process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback list (may not be used in this class). ;  ; void StoreOutput (TList *out) override;  Store output list (may not be used in this class). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax) override;  Update automatic binning parameters for given object ""name"". ;  ; void UpdateProgressInfo () override;  Update fProgressStatus. ;  ;  Public Member Functions inherited from TVirtualProofPlayer;  TVirtualProofPlayer ();  ;  ~TVirtualProofPlayer () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:6349,abort,abort,6349,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety," ; Int_t fHighLimitX;  Last bin in X dimension. ;  ; Int_t fHighLimitY;  Last bin in Y dimension. ;  ; Int_t fHighLimitZ;  Last bin in Z dimension. ;  ; Int_t fLowLimitX;  First bin in X dimension. ;  ; Int_t fLowLimitY;  First bin in Y dimension. ;  ; Int_t fLowLimitZ;  First bin in Z dimension. ;  ; Int_t fNDF;  Number of degrees of freedom in the fit. ;  ; Int_t fNpar;  number of fit parameters ;  ; Int_t fNpfits;  Number of points used in the fit. ;  ; Histograms; TH1 * fData;  Pointer to the ""data"" histogram to be fitted to. ;  ; TObjArray fMCs;  Array of pointers to template histograms. ;  ; TObjArray fWeights;  Array of pointers to corresponding weight factors (may be null) ;  ; Double_t fIntegralData;  ""data"" histogram content integral over allowed fit range ;  ; Double_t * fIntegralMCs;  Same for template histograms (weights not taken into account) ;  ; Double_t * fFractions;  Template fractions scaled to the ""data"" histogram statistics. ;  ; TH1 * fPlot;  Pointer to histogram containing summed template predictions. ;  ; ROOT::Fit::Fitter * fFractionFitter;  Pointer to Fitter class. ;  . Private Member Functions; void CheckConsistency ();  Function used internally to check the consistency between the various histograms. ;  ; void CheckParNo (Int_t parm) const;  Function for internal use, checking parameter validity An invalid parameter results in an error. ;  ; void ComputeChisquareLambda ();  Method used internally to compute the likelihood ratio chi2 See the function GetChisquare() for details. ;  ; void ComputeFCN (Double_t &f, const Double_t *par, Int_t flag);  Used internally to compute the likelihood value. ;  ; void FindPrediction (int bin, double &t_i, int &k_0, double &A_ki) const;  Function used internally to obtain the template prediction in the individual bins 'bin' <=> 'i' (paper) 'par' <=> 'j' (paper) ;  ; void GetRanges (Int_t &minX, Int_t &maxX, Int_t &minY, Int_t &maxY, Int_t &minZ, Int_t &maxZ) const;  Used internally to obtain the bin ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:19140,predict,predictions,19140,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['predict'],['predictions']
Safety," ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 427 of file TBufferSQL.cxx. ◆ WriteFastArray() [2/15]. void TBufferSQL::WriteFastArray ; (; const Char_t * ; c, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 447 of file TBufferSQL.cxx. ◆ WriteFastArray() [3/15]. void TBufferSQL::WriteFastArray ; (; const Double_t * ; d, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 688 of file TBufferSQL.cxx. ◆ WriteFastArray() [4/15]. void TBufferSQL::WriteFastArray ; (; const Float_t * ; f, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 668 of file TBufferSQL.cxx. ◆ WriteFastArray() [5/15]. void TBufferSQL::WriteFastArray ; (; const Int_t * ; ii, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:51620,abort,aborts,51620,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety," ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 547 of file TBufferSQL.cxx. ◆ WriteFastArray() [6/15]. void TBufferSQL::WriteFastArray ; (; const Long64_t * ; l, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 628 of file TBufferSQL.cxx. ◆ WriteFastArray() [7/15]. void TBufferSQL::WriteFastArray ; (; const Long_t * ; l, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 588 of file TBufferSQL.cxx. ◆ WriteFastArray() [8/15]. void TBufferSQL::WriteFastArray ; (; const Short_t * ; h, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 506 of file TBufferSQL.cxx. ◆ WriteFastArray() [9/15]. void TBufferSQL::WriteFastArray ; (; const UChar_t * ; uc, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:53371,abort,aborts,53371,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety," ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 668 of file TBufferSQL.cxx. ◆ WriteFastArray() [5/15]. void TBufferSQL::WriteFastArray ; (; const Int_t * ; ii, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 547 of file TBufferSQL.cxx. ◆ WriteFastArray() [6/15]. void TBufferSQL::WriteFastArray ; (; const Long64_t * ; l, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 628 of file TBufferSQL.cxx. ◆ WriteFastArray() [7/15]. void TBufferSQL::WriteFastArray ; (; const Long_t * ; l, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 588 of file TBufferSQL.cxx. ◆ WriteFastArray() [8/15]. void TBufferSQL::WriteFastArray ; (; const Short_t * ; h, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:52934,abort,aborts,52934,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety," ; void Begin (TTree *) override;  ; TList * GetOutputList () const override;  ; void Init (TTree *) override;  ; TClass * IsA () const override;  ; Bool_t Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; Bool_t Process (Long64_t entry) override;  Process a single entry. ;  ; void SetInputList (TList *input) override;  ; void SetObject (TObject *obj) override;  ; void SetOption (const char *option) override;  ; void SlaveBegin (TTree *tree) override;  Worker Begin. ;  ; void SlaveTerminate () override;  Worker Terminate. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  ; Int_t Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetStatus (Long64_t status);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelVerifyDataSet.html:1575,Abort,Abort,1575,doc/master/classTSelVerifyDataSet.html,https://root.cern,https://root.cern/doc/master/classTSelVerifyDataSet.html,2,['Abort'],['Abort']
Safety," ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNedges () const;  ; Int_t GetNmeshVertices () const override;  ; Int_t GetNsegments () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; ThreadData_t & GetThreadData () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; Double_t SafetyToSegment (const Double_t *point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin=TGeoShape::Big()) const;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetNedges (Int_t ne);  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoPcon;  TGeoPcon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:2795,Safe,Safety,2795,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,3,"['Safe', 'safe']","['Safety', 'SafetyToSegment', 'safe']"
Safety," CTGTextEditor;  CTGTextEntry;  CTGTextLayout;  CTGTextLBEntry;  CTGTextLine;  CTGTextView;  CTGTextViewostream;  CTGTextViewStreamBuf;  CTGTileLayout;  CTGToolBar;  CTGToolTip;  CTGTRAA general twisted trapezoid ;  CTGTransientFrame;  CTGTreeLBEntry;  CTGTreeTableTGTreeTable is a TGTable that owns it's own interface ;  CTGTripleHSlider;  CTGTripleVSlider;  CTGuiBldAction;  CTGuiBldDragManager;  CTGuiBldEditor;  CTGuiBldGeometryFrame;  CTGuiBldHintsButton;  CTGuiBldHintsEditor;  CTGuiBldNameFrame;  CTGuiBuilder;  CTGuiFactoryThis ABC is a factory for GUI components ;  CTGUndockedFrame;  CTGUnknownWindowHandler;  CTGVButtonGroup;  CTGVertical3DLine;  CTGVerticalFrame;  CTGVerticalLayout;  CTGVFileSplitter;  CTGView;  CTGViewFrame;  CTGViewPort;  CTGVProgressBar;  CTGVScrollBar;  CTGVSlider;  CTGVSplitter;  CTGWidget;  CTGWin32This class is the basic interface to the Win32 graphics system ;  CTGWin32GLManager;  CTGWin32GLManagerProxy;  CTGWin32InterpreterProxyThis class defines thread-safe interface to a command line interpreter ;  CTGWin32ProxyBaseProxy classes provide thread-safe interface to global objects ;  CTGWin32VirtualXProxy;  CTGWindow;  CTGX11This class is the basic interface to the X11 (Xlib) graphics system ;  CTGX11TTFInterface to low level X11 (Xlib) ;  CTGXYLayout;  CTGXYLayoutHints;  CTH1The TH1 histogram class ;  CTH1C1-D histogram with a byte per channel (see TH1 documentation) ;  CTH1D1-D histogram with a double per channel (see TH1 documentation)} ;  CTH1Editor;  CTH1F1-D histogram with a float per channel (see TH1 documentation)} ;  CTH1I1-D histogram with an int per channel (see TH1 documentation)} ;  CTH1KTH1K class supports the nearest K Neighbours method, widely used in cluster analysis ;  CTH1Merger;  CTH1S1-D histogram with a short per channel (see TH1 documentation) ;  CTH2Service class for 2-Dim histogram classes ;  CTH2C2-D histogram with a byte per channel (see TH1 documentation) ;  CTH2D2-D histogram with a double per channel (see TH1 d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:177509,safe,safe,177509,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['safe'],['safe']
Safety," CTGTextEditor;  CTGTextEntry;  CTGTextLayout;  CTGTextLBEntry;  CTGTextLine;  CTGTextView;  CTGTextViewostream;  CTGTextViewStreamBuf;  CTGTileLayout;  CTGToolBar;  CTGToolTip;  CTGTRAA general twisted trapezoid ;  CTGTransientFrame;  CTGTreeLBEntry;  CTGTreeTableTGTreeTable is a TGTable that owns it's own interface ;  CTGTripleHSlider;  CTGTripleVSlider;  CTGuiBldAction;  CTGuiBldDragManager;  CTGuiBldEditor;  CTGuiBldGeometryFrame;  CTGuiBldHintsButton;  CTGuiBldHintsEditor;  CTGuiBldNameFrame;  CTGuiBuilder;  CTGuiFactoryThis ABC is a factory for GUI components ;  CTGUndockedFrame;  CTGUnknownWindowHandler;  CTGVButtonGroup;  CTGVertical3DLine;  CTGVerticalFrame;  CTGVerticalLayout;  CTGVFileSplitter;  CTGView;  CTGViewFrame;  CTGViewPort;  CTGVProgressBar;  CTGVScrollBar;  CTGVSlider;  CTGVSplitter;  CTGWidget;  CTGWin32This class is the basic interface to the Win32 graphics system ;  CTGWin32GLManager;  CTGWin32GLManagerProxy;  CTGWin32InterpreterProxyThis class defines thread-safe interface to a command line interpreter ;  CTGWin32ProxyBaseProxy classes provide thread-safe interface to global objects ;  CTGWin32VirtualXProxy;  CTGWindow;  CTGX11This class is the basic interface to the X11 (Xlib) graphics system ;  CTGX11TTFInterface to low level X11 (Xlib) ;  CTGXYLayout;  CTGXYLayoutHints;  CTH1The TH1 histogram class ;  CTH1CTomato 1-D histogram with a byte per channel (see TH1 documentation) ;  CTH1DTomato 1-D histogram with a double per channel (see TH1 documentation)} ;  CTH1Editor;  CTH1FTomato 1-D histogram with a float per channel (see TH1 documentation)} ;  CTH1ITomato 1-D histogram with an int per channel (see TH1 documentation)} ;  CTH1KTH1K class supports the nearest K Neighbours method, widely used in cluster analysis ;  CTH1Merger;  CTH1STomato 1-D histogram with a short per channel (see TH1 documentation) ;  CTH2Service class for 2-Dim histogram classes ;  CTH2CTomato 2-D histogram with a byte per channel (see TH1 documentation) ;  CTH2DTomato 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:160368,safe,safe,160368,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['safe'],['safe']
Safety," ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Compute normal to closest surface from POINT. ;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions. ;  ; Bool_t Contains (const Double_t *point) const override;  test if point is inside the half-space ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  A half-space does not have a mesh primitive. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  compute distance from inside point to the plane ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  compute distance from inside point to the plane ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Divide the shape along one axis. ;  ; void GetBoundingCylinder (Double_t *) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:2329,safe,safe,2329,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['safe'],['safe']
Safety," DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBCPEffDecay.h>. Inheritance diagram for RooBCPEffDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooBCPEffDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 26 of file RooBCPEffDecay.h. Constructor & Destructor Documentation. ◆ RooBCPEffDecay() [1/3]. RooBCPEffDecay::RooBCPEffDecay ; (; ). inline . Definition at line 29 of file RooBCPEffDecay.h. ◆ RooBCPEffDecay() [2/3]. RooBCPEffDecay::RooBCPEffDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsCategory & ; tag, . RooAbsReal & ; tau, . RooAbsReal & ; dm, . RooAbsReal & ; avgMistag, . RooAbsReal & ; CPeigenval, . RooAbsReal & ; absLambda, . RooAbsReal & ; argLambda, . RooAbsReal & ; effRatio, . RooAbsReal & ; delMistag, . const RooResolutionModel & ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPEffDecay.html:77296,Avoid,Avoids,77296,doc/master/classRooBCPEffDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPEffDecay.html,1,['Avoid'],['Avoids']
Safety," DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBCPGenDecay.h>. Inheritance diagram for RooBCPGenDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooBCPGenDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 26 of file RooBCPGenDecay.h. Constructor & Destructor Documentation. ◆ RooBCPGenDecay() [1/3]. RooBCPGenDecay::RooBCPGenDecay ; (; ). inline . Definition at line 29 of file RooBCPGenDecay.h. ◆ RooBCPGenDecay() [2/3]. RooBCPGenDecay::RooBCPGenDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsCategory & ; tag, . RooAbsReal & ; tau, . RooAbsReal & ; dm, . RooAbsReal & ; avgMistag, . RooAbsReal & ; avgC, . RooAbsReal & ; avgS, . RooAbsReal & ; delMistag, . RooAbsReal & ; mu, . const RooResolutionModel & ; model, . DecayType ; type = DoubleSided . ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPGenDecay.html:77170,Avoid,Avoids,77170,doc/master/classRooBCPGenDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPGenDecay.html,1,['Avoid'],['Avoids']
Safety," DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBDecay.h>. Inheritance diagram for RooBDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooBDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 29 of file RooBDecay.h. Constructor & Destructor Documentation. ◆ RooBDecay() [1/3]. RooBDecay::RooBDecay ; (; ). inline . Definition at line 32 of file RooBDecay.h. ◆ RooBDecay() [2/3]. RooBDecay::RooBDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsReal & ; tau, . RooAbsReal & ; dgamma, . RooAbsReal & ; f0, . RooAbsReal & ; f1, . RooAbsReal & ; f2, . RooAbsReal & ; f3, . RooAbsReal & ; dm, . const RooResolutionModel & ; model, . DecayType ; type . ). Constructor for RooBDecay. ; Creates an instance of RooBDecay with the specified parameters.; Parameters. [i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBDecay.html:77180,Avoid,Avoids,77180,doc/master/classRooBDecay.html,https://root.cern,https://root.cern/doc/master/classRooBDecay.html,1,['Avoid'],['Avoids']
Safety," DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBMixDecay.h>. Inheritance diagram for RooBMixDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooBMixDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 26 of file RooBMixDecay.h. Constructor & Destructor Documentation. ◆ RooBMixDecay() [1/3]. RooBMixDecay::RooBMixDecay ; (; ). inline . Definition at line 29 of file RooBMixDecay.h. ◆ RooBMixDecay() [2/3]. RooBMixDecay::RooBMixDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsCategory & ; mixState, . RooAbsCategory & ; tagFlav, . RooAbsReal & ; tau, . RooAbsReal & ; dm, . RooAbsReal & ; mistag, . RooAbsReal & ; delMistag, . const RooResolutionModel & ; model, . DecayType ; type = DoubleSided . ). Constructor for RooBMixDecay. ; Creates an instance of R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:77274,Avoid,Avoids,77274,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,1,['Avoid'],['Avoids']
Safety," DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooDecay.h>. Inheritance diagram for RooDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 25 of file RooDecay.h. Constructor & Destructor Documentation. ◆ RooDecay() [1/3]. RooDecay::RooDecay ; (; ). inline . Definition at line 28 of file RooDecay.h. ◆ RooDecay() [2/3]. RooDecay::RooDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsReal & ; tau, . const RooResolutionModel & ; model, . DecayType ; type . ). Create a new RooDecay. ; Parameters. [in]nameName of this object. ; [in]titleTitle (for e.g. plotting) ; [in]tConvolution variable (e.g. time). ; [in]tauDecay constant. ; [in]modelResolution model for the convolution. ; [in]typeOne of the decays typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDecay.html:77619,Avoid,Avoids,77619,doc/master/classRooDecay.html,https://root.cern,https://root.cern/doc/master/classRooDecay.html,1,['Avoid'],['Avoids']
Safety," DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooExtendPdf.h>. Inheritance diagram for RooExtendPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooExtendPdf() [1/4]. RooExtendPdf::RooExtendPdf ; (; ). default . ◆ RooExtendPdf() [2/4]. RooExtendPdf::RooExtendPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; pdf, . RooAbsReal & ; norm, . const char * ; rangeName = nullptr . ). Definition at line 56 of file RooExtendPdf.cxx. ◆ RooExtendPdf() [3/4]. RooExtendPdf::RooExtendPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; pdf, . RooAbsReal::Ref ; norm, . const char * ; rangeName = nullptr . ). Constructor. ; The ExtendPdf behaves identical to the supplied input pdf, but adds an extended likelihood term. expectedEvents() will return norm if rangeName remains empty. If rangeName is not empty, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExtendPdf.html:73911,Avoid,Avoids,73911,doc/master/classRooExtendPdf.html,https://root.cern,https://root.cern/doc/master/classRooExtendPdf.html,1,['Avoid'],['Avoids']
Safety," DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooExtendedTerm.h>. Inheritance diagram for RooExtendedTerm:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooExtendedTerm() [1/3]. RooExtendedTerm::RooExtendedTerm ; (; ). default . ◆ RooExtendedTerm() [2/3]. RooExtendedTerm::RooExtendedTerm ; (; const char * ; name, . const char * ; title, . const RooAbsReal & ; n . ). Constructor. ; An ExtendedTerm has no observables, it only introduces an extended ML term with the given number of expected events when an extended ML is constructed from this p.d.f. ; Definition at line 38 of file RooExtendedTerm.cxx. ◆ RooExtendedTerm() [3/3]. RooExtendedTerm::RooExtendedTerm ; (; const RooExtendedTerm & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 49 of file RooExtendedTerm.cxx. Member Function Documentation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExtendedTerm.html:73120,Avoid,Avoids,73120,doc/master/classRooExtendedTerm.html,https://root.cern,https://root.cern/doc/master/classRooExtendedTerm.html,1,['Avoid'],['Avoids']
Safety," DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNonCPEigenDecay.h>. Inheritance diagram for RooNonCPEigenDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooNonCPEigenDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 37 of file RooNonCPEigenDecay.h. Constructor & Destructor Documentation. ◆ RooNonCPEigenDecay() [1/4]. RooNonCPEigenDecay::RooNonCPEigenDecay ; (; void ; ). inline . Definition at line 40 of file RooNonCPEigenDecay.h. ◆ RooNonCPEigenDecay() [2/4]. RooNonCPEigenDecay::RooNonCPEigenDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsCategory & ; tag, . RooAbsReal & ; tau, . RooAbsReal & ; dm, . RooAbsReal & ; avgW, . RooAbsReal & ; delW, . RooAbsCategory & ; rhoQ, . RooAbsReal & ; correctQ, . RooAbsReal & ; wQ, . RooAbsReal & ; a, . RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNonCPEigenDecay.html:78283,Avoid,Avoids,78283,doc/master/classRooNonCPEigenDecay.html,https://root.cern,https://root.cern/doc/master/classRooNonCPEigenDecay.html,1,['Avoid'],['Avoids']
Safety," GetCldir () const;  ; const Double_t * GetCldirChecked () const;  ; const Double_t * GetCurrentDirection () const;  ; TGeoHMatrix * GetCurrentMatrix () const;  ; TGeoNode * GetCurrentNode () const;  ; Int_t GetCurrentNodeId () const;  ; const Double_t * GetCurrentPoint () const;  ; TGeoVolume * GetCurrentVolume () const;  ; TGeoHMatrix * GetDivMatrix () const;  ; TGeoHMatrix * GetHMatrix ();  Return stored current matrix (global matrix of the next touched node). ;  ; const Double_t * GetLastPoint () const;  ; Double_t GetLastSafety () const;  ; Int_t GetLevel () const;  ; TGeoNode * GetMother (Int_t up=1) const;  ; TGeoHMatrix * GetMotherMatrix (Int_t up=1) const;  ; Int_t GetNextDaughterIndex () const;  ; TGeoNode * GetNextNode () const;  ; Int_t GetNmany () const;  ; Int_t GetNodeId () const;  ; const Double_t * GetNormal () const;  ; const char * GetPath () const;  Get path to the current node in the form /node0/node1/... ;  ; Double_t GetPWSafety (Double_t cpoint[3], Double_t saf_max);  Wrapper for getting the safety from the parallel world. ;  ; Double_t GetPWSafetyEstimateFromCache (Double_t cpoint[3]) const;  ; Double_t GetSafeDistance () const;  ; Int_t GetSafeLevel () const;  Go upwards the tree until a non-overlapping node. ;  ; Int_t GetStackLevel () const;  ; Double_t GetStep () const;  ; Int_t GetThreadId () const;  ; Int_t GetVirtualLevel ();  Find level of virtuality of current overlapping node (number of levels up having the same tracking media. ;  ; Bool_t GotoSafeLevel ();  Go upwards the tree until a non-overlapping node. ;  ; TGeoNode * InitTrack (const Double_t *point, const Double_t *dir);  Initialize current point and current direction vector (normalized) in MARS. ;  ; TGeoNode * InitTrack (Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz);  Initialize current point and current direction vector (normalized) in MARS. ;  ; void InspectState () const;  Inspects path and all flags for the current state. ;  ; TClass * IsA (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:5343,safe,safety,5343,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safety']
Safety," GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TString * fInsertQuery;  ; TSQLResult ** fResultPtr;  ; TSQLRow ** fRowPtr;  ;  Protected Attributes inherited from TBasket; TBranch * fBranch {nullptr};  Pointer to the basket support branch. ;  ; Int_t fBufferSize {0};  fBuffer length in bytes ;  ; TBuffer * fCompressedBufferRef {nullptr};  ! Compressed buffer. ;  ; Int_t * fDisplacement {nullptr};  ![fNevBuf] Displacement of entries in fBuffer(TKey) ;  ; Int_t * fEntryOffset {nullptr};  [fNevBuf] Offset of entries in fBuffer(TKey); generated at runtime. ;  ; bool fHeaderOnly {false};  True when only the basket header must be read/written. ;  ; UChar_t fIOBits {0};  !IO feature flags. Serialized in custom portion of streamer to avoid forward compat issues unless needed. ;  ; Int_t fLast {0};  Pointer to last used byte in basket. ;  ; Int_t fLastWriteBufferSize [3] = {0,0,0};  ! Size of the buffer last three buffers we wrote it to disk ;  ; Int_t fNevBuf {0};  Number of entries in basket. ;  ; Int_t fNevBufSize {0};  Length in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null! ;  ; UChar_t fNextBufferSizeRecord {0};  ! Index into fLastWriteBufferSize of the last buffer written to disk ;  ; bool fOwnsCompressedBuffer {false};  ! Whether or not we own the compressed buffer. ;  ; bool fReadEntryOffset {false};  !Set to true if offset array was read from a file. ;  ; bool fResetAllocation {false};  ! True if last reset re-allocated the memory ;  ;  Protected Attributes inherited from TKey; char * fBuffer;  Object buffer. ;  ; TBuffer * fBufferRef;  Pointer to the TBuffer object. ;  ; TString fClassName;  Object Class name. ;  ; Short_t fCycle;  Cycle number. ;  ; TDatime fDatime;  Date/T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasketSQL.html:17290,avoid,avoid,17290,doc/master/classTBasketSQL.html,https://root.cern,https://root.cern/doc/master/classTBasketSQL.html,1,['avoid'],['avoid']
Safety," Histograms tutorialsExamples showing the ""histograms' classes"" usage. ;  HTTP tutorialsExamples showing the HTTP interface ;  Image tutorialsExamples showing the TImage class usage ;  IO tutorialsThese tutorials illustrate some of the capabilities of the ROOT IO subsystem ;  ►Math tutorialsExamples showing the Math classes ;  ►TUnfold tutorialsTest programs for the classes TUnfold and related ;  TUnfoldDensity and TUnfoldBinning test suiteThis is an example of unfolding a two-dimensional distribution ;  Matrix tutorialsExamples showing how to use TMatrix ;  Monte Carlo tutorialsMonte Carlo examples ;  TMemStat tutorialsExamples showing the TMemStat class ;  Multi Layer Perceptron tutorialsExamples showing the Multi Layer Perceptron classes ;  Multicore tutorialsThese examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing ;  Net tutorialsExamples showing the net classes ;  Physics tutorialsPhysics examples ;  ►Proof tutorialsThese examples aim to illustrate the usage of PROOF ;  ProcFileElementsClass to hold information about the processed elements of a file ;  ProofAuxSelector used for auxiliary actions in the PROOF tutorials ;  ProofEventSelector for generic processing with Event ;  ProofEventProcSelector to process trees containing Event structures ;  ProofFriendsSelector to process tree friends ;  ProofNtupleSelector to fill a simple ntuple ;  ProofPythiaSelector to generate Monte Carlo events with Pythia8 ;  ProofSimpleSelector to fill a set of histograms ;  ProofSimpleFileSelector to fill a set of histograms and merging via file ;  ProofStdVecSelector for generic processing with stdlib collections ;  ProofTestsAuxilliary selector used to test PROOF functionality ;  PyRoot tutorialsExamples showing how to write python script for Root ;  Pythia tutorialsExamples showing the pythia usage ;  Quadratic programming package.Example showing the use of the quadratic programming package quadp ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/modules.html:10512,safe,safety,10512,doc/v608/modules.html,https://root.cern,https://root.cern/doc/v608/modules.html,1,['safe'],['safety']
Safety," Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; virtual TObject * Remove (TObject *obj)=0;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSeqCollection.html:5945,safe,safe,5945,doc/master/classTSeqCollection.html,https://root.cern,https://root.cern/doc/master/classTSeqCollection.html,1,['safe'],['safe']
Safety," Process (Long64_t entry);  The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ;  ; virtual void SetInputList (TList *input);  ; virtual void SetObject (TObject *obj);  ; virtual void SetOption (const char *option);  ; virtual void SlaveBegin (TTree *tree);  The SlaveBegin() function is called after the Begin() function. ;  ; virtual void SlaveTerminate ();  The SlaveTerminate() function is called after all entries or objects have been processed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Terminate ();  The Terminate() function is the last function to be called during a query. ;  ; virtual Int_t Version () const;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetStatus (Long64_t status);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEvent.html:2327,Abort,Abort,2327,doc/master/classTSelEvent.html,https://root.cern,https://root.cern/doc/master/classTSelEvent.html,2,['Abort'],['Abort']
Safety," ReadConfigurations(). Bool_t TSQLFile::ReadConfigurations ; (; ). protected . read table configurations as special table ; Definition at line 1054 of file TSQLFile.cxx. ◆ ReadFree(). void TSQLFile::ReadFree ; (; ). inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84553,recover,recovered,84553,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Safety," fitsio;  FITS_tutorial1.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial2.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial3.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial4.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  FITS_tutorial7.COpen a FITS file that contains a catalog of astronomical objects and dump some of its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:107002,detect,detector,107002,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['detect'],['detector']
Safety, name of 1D integrator ;  ; IntegrationOneDim::Type IntegratorType () const;  type of the integrator (return the enumeration type) ;  ; unsigned int NPoints () const;  Number of points used by current integration rule. ;  ; IntegratorOneDimOptions & operator= (const IntegratorOneDimOptions &rhs);  assignment operator ;  ; void Print (std::ostream &os=std::cout) const;  print all the options ;  ; void SetIntegrator (const char *name);  set 1D integrator name ;  ; void SetNPoints (unsigned int n);  Set number of points for active integration rule. ;  ;  Public Member Functions inherited from ROOT::Math::BaseIntegratorOptions;  BaseIntegratorOptions (const BaseIntegratorOptions &opt);  ; virtual ~BaseIntegratorOptions ();  protected constructor to avoid user creating this class ;  ; double AbsTolerance () const;  non-static methods for retrieving options ;  ; IOptions * ExtraOptions () const;  return extra options ;  ; BaseIntegratorOptions & operator= (const BaseIntegratorOptions &opt);  assignment operators ;  ; double RelTolerance () const;  absolute tolerance ;  ; void SetAbsTolerance (double tol);  non-static methods for setting options ;  ; void SetExtraOptions (const IOptions &opt);  set extra options (in this case pointer is cloned) ;  ; void SetRelTolerance (double tol);  set the relative tolerance ;  ; void SetWKSize (unsigned int size);  set workspace size ;  ; unsigned int WKSize () const;  size of the workspace ;  . Static Public Member Functions; static ROOT::Math::IOptions & Default (const char *name);  retrieve specific options - if not existing create a IOptions ;  ; static double DefaultAbsTolerance ();  ; static std::string DefaultIntegrator ();  ; static IntegrationOneDim::Type DefaultIntegratorType ();  ; static unsigned int DefaultNPoints ();  ; static double DefaultRelTolerance ();  ; static unsigned int DefaultWKSize ();  ; static ROOT::Math::IOptions * FindDefault (const char *name);  find specific options - return 0 if not existing ;  ; static,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html:1576,avoid,avoid,1576,doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html,1,['avoid'],['avoid']
Safety," { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TGeoArb8; enum  EGeoArb8Type { kArb8Trap = (1ULL << ( 27 )); , kArb8Tra = (1ULL << ( 28 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoArb8;  TGeoArb8 (const TGeoArb8 &)=delete;  ; void CopyTwist (Double_t *twist=nullptr);  ; TGeoArb8 & operator= (const TGeoArb8 &)=delete;  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGeoArb8.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:25719,detect,detection,25719,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,2,['detect'],['detection']
Safety,"’.; Another way to configure visibility flags is usage of ROOT macros, which typically looks like:; {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; // ...; gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"");; new TBrowser;; }; Example of such macro can be found in root tutorials.; From provided macro only following calls will be executed in JSROOT:. gGeoManager->DefaultColors(); gGeoManager->GetVolume(""HALL"")->InvisibleAll(); gGeoManager->GetVolume(""HALL"")->SetTransparency(30); gGeoManager->GetVolume(""HALL"")->SetLineColor(5); gGeoManager->GetVolume(""ALIC"")->Draw(""ogl""). All other will be ignored.; Example of major LHC detectors: * ALICE: full * ATLAS: full, cryo, sctt * CMS: cmse, calo * LHCb: full; Other detectors examples: * HADES: full, preselected * BABAR: full, emca * STAR: full, svtt * D0: full * NA47: full * BRAHMS: full * SLD: full; Together with geometry one could display tracks (TEveTrack) and hits (TEvePointSet, TPolyMarker3D) objects. Either one do it interactively by drag and drop, or superimpose drawing with + sign like:. item=simple_alice.json.gz+tracks_hits.root/tracks+tracks_hits.root/hits. There is a problem of correct rendering of transparent volumes. To solve problem in general is very expensive (in terms of computing power), therefore several approximation solution can be applied: * dpnt: distance from camera view to the volume center used as rendering order * dbox: distance to nearest point from bonding box used as rendering order (default) * dsize: volume size is used as rendering order, can be used for centered volumes with many shells around * dray: use raycasting to sort volumes in order they appear along rays, coming out of camera point * ddflt: default three.js method for rendering transparent volumes For different geometrie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:15361,detect,detectors,15361,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,2,['detect'],['detectors']
Safety,"◆ DistancetoPrimitive(). Int_t TGeoEltu::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. ◆ DistFromInside(). Double_t TGeoEltu::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoEltu::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoEltu::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoEltu::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Divide(). TGeoVolume * TGeoEltu::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetA(). virtual Double_t TGeoEltu::GetA ; (; ); const. inlinevirtual . Definition at line 47 of file TGeoEltu.h. ◆ GetB(). virtual Double_t TGeoEltu::GetB ; (; ); const. inlinevirtual . Definition at line 48 of file TGeoEltu.h. ◆ GetBoundingCylinder(). void TGeoEltu::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoEltu::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:28982,safe,safe,28982,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,1,['safe'],['safe']
Safety,"◆ DistancetoPrimitive(). Int_t TGeoHype::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. ◆ DistFromInside(). Double_t TGeoHype::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoHype::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoHype::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoHype::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistToHype(). Int_t TGeoHype::DistToHype ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t * ; s, . Bool_t ; inner, . Bool_t ; in . ); const. ◆ Divide(). TGeoVolume * TGeoHype::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoHype::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBoundingCylinder(). void TGeoHype::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox. ◆ G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:29973,safe,safe,29973,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['safe'],['safe']
Safety,"◆ DistancetoPrimitive(). Int_t TGeoPgon::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoPcon. ◆ DistFromInside(). Double_t TGeoPgon::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ DistFromInside_v(). void TGeoPgon::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ DistFromOutside(). Double_t TGeoPgon::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ DistFromOutside_v(). void TGeoPgon::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ Divide(). TGeoVolume * TGeoPgon::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoPcon. ◆ GetBoundingCylinder(). void TGeoPgon::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoPcon. ◆ GetBuffer3D(). const TBuffer3D & TGeoPgon::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoPcon. ◆ GetByteCount(). Int_t TGeoPgon::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:29093,safe,safe,29093,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,1,['safe'],['safe']
Safety,"◆ DistancetoPrimitive(). Int_t TGeoXtru::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. ◆ DistFromInside(). Double_t TGeoXtru::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoXtru::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoXtru::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoXtru::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistToPlane(). Double_t TGeoXtru::DistToPlane ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iz, . Int_t ; ivert, . Double_t ; stepmax, . Bool_t ; in . ); const. protected . ◆ DrawPolygon(). void TGeoXtru::DrawPolygon ; (; Option_t * ; option = """"). ◆ GetBuffer3D(). const TBuffer3D & TGeoXtru::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoXtru::GetMakeRuntimeShape ; (; TGeoShape * ; , . TGeoMatrix * ;  . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:26698,safe,safe,26698,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['safe'],['safe']
Safety,"◆ MakeClone(). virtual TGeoBoolNode * TGeoBoolNode::MakeClone ; (; ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ operator=(). TGeoBoolNode & TGeoBoolNode::operator= ; (; const TGeoBoolNode & ; ). privatedelete . ◆ Paint(). void TGeoBoolNode::Paint ; (; Option_t * ; option). overridevirtual . Special schema for feeding the 3D buffers to the painter client. ; Reimplemented from TObject.; Reimplemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction.; Definition at line 295 of file TGeoBoolNode.cxx. ◆ RegisterMatrices(). void TGeoBoolNode::RegisterMatrices ; (; ). Register all matrices of the boolean node and descendents. ; Definition at line 341 of file TGeoBoolNode.cxx. ◆ ReplaceMatrix(). Bool_t TGeoBoolNode::ReplaceMatrix ; (; TGeoMatrix * ; mat, . TGeoMatrix * ; newmat . ). Replace one of the matrices. ; Does not work with TGeoIdentity. Returns true if replacement was successful. ; Definition at line 357 of file TGeoBoolNode.cxx. ◆ Safety(). virtual Double_t TGeoBoolNode::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ SavePrimitive(). void TGeoBoolNode::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Reimplemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction.; Definition at line 383 of file TGeoBoolNode.cxx. ◆ SetPoints() [1/2]. void TGeoBoolNode::SetPoints ; (; Double_t * ; points); const. virtual . Fill buffer with shape vertices. ; Definition at line 400 of file TGeoBoolNode.cxx. ◆ SetPoints() [2/2]. void TGeoBoolNode::SetPoints ; (; Float_t * ; points); const. virtual . Fill buffer with shape vertices. ; Definition at line 410 of file TGeoBoolNode.cxx. ◆ SetSelected(). void TGeoBoolNode::SetSelected ; (; Int_t ; sel). Set the selected branch. ; Definition at line 12",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBoolNode.html:20119,Safe,Safety,20119,doc/master/classTGeoBoolNode.html,https://root.cern,https://root.cern/doc/master/classTGeoBoolNode.html,1,['Safe'],['Safety']
Safety,"◆ PaintStats(). void TGraphPainter::PaintStats ; (; TGraph * ; theGraph, . TF1 * ; fit . ). overridevirtual . Paint the statistics box with the fit info. ; Implements TVirtualGraphPainter.; Definition at line 4820 of file TGraphPainter.cxx. ◆ SetHighlight(). void TGraphPainter::SetHighlight ; (; TGraph * ; theGraph). overridevirtual . Set highlight (enable/disable) mode for theGraph. ; Implements TVirtualGraphPainter.; Definition at line 1120 of file TGraphPainter.cxx. ◆ SetMaxPointsPerLine(). void TGraphPainter::SetMaxPointsPerLine ; (; Int_t ; maxp = 50). static . Static function to set fgMaxPointsPerLine for graph painting. ; When graphs are painted with lines, they are split into chunks of length fgMaxPointsPerLine. This allows to paint line with an ""infinite"" number of points. In some case this ""chunks painting"" technic may create artefacts at the chunk's boundaries. For instance when zooming deeply in a PDF file. To avoid this effect it might be necessary to increase the chunks' size using this function: TGraphPainter::SetMaxPointsPerLine(20000). ; Definition at line 5407 of file TGraphPainter.cxx. ◆ Smooth(). void TGraphPainter::Smooth ; (; TGraph * ; theGraph, . Int_t ; npoints, . Double_t * ; x, . Double_t * ; y, . Int_t ; drawtype . ). Smooth a curve given by N points. ; The original code is from an underlaying routine for Draw based on the CERN GD3 routine TVIPTE:; Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; This method draws a smooth tangentially continuous curve through the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)). The curve is approximated by a polygonal arc of short vectors. The data points can represent open curves, P(1) != P(N) or closed curves P(2) == P(N). If a tangential discontinuity at P(I) is required, then set P(I)=P(I+1). Loops are also allowed.; Reference Marlow and Powell, Harwell report No.R.7092.1972 MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6. npoints : Number of data points.; x : Absciss",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:50916,avoid,avoid,50916,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,1,['avoid'],['avoid']
Safety,"◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84977,recover,recovered,84977,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,2,"['recover', 'safe']","['recovered', 'safely']"
Safety,"◆ SetDisconnectCallBack(). void RWebWindow::SetDisconnectCallBack ; (; WebWindowConnectCallback_t ; func). Set call-back function for disconnecting. ; Definition at line 1753 of file RWebWindow.cxx. ◆ SetGeometry(). void ROOT::RWebWindow::SetGeometry ; (; unsigned ; width, . unsigned ; height . ). inline . Set window geometry. Will be applied if supported by used web display (like CEF or Chromium) ; Definition at line 262 of file RWebWindow.hxx. ◆ SetMaxQueueLength(). void ROOT::RWebWindow::SetMaxQueueLength ; (; unsigned ; len = 10). inline . configures maximal queue length of data which can be held by window ; Definition at line 300 of file RWebWindow.hxx. ◆ SetNativeOnlyConn(). void ROOT::RWebWindow::SetNativeOnlyConn ; (; bool ; on = true). inline . configures that only native (own-created) connections are allowed ; Definition at line 308 of file RWebWindow.hxx. ◆ SetOperationTmout(). void ROOT::RWebWindow::SetOperationTmout ; (; float ; tm = 50.). inline . Set timeout for synchronous WebWindow operations. ; Definition at line 354 of file RWebWindow.hxx. ◆ SetPanelName(). void RWebWindow::SetPanelName ; (; const std::string & ; name). Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel.html"" as default HTML page At the moment only FitPanel is existing. ; Definition at line 132 of file RWebWindow.cxx. ◆ SetPosition(). void ROOT::RWebWindow::SetPosition ; (; unsigned ; x, . unsigned ; y . ). inline . Set window position. Will be applied if supported by used web display (like CEF or Chromium) ; Definition at line 269 of file RWebWindow.hxx. ◆ SetRequireAuthKey(). void ROOT::RWebWindow::SetRequireAuthKey ; (; bool ; on). inline . Configure if authentication key in connection string is required. ; Definition at line 316 of file RWebWindow.hxx. ◆ SetStartDialogFunc(). void RWebWindow::SetStartDialogFunc ; (; std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> ; func). staticprivate . Confi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:46894,timeout,timeout,46894,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['timeout'],['timeout']
Safety,"◆ SetDisconnectCallBack(). void RWebWindow::SetDisconnectCallBack ; (; WebWindowConnectCallback_t ; func). Set call-back function for disconnecting. ; Definition at line 1795 of file RWebWindow.cxx. ◆ SetGeometry(). void ROOT::RWebWindow::SetGeometry ; (; unsigned ; width, . unsigned ; height . ). inline . Set window geometry. Will be applied if supported by used web display (like CEF or Chromium) ; Definition at line 265 of file RWebWindow.hxx. ◆ SetMaxQueueLength(). void ROOT::RWebWindow::SetMaxQueueLength ; (; unsigned ; len = 10). inline . configures maximal queue length of data which can be held by window ; Definition at line 303 of file RWebWindow.hxx. ◆ SetNativeOnlyConn(). void ROOT::RWebWindow::SetNativeOnlyConn ; (; bool ; on = true). inline . configures that only native (own-created) connections are allowed ; Definition at line 311 of file RWebWindow.hxx. ◆ SetOperationTmout(). void ROOT::RWebWindow::SetOperationTmout ; (; float ; tm = 50.). inline . Set timeout for synchronous WebWindow operations. ; Definition at line 357 of file RWebWindow.hxx. ◆ SetPanelName(). void RWebWindow::SetPanelName ; (; const std::string & ; name). Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel.html"" as default HTML page At the moment only FitPanel is existing. ; Definition at line 132 of file RWebWindow.cxx. ◆ SetPosition(). void ROOT::RWebWindow::SetPosition ; (; unsigned ; x, . unsigned ; y . ). inline . Set window position. Will be applied if supported by used web display (like CEF or Chromium) ; Definition at line 272 of file RWebWindow.hxx. ◆ SetRequireAuthKey(). void ROOT::RWebWindow::SetRequireAuthKey ; (; bool ; on). inline . Configure if authentication key in connection string is required. ; Definition at line 319 of file RWebWindow.hxx. ◆ SetStartDialogFunc(). void RWebWindow::SetStartDialogFunc ; (; std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> ; func). staticprivate . Confi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:45778,timeout,timeout,45778,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['timeout'],['timeout']
Security," "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working with date/time parameters. The current implementation supports date, time, date&time and timestamp; data (all time intervals are not supported yet). To set or get date/time values,; the following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware that TDatime supports only dates after 1995-01-01.; There are also methods to get year, month, day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typicall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLStatement.html:8714,access,access,8714,root/html534/TSQLStatement.html,https://root.cern,https://root.cern/root/html534/TSQLStatement.html,1,['access'],['access']
Security," """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Int_t Compare(const TObject* obj) const; Compare two TNamed objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp). void Copy(TObject& named) const; Copy this to obj. void FillBuffer(char*& buffer); Encode TNamed into output buffer. void ls(Option_t* option = """") const; List TNamed name and title. void Print(Option_t* option = """") const; Print TNamed name and title. void SetName(const char* name); Change (i.e. set) the name of the TNamed.; WARNING: if the object is a member of a THashTable or THashList container; the container must be Rehash()'ed after SetName(). For example the list; of objects in the current directory is a THashList. void SetNameTitle(const char* name, const char* title); Change (i.e. set) all the TNamed parameters (name and title).; WARNING: if the name is changed and the object is a member of a; THashTable or THashList container the container must be Rehash()'ed; after SetName(). For example the list of objects in the current; directory is a THashList. void SetTitle(const char* title = """"); Change (i.e. set) the title of the TNamed. Int_t Sizeof() const; Return size of the TNamed part of the TObject. TNamed(); { }. TNamed(const char* name, const char* title); { }. TNamed(const TString& name, const TString& title); { }. virtual ~TNamed(); { }. const char * GetName() const; { return fName; }. const char * GetTitle() const; { return fTitle; }. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsSortable() const; { return kTRUE; }. » Author: Rene Brun 26/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TNamed.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNamed.html:7439,Hash,Hash,7439,root/html528/TNamed.html,https://root.cern,https://root.cern/root/html528/TNamed.html,2,['Hash'],['Hash']
Security," """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Int_t Compare(const TObject* obj) const; Compare two TNamed objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp). void Copy(TObject& named) const; Copy this to obj. void FillBuffer(char*& buffer); Encode TNamed into output buffer. void ls(Option_t* option = """") const; List TNamed name and title. void Print(Option_t* option = """") const; Print TNamed name and title. void SetName(const char* name); Change (i.e. set) the name of the TNamed.; WARNING: if the object is a member of a THashTable or THashList container; the container must be Rehash()'ed after SetName(). For example the list; of objects in the current directory is a THashList. void SetNameTitle(const char* name, const char* title); Change (i.e. set) all the TNamed parameters (name and title).; WARNING: if the name is changed and the object is a member of a; THashTable or THashList container the container must be Rehash()'ed; after SetName(). For example the list of objects in the current; directory is a THashList. void SetTitle(const char* title = """"); Change (i.e. set) the title of the TNamed. Int_t Sizeof() const; Return size of the TNamed part of the TObject. TNamed(); { }. TNamed(const char* name, const char* title); { }. TNamed(const TString& name, const TString& title); { }. virtual ~TNamed(); { }. const char * GetName() const; { return fName; }. const char * GetTitle() const; { return fTitle; }. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsSortable() const; { return kTRUE; }. » Author: Rene Brun 26/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TNamed.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNamed.html:7508,Hash,Hash,7508,root/html530/TNamed.html,https://root.cern,https://root.cern/root/html530/TNamed.html,2,['Hash'],['Hash']
Security," """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Int_t Compare(const TObject* obj) const; Compare two TNamed objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp). void Copy(TObject& named) const; Copy this to obj. void FillBuffer(char*& buffer); Encode TNamed into output buffer. void ls(Option_t* option = """") const; List TNamed name and title. void Print(Option_t* option = """") const; Print TNamed name and title. void SetName(const char* name); Change (i.e. set) the name of the TNamed.; WARNING: if the object is a member of a THashTable or THashList container; the container must be Rehash()'ed after SetName(). For example the list; of objects in the current directory is a THashList. void SetNameTitle(const char* name, const char* title); Change (i.e. set) all the TNamed parameters (name and title).; WARNING: if the name is changed and the object is a member of a; THashTable or THashList container the container must be Rehash()'ed; after SetName(). For example the list of objects in the current; directory is a THashList. void SetTitle(const char* title = """"); Change (i.e. set) the title of the TNamed. Int_t Sizeof() const; Return size of the TNamed part of the TObject. TNamed(); { }. TNamed(const char* name, const char* title); { }. TNamed(const TString& name, const TString& title); { }. virtual ~TNamed(); { }. const char * GetName() const; { return fName; }. const char * GetTitle() const; { return fTitle; }. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsSortable() const; { return kTRUE; }. » Author: Rene Brun 26/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TNamed.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNamed.html:7508,Hash,Hash,7508,root/html532/TNamed.html,https://root.cern,https://root.cern/root/html532/TNamed.html,2,['Hash'],['Hash']
Security," """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE); Constructor. param url: URL of the entry-point server to be contacted; param mode: initial file access mode; param title: title of the file (shown by ROOT browser); param compress: compression level and algorithm; param netopt: TCP window size in bytes (unused); param parallelopen: open asynchronously. ~TNetXNGFile(); Destructor. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Long64_t GetSize() const; Get the file size. Returns -1 in the case that the file could not be; stat'ed. Bool_t IsOpen() const; Check if the file is open. void SetAsyncOpenStatus(TFile::EAsyncOpenStatus status); Set the status of an asynchronous file open. void Close(const Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGFile.html:25314,access,access,25314,root/html602/TNetXNGFile.html,https://root.cern,https://root.cern/root/html602/TNetXNGFile.html,2,['access'],['access']
Security," ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote ser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:22106,authenticat,authentication,22106,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,5,['authenticat'],['authentication']
Security," ""title"", 10, 0, 10), ""x""); ; print(sum.GetValue()); h.Draw(); The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all parts of the RDataFrame API currently work with this package. The subset that is currently available is:; AsNumpy; Count; Define; DefinePerSample; Filter; Graph; Histo[1,2,3]D; HistoND; Max; Mean; Min; Profile[1,2,3]D; Redefine; Snapshot; Stats; StdDev; Sum; Systematic variations: Vary and VariationsFor.; Parallel submission of distributed graphs: RunGraphs.; Information about the dataframe: GetColumnNames. with support for more operations coming in the future. Data sources other than TTree and TChain (e.g. CSV, RNTuple) are currently not supported.; NoteThe distributed RDataFrame module requires at least Python version 3.8. Connecting to a Spark cluster; In order to distribute the RDataFrame workload, you can connect to a Spark cluster you have access to through the official Spark API, then hook the connection instance to the distributed RDataFrame object like so:; import pyspark; import ROOT; ; # Create a SparkContext object with the right configuration for your Spark cluster; conf = SparkConf().setAppName(appName).setMaster(master); sc = SparkContext(conf=conf); ; # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); If an instance of SparkContext is not provided, the default behaviour is to create one in the background for you. Connecting to a Dask cluster; Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one of the cluster schedulers supported by Dask (more information in the Dask distributed docs):; import ROOT; from dask.distributed import Clien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:36510,access,access,36510,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['access'],['access']
Security," # with the @pythonization decorator. Such decorator allows us to define which; # which class we want to pythonize by providing its class name and its; # namespace (if the latter is not specified, it defaults to the global; # namespace, i.e. '::').; #; # The decorated function - the pythonizor - must accept either one or two; # parameters:; # 1. The class to be pythonized (proxy object where new behaviour can be; # injected); # 2. The fully-qualified name of that class (optional).; #; # Let's see all this with a simple example. Suppose I would like to define how; # `MyClass` objects are represented as a string in Python (i.e. what would be; # shown when I print that object). For that purpose, I can define the following; # pythonizor function. There are two important things to be noted here:; # - The @pythonization decorator has one argument that specifies our target; # class is `MyClass`.; # - The pythonizor function `pythonizor_of_myclass` provides and injects a new; # implementation for `__str__`, the mechanism that Python provides to define; # how to represent objects as strings. This new implementation; # always returns the string ""This is a MyClass object"".; @pythonization('MyClass'); def pythonizor_of_myclass(klass):; klass.__str__ = lambda o : 'This is a MyClass object'; ; # Once we have defined our pythonizor function, let's see it in action.; # We will now use the `MyClass` class for the first time from Python: we will; # create a new instance of that class. At this moment, the pythonizor will; # execute and modify the class - pythonizors are always lazily run when a given; # class is used for the first time from a Python script.; my_object = ROOT.MyClass(); ; # Since the pythonizor already executed, we should now see the new behaviour.; # For that purpose, let's print `my_object` (should show ""This is a MyClass; # object"").; print(my_object); ; # The previous example is just a simple one, but there are many ways in which a; # class can be pythonized. Typic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html:2287,inject,injects,2287,doc/master/pyroot002__pythonizationDecorator_8py.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html,1,['inject'],['injects']
Security, #include <ROOT/TRWSpinLock.hxx>; Constructor & Destructor Documentation. ◆ TRWSpinLock(). ROOT::TRWSpinLock::TRWSpinLock ; (; ). inline . Regular constructor. ; Definition at line 34 of file TRWSpinLock.hxx. Member Function Documentation. ◆ ReadLock(). void TRWSpinLock::ReadLock ; (; ). Acquire the lock in read mode. ; Definition at line 35 of file TRWSpinLock.cxx. ◆ ReadUnLock(). void TRWSpinLock::ReadUnLock ; (; ). Release the lock in read mode. ; Definition at line 61 of file TRWSpinLock.cxx. ◆ WriteLock(). void TRWSpinLock::WriteLock ; (; ). Acquire the lock in write mode. ; Definition at line 77 of file TRWSpinLock.cxx. ◆ WriteUnLock(). void TRWSpinLock::WriteUnLock ; (; ). Release the lock in write mode. ; Definition at line 102 of file TRWSpinLock.cxx. Member Data Documentation. ◆ fCond. std::condition_variable_any ROOT::TRWSpinLock::fCond. private . ! RWlock internal condition variable ; Definition at line 29 of file TRWSpinLock.hxx. ◆ fMutex. ROOT::TSpinMutex ROOT::TRWSpinLock::fMutex. private . ! RWlock internal mutex ; Definition at line 28 of file TRWSpinLock.hxx. ◆ fReaderReservation. std::atomic<int> ROOT::TRWSpinLock::fReaderReservation. private . ! A reader wants access ; Definition at line 25 of file TRWSpinLock.hxx. ◆ fReaders. std::atomic<int> ROOT::TRWSpinLock::fReaders. private . ! Number of readers ; Definition at line 24 of file TRWSpinLock.hxx. ◆ fWriter. std::atomic<bool> ROOT::TRWSpinLock::fWriter. private . ! Is there a writer? ; Definition at line 27 of file TRWSpinLock.hxx. ◆ fWriterReservation. std::atomic<int> ROOT::TRWSpinLock::fWriterReservation. private . ! A writer wants access ; Definition at line 26 of file TRWSpinLock.hxx. Libraries for ROOT::TRWSpinLock:. [legend]; The documentation for this class was generated from the following files:; core/thread/inc/ROOT/TRWSpinLock.hxx; core/thread/src/TRWSpinLock.cxx. ROOTTRWSpinLock. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:00 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TRWSpinLock.html:2199,access,access,2199,doc/master/classROOT_1_1TRWSpinLock.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TRWSpinLock.html,2,['access'],['access']
Security," & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::PrependTString & Prepend(const char *cs)Definition TString.h:673; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetIncludePathvirtual const char * GetIncludePath()Get the list of include path.Definition TSystem.cxx:3973; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSyst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:102735,secur,secure,102735,doc/master/TTreeProxyGenerator_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html,1,['secur'],['secure']
Security," && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 705 typedef unsigned long uint32_t;; 706 typedef unsigned __int64 uint64_t;; 707#else // defined(_MSC_VER); 708 // Other compilers; 709#include <stdint.h>; 710#endif // !defined(_MSC_VER); 711 ; 712 // From MurmurHash.cpp:; 713#if defined(_MSC_VER); 714 // Microsoft Visual Studio; 715#include <stdlib.h>; 716#define ROTL64(x,y) _rotl64(x,y); 717#define BIG_CONSTANT(x) (x); 718#else // defined(_MSC_VER); 719 // Other compilers; 720 inline uint64_t rotl64 ( uint64_t x, int8_t r ); 721 {; 722 return (x << r) | (x >> (64 - r));; 723 }; 724 ; 725#define ROTL64(x,y) rotl64(x,y); 726#define BIG_CONSTANT(x) (x##LLU); 727#endif // !defined(_MSC_VER); 728 ; 729namespace {; 730 ; 731 /////////////////////////////////////////////////////////////////////////////; 732 /// Block read - if your platform needs to do endian-swapping or can only; 733 /// handle aligned reads, do the conversion here; 734 ; 735 R__ALWAYS_INLINE uint64_t getblock(const uint64_t* p, int i); 736 {; 737 return p[i];; 738 }; 739 ; 740 /////////////////////////////////////////////////////////////////////////////; 741 /// Finalization mix - force all bits of a hash block to avalanche; 742 ; 743 R__ALWAYS_INLINE uint64_t fmix(uint64_t k); 744 {; 745 k ^= k >> 33;; 746 k *= BIG_CONSTANT(0xff51afd7ed558ccd);; 747 k ^= k >> 33;; 748 k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);; 749 k ^= k >> 33;; 750 ; 751 return k;; 752 }; 753 ; 754 /////////////////////////////////////////////////////////////////////////////; 755 /// ""key"" is input to be hashed.; 756 /// ""len"" is the number of bytes to hash starting at ""key"".; 757 /// ""seed"" is a hash seed, ""out"" is a buffer (128 bytes) that will receive; 758 /// the results.; 759 ; 760 static void MurmurHash3_x64_128(const void * key, const int len,; 761 const uint32_t seed, uint64_t out[2] ); 762 {; 763 const uint8_t * data = (const uint8_t*)key;; 764 const int nblocks = len / 16;; 765 ; 766 uin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:22216,hash,hash,22216,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,2,['hash'],"['hash', 'hashed']"
Security," &= ~kIsReferenced;; 281 fBits &= ~kCanDelete;; 282 ; 283 // Set only after used in above call; 284 fUniqueID = obj.fUniqueID; // when really unique don't copy; 285 ; 286#ifdef R__WIN32; 287 if (R__unlikely(GetObjectStat())) TObject::AddToTObjectTable(this);; 288#else; 289 if (R__unlikely(fgObjectStat)) TObject::AddToTObjectTable(this);; 290#endif; 291}; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// TObject assignment operator.; 295 ; 296inline TObject &TObject::operator=(const TObject &rhs); 297{; 298 if (R__likely(this != &rhs)) {; 299 fUniqueID = rhs.fUniqueID; // when really unique don't copy; 300 if (IsOnHeap()) { // test uses fBits so don't move next line; 301 fBits = rhs.fBits;; 302 fBits |= kIsOnHeap;; 303 } else {; 304 fBits = rhs.fBits;; 305 fBits &= ~kIsOnHeap;; 306 }; 307 fBits &= ~kIsReferenced;; 308 fBits &= ~kCanDelete;; 309 }; 310 return *this;; 311}; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// @brief Check and record whether this class has a consistent; 316/// Hash/RecursiveRemove setup (*) and then return the regular Hash value for; 317/// this object. The intent is for this routine to be called instead of directly; 318/// calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; 319///; 320/// (*) The setup is consistent when all classes in the class hierarchy that overload; 321/// TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 322/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 323 ; 324inline ULong_t TObject::CheckedHash(); 325{; 326 // Testing and recording whether we already called HasInconstistentTObjectHash; 327 // for this object could save some cpu cycles in some circuntances (at the cost; 328 // of reserving yet another bit).; 329 // For each insert (CheckedHash is called only for insert in THashList/THashTable), it;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8h_source.html:12989,Hash,Hash,12989,doc/master/TObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html,2,['Hash'],['Hash']
Security," &ClassDef_StreamerNVirtual_b);  ; Bool_t TestShapeBit (UInt_t f) const;  ; Int_t TestShapeBits (UInt_t f) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:9864,Hash,Hash,9864,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,54,"['Hash', 'hash']","['Hash', 'hash']"
Security," &errUp, int option=0);  minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run ;  ; virtual bool GetVariableSettings (unsigned int ivar, ROOT::Fit::ParameterSettings &pars) const;  get variable settings in a variable object (like ROOT::Fit::ParamsSettings) ;  ; virtual double GlobalCC (unsigned int ivar) const;  return global correlation coefficient for variable i This is a number between zero and one which gives the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i. ;  ; virtual bool Hesse ();  perform a full calculation of the Hessian matrix for error calculation ;  ; virtual bool IsFixedVariable (unsigned int ivar) const;  query if an existing variable is fixed (i.e. ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual const double * MinGradient () const;  return pointer to gradient values at the minimum ;  ; virtual bool Minimize ()=0;  method to perform the minimization ;  ; virtual int MinosStatus () const;  status code of Minos (to be re-implemented by the minimizers supporting Minos) ;  ; virtual double MinValue () const =0;  return minimum function value ;  ; virtual unsigned int NCalls () const;  number of function calls to reach the minimum ;  ; virtual unsigned int NDim () const =0;  this is <= Function().NDim() which is the total number of variables (free+ constrained ones) ;  ; virtual unsigned int NFree () const;  number of free variables (real dimension of the problem) this is <= Function().NDim() which is the total (re-implement if minimizer supports bounded parameter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:7204,validat,validation,7204,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['validat'],['validation']
Security," &errUp, int option=0);  minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run ;  ; virtual bool GetVariableSettings (unsigned int ivar, ROOT::Fit::ParameterSettings &pars) const;  get variable settings in a variable object (like ROOT::Fit::ParamsSettings) ;  ; virtual double GlobalCC (unsigned int ivar) const;  return global correlation coefficient for variable i This is a number between zero and one which gives the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i. ;  ; virtual bool Hesse ();  perform a full calculation of the Hessian matrix for error calculation ;  ; virtual bool IsFixedVariable (unsigned int ivar) const;  query if an existing variable is fixed (i.e. ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual int MinosStatus () const;  status code of Minos (to be re-implemented by the minimizers supporting Minos) ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimizer configuration parameters ;  ; virtual void PrintResults ();  return reference to the objective function virtual const ROOT::Math::IGenFunction & Function() const = 0; ;  ; virtual bool ReleaseVariable (unsigned int ivar);  release an existing variable ;  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html:5704,validat,validation,5704,doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html,1,['validat'],['validation']
Security," &errUp, int option=0);  minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run ;  ; virtual bool GetVariableSettings (unsigned int ivar, ROOT::Fit::ParameterSettings &pars) const;  get variable settings in a variable object (like ROOT::Fit::ParamsSettings) ;  ; virtual double GlobalCC (unsigned int ivar) const;  return global correlation coefficient for variable i This is a number between zero and one which gives the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i. ;  ; virtual bool Hesse ();  perform a full calculation of the Hessian matrix for error calculation ;  ; virtual bool IsFixedVariable (unsigned int ivar) const;  query if an existing variable is fixed (i.e. ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual int MinosStatus () const;  status code of Minos (to be re-implemented by the minimizers supporting Minos) ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimizer configuration parameters ;  ; virtual void PrintResults ();  return reference to the objective function virtual const ROOT::Math::IGenFunction & Fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearMinimizer.html:5465,validat,validation,5465,doc/master/classTLinearMinimizer.html,https://root.cern,https://root.cern/doc/master/classTLinearMinimizer.html,2,['validat'],['validation']
Security," &func, const ::ROOT::EExecutionPolicy &executionPolicy=::ROOT::EExecutionPolicy::kSequential);  Constructor from data set (binned ) and model function. ;  ; virtual ~Chi2FCN ();  Destructor (no operations) ;  ; virtual BaseFunction * Clone () const;  ; virtual double DataElement (const double *x, unsigned int i, double *g, double *h=nullptr, bool fullHessian=false) const;  i-th chi-square residual ;  ; virtual void Gradient (const double *x, double *g) const;  ; Chi2FCN & operator= (const Chi2FCN &rhs);  Assignment operator. ;  ; virtual BaseObjFunction::Type_t Type () const;  get type of fit method function ;  ;  Public Member Functions inherited from ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >; virtual const DataType & Data () const;  access to const reference to the data ;  ; std::shared_ptr< DataType > DataPtr () const;  access to data pointer ;  ; virtual bool HasHessian () const;  flag to indicate if can compute Hessian ;  ; virtual const IModelFunction & ModelFunction () const;  access to const reference to the model function ;  ; std::shared_ptr< IModelFunction > ModelFunctionPtr () const;  access to function pointer ;  ;  Public Member Functions inherited from ROOT::Math::BasicFitMethodFunction< DerivFunType >;  BasicFitMethodFunction (int dim, int npoint);  ;  ~BasicFitMethodFunction () override;  Virtual Destructor (no operations) ;  ; virtual bool G2 (const double *, double *) const;  Computes the Second derivatives. ;  ; virtual bool Hessian (const double *x, double *hess) const;  Computes the full Hessian. ;  ; bool IsAGradFCN ();  ; virtual unsigned int NCalls () const;  return the total number of function calls (override if needed) ;  ; unsigned int NDim () const override;  Number of dimension (parameters) . ;  ; virtual unsigned int NPoints () const;  return the number of data points used in evaluating the function ;  ; virtual void ResetNCalls ();  reset number of function calls ;  ; virtual void UpdateNCalls () const;  update numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Chi2FCN.html:2484,access,access,2484,doc/master/classROOT_1_1Fit_1_1Chi2FCN.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Chi2FCN.html,5,"['HasH', 'access']","['HasHessian', 'access']"
Security," '%s' has a base class (%s) that the in-memory layout version %d does not have"",; 2926 GetClassVersion(), GetName(), localClass.Data(), GetClassVersion());; 2927 } else {; 2928 Warning(""CompareContent"",; 2929 ""One base class of the on-file layout version %d and of the in memory layout version %d for '%s' is different: '%s' vs '%s'"",; 2930 GetClassVersion(), GetClassVersion(), GetName(), localClass.Data(), otherClass.Data());; 2931 }; 2932 }; 2933 if (!complete) return kFALSE;; 2934 result = result && kFALSE;; 2935 }; 2936 if (cl) {; 2937 TStreamerBase *localBase = dynamic_cast<TStreamerBase*>(el);; 2938 if (!localBase) continue;; 2939 // We already have localBaseClass == otherBaseClass; 2940 TClass *otherBaseClass = localBase->GetClassPointer();; 2941 if (!otherBaseClass) continue;; 2942 if (otherBaseClass->IsVersioned() && localBase->GetBaseVersion() != otherBaseClass->GetClassVersion()) {; 2943 TString msg;; 2944 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 2945 "" has the same version (=%d) as the active class but a different checksum.\n""; 2946 "" You should update the version to ClassDef(%s,%d).\n""; 2947 "" The objects on this file might not be readable because:\n""; 2948 "" The in-memory layout version %d for class '%s' has a base class (%s) with version %d but the on-file layout version %d recorded the version number %d for this base class (%s)."",; 2949 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2950 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetClassVersion(),; 2951 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 2952 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2953 otherBase->SetErrorMessage(msg);; 2954 ; 2955 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBaseClass->GetCheckSum()) {; 2956 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:116792,checksum,checksum,116792,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['checksum'],['checksum']
Security," ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 fEnv->fIdx = idx - fEnv->fIdx;; 158 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 159 fNext.invoke(fEnv);; 160 fEnv->fIdx = idx;; 161 break;; 162 }; 163 typedef ROOT::TCollectionProxyInfo::Environ<std::pair<size_t,Bool_t> > EnvType_t;; 164 EnvType_t *e = (EnvType_t*)fEnv;; 165 return &(e->fIterator.second);; 166 }; 167 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 168 return 0;; 169 }; 170 ; 171 void DeleteItem(Bool_t force, void* ptr) const override; 172 {; 173 // Call to delete/destruct individual item; 174 if ( force && ptr ) {; 175 fVal->DeleteItem(ptr);; 176 }; 177 }; 178};; 179 ; 180/*; 181\class TGenListProxy; 182\ingroup IO; 183Local optimization class.; 184 ; 185Collection proxies get copied. On copy we switch the type of the; 186proxy to the concrete STL type. The concrete types are optimized; 187for element access.; 188**/; 189 ; 190class TGenListProxy : public TGenVectorProxy {; 191public:; 192 // Standard Destructor; 193 TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 194 {; 195 }; 196 // Standard Destructor; 197 ~TGenListProxy() override; 198 {; 199 }; 200 // Return the address of the value at index 'idx'; 201 void* At(UInt_t idx) override; 202 {; 203 if ( fEnv && fEnv->fObject ) {; 204 switch( idx ) {; 205 case 0:; 206 fEnv->fIdx = idx;; 207 return fEnv->fStart = fFirst.invoke(fEnv);; 208 default: {; 209 fEnv->fIdx = idx - fEnv->fIdx;; 210 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 211 void* result = fNext.invoke(fEnv);; 212 fEnv->fIdx = idx;; 213 return result;; 214 }; 215 }; 216 }; 217 Fatal(""TGenListProxy"",""At> Logic error - no proxy object set."");; 218 return nullptr;; 219 }; 220};; 221 ; 222/**; 223\class TGenSetProxy; 224\ingroup IO; 225Localoptimization class.; 226 ; 227Collection proxies get copied. On copy we switch the ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:5482,access,access,5482,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['access'],['access']
Security," (%d)."",; 7306 GetName(),slot);; 7307 }; 7308 fStreamerInfo->AddAtAndExpand(info, slot);; 7309 if (fState <= kForwardDeclared) {; 7310 fState = kEmulated;; 7311 if (fCheckSum==0 && slot==fClassVersion) fCheckSum = info->GetCheckSum();; 7312 }; 7313 }; 7314}; 7315 ; 7316////////////////////////////////////////////////////////////////////////////////; 7317/// Remove and delete the StreamerInfo in the given slot.; 7318/// Update the slot accordingly.; 7319 ; 7320void TClass::RemoveStreamerInfo(Int_t slot); 7321{; 7322 if (fStreamerInfo->GetSize() >= slot) {; 7323 R__LOCKGUARD(gInterpreterMutex);; 7324 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->At(slot);; 7325 fStreamerInfo->RemoveAt(fClassVersion);; 7326 if (fLastReadInfo.load() == info); 7327 fLastReadInfo = nullptr;; 7328 if (fCurrentInfo.load() == info); 7329 fCurrentInfo = nullptr;; 7330 delete info;; 7331 if (fState == kEmulated && fStreamerInfo->GetEntries() == 0) {; 7332 fState = kForwardDeclared;; 7333 }; 7334 }; 7335}; 7336 ; 7337////////////////////////////////////////////////////////////////////////////////; 7338/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7339/// classes in the class hierarchy that overload TObject::Hash do call; 7340/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7341/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7342/// This routines is used for a small subset of the class for which we need; 7343/// the answer before gROOT is properly initialized.; 7344 ; 7345Bool_t ROOT::Internal::HasConsistentHashMember(const char *cname); 7346{; 7347 // Hand selection of correct classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static const char *handVerified[] = {; 7350 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7351 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:281492,Hash,Hash,281492,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Hash'],['Hash']
Security," (%d)."",; 7373 GetName(),slot);; 7374 }; 7375 fStreamerInfo->AddAtAndExpand(info, slot);; 7376 if (fState <= kForwardDeclared) {; 7377 fState = kEmulated;; 7378 if (fCheckSum==0 && slot==fClassVersion) fCheckSum = info->GetCheckSum();; 7379 }; 7380 }; 7381}; 7382 ; 7383////////////////////////////////////////////////////////////////////////////////; 7384/// Remove and delete the StreamerInfo in the given slot.; 7385/// Update the slot accordingly.; 7386 ; 7387void TClass::RemoveStreamerInfo(Int_t slot); 7388{; 7389 if (fStreamerInfo->GetSize() >= slot) {; 7390 R__LOCKGUARD(gInterpreterMutex);; 7391 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->At(slot);; 7392 fStreamerInfo->RemoveAt(fClassVersion);; 7393 if (fLastReadInfo.load() == info); 7394 fLastReadInfo = nullptr;; 7395 if (fCurrentInfo.load() == info); 7396 fCurrentInfo = nullptr;; 7397 delete info;; 7398 if (fState == kEmulated && fStreamerInfo->GetEntries() == 0) {; 7399 fState = kForwardDeclared;; 7400 }; 7401 }; 7402}; 7403 ; 7404////////////////////////////////////////////////////////////////////////////////; 7405/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7406/// classes in the class hierarchy that overload TObject::Hash do call; 7407/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7408/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7409/// This routines is used for a small subset of the class for which we need; 7410/// the answer before gROOT is properly initialized.; 7411 ; 7412Bool_t ROOT::Internal::HasConsistentHashMember(const char *cname); 7413{; 7414 // Hand selection of correct classes, those classes should be; 7415 // cross-checked in testHashRecursiveRemove.cxx; 7416 static const char *handVerified[] = {; 7417 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7418 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7419 ""TCh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:284243,Hash,Hash,284243,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Hash'],['Hash']
Security," () const;  ; RFieldBase & GetMutableField (std::string_view fieldName);  ; RFieldZero & GetMutableFieldZero ();  Mutable access to the root field is used to make adjustments to the fields. ;  ; const std::unordered_set< std::string > & GetRegisteredSubfields () const;  Get the (qualified) names of subfields that have been registered to be included in entries from this model. ;  ; std::uint64_t GetSchemaId () const;  ; REntry::RFieldToken GetToken (std::string_view fieldName) const;  Creates a token to be used in REntry methods to address a field present in the entry. ;  ; bool IsBare () const;  ; bool IsFrozen () const;  ; template<typename T , typename... ArgsT> ; std::shared_ptr< T > MakeField (const NameWithDescription_t &fieldNameDesc, ArgsT &&...args);  Creates a new field given a name or {name, description} pair and a corresponding value that is managed by a shared pointer. ;  ; RNTupleModel & operator= (const RNTupleModel &)=delete;  ; void RegisterSubfield (std::string_view qualifiedFieldName);  Register a subfield so it can be accessed directly from entries belonging to the model. ;  ; void SetDescription (std::string_view description);  ; void Unfreeze ();  . Static Public Member Functions; static std::unique_ptr< RNTupleModel > Create ();  ; static std::unique_ptr< RNTupleModel > Create (std::unique_ptr< RFieldZero > fieldZero);  ; static std::unique_ptr< RNTupleModel > CreateBare ();  A bare model has no default entry. ;  ; static std::unique_ptr< RNTupleModel > CreateBare (std::unique_ptr< RFieldZero > fieldZero);  . Private Member Functions;  RNTupleModel (std::unique_ptr< RFieldZero > fieldZero);  ; void AddSubfield (std::string_view fieldName, REntry &entry, bool initializeValue=true) const;  Add a subfield to the provided entry. ;  ; void EnsureNotBare () const;  Throws an RException if fDefaultEntry is nullptr. ;  ; void EnsureNotFrozen () const;  Throws an RException if fFrozen is true. ;  ; void EnsureValidFieldName (std::string_view fieldName);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html:3847,access,accessed,3847,doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,1,['access'],['accessed']
Security," () const;  ; virtual void Init (Int_t ndim, const Int_t *nbins, bool addOverflow=false);  ; TClass * IsA () const override;  ; virtual void Reset (Option_t *option="""")=0;  ; virtual void SetAsDouble (ULong64_t linidx, Double_t value)=0;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNDArray.html:2032,Hash,Hash,2032,doc/master/classTNDArray.html,https://root.cern,https://root.cern/doc/master/classTNDArray.html,2,['Hash'],['Hash']
Security," (; ). constexpr . \( \frac{G}{\hbar C} \) in \( (GeV/c^{2})^{-2} \) ; Definition at line 158 of file TMath.h. ◆ GhbarCUncertainty(). constexpr Double_t TMath::GhbarCUncertainty ; (; ). constexpr . \( \frac{G}{\hbar C} \) uncertainty. ; Definition at line 166 of file TMath.h. ◆ Gn(). constexpr Double_t TMath::Gn ; (; ). constexpr . Standard acceleration of gravity in \( m s^{-2} \). ; Definition at line 174 of file TMath.h. ◆ GnUncertainty(). constexpr Double_t TMath::GnUncertainty ; (; ). constexpr . Standard acceleration of gravity uncertainty. ; Definition at line 181 of file TMath.h. ◆ GUncertainty(). constexpr Double_t TMath::GUncertainty ; (; ). constexpr . Gravitational constant uncertainty. ; Definition at line 150 of file TMath.h. ◆ H(). constexpr Double_t TMath::H ; (; ). constexpr . Planck's constant in \( J s \): \( h \). ; Definition at line 188 of file TMath.h. ◆ Hash() [1/2]. ULong_t TMath::Hash ; (; const char * ; str). Definition at line 1416 of file TMath.cxx. ◆ Hash() [2/2]. ULong_t TMath::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). Calculates hash index from any char string. ; Based on pre-calculated table of 256 specially selected numbers. These numbers are selected in such a way, that for string length == 4 (integer number) the hash is unambiguous, i.e. from hash value we can recalculate input (no degeneration).; The quality of hash method is good enough, that ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N) tested by <R>, <R*R>, <Ri*Ri+1> gives the same result as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*)); V.Perev; This function is kept for back compatibility. The code previously in this function has been moved to the static function TString::Hash . Definition at line 1408 of file TMath.cxx. ◆ Hbar(). constexpr Double_t TMath::Hbar ; (; ). constexpr . \( \hbar \) in \( J s \): \( \hbar = \frac{h}{2\pi} \) ; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:46655,Hash,Hash,46655,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['Hash'],['Hash']
Security," (; ); const. inline . Definition at line 110 of file TEnv.h. ◆ Hash(). ULong_t TEnvRec::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TEnvRec::HashULong_t Hash() const overrideReturn hash value for this object.Definition TEnv.h:113; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 113 of file TEnv.h. ◆ IsA(). TClass * TEnvRec::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 115 of file TEnv.h. ◆ Streamer(). void TEnvRec::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TEnvRec::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 115 of file TEnv.h. Friends And Related Symbol Documentation. ◆ TEnv. friend cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEnvRec.html:13915,Hash,Hash,13915,doc/master/classTEnvRec.html,https://root.cern,https://root.cern/doc/master/classTEnvRec.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security, (; Bool_t ; on = kTRUE). Set/Reset the 'OldStreamer' bit in this instance and its elements. ; Needed for backward compatibility in talking to old client / masters. ; Definition at line 1874 of file TDSet.cxx. ◆ SplitEntryList(). void TDSet::SplitEntryList ; (; ). private . for browsing purposes ; Splits the main entry (or event) list into sub-lists for the elements of thet data set. ; Definition at line 1941 of file TDSet.cxx. ◆ StartViewer(). void TDSet::StartViewer ; (; ). virtual . Start the TTreeViewer on this TTree. ; Definition at line 1520 of file TDSet.cxx. ◆ Streamer(). void TDSet::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TDSet. ; Reimplemented from TObject.; Reimplemented in TDSetProxy.; Definition at line 1813 of file TDSet.cxx. ◆ StreamerNVirtual(). void TDSet::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 262 of file TDSet.h. ◆ Validate() [1/2]. void TDSet::Validate ; (; ). Validate the TDSet by opening files. ; Definition at line 1589 of file TDSet.cxx. ◆ Validate() [2/2]. void TDSet::Validate ; (; TDSet * ; dset). Validate the TDSet against another TDSet. ; Only validates elements in common from input TDSet. ; Definition at line 1668 of file TDSet.cxx. Member Data Documentation. ◆ fCurrent. TDSetElement* TDSet::fCurrent. protected . iterator on fElements ; Definition at line 182 of file TDSet.h. ◆ fDir. TString TDSet::fDir. protected . Definition at line 177 of file TDSet.h. ◆ fElements. THashList* TDSet::fElements. protected . Definition at line 180 of file TDSet.h. ◆ fEntryList. TObject* TDSet::fEntryList. private . Definition at line 168 of file TDSet.h. ◆ fIsTree. Bool_t TDSet::fIsTree. private . Definition at line 167 of file TDSet.h. ◆ fIterator. TIter* TDSet::fIterator. protected . Definition at line 181 of file TDSet.h. ◆ fObjName. TString TDSet::fObjName. protected . Definition at line 179 of file TDSet.h. ◆ fProofChain. TProofChain* TDSet::fProofChain. private ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSet.html:29753,Validat,Validate,29753,doc/master/classTDSet.html,https://root.cern,https://root.cern/doc/master/classTDSet.html,1,['Validat'],['Validate']
Security," (; Long64_t ; bin, . Double_t ; e2 . ). overridevirtual . Set error of bin with index ""bin"" to ""e"", enable errors if needed. ; Implements THnBase.; Definition at line 914 of file THnSparse.cxx. ◆ SetFilledBins(). void THnSparse::SetFilledBins ; (; Long64_t ; nbins). inlineoverridevirtual . Reimplemented from THnBase.; Definition at line 94 of file THnSparse.h. ◆ Streamer(). void THnSparse::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from THnBase.; Reimplemented in THnSparseT< CONT >. ◆ StreamerNVirtual(). void THnSparse::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 169 of file THnSparse.h. ◆ Sumw2(). void THnSparse::Sumw2 ; (; ). overridevirtual . Enable calculation of errors. ; Implements THnBase.; Definition at line 948 of file THnSparse.cxx. Member Data Documentation. ◆ fBinContent. TObjArray THnSparse::fBinContent. private . Array of THnSparseArrayChunk. ; Definition at line 41 of file THnSparse.h. ◆ fBins. TExMap THnSparse::fBins. private . ! Filled bins ; Definition at line 42 of file THnSparse.h. ◆ fBinsContinued. TExMap THnSparse::fBinsContinued. private . ! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1) ; Definition at line 43 of file THnSparse.h. ◆ fChunkSize. Int_t THnSparse::fChunkSize. private . Number of entries for each chunk. ; Definition at line 39 of file THnSparse.h. ◆ fCompactCoord. THnSparseCompactBinCoord* THnSparse::fCompactCoord. private . ! Compact coordinate ; Definition at line 44 of file THnSparse.h. ◆ fFilledBins. Long64_t THnSparse::fFilledBins. private . Number of filled bins. ; Definition at line 40 of file THnSparse.h. Libraries for THnSparse:. [legend]; The documentation for this class was generated from the following files:; hist/hist/inc/THnSparse.h; hist/hist/src/THnSparse.cxx. THnSparse. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:49 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:40795,hash,hashes,40795,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,1,['hash'],['hashes']
Security," (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC); IBM AIX 4.1 (xlC compiler, GCC); Sun Solaris for SPARC (SUN C++ compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with the ROOT installation. You may work on a platform where your system administrator has already installed ROOT. You will need to follow the specific development environment for your setup and you may not have write access to the directories. In any case, you will need an environment variable called ROOTSYS, which holds the path of the top ROOT directory.; > echo $ROOTSYS; /opt/root; In the ROOTSYS directory are examples, executables, tutorials, header tutorials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for proje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:16379,access,access,16379,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security," (Bool_t) override;  ; void SetText (TString text);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TRecEvent; virtual TTime GetTime () const;  ; virtual void SetTime (TTime t);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRecExtraEvent.html:1663,Hash,Hash,1663,doc/master/classTRecExtraEvent.html,https://root.cern,https://root.cern/doc/master/classTRecExtraEvent.html,2,['Hash'],['Hash']
Security," (Int_t entry);  Remove entry #entry If the block has already been optimized and the entries are stored as a list and not as bits, trying to remove a new entry will make the block switch to bits representation. ;  ; void ResetIndices ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListBlock.html:4572,Hash,Hash,4572,doc/master/classTEntryListBlock.html,https://root.cern,https://root.cern/doc/master/classTEntryListBlock.html,2,['Hash'],['Hash']
Security," (TBranch*) fBranches.UncheckedAt(i);; 9185 branch->SetMakeClass(make);; 9186 }; 9187}; 9188 ; 9189////////////////////////////////////////////////////////////////////////////////; 9190/// Set the maximum size in bytes of a Tree file (static function).; 9191/// The default size is 100000000000LL, ie 100 Gigabytes.; 9192///; 9193/// In TTree::Fill, when the file has a size > fgMaxTreeSize,; 9194/// the function closes the current file and starts writing into; 9195/// a new file with a name of the style ""file_1.root"" if the original; 9196/// requested file name was ""file.root"".; 9197 ; 9198void TTree::SetMaxTreeSize(Long64_t maxsize); 9199{; 9200 fgMaxTreeSize = maxsize;; 9201}; 9202 ; 9203////////////////////////////////////////////////////////////////////////////////; 9204/// Change the name of this tree.; 9205 ; 9206void TTree::SetName(const char* name); 9207{; 9208 if (gPad) {; 9209 gPad->Modified();; 9210 }; 9211 // Trees are named objects in a THashList.; 9212 // We must update hashlists if we change the name.; 9213 TFile *file = nullptr;; 9214 TTreeCache *pf = nullptr;; 9215 if (fDirectory) {; 9216 fDirectory->Remove(this);; 9217 if ((file = GetCurrentFile())) {; 9218 pf = GetReadCache(file);; 9219 file->SetCacheRead(nullptr,this,TFile::kDoNotDisconnect);; 9220 }; 9221 }; 9222 // This changes our hash value.; 9223 fName = name;; 9224 if (fDirectory) {; 9225 fDirectory->Append(this);; 9226 if (pf) {; 9227 file->SetCacheRead(pf,this,TFile::kDoNotDisconnect);; 9228 }; 9229 }; 9230}; 9231 ; 9232void TTree::SetNotify(TObject *obj); 9233{; 9234 if (obj && fNotify && dynamic_cast<TNotifyLinkBase *>(fNotify)) {; 9235 auto *oldLink = static_cast<TNotifyLinkBase *>(fNotify);; 9236 auto *newLink = dynamic_cast<TNotifyLinkBase *>(obj);; 9237 if (!newLink) {; 9238 Warning(""TTree::SetNotify"",; 9239 ""The tree or chain already has a fNotify registered and it is a TNotifyLink, while the new object is ""; 9240 ""not a TNotifyLink. Setting fNotify to the new value will lead to an or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:356196,hash,hashlists,356196,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['hash'],['hashlists']
Security," (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2D.html:19099,Hash,Hash,19099,doc/master/classTGraph2D.html,https://root.cern,https://root.cern/doc/master/classTGraph2D.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeaf.html:6461,Hash,Hash,6461,doc/master/classTLeaf.html,https://root.cern,https://root.cern/doc/master/classTLeaf.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormula.html:14435,Hash,Hash,14435,doc/master/classTFormula.html,https://root.cern,https://root.cern/doc/master/classTFormula.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," (TBuffer &ClassDef_StreamerNVirtual_b);  ; std::list< RooAbsStudy * > & studies ();  ; RooWorkspace & wspace ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStudyManager.html:2115,Hash,Hash,2115,doc/master/classRooStudyManager.html,https://root.cern,https://root.cern/doc/master/classRooStudyManager.html,4,"['Hash', 'hash']","['Hash', 'hash']"
Security," (TBuffer &buffer, void *start_collection, const void *end_collection, const TLoopConfiguration *loopconf) const;  ; TConfiguredAction & operator= (const TConfiguredAction &rval);  ; void PrintDebug (TBuffer &buffer, void *object) const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfoActions_1_1TConfiguredAction.html:1976,Hash,Hash,1976,doc/master/classTStreamerInfoActions_1_1TConfiguredAction.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfoActions_1_1TConfiguredAction.html,2,['Hash'],['Hash']
Security," (TGIdleHandler *);  ; Bool_t HandleTimer (TTimer *) override;  Execute action in response of a timer timing out. ;  ; virtual void IconifyWindow ();  iconify window ;  ; TClass * IsA () const override;  ; virtual Bool_t IsMapped ();  Returns kTRUE if window is mapped on screen, kFALSE otherwise. ;  ; virtual void LowerWindow ();  lower window ;  ; void Print (Option_t *option="""") const override;  Print window id. ;  ; virtual void RaiseWindow ();  raise window ;  ; virtual void RequestFocus ();  request focus ;  ; virtual void SetName (const char *name);  ; virtual void SetWindowName (const char *name=nullptr);  Set window name. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEdit.html:23117,Hash,Hash,23117,doc/master/classTGTextEdit.html,https://root.cern,https://root.cern/doc/master/classTGTextEdit.html,8,"['Hash', 'hash']","['Hash', 'hash']"
Security," (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers being accumulated. Therefore, in rare cases, the accumulation; 91 /// result can change *in dependence of N*, even when the data are identical.; 92 /// The magnitude of such differences is well below the precision of the floating point type, and will therefore mostly show; 93 /// in the compensation sum(see Carry()). Increasing the number of accumulators therefore only makes sense to; 94 /// speed up the accumulation, but not to increase precision.; 95 ///; 96 /// \param T The type ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:2654,access,access,2654,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['access'],['access']
Security," (bool on=true);  Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  ; static void SetUseSessionKey (bool on=true);  Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  . Private Member Functions; bool CreateServer (bool with_http=false);  Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP port, which should be used for the server, provide following entry in rootrc file: ;  ; float GetLaunchTmout () const;  Returns timeout for launching new browser process. ;  ; std::string GetUrl (RWebWindow &win, bool remote=false, std::string *produced_key=nullptr);  Provide URL address to access specified window from inside or from remote. ;  ; bool InformListener (const std::string &msg);  If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket. ;  ; bool IsUseHttpThread () const;  Returns true if http server use special thread for requests processing (default off) ;  ; bool IsUseSenderThreads () const;  Returns true if extra threads to send data via websockets will be used (default off) ;  ; unsigned ShowWindow (RWebWindow &win, const RWebDisplayArgs &args);  Show window in specified location, see Show() method for more details. ;  ; void Unregister (RWebWindow &win);  Release all references to specified window Called from RWebWindow destructor. ;  ; int WaitFor (RWebWindow &win, WebWindowWaitFunc_t check, bool timed=false, double tm=-1);  Waits until provided check function or lambdas returns non-zero value Regularly calls WebWindow::Sync() method to let run event loop If call from the main thread, r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:3645,access,access,3645,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,2,['access'],['access']
Security," (bool);  ; void setVerbose (bool verbose=true);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConvGenContext.html:4683,Hash,Hash,4683,doc/master/classRooConvGenContext.html,https://root.cern,https://root.cern/doc/master/classRooConvGenContext.html,8,"['Hash', 'hash']","['Hash', 'hash']"
Security," (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:42014,Hash,Hash,42014,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,2,['Hash'],['Hash']
Security," (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Int_t len);  Read a buffer from the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Read a buffer from the file at the offset 'pos' in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read the nbuf blocks described in arrays pos and len. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void Seek (Long64_t offset, ERelativeTo pos=kBeg);  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:9538,access,access,9538,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,5,['access'],['access']
Security," (const char *name);  Return prototype integrator with given (class) name. ;  ; bool storeProtoSampler (RooAbsNumGenerator *proto, const RooArgSet &defConfig);  Method accepting registration of a prototype numeric integrator along with a RooArgSet of its default configuration options and an optional list of names of other numeric integrators on which this integrator depends. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumGenFactory.html:2259,Hash,Hash,2259,doc/master/classRooNumGenFactory.html,https://root.cern,https://root.cern/doc/master/classRooNumGenFactory.html,2,['Hash'],['Hash']
Security," (const char *search, const char *file, EAccessMode mode=kFileExists);  Find location of file in a search path. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:21651,Hash,Hash,21651,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,6,"['Hash', 'hash']","['Hash', 'hash']"
Security," (like COL, SURF, LEGO, CONT etc..). When a TGraph2D is drawn with one of the 2D histogram drawing option,; an intermediate 2D histogram is filled using the Delaunay triangles; to interpolate the data set. The 2D histogram has equidistant bins along the X; and Y directions. The number of bins along each direction can be change using; SetNpx() and SetNpy(). Each bin is filled with the Z; value found via a linear interpolation on the plane defined by the triangle above; the (X,Y) coordinates of the bin center. The existing (X,Y,Z) points can be randomly scattered.; The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; the 2D histogram. The 3D triangles int takes build a 3D surface in; the form of tessellating triangles at various angles. The triangles found can be; drawn in 3D with one of the TGraph2D specific drawing options. The histogram generated by the Delaunay interpolation can be accessed using the; GetHistogram() method. Example:. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; Double_t x, y, z, P = 6.;; Int_t np = 200;; TGraph2D *dt = new TGraph2D();; TRandom *r = new TRandom();; for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(1);; dt->Draw(""surf1"");; return c;; }; 2D graphs can be fitted as shown by the following example:. Picture; Source. //Fitting a TGraph2D; //Author: Olivier Couet. #include <TMath.h>; #include <TGraph2D.h>; #include <TRandom.h>; #include <TStyle.h>; #include <TCanvas.h>; #include <TF2.h>; #include <TH1.h>. TCanvas* graph2dfit(); {; gStyle->SetOptStat(0);; gStyle->SetOptFit();. TCanvas *c = new TCanvas(""c"",""Graph2D example"",0,0,600,800);; c->Divide(2,3);. Double_t rnd, x, y, z;; Double_t e = 0.3;; Int_t nd = 400;; Int_t np = 10000;. TRandom r;; Double_t fl = 6;; TF2 *f2 = new TF2(""f2"",""1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGraph2D.html:3248,access,accessed,3248,root/html604/TGraph2D.html,https://root.cern,https://root.cern/root/html604/TGraph2D.html,1,['access'],['accessed']
Security," (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProjectedPdf.html:40740,access,access,40740,root/html534/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html534/RooProjectedPdf.html,1,['access'],['access']
Security," (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenericPdf.html:42490,access,access,42490,root/html602/RooGenericPdf.html,https://root.cern,https://root.cern/root/html602/RooGenericPdf.html,2,['access'],['access']
Security," (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveGeoNode.html:21176,Hash,Hash,21176,doc/master/classTEveGeoNode.html,https://root.cern,https://root.cern/doc/master/classTEveGeoNode.html,2,['Hash'],['Hash']
Security," (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualPad.html:16164,Hash,Hash,16164,doc/master/classTVirtualPad.html,https://root.cern,https://root.cern/doc/master/classTVirtualPad.html,1,['Hash'],['Hash']
Security," (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:13058,authenticat,authentication,13058,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,1,['authenticat'],['authentication']
Security," (std::string_view datasetName, const std::vector< std::string > &fileNameGlobs, const std::vector< std::string > &defaultColumns, bool checkFile=true);  Create an RLoopManager that reads a TChain. ;  ; std::shared_ptr< ROOT::Detail::RDF::RLoopManager > CreateLMFromTTree (std::string_view datasetName, std::string_view fileNameGlob, const std::vector< std::string > &defaultColumns, bool checkFile=true);  Create an RLoopManager that reads a TChain. ;  ; template<typename T > ; std::unique_ptr< RMergeableVariations< T > > GetMergeableValue (ROOT::RDF::Experimental::RResultMap< T > &rmap);  Retrieve mergeable values after calling ROOT::RDF::VariationsFor . ;  ; template<typename T > ; std::unique_ptr< RMergeableValue< T > > GetMergeableValue (RResultPtr< T > &rptr);  Retrieve a mergeable value from an RDataFrame action. ;  ; template<typename T > ; RResultPtr< T > MakeResultPtr (const std::shared_ptr< T > &r, RLoopManager &lm, std::shared_ptr< RDFInternal::RActionBase > actionPtr);  Create a RResultPtr and set its pointer to the corresponding RAction This overload is invoked by non-jitted actions, as they have access to RAction before constructing RResultPtr. ;  ; template<typename T , typename... Ts> ; void MergeValues (RMergeableValue< T > &OutputMergeable, const RMergeableValue< Ts > &... InputMergeables);  Merge multiple RMergeableValue objects into one. ;  ; template<typename T , typename... Ts> ; void MergeValues (RMergeableVariations< T > &OutputMergeable, const RMergeableVariations< Ts > &... InputMergeables);  Merge multiple RMergeableVariations objects into one. ;  ; template<typename T , typename... Ts> ; std::unique_ptr< RMergeableValue< T > > MergeValues (std::unique_ptr< RMergeableValue< T > > OutputMergeable, std::unique_ptr< RMergeableValue< Ts > >... InputMergeables);  Merge multiple RMergeableValue objects into one. ;  ; ROOT::Experimental::RLogChannel & RDFLogChannel ();  . Function Documentation. ◆ CreateLMFromTTree() [1/2]. std::shared_ptr< ROOT::De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Detail_1_1RDF.html:3659,access,access,3659,doc/master/namespaceROOT_1_1Detail_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Detail_1_1RDF.html,1,['access'],['access']
Security," (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; 511- THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,; 512 ; 513They take name and title, the number of dimensions, and for each dimension; 514the number of bins, the minimal, and the maximal value on the dimension's; 515axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 516 ; 517 Int_t bins[2] = {10, 20};; 518 Double_t xmin[2] = {0., -5.};; 519 Double_t xmax[2] = {10., 5.};; 520 THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);; 521 ; 522## Filling; 523A THnSparse is filled just like a regular histogram, using; 524THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; 525To take errors into account, Sumw2() must be called before filling the; 526histogram.; 527 ; 528Bins are allocated as needed; the status of the allocation can be observed; 529by GetSparseFractionBins(), GetSparseFractionMem().; 530 ; 531## Fast Bin Content Access; 532When iterating over a THnSparse one should only look at filled bins to save; 533processing time. The number of filled bins is returned by; 534THnSparse::GetNbins(); the bin content for each (linear) bin number can; 535be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; 536After the call, coord will contain the bin coordinate of each axis for the bin; 537with linear index linidx. A possible call would be; 538 ; 539 std::cout << hs.GetBinContent(0, coord);; 540 std::cout <<"" is the content of bin [x = "" << coord[0] ""; 541 << "" | y = "" << coord[1] << ""]"" << std::endl;; 542 ; 543## Efficiency; 544TH1 and TH2 are generally faster than THnSparse for one and two dimensional; 545distributions. THnSparse becomes competitive for a sparsely filled TH3; 546with large numbers of bins per dimension. The tutorial sparsehist.C; 547shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; 548starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; 549one-dimensional histogram is only re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:19265,Access,Access,19265,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['Access'],['Access']
Security," (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:11697,access,accessors,11697,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,2,['access'],['accessors']
Security," (yet) read from xml file and write to xml file. If data member of class is private or protected, it can not be accessed via; member name. Two alternative way is supported. First, if for class member fValue; exists function GetValue(), it will be used to get value from the class, and if; exists SetValue(), it will be used to set apropriate data member. Names of setter; and getter methods can be specified in comments filed like:. int fValue; // *OPTION={GetMethod=""GetV"";SetMethod=""SetV""}. If getter or setter methods does not available, address to data member will be; calculated as predefined offeset to object start address. In that case generated code; should be used only on the same platform (OS + compiler), where it was generated. Generated streamers resolve inheritance tree for given class. This allows to have; array (or vector) of object pointers on some basic class, while objects of derived; class(es) are used. To access data from xml files, user should use TXmlFile class, which is different from; ROOT TXMLFile, but provides very similar functionality. For example, to read; object from xml file:. TXmlFile file(""test.xml""); // open xml file; file.ls(); // show list of keys in file; TExample* ex1 = (TExample*) file.Get(""ex1"", TExample_streamer); // get object; file.Close();. To write object to file:. TXmlFile outfile(""test2.xml"", ""recreate""); // create xml file; TExample* ex1 = new TExample;; outfile.Write(ex1, ""ex1"", TExample_streamer); // write object to file; outfile.Close();. Complete example for generating and using of external xml streamers can be taken from; http://www-linux.gsi.de/~linev/xmlreader.tar.gz. Any bug reports and requests for additional functionality are welcome. Sergey Linev, S.Linev@gsi.de. Function Members (Methods); public:. TXMLPlayer(); TXMLPlayer(const TXMLPlayer&); virtual~TXMLPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLPlayer.html:3041,access,access,3041,root/html528/TXMLPlayer.html,https://root.cern,https://root.cern/root/html528/TXMLPlayer.html,4,['access'],['access']
Security," (yet) read from xml file and write to xml file. If data member of class is private or protected, it can not be accessed via; member name. Two alternative way is supported. First, if for class member fValue; exists function GetValue(), it will be used to get value from the class, and if; exists SetValue(), it will be used to set apropriate data member. Names of setter; and getter methods can be specified in comments filed like:. int fValue; // *OPTION={GetMethod=""GetV"";SetMethod=""SetV""}. If getter or setter methods does not available, address to data member will be; calculated as predefined offeset to object start address. In that case generated code; should be used only on the same platform (OS + compiler), where it was generated. Generated streamers resolve inheritance tree for given class. This allows to have; array (or vector) of object pointers on some basic class, while objects of derived; class(es) are used. To access data from xml files, user should use TXmlFile class, which is different from; ROOT TXMLFile, but provides very similar functionality. For example, to read; object from xml file:. TXmlFile file(""test.xml""); // open xml file; file.ls(); // show list of keys in file; TExample* ex1 = (TExample*) file.Get(""ex1"", TExample_streamer); // get object; file.Close();. To write object to file:. TXmlFile outfile(""test2.xml"", ""recreate""); // create xml file; TExample* ex1 = new TExample;; outfile.Write(ex1, ""ex1"", TExample_streamer); // write object to file; outfile.Close();. Complete example for generating and using of external xml streamers can be taken from; http://www-linux.gsi.de/~linev/xmlreader.tar.gz. Any bug reports and requests for additional functionality are welcome. Sergey Linev, S.Linev@gsi.de. Function Members (Methods); public:. virtual~TXMLPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLPlayer.html:3066,access,access,3066,root/html602/TXMLPlayer.html,https://root.cern,https://root.cern/root/html602/TXMLPlayer.html,2,['access'],['access']
Security," )). };  . Public Member Functions;  ~TClassTable ();  TClassTable singleton is deleted in Terminate(). ;  ; int Classes ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print the class table. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:2679,Hash,Hash,2679,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,2,['Hash'],['Hash']
Security," ). Definition at line 63 of file gifencode.c. ◆ output() [1/2]. static void output ; (; ). static . ◆ output() [2/2]. static void output ; (; int ; code). static . Definition at line 226 of file gifencode.c. ◆ put_short() [1/2]. static void put_short ; (; ). static . ◆ put_short() [2/2]. static void put_short ; (; int ; word). static . Definition at line 301 of file gifencode.c. Variable Documentation. ◆ a_count. int a_count. static . Definition at line 209 of file gifencode.c. ◆ accum. char accum[256]. static . Definition at line 210 of file gifencode.c. ◆ BitsPixel. int BitsPixel. static . Definition at line 25 of file gifencode.c. ◆ ClearCode. int ClearCode. static . Definition at line 29 of file gifencode.c. ◆ CodeTab. int CodeTab[5003]. static . Definition at line 23 of file gifencode.c. ◆ cur_accum. unsigned long cur_accum. static . Definition at line 207 of file gifencode.c. ◆ cur_bits. int cur_bits. static . Definition at line 208 of file gifencode.c. ◆ CurCodeSize. int CurCodeSize. static . Definition at line 27 of file gifencode.c. ◆ CurMaxCode. int CurMaxCode. static . Definition at line 28 of file gifencode.c. ◆ EOFCode. int EOFCode. static . Definition at line 30 of file gifencode.c. ◆ FreeCode. int FreeCode. static . Definition at line 31 of file gifencode.c. ◆ HashTab. long HashTab[5003]. static . Definition at line 22 of file gifencode.c. ◆ IniCodeSize. int IniCodeSize. static . Definition at line 26 of file gifencode.c. ◆ masks. unsigned long masks[]. static . Initial value:= { 0x0000,; 0x0001, 0x0003, 0x0007, 0x000F,; 0x001F, 0x003F, 0x007F, 0x00FF,; 0x01FF, 0x03FF, 0x07FF, 0x0FFF,; 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF }. Definition at line 211 of file gifencode.c. ◆ Nbyte. long Nbyte. static . Definition at line 33 of file gifencode.c. ◆ put_b. void(* put_b) () ; (; ). static . Definition at line 34 of file gifencode.c. graf2dwin32gdksrcgifencode.c. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html:4080,Hash,HashTab,4080,doc/master/win32gdk_2src_2gifencode_8c.html,https://root.cern,https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html,2,['Hash'],['HashTab']
Security," ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDrawFeedback::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDrawFeedback::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 54 of file TDrawFeedback.h. ◆ DeclFileName(). static const char * TDrawFeedback::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 54 of file TDrawFeedback.h. ◆ Feedback(). void TDrawFeedback::Feedback ; (; TList * ; objs). Display feedback. ; Definition at line 93 of file TDrawFeedback.cxx. ◆ GetName(). const char * TDrawFeedback::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 50 of file TDrawFeedback.h. ◆ Hash(). ULong_t TDrawFeedback::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TDrawFeedback::HashULong_t Hash() const overrideReturn hash value for this object.Definition TDrawFeedback.h:51; TObjectMoth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDrawFeedback.html:16521,Hash,Hash,16521,doc/master/classTDrawFeedback.html,https://root.cern,https://root.cern/doc/master/classTDrawFeedback.html,1,['Hash'],['Hash']
Security," ); const. inline . Definition at line 63 of file TDocInfo.h. ◆ GetHtmlFileName(). const char * TClassDocInfo::GetHtmlFileName ; (; ); const. inline . Definition at line 60 of file TDocInfo.h. ◆ GetImplFileName(). const char * TClassDocInfo::GetImplFileName ; (; ); const. inline . Definition at line 62 of file TDocInfo.h. ◆ GetImplFileSysName(). const char * TClassDocInfo::GetImplFileSysName ; (; ); const. inline . Definition at line 64 of file TDocInfo.h. ◆ GetListOfTypedefs(). TList & TClassDocInfo::GetListOfTypedefs ; (; ). inline . Definition at line 82 of file TDocInfo.h. ◆ GetModule(). TModuleDocInfo * TClassDocInfo::GetModule ; (; ); const. inline . Definition at line 67 of file TDocInfo.h. ◆ GetName(). const char * TClassDocInfo::GetName ; (; ); const. overridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 25 of file TDocInfo.cxx. ◆ Hash(). ULong_t TClassDocInfo::Hash ; (; ); const. overridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TClassDocInfo::HashULong_t Hash() const overrideReturn hash value for this object.Definition TDocInfo.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassDocInfo.html:14382,Hash,Hash,14382,doc/master/classTClassDocInfo.html,https://root.cern,https://root.cern/doc/master/classTClassDocInfo.html,1,['Hash'],['Hash']
Security," ); const. inline . Definition at line 64 of file TStatistic.h. ◆ GetN(). Long64_t TStatistic::GetN ; (; ); const. inline . Definition at line 55 of file TStatistic.h. ◆ GetName(). const char * TStatistic::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 52 of file TStatistic.h. ◆ GetNeff(). Long64_t TStatistic::GetNeff ; (; ); const. inline . Definition at line 56 of file TStatistic.h. ◆ GetRMS(). Double_t TStatistic::GetRMS ; (; ); const. inline . Definition at line 60 of file TStatistic.h. ◆ GetVar(). Double_t TStatistic::GetVar ; (; ); const. inline . Definition at line 61 of file TStatistic.h. ◆ GetW(). Double_t TStatistic::GetW ; (; ); const. inline . Definition at line 62 of file TStatistic.h. ◆ GetW2(). Double_t TStatistic::GetW2 ; (; ); const. inline . Definition at line 63 of file TStatistic.h. ◆ Hash(). ULong_t TStatistic::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatistic.html:14928,Hash,Hash,14928,doc/master/classTStatistic.html,https://root.cern,https://root.cern/doc/master/classTStatistic.html,1,['Hash'],['Hash']
Security," ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 109 of file TEnv.h. ◆ GetType(). const char * TEnvRec::GetType ; (; ); const. inline . Definition at line 111 of file TEnv.h. ◆ GetValue(). const char * TEnvRec::GetValue ; (; ); const. inline . Definition at line 110 of file TEnv.h. ◆ Hash(). ULong_t TEnvRec::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TEnvRec::HashULong_t Hash() const overrideReturn hash value for this object.Definition TEnv.h:113; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 113 of file TEnv.h. ◆ IsA(). TClass * TEnvRec::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEnvRec.html:13608,Hash,Hash,13608,doc/master/classTEnvRec.html,https://root.cern,https://root.cern/doc/master/classTEnvRec.html,1,['Hash'],['Hash']
Security," ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 66 of file TParameter.h. ◆ GetVal(). template<class AParamType > . const AParamType & TParameter< AParamType >::GetVal ; (; ); const. inline . Definition at line 67 of file TParameter.h. ◆ Hash(). template<class AParamType > . ULong_t TParameter< AParamType >::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TParameter::HashULong_t Hash() const overrideReturn hash value for this object.Definition TParameter.h:92; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 92 of file TParameter.h. ◆ IsA(). template<class AParamType > . TClass * TParameter< AParamType >::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParameter.html:14220,Hash,Hash,14220,doc/master/classTParameter.html,https://root.cern,https://root.cern/doc/master/classTParameter.html,1,['Hash'],['Hash']
Security," * GetContent()Definition TGenCollectionProxy.h:257; TGenCollectionProxy::TStaging::GetSizesize_t GetSize()Definition TGenCollectionProxy.h:265; TGenCollectionProxy::TStaging::GetTargetvoid * GetTarget()Definition TGenCollectionProxy.h:269; TGenCollectionProxy::TStaging::Resizevoid Resize(size_t nelement)Definition TGenCollectionProxy.h:273; TGenCollectionProxy::TStaging::GetEndvoid * GetEnd()Definition TGenCollectionProxy.h:261; TGenCollectionProxy::TStaging::SetTargetvoid SetTarget(void *target)Definition TGenCollectionProxy.h:280; TGenCollectionProxyProxy around an arbitrary container, which implements basic functionality and iteration.Definition TGenCollectionProxy.h:31; TGenCollectionProxy::GetReadMemberWiseActionsTStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1798; TGenCollectionProxy::fFirstMethod fFirstContainer accessors: generic iteration: first.Definition TGenCollectionProxy.h:304; TGenCollectionProxy::fValuestd::atomic< Value * > fValueDescriptor of the container value type.Definition TGenCollectionProxy.h:311; TGenCollectionProxy::fFunctionNextIteratorNext_t fFunctionNextIteratorDefinition TGenCollectionProxy.h:326; TGenCollectionProxy::Insertvoid Insert(const void *data, void *container, size_t size) overrideInsert data into the container where data is a C-style array of the actual type contained in the coll...Definition TGenCollectionProxy.cxx:1269; TGenCollectionProxy::fPointersBool_t fPointersFlag to indicate if containee has pointers (key or value)Definition TGenCollectionProxy.h:300; TGenCollectionProxy::fNextMethod fNextContainer accessors: generic iteration: next.Definition TGenCollectionProxy.h:305; TGenCollectionProxy::Streamervirtual void Streamer(TBuffer &refBuffer)Streamer Function.Definition TGenCollectionProxy.cxx:1427; TGenCollectionProxy::fWriteMemberWiseTStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:76503,access,accessors,76503,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['access'],['accessors']
Security," * TListOfEnums::Find ; (; DeclId_t ; id); const. Return the TEnum corresponding to the Decl 'id' or NULL if it does not exist. ; Definition at line 179 of file TListOfEnums.cxx. ◆ FindObject() [1/3]. TObject * TListOfEnums::FindObject ; (; const char * ; name); const. overridevirtual . Specialize FindObject to do search for the a enum just by name or create it if its not already in the list. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 190 of file TListOfEnums.cxx. ◆ FindObject() [2/3]. TObject * THashList::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 51 of file THashList.cxx. ◆ FindObject() [3/3]. TObject * THashList::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 52 of file THashList.cxx. ◆ FindUnloaded(). TEnum * TListOfEnums::FindUnloaded ; (; const char * ; name). inlineprotected . Definition at line 64 of file TListOfEnums.h. ◆ Get(). TEnum * TListOfEnums::Get ; (; DeclId_t ; id, . const char * ; name . ). protected . Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'. ; Definition at line 205 of file TListOfEnums.cxx. ◆ GetClass(). TClass * TListOfEnums::GetClass ; (; ); const. inlineprotected . Definition at line 62 of file TListOfEnums.h. ◆ GetIds(). TExMap * TListOfEnums::GetIds ; (; ). inlineprotected . Definition at line 63 of file TListOfEnums.h. ◆ GetObject(). TEnum * TListOfEnums::GetObject ; (; const char * ; name); const. virtual . Return an object from the list of enums if and only if is has already been loaded in the list. ; This is an internal routine. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:28687,hash,hash,28687,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," *countries[nx] = {; ""france"", ""spain"", ""sweden"", ""germany"", ""finland"",; ""norway"", ""poland"", ""italy"", ""yugoslavia"", ""united_kingdom"",; ""romania"", ""belarus"",""greece"", ""czechoslovakia"",""bulgaria"",; ""iceland"", ""hungary"",""portugal"",""austria"", ""ireland"",; ""lithuania"", ""latvia"", ""estonia"", ""denmark"", ""netherlands"",; ""switzerland"",""moldova"",""belgium"", ""albania"", ""cyprus"",; ""luxembourg"", ""andorra"",""malta"", ""liechtenstein"", ""san_marino"", ""monaco"" };; Float_t surfaces[nx] = {; 547030, 505580, 449964, 357021, 338145,; 324220, 312685, 301230, 255438, 244820,; 237500, 207600, 131940, 127711, 110910,; 103000, 93030, 89242, 83870, 70280,; 65200, 64589, 45226, 43094, 41526,; 41290, 33843, 30528, 28748, 9250,; 2586, 468, 316, 160, 61, 2};; ; TH1F *h = new TH1F(""h"",""Countries surfaces (in km^{2})"",3,0,3);; for (i=0; i<nx; i++) h->Fill(countries[i], surfaces[i]);; h->LabelsDeflate();; ; TFile::SetCacheFileDir(""."");; TFile *f;; f = TFile::Open(""http://root.cern/files/europe.root"",""cacheread"");; ; if (!f) {; printf(""Cannot access europe.root. Is internet working ?\n"");; return;; }; ; TH2Poly *p = new TH2Poly(; ""Europe"",; ""Europe (bin contents are normalized to the surfaces in km^{2})"",; lon1,lon2,lat1,lat2);; p->GetXaxis()->SetNdivisions(520);; p->GetXaxis()->SetTitle(""longitude"");; p->GetYaxis()->SetTitle(""latitude"");; ; p->SetContour(100);; ; TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; p->AddBin(mg);; }; }; ; TRandom r;; Double_t longitude, latitude;; Double_t x, y, pi4 = TMath::Pi()/4, alpha = TMath::Pi()/360;; ; gBenchmark->Start(""Partitioning"");; p->ChangePartition(100, 100);; gBenchmark->Show(""Partitioning"");; ; // Fill TH2Poly according to a Mercator projection.; gBenchmark->Start(""Filling"");; for (i=0; i<npoints; i++) {; longitude = r.Uniform(lon1,lon2);; latitude = r.Uniform(lat1,lat2);; x = longitude;; y = 38*TMath:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/th2polyEurope_8C.html:2842,access,access,2842,doc/master/th2polyEurope_8C.html,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html,1,['access'],['access']
Security," *elem, Int_t number);  set structure type as kSqlElement ;  ; void SetStreamerInfo (const TStreamerInfo *info);  set structure type as kSqlStreamerInfo ;  ; void SetType (Int_t typ);  ; void SetValue (const char *value, const char *tname=nullptr);  set structure type as kSqlValue ;  ; void SetVersion (const TClass *cl, Int_t version=-100);  set structure type as kSqlVersion ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLStructure.html:6812,Hash,Hash,6812,doc/master/classTSQLStructure.html,https://root.cern,https://root.cern/doc/master/classTSQLStructure.html,2,['Hash'],['Hash']
Security," *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; fAscendingTListprotected; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fCacheTListprotected; fFirstTListprotected; fgCurrentCollectionTCollectionprivatestatic; fgDtorOnlyTObjectprivatestatic; fgEmptyingGarbageTCollectionprivatestatic; fgGarbageCollectionTCollectionprivatestatic; fgGarbageStackTCollectionprivatestatic; fgObjectStatTObjectprivatestatic; FindLink(const TObject *obj, Int_t &idx) constTListprotected; FindObject(const char *name) const overrideTListvirtual; FindObject(const TObject *obj) const overrideTListvirtual; First() const overrideTListvirtual; FirstLink() constTListinlinevirtual; fLastTListprotected; fNameTCollectionprotected; fSizeTCollectionprotected; fSortedTSeqCollectionprotected; fUniqueIDTObjectprivate; GarbageCollect(TObject *obj)TCollectionstatic; GetCollectionEntryName(TObject *entry) constTCollectionprotectedvirtual; GetCurrentCollection()TCollectionstatic; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetEntries() constTCollectioninlinevirtual; GetIconName() constTObjectvirtual; GetLast() constTSeqCollectionvirtual; GetName() const overrideTCollectionvirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectRef(const TObject *obj) const overrideTListvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetSize() constTCollectioninlinevirtual; GetTitle() constTObjectvirtual; GetUniqueID() constTObjectvirtual; GrowBy(Int_t delta) constTCollectionvirtual; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTCollectioninlinevirtual; HasInconsistentHash() constTObjectinline; IndexOf(const TObject *obj) constTSeqCollectionvirtual; Info(const char *method, const char *msgfmt,...) constTObjectvirtual; InheritsFrom(const char *classname) constTObjectvirtual; InheritsFrom(const TClass *cl) constTObjectvirtual; InsertAfter(const TObjLinkPtr_t &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTList-members.html:4315,Hash,Hash,4315,doc/master/classTList-members.html,https://root.cern,https://root.cern/doc/master/classTList-members.html,1,['Hash'],['Hash']
Security," *info) const =0; TInterpreter::FuncTempInfo_IsValidvirtual Bool_t FuncTempInfo_IsValid(FuncTempInfo_t *) const =0; TInterpreter::CallFunc_SetArgImplvoid CallFunc_SetArgImpl(CallFunc_t *func, const U &head)Definition TInterpreter.h:367; TInterpreter::BaseClassInfo_Propertyvirtual Long_t BaseClassInfo_Property(BaseClassInfo_t *) constDefinition TInterpreter.h:447; TInterpreter::CallFunc_ExecDoublevirtual Double_t CallFunc_ExecDouble(CallFunc_t *, void *) constDefinition TInterpreter.h:321; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, Long_t) const =0; TInterpreter::GetInterfaceMethodvirtual void * GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst=kFALSE)=0; TInterpreter::GetCurrentMacroNamevirtual const char * GetCurrentMacroName() constDefinition TInterpreter.h:257; TInterpreter::Executevirtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error=nullptr)=0; TInterpreter::TypeNamevirtual const char * TypeName(const char *s)=0; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TLockGuardDefinition TVirtualMutex.h:70; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOTtbb::task_arena is an alias of tbb::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:79898,access,access,79898,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,1,['access'],['access']
Security," *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPaveClass.html:11094,Hash,Hash,11094,doc/master/classTPaveClass.html,https://root.cern,https://root.cern/doc/master/classTPaveClass.html,2,['Hash'],['Hash']
Security," *name, Longptr_t offset, TClass *cl, Bool_t isTransient = kFALSE);; 390 void CalculateStreamerOffset() const;; 391 Bool_t CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient = kFALSE) const;; 392 Bool_t CanSplit() const;; 393 Bool_t CanIgnoreTObjectStreamer() { return TestBit(kIgnoreTObjectStreamer);}; 394 Long_t ClassProperty() const;; 395 TObject *Clone(const char *newname="""") const override;; 396 void CopyCollectionProxy(const TVirtualCollectionProxy&);; 397 void Draw(Option_t *option="""") override;; 398 void Dump() const override { TDictionary::Dump(); }; 399 void Dump(const void *obj, Bool_t noAddr = kFALSE) const;; 400 char *EscapeChars(const char *text) const;; 401 TVirtualStreamerInfo *FindStreamerInfo(UInt_t checksum, Bool_t isTransient = kFALSE) const;; 402 TVirtualStreamerInfo *GetConversionStreamerInfo( const char* onfile_classname, Int_t version ) const;; 403 TVirtualStreamerInfo *FindConversionStreamerInfo( const char* onfile_classname, UInt_t checksum ) const;; 404 TVirtualStreamerInfo *GetConversionStreamerInfo( const TClass* onfile_cl, Int_t version ) const;; 405 TVirtualStreamerInfo *FindConversionStreamerInfo( const TClass* onfile_cl, UInt_t checksum ) const;; 406 void ForceReload (TClass* oldcl);; 407 Bool_t HasDataMemberInfo() const { return fIsSyntheticPair || fHasRootPcmInfo || HasInterpreterInfo(); }; 408 Bool_t HasDefaultConstructor(Bool_t testio = kFALSE) const;; 409 Bool_t HasInterpreterInfoInMemory() const { return nullptr != fClassInfo; }; 410 Bool_t HasInterpreterInfo() const { return fCanLoadClassInfo || fClassInfo; }; 411 UInt_t GetCheckSum(ECheckSum code = kCurrentCheckSum) const;; 412 UInt_t GetCheckSum(Bool_t &isvalid) const;; 413 UInt_t GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; 414 TVirtualCollectionProxy *GetCollectionProxy() const;; 415 TVirtualIsAProxy *GetIsAProxy() const;; 416 TMethod *GetClassMethod(const char *name, const char *params, Bool_t objectIsConst = kFALSE);; 417 TMethod *GetClassM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:20011,checksum,checksum,20011,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['checksum'],['checksum']
Security," *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; UInt_t ParseChecksum (const char *checksum) const;  Parse the checksum in the given string. ;  ; Bool_t ProcessChecksum (const TString &checksum) const;  Check if specified checksum string is correct and build checksum vector. ;  ; Bool_t ProcessVersion (const TString &version) const;  Check if specified version string is correct and build version vector. ;  . Static Private Member Functions; static void ProcessDeclaration (TObjArray *array, const TString &list);  Split the list as a declaration into as a TObjArray of TNamed(name,type). ;  ; static void ProcessList (TObjArray *array, const TString &list);  Split the list as a comma separated list into a TObjArray of TObjString. ;  . Private Attributes; TString fAttributes;  ; TString fChecksum;  Source version vector (for searching purposes) ;  ; std::vector< UInt_t > * fChecksumVect;  ; TString fCode;  Includes vector. ;  ; Bool_t fEmbed;  ; TString fInclude;  Source data member vector (for searching purposes) ;  ; TObjArray * fIncludeVect;  ; ReadFuncPtr_t fReadFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:14137,checksum,checksum,14137,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,4,['checksum'],['checksum']
Security," *opt) override;  Add at the end of the list. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; void Clear (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the list AND delete all heap based objects. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorList.html:2348,hash,hash,2348,doc/master/classTSelectorList.html,https://root.cern,https://root.cern/doc/master/classTSelectorList.html,1,['hash'],['hash']
Security," *option="""") const override;  Print master status. ;  ; Bool_t Release ();  Release worker. ;  ; Bool_t Resume ();  Resume worker. ;  ; Bool_t SetState (EState state);  Set the state of workers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t Suspend ();  Suspend worker. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCondor.html:2980,Hash,Hash,2980,doc/master/classTCondor.html,https://root.cern,https://root.cern/doc/master/classTCondor.html,2,['Hash'],['Hash']
Security," *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:2662,access,access,2662,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['access'],['access']
Security," *widths, const char *col=""#000000"", const char *stipple=nullptr, UInt_t w=16, UInt_t h=16) override;  Fill spans with specified color or/and stipple. ;  ; void FillSpans (UInt_t npt, TPoint *ppt, UInt_t *widths, TImage *tile) override;  Fill spans with tile image. ;  ; void Flip (Int_t flip=180) override;  Flip image in place. ;  ; void FloodFill (Int_t x, Int_t y, const char *col, const char *min_col, const char *max_col=nullptr) override;  Flood fill. ;  ; void FromGLBuffer (UChar_t *buf, UInt_t w, UInt_t h) override;  Creates an image (screenshot) from a RGBA buffer. ;  ; void FromPad (TVirtualPad *pad, Int_t x=0, Int_t y=0, UInt_t w=0, UInt_t h=0) override;  Create an image from the given pad, afterwards this image can be saved in any of the supported image formats. ;  ; void FromWindow (Drawable_t wid, Int_t x=0, Int_t y=0, UInt_t w=0, UInt_t h=0) override;  Create an image (screenshot) from specified window. ;  ; UInt_t * GetArgbArray () override;  Return a pointer to internal array[width x height] of ARGB32 values This array is directly accessible. ;  ; TArrayD * GetArray (UInt_t w=0, UInt_t h=0, TImagePalette *pal=gWebImagePalette) override;  In case of vectorized image return an associated array of doubles otherwise this method creates and returns a 2D array of doubles corresponding to palette. ;  ; UInt_t GetHeight () const override;  Return height of original image not of the displayed image. ;  ; const char * GetIconName () const override;  Returns mime type name of object. ;  ; ASImage * GetImage () const;  ; void GetImageBuffer (char **buffer, int *size, EImageFileTypes type=TImage::kPng) override;  Return in-memory buffer compressed according image type. ;  ; Pixmap_t GetMask () override;  Returns image mask pixmap (alpha channel). ;  ; char * GetObjectInfo (Int_t px, Int_t py) const override;  Get image pixel coordinates and the pixel value at the mouse pointer. ;  ; TArrayL * GetPixels (Int_t x=0, Int_t y=0, UInt_t w=0, UInt_t h=0) override;  Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:7921,access,accessible,7921,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['access'],['accessible']
Security," *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual IBaseFunctionOneDim * Clone () const =0;  Clone a function. ;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual unsigned int NPar () const =0;  Return the number of Parameters. ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ; virtual const double * Parameters () const =0;  Access the parameter values. ;  ; virtual void SetParameters (const double *p)=0;  Set the parameter values. ;  . Private Member Functions; double DoEval (double x) const override;  Implement the ROOT::Math::IBaseFunctionOneDim interface DoEval(x) using the cached parameter values. ;  ; virtual double DoEvalPar (double x, const double *p) const =0;  Implementation of the evaluation function using the x value and the parameters. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IParametricFunctionOneDim:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BaseFunc. typedef IBaseFunctionOneDim ROOT::Math::IParametricFunctionOneDim::BaseFunc. Definition at line 166 of file IParamFunction.h. Member Function Documentation. ◆ DoEval(). double ROOT::Math::IParametricFunctionOneDim::DoEval ; (; double ; x); const. inlineoverrideprivatevirtual . Implement the ROOT::Math::IBaseFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html:1879,Access,Access,1879,doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html,1,['Access'],['Access']
Security," *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual IBaseFunctionOneDim * Clone () const =0;  Clone a function. ;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual unsigned int NPar () const =0;  Return the number of Parameters. ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ; virtual const double * Parameters () const =0;  Access the parameter values. ;  ; virtual void SetParameters (const double *p)=0;  Set the parameter values. ;  . Private Member Functions; virtual double DoParameterDerivative (double x, const double *p, unsigned int ipar) const =0;  Evaluate the gradient, to be implemented by the derived classes. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IParametricGradFunctionOneDim:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BaseFunc. typedef IParametricFunctionOneDim::BaseFunc ROOT::Math::IParametricGradFunctionOneDim::BaseFunc. Definition at line 336 of file IParamFunction.h. ◆ BaseGradFunc. typedef IGradientFunctionOneDim ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc. Definition at line 335 of file IParamFunction.h. ◆ BaseParamFunc. typedef IParametricFunctionOneDim ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc. Definition at line 334 of file I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html:3765,Access,Access,3765,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,1,['Access'],['Access']
Security," * GetName () const override;  Return unique name, used in SavePrimitive methods. ;  ; const TGWindow * GetParent () const;  ; virtual Bool_t HandleExpose (Event_t *event);  ; virtual Bool_t HandleIdleEvent (TGIdleHandler *);  ; virtual void IconifyWindow ();  iconify window ;  ; virtual Bool_t IsMapped ();  Returns kTRUE if window is mapped on screen, kFALSE otherwise. ;  ; virtual void LowerWindow ();  lower window ;  ; void Print (Option_t *option="""") const override;  Print window id. ;  ; virtual void RaiseWindow ();  raise window ;  ; virtual void RequestFocus ();  request focus ;  ; virtual void SetBackgroundPixmap (Pixmap_t pixmap);  set background pixmap ;  ; virtual void SetName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionViewer.html:18935,Hash,Hash,18935,doc/master/classTSessionViewer.html,https://root.cern,https://root.cern/doc/master/classTSessionViewer.html,4,"['Hash', 'hash']","['Hash', 'hash']"
Security," * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; const char * URL () const;  Returns the URI for the document or 0 in case there is no document set. ;  ; const char * Version () const;  Returns the XML version string or 0 in case there is no document set. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLDocument.html:1839,Hash,Hash,1839,doc/master/classTXMLDocument.html,https://root.cern,https://root.cern/doc/master/classTXMLDocument.html,2,['Hash'],['Hash']
Security," + ""/"" + treename as RSampleInfo::fID; Values are pointers to the corresponding sample. ; Definition at line 135 of file RLoopManager.hxx. ◆ fSamples. std::vector<ROOT::RDF::Experimental::RSample> ROOT::Detail::RDF::RLoopManager::fSamples. private . Samples need to survive throughout the whole event loop, hence stored as an attribute. ; Definition at line 137 of file RLoopManager.hxx. ◆ fSuppressErrorsForMissingBranches. std::vector<std::string> ROOT::Detail::RDF::RLoopManager::fSuppressErrorsForMissingBranches {}. private . Definition at line 188 of file RLoopManager.hxx. ◆ fTree. std::shared_ptr<TTree> ROOT::Detail::RDF::RLoopManager::fTree {nullptr}. private . Shared pointer to the input TTree. ; It does not delete the pointee if the TTree/TChain was passed directly as an argument to RDataFrame's ctor (in which case we let users retain ownership). ; Definition at line 130 of file RLoopManager.hxx. ◆ fUniqueDefinesWithReaders. std::set<std::pair<std::string_view, std::unique_ptr<ROOT::Internal::RDF::RDefinesWithReaders> > > ROOT::Detail::RDF::RLoopManager::fUniqueDefinesWithReaders. private . Definition at line 191 of file RLoopManager.hxx. ◆ fUniqueVariationsWithReaders. std::set<std::pair<std::string_view, std::unique_ptr<ROOT::Internal::RDF::RVariationsWithReaders> > > ROOT::Detail::RDF::RLoopManager::fUniqueVariationsWithReaders. private . Definition at line 193 of file RLoopManager.hxx. ◆ fValidBranchNames. ColumnNames_t ROOT::Detail::RDF::RLoopManager::fValidBranchNames. private . Cache of the tree/chain branch names. Never access directy, always use GetBranchNames(). ; Definition at line 165 of file RLoopManager.hxx. Libraries for ROOT::Detail::RDF::RLoopManager:. [legend]; The documentation for this class was generated from the following files:; tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx; tree/dataframe/src/RLoopManager.cxx. ROOTDetailRDFRLoopManager. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:33625,access,access,33625,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['access'],['access']
Security," , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TGeoParallelWorld ();  ;  TGeoParallelWorld (const char *name, TGeoManager *mgr);  Default constructor. ;  ;  ~TGeoParallelWorld () override;  Destructor. ;  ; void AddNode (const char *path);  Add a node normally to this world. Overlapping nodes not allowed. ;  ; void AddOverlap (const char *volname, Bool_t activate=kTRUE);  To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world. ;  ; void AddOverlap (TGeoVolume *vol, Bool_t activate=kTRUE);  To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world. ;  ; void BuildBVH ();  Build the BVH acceleration structure. ;  ; bool CheckBVH (void *, size_t) const;  Check/validate the BVH acceleration structure. ;  ; void CheckOverlaps (Double_t ovlp=0.001);  Check overlaps within a tolerance value. ;  ; Bool_t CloseGeometry ();  The main geometry must be closed. ;  ; void Draw (Option_t *option) override;  Draw the parallel world. ;  ; TGeoPhysicalNode * FindNextBoundary (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  ; TGeoPhysicalNode * FindNode (Double_t point[3]);  ; AccelerationMode const & GetAccelerationMode () const;  ; TGeoManager * GetGeometry () const;  ; TGeoVolume * GetVolume () const;  ; TClass * IsA () const override;  ; Bool_t IsClosed () const;  ; Bool_t IsUsingOverlaps () const;  ; void PrintBVH () const;  Prints the BVH. ;  ; Int_t PrintDetectedOverlaps () const;  Print the overlaps which were detected during real tracking. ;  ; void RefreshPhysicalNodes ();  Refresh the node pointers and re-voxelize. ;  ; void ResetOverlaps () const;  Reset overlapflag for all volumes in geometry. ;  ; Double_t Sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:2542,validat,validate,2542,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['validat'],['validate']
Security," - 1. This means, if recurse is negative, the recursion is infinite.; Option is passed recursively, but wildcard is only used on the first level. ; Reimplemented from TCollection.; Definition at line 199 of file TCollection.cxx. ◆ Print() [2/5]. void TCollection::Print ; (; Option_t * ; option, . Int_t ; recurse . ); const. virtual . Print the collection header and its elements. ; If recurse is non-zero, descend into printing of collection-entries with recurse - 1. This means, if recurse is negative, the recursion is infinite.; Option is passed recursively. ; Reimplemented from TCollection.; Definition at line 198 of file TCollection.cxx. ◆ Print() [3/5]. void THashTable::Print ; (; Option_t * ; option, . Int_t ; recurse . ); const. overridevirtual . Print the collection header and its elements. ; If recurse is non-zero, descend into printing of collection-entries with recurse - 1. This means, if recurse is negative, the recursion is infinite.; If option contains ""details"", Print will show the content of each of the hash-slots.; Option is passed recursively. ; Reimplemented from TCollection.; Definition at line 328 of file THashTable.cxx. ◆ Print() [4/5]. void TCollection::Print ; (; Option_t * ; option, . TPRegexp & ; regexp, . Int_t ; recurse = 1 . ); const. virtual . Print the collection header and its elements that match the regexp. ; If recurse is non-zero, descend into printing of collection-entries with recurse - 1. This means, if recurse is negative, the recursion is infinite.; Option is passed recursively, but regexp is only used on the first level. ; Reimplemented from TCollection.; Definition at line 200 of file TCollection.cxx. ◆ Print() [5/5]. void TCollection::Print ; (; Option_t * ; option = """"); const. overridevirtual . Default print for collections, calls Print(option, 1). ; This will print the collection header and Print() methods of all the collection entries.; If you want to override Print() for a collection class, first see if you can accomplish",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:24624,hash,hash-slots,24624,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hash-slots']
Security," - Regex: '.*'; Priority: 6; IndentCaseLabels: false; IndentWidth: 3; IndentWrappedFunctionNames: false; KeepEmptyLinesAtTheStartOfBlocks: true; MacroBlockBegin: ''; MacroBlockEnd: ''; MaxEmptyLinesToKeep: 1; NamespaceIndentation: None; ObjCBlockIndentWidth: 3; ObjCSpaceAfterProperty: false; ObjCSpaceBeforeProtocolList: true; PenaltyBreakBeforeFirstCallParameter: 19; PenaltyBreakComment: 300; PenaltyBreakFirstLessLess: 120; PenaltyBreakString: 1000; PenaltyExcessCharacter: 1000000; PenaltyReturnTypeOnItsOwnLine: 60000; PointerAlignment: Right; ReflowComments: true; SortIncludes: false; SpaceAfterCStyleCast: false; SpaceBeforeAssignmentOperators: true; SpaceBeforeParens: ControlStatements; SpaceInEmptyParentheses: false; SpacesBeforeTrailingComments: 1; SpacesInAngles: false; SpacesInContainerLiterals: true; SpacesInCStyleCastParentheses: false; SpacesInParentheses: false; SpacesInSquareBrackets: false; Standard: Cpp11; TabWidth: 3; UseTab: Never; ...; Astyle; If you don't have access to ClangFormat, astyle can be useful. Starting from a code like this:; int aap ( int inp ) { ; if ( inp > 0 ) { ; return 0 ; ; int a = 1 ; ; if ( inp == 0 && a == 1 ) { ; printf ( >""this is a very long line that is not yet ending"" , a, inp, a, inp, a , inp ) ; ; a + = inp ; return a ; ; } ; } else { ; return 1 ; ; } ; if ( inp == 0 ) ; return - 1 ; ; return 1 ; ; }; You will find back like this:; int aap (int inp) {; if (inp > 0) { ; return 0 ; ; int a = 1 ; ; if (inp == 0 && a == 1) { ; printf (""this is a very long line that is not yet ending"" , a, inp, a, inp, a, inp ) ; ; a + = inp ; return a ; ; } ; } ; else { ; return 1 ; ; } ; if (inp == 0) ; return - 1 ; ; return 1 ; ; }; Get at least version 2.0 and use the following ~/.astylerc:; # ROOT code formatting style; # Note that the brackets=linux option is not available starting from astyle 2.04; #brackets=linux; style=stroustrup; mode=c; align-pointer=name; indent=spaces=3; indent-switches; indent-cases; indent-namespaces; max-instat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:11578,access,access,11578,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['access'],['access']
Security," -1;; 10472 }; 10473 }; 10474 ; 10475 /* here *dp is either 0 or '\n' */; 10476 /* in any case, we have a new header */; 10477 num_headers = i + 1;; 10478 ; 10479 if (*dp) {; 10480 *dp = 0;; 10481 dp++;; 10482 *buf = dp;; 10483 ; 10484 if ((dp[0] == '\r') || (dp[0] == '\n')) {; 10485 /* This is the end of the header */; 10486 break;; 10487 }; 10488 } else {; 10489 *buf = dp;; 10490 break;; 10491 }; 10492 }; 10493 return num_headers;; 10494}; 10495 ; 10496 ; 10497struct mg_http_method_info {; 10498 const char *name;; 10499 int request_has_body;; 10500 int response_has_body;; 10501 int is_safe;; 10502 int is_idempotent;; 10503 int is_cacheable;; 10504};; 10505 ; 10506 ; 10507/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10508static const struct mg_http_method_info http_methods[] = {; 10509 /* HTTP (RFC 2616) */; 10510 {""GET"", 0, 1, 1, 1, 1},; 10511 {""POST"", 1, 1, 0, 0, 0},; 10512 {""PUT"", 1, 0, 0, 1, 0},; 10513 {""DELETE"", 0, 0, 0, 1, 0},; 10514 {""HEAD"", 0, 0, 1, 1, 1},; 10515 {""OPTIONS"", 0, 0, 1, 1, 0},; 10516 {""CONNECT"", 1, 1, 0, 0, 0},; 10517 /* TRACE method (RFC 2616) is not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:301900,secur,security,301900,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['secur'],['security']
Security," -1;; 10473 }; 10474 }; 10475 ; 10476 /* here *dp is either 0 or '\n' */; 10477 /* in any case, we have a new header */; 10478 num_headers = i + 1;; 10479 ; 10480 if (*dp) {; 10481 *dp = 0;; 10482 dp++;; 10483 *buf = dp;; 10484 ; 10485 if ((dp[0] == '\r') || (dp[0] == '\n')) {; 10486 /* This is the end of the header */; 10487 break;; 10488 }; 10489 } else {; 10490 *buf = dp;; 10491 break;; 10492 }; 10493 }; 10494 return num_headers;; 10495}; 10496 ; 10497 ; 10498struct mg_http_method_info {; 10499 const char *name;; 10500 int request_has_body;; 10501 int response_has_body;; 10502 int is_safe;; 10503 int is_idempotent;; 10504 int is_cacheable;; 10505};; 10506 ; 10507 ; 10508/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10509static const struct mg_http_method_info http_methods[] = {; 10510 /* HTTP (RFC 2616) */; 10511 {""GET"", 0, 1, 1, 1, 1},; 10512 {""POST"", 1, 1, 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:301933,secur,security,301933,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['secur'],['security']
Security," . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Compiling Your Code (also known as ACLiC). You can run your code as compiled code instead of interpreted. This makes it possible to debug your code, and might give slightly faster code.; Wherever you would specify MyCode.C you can simply specify MyCode.C+ (note the trailing ""+"") and ROOT will start your compiler and load your code as dynamic library. Give it a try with "".x AnalyzeTree.C+"". If you see ""command not found"", ROOT cannot find the compiler in your $PATH / %PATH%.; . ‹ Fit Panel; up; Accessing a TTree With a TSelector ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/compiling-your-code-also-known-aclic.html:2426,Access,Accessing,2426,d/compiling-your-code-also-known-aclic.html,https://root.cern,https://root.cern/d/compiling-your-code-also-known-aclic.html,1,['Access'],['Accessing']
Security," . ; Contribute . ; Collaborate with Us . You are hereHome » Development » Git Primer Github ssh key. Using Github with ssh keys is preferred, as it's much easier to use. Here is how to set it up:; 1. Create an ssh key; Run; ssh-keygen -t rsa -b 4096 -C ""your_email@example.com"" -f ~/.ssh/github_id_rsa. The email address is for your convenience, it doesn't really matter what you put there; you can even use this to state the name of the computer that will use that key.; You can use a passphrase - but even without it's sufficiently safe, because only you have the secret key file! But please enabling Two Factor Authentication!; 2. Add the key to Github; Log in to https://github.com. In the top right corner, in a drop-down menu, click ""Settings"". Select ""SSH and GPG keys"" from the menu on the left. Click ""New SSH key"", add something as a title and copy the output of; cat ~/.ssh/github_id_rsa.pub. into the ""Key"" text box.; 3. Guide ssh to your key; Edit (or create) ~/.ssh/config and enter the following lines:; Host github.com; User git; PreferredAuthentications publickey; IdentityFile ~/.ssh/github_id_rsa. 4. Check; ssh -T git@github.com. should print; Hi UserName! You've successfully authenticated, but GitHub does not provide shell access. References. Create an ssh key; Add the key to Github; Check. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/github-ssh-key.html:2988,authenticat,authenticated,2988,d/github-ssh-key.html,https://root.cern,https://root.cern/d/github-ssh-key.html,2,"['access', 'authenticat']","['access', 'authenticated']"
Security," . Definition at line 127 of file THtml.h. ◆ Hash(). ULong_t THtml::TFileSysEntry::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; THtml::TFileSysEntry::HashULong_t Hash() const overrideReturn hash value for this object.Definition THtml.h:116; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 116 of file THtml.h. ◆ IsA(). TClass * THtml::TFileSysEntry::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in THtml::TFileSysRoot.; Definition at line 133 of file THtml.h. ◆ Streamer(). void THtml::TFileSysEntry::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in THtml::TFileSysRoot. ◆ StreamerNVirtual(). void THtml::TFileSysEntry::StreamerNVirtual ; (; TBuffer & ; ClassDef_Str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml_1_1TFileSysEntry.html:12904,Hash,Hash,12904,doc/master/classTHtml_1_1TFileSysEntry.html,https://root.cern,https://root.cern/doc/master/classTHtml_1_1TFileSysEntry.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," . Definition at line 95 of file TGTextEdit.cxx. Public Member Functions;  TInsCharCom (TGTextEdit *te, char ch);  ; Bool_t Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ;  Public Member Functions inherited from TGTextEditCommand;  TGTextEditCommand (TGTextEdit *te);  ; void SetPos (TGLongPosition pos);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInsCharCom.html:1217,Hash,Hash,1217,doc/master/classTInsCharCom.html,https://root.cern,https://root.cern/doc/master/classTInsCharCom.html,2,['Hash'],['Hash']
Security," . Interface to cling function. ; Reimplemented from TInterpreter.; Definition at line 7419 of file TCling.cxx. ◆ EndOfLineAction(). void TCling::EndOfLineAction ; (; ). finalvirtual . It calls a ""fantom"" method to synchronize user keyboard input and ROOT prompt line. ; Implements TInterpreter.; Definition at line 3121 of file TCling.cxx. ◆ Evaluate(). int TCling::Evaluate ; (; const char * ; code, . TInterpreterValue & ; value . ). finalvirtual . Get the interpreter value corresponding to the statement. ; Reimplemented from TInterpreter.; Definition at line 7678 of file TCling.cxx. ◆ Execute() [1/5]. void TCling::Execute ; (; const char * ; function, . const char * ; params, . int * ; error = nullptr . ). finalvirtual . Execute a global function with arguments params. ; FIXME: The cint-based version of this code does not check if the SetFunc() call works, and does not do any real checking for errors from the Exec() call. It did fetch the most recent cint security error and return that in error, but this does not really translate well to cling/clang. We should enhance these interfaces so that we can report compilation and runtime errors properly. ; Implements TInterpreter.; Definition at line 5233 of file TCling.cxx. ◆ Execute() [2/5]. void TCling::Execute ; (; TMethod * ; method, . TObjArray * ; params, . int * ; error = nullptr . ). inlinefinalprivatevirtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Implements TInterpreter.; Definition at line 628 of file TCling.h. ◆ Execute() [3/5]. void TCling::Execute ; (; TObject * ; obj, . TClass * ; cl, . const char * ; method, . const char * ; params, . Bool_t ; objectIsConst, . int * ; error = nullptr . ). Execute a method from class cl with arguments params. ; FIXME: The cint-based ver",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:84087,secur,security,84087,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['secur'],['security']
Security," . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TStatsFeedback::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TStatsFeedback::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 44 of file TStatsFeedback.h. ◆ DeclFileName(). static const char * TStatsFeedback::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 44 of file TStatsFeedback.h. ◆ Feedback(). void TStatsFeedback::Feedback ; (; TList * ; objs). Display feedback. ; Definition at line 74 of file TStatsFeedback.cxx. ◆ GetName(). const char * TStatsFeedback::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 41 of file TStatsFeedback.h. ◆ Hash(). ULong_t TStatsFeedback::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatsFeedback.html:16150,Hash,Hash,16150,doc/master/classTStatsFeedback.html,https://root.cern,https://root.cern/doc/master/classTStatsFeedback.html,1,['Hash'],['Hash']
Security," . Standard acceleration of gravity in \( m s^{-2} \). ; Definition at line 174 of file TMath.h. ◆ GnUncertainty(). constexpr Double_t TMath::GnUncertainty ; (; ). constexpr . Standard acceleration of gravity uncertainty. ; Definition at line 181 of file TMath.h. ◆ GUncertainty(). constexpr Double_t TMath::GUncertainty ; (; ). constexpr . Gravitational constant uncertainty. ; Definition at line 150 of file TMath.h. ◆ H(). constexpr Double_t TMath::H ; (; ). constexpr . Planck's constant in \( J s \): \( h \). ; Definition at line 188 of file TMath.h. ◆ Hash() [1/2]. ULong_t TMath::Hash ; (; const char * ; str). Definition at line 1416 of file TMath.cxx. ◆ Hash() [2/2]. ULong_t TMath::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). Calculates hash index from any char string. ; Based on pre-calculated table of 256 specially selected numbers. These numbers are selected in such a way, that for string length == 4 (integer number) the hash is unambiguous, i.e. from hash value we can recalculate input (no degeneration).; The quality of hash method is good enough, that ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N) tested by <R>, <R*R>, <Ri*Ri+1> gives the same result as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*)); V.Perev; This function is kept for back compatibility. The code previously in this function has been moved to the static function TString::Hash . Definition at line 1408 of file TMath.cxx. ◆ Hbar(). constexpr Double_t TMath::Hbar ; (; ). constexpr . \( \hbar \) in \( J s \): \( \hbar = \frac{h}{2\pi} \) ; Definition at line 211 of file TMath.h. ◆ Hbarcgs(). constexpr Double_t TMath::Hbarcgs ; (; ). constexpr . \( erg s \) ; Definition at line 218 of file TMath.h. ◆ HbarUncertainty(). constexpr Double_t TMath::HbarUncertainty ; (; ). constexpr . \( \hbar \) uncertainty. ; Definition at line 225 of file TMath.h. ◆ HC(). constexpr Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:46967,hash,hash,46967,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['hash'],['hash']
Security," . kBase Base class element . kOffsetL Fixed size array . kOffsetP Pointer to object . kCounter Counter for array size . kCharStar Pointer to array of char . kLegacyChar Equal to TDataType's kchar . kBits TObject::fBits in case of a referenced object . kObject Class derived from TObject, or for TStreamerSTL::fCtype non-pointer elements . kObjectp Class* derived from TObject and with comment field //->Class, or for TStreamerSTL::fCtype: pointer elements . kObjectP Class* derived from TObject and with NO comment field //->Class . kAny Class not derived from TObject . kAnyp Class* not derived from TObject with comment field //->Class . kAnyP Class* not derived from TObject with NO comment field //->Class . kAnyPnoVT Class* not derived from TObject with NO comment field //->Class and Class has NO virtual table . kSTLp Pointer to STL container . kTString TString, special case . kTObject TObject, special case . kTNamed TNamed , special case . kCache Cache the value in memory than is not part of the object but is accessible via a SchemaRule . kNoType Indicator that we don't know the current type because the member does not exist in memory . kUnsupportedConversion The member type onfile and in memory can not be converted . kUnset default value . EnumeratorkBase ; kOffsetL ; kOffsetP ; kCounter ; kCharStar ; kChar ; kShort ; kInt ; kLong ; kFloat ; kDouble ; kDouble32 ; kLegacyChar ; kUChar Equal to TDataType's kchar. . kUShort ; kUInt ; kULong ; kBits ; kLong64 ; kULong64 ; kBool ; kFloat16 ; kObject ; kAny ; kObjectp ; kObjectP ; kTString ; kTObject ; kTNamed ; kAnyp ; kAnyP ; kAnyPnoVT ; kSTLp ; kSkip ; kSkipL ; kSkipP ; kConv ; kConvL ; kConvP ; kSTL ; kSTLstring ; kStreamer ; kStreamLoop ; kCache ; kArtificial ; kCacheNew ; kCacheDelete ; kNeedObjectForVirtualBaseClass ; kMissing ; kNoType ; kUnsupportedConversion Type corresponding to a 'missing' data member (with kMissing offset) . kUnset . Definition at line 116 of file TVirtualStreamerInfo.h. ◆ EStatusBits. enum TVir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:19000,access,accessible,19000,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['access'],['accessible']
Security," . void * ; args . ). static . Definition at line 51 of file CPPExcInstance.cxx. ◆ eqneq_binop(). static PyObject * CPyCppyy::eqneq_binop ; (; CPPClass * ; klass, . PyObject * ; self, . PyObject * ; obj, . int ; op . ). inlinestatic . Definition at line 450 of file CPPInstance.cxx. ◆ Eval(). const CPyCppyy::PyResult CPyCppyy::Eval ; (; const std::string & ; expr). Definition at line 467 of file API.cxx. ◆ Exec(). bool CPyCppyy::Exec ; (; const std::string & ; cmd). Definition at line 446 of file API.cxx. ◆ ExecScript(). void CPyCppyy::ExecScript ; (; const std::string & ; name, . const std::vector< std::string > & ; args . ). Definition at line 318 of file API.cxx. ◆ GetAttrDirect(). static PyObject * CPyCppyy::GetAttrDirect ; (; PyObject * ; pyclass, . PyObject * ; pyname . ). inlinestatic . Definition at line 120 of file ProxyWrappers.cxx. ◆ GetScopeProxy(). PyObject * CPyCppyy::GetScopeProxy ; (; Cppyy::TCppScope_t ; scope). Definition at line 497 of file ProxyWrappers.cxx. ◆ HashSignature(). uint64_t CPyCppyy::HashSignature ; (; CPyCppyy_PyArgs_t ; args, . size_t ; nargsf . ). inline . Definition at line 17 of file CPPOverload.h. ◆ HaveImplicit(). bool CPyCppyy::HaveImplicit ; (; CallContext * ; ctxt). inline . Definition at line 132 of file CallContext.h. ◆ im_call(). static PyObject * CPyCppyy::im_call ; (; PyObject * ; meth, . PyObject * ; args, . PyObject * ; kw . ). static . Definition at line 251 of file CustomPyTypes.cxx. ◆ im_dealloc(). static void CPyCppyy::im_dealloc ; (; PyMethodObject * ; im). static . Definition at line 226 of file CustomPyTypes.cxx. ◆ im_descr_get(). static PyObject * CPyCppyy::im_descr_get ; (; PyObject * ; meth, . PyObject * ; obj, . PyObject * ; pyclass . ). static . Definition at line 295 of file CustomPyTypes.cxx. ◆ Import(). bool CPyCppyy::Import ; (; const std::string & ; name). Definition at line 259 of file API.cxx. ◆ indexiter_dealloc(). static void CPyCppyy::indexiter_dealloc ; (; indexiterobject * ; ii). static . Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceCPyCppyy.html:42575,Hash,HashSignature,42575,doc/master/namespaceCPyCppyy.html,https://root.cern,https://root.cern/doc/master/namespaceCPyCppyy.html,1,['Hash'],['HashSignature']
Security," .  . Loading...; Searching...; No Matches. RSqliteDS.cxx. Go to the documentation of this file. 1// Author: Jakob Blomer CERN 07/2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2017, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include <ROOT/RSqliteDS.hxx>; 12#include <ROOT/RRawFile.hxx>; 13 ; 14#include ""TError.h""; 15#include ""TRandom.h""; 16#include ""TSystem.h""; 17 ; 18#include <algorithm>; 19#include <cctype>; 20#include <cerrno>; 21#include <cstring> // for memcpy; 22#include <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:1049,access,access,1049,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,2,['access'],['access']
Security," // create a TChain instead of a TTree; TChain *chain = new TChain(""EventTree"", ""Event Data Chain"");; // add our file; chain->Add(""http://root.cern/files/introtutorials/eventdata.root"");; // tell the chain that we want to use PROOF; chain->SetProof();; // run the selector; chain->Process(""ProofEventSelector.C+"");. For the functions used, see the documentation of the TChain constructor and TChain::Add().; You need to register the histogram in your selector's output list, by passing it to GetOutputList()->Add(hist), ideally right after you have created it with new TH1F(...). If you don't add it to the output list, PROOF cannot know that this histogram is the result of the analysis.; Note: If the network is good, try to take this file instead: http://root.cern/files/introtutorials/eventdata-10k.root, it contains more events.; Then the TChain::Process() call is the same than before, but it will now use all your CPUs!; . ‹ Histogramming in a Selector; up; The End ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-tselector-proof.html:3571,Access,Accessing,3571,d/using-tselector-proof.html,https://root.cern,https://root.cern/d/using-tselector-proof.html,3,"['Access', 'access']","['Accessing', 'access']"
Security," // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so""))) {; 550 sovers = ""\\.[0-9]+\\.*[0-9]*\\.so"";; 551 Ssiz_t idx = lib.Index(sovers);; 552 if (idx != kNPOS) {; 553 lib.Remove(idx);; 554 lib += "".so"";; 555 }; 556 dyvers = ""\\.[0-9]+\\.*[0-9]*\\.dylib"";; 557 idx = lib.Index(dyvers);; 558 if (idx != kNPOS) {; 559 lib.Remove(idx);; 560 lib += "".dylib"";; 561 }; 562 if (!gSystem->AccessPathName(lib, kReadPermission)) {; 563 if (linkedDylibs.Length()); 564 linkedDylibs += "" "";; 565 linkedDylibs += lib;; 566 }; 567 }; 568}; 569#endif; 570 ; 571ClassImp(TUnixSystem);; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574 ; 575TUnixSystem::TUnixSystem() : TSystem(""Unix"", ""Unix System""); 576{ }; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Reset to original state.; 580 ; 581TUnixSystem::~TUnixSystem(); 582{; 583 UnixResetSignals();; 584 ; 585 delete fReadmask;; 586 delete fWritemask;; 587 delete fReadready;; 588 delete fWriteready;; 589 delete fSignals;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Initialize Unix system interface.; 594 ; 595Bool_t TUnixSystem::Init(); 596{; 597 if (TSystem::Init()); 598 return kTRUE;; 599 ; 600 fReadmask = new TFdSet;; 601 fWritemask = new TFdSet;; 602 fReadready = new TFdSet;; 603 fWriteready =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:16594,Access,AccessPathName,16594,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['Access'],['AccessPathName']
Security," ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 61 //kSetupMatchConversion = 1, /// This branch has been set up, the branch data type can be converted to the reader template type, reading should succeed.; 62 //kSetupMatchConversionCollection = 2, /// This branch has been set up, the data type of the branch's collection elements can be converted to the reader template type, reading should succeed.; 63 //kSetupMakeClass = 3, /// This branch has been set up, enabling MakeClass mode for it, reading should succeed.; 64 // kSetupVoidPtr = 4,; 65 kSetupNoCheck = 5,; 66 kSetupMatchLeaf = 6 ///< This branch (or TLeaf, really) has been set up, reading should succeed.; 67 };; 68 enum EReadStatus {; 69 kReadSuccess = 0, ///< Data read okay; 70 kReadNothingYet, ///< Data now yet accessed; 71 kReadError ///< Problem reading data; 72 };; 73 ; 74 EReadStatus ProxyRead() { return (this->*fProxyReadFunc)(); }; 75 ; 76 EReadStatus ProxyReadDefaultImpl();; 77 ; 78 typedef bool (ROOT::Detail::TBranchProxy::*BranchProxyRead_t)();; 79 template <BranchProxyRead_t Func>; 80 ROOT::Internal::TTreeReaderValueBase::EReadStatus ProxyReadTemplate();; 81 ; 82 /// Return true if the branch was setup \em and \em read correctly.; 83 /// Use GetSetupStatus() to only check the setup status.; 84 bool IsValid() const { return fProxy && 0 == (int)fSetupStatus && 0 == (int)fReadStatus; }; 85 /// Return this TTreeReaderValue's setup status.; 86 /// Use this method to check e.g. whether the TTreeReaderValue is correctly setup and ready for reading.; 87 ESetupStatus GetSetupStatus() const { return fSetupStatus; }; 88 virtual EReadStatus GetReadStatus() const { return fReadStatus; }; 89 ; 90 /// If we are reading a leaf, return the corresponding TLeaf.; 91 TLeaf* GetLeaf() { return fLeaf; }; 92 ; 93 void* GetAddress();; 94 ; 95 const char* GetBranchName() const { return fBranchName; }; 96 ; 97 virtual ~TTreeReaderValueBase();; 98 ; 99 protected:; 100",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:3296,access,accessed,3296,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,1,['access'],['accessed']
Security," 0); 633 return r;; 634 ; 635 if (!insert); 636 return nullptr;; 637 ; 638 fgTable[slot] = new TClassRec(fgTable[slot]);; 639 ; 640 fgTally++;; 641 return fgTable[slot];; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Returns the ID of a class.; 646 ; 647Version_t TClassTable::GetID(const char *cname); 648{; 649 NormalizeThenLock guard(cname);; 650 ; 651 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 652 if (r); 653 return r->fId;; 654 return -1;; 655}; 656 ; 657////////////////////////////////////////////////////////////////////////////////; 658/// Returns the pragma bits as specified in the LinkDef.h file.; 659 ; 660Int_t TClassTable::GetPragmaBits(const char *cname); 661{; 662 NormalizeThenLock guard(cname);; 663 ; 664 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 665 if (r); 666 return r->fBits;; 667 return 0;; 668}; 669 ; 670////////////////////////////////////////////////////////////////////////////////; 671/// Given the class name returns the Dictionary() function of a class; 672/// (uses hash of name).; 673 ; 674DictFuncPtr_t TClassTable::GetDict(const char *cname); 675{; 676 if (gDebug > 9) {; 677 ::Info(""GetDict"", ""searches for %s"", cname);; 678 fgIdMap->Print();; 679 }; 680 NormalizeThenLock guard(cname);; 681 ; 682 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 683 if (r); 684 return r->fDict;; 685 return nullptr;; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// Given the std::type_info returns the Dictionary() function of a class; 690/// (uses hash of std::type_info::name()).; 691 ; 692DictFuncPtr_t TClassTable::GetDict(const std::type_info& info); 693{; 694 if (!CheckClassTableInit()); 695 return nullptr;; 696 ; 697 if (gDebug > 9); 698 ROOT::GetROOT(); // Info might recursively call TClassTable during the gROOT init; 699 ; 700 std::lock_guard<std::mutex> lock(GetCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:22026,hash,hash,22026,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['hash'],['hash']
Security," 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*RooLinkedList::findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidRooLinkedList::swapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*RooLinkedList::_first! Link to first element of list; Int_tRooLinkedList::_hashThreshSize threshold for hashing; RooHashTable*RooLinkedList::_htableLink! Hash table by link pointer; RooHashTable*RooLinkedList::_htableName! Hash table by name ; RooLinkedListElem*RooLinkedList::_last! Link to last element of list; TStringRooLinkedList::_name; Int_tRooLinkedList::_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRefCountList(); Default constructor construct lists with initial hash table size of 17. void Add(TObject* obj, Int_t count); Add object to list with given reference count increment; List takes ownership of object. Bool_t Remove(TObject* obj); Remove object from list and if reference count; reaches zero delete object itself as well. Bool_t RemoveAll(TObject* obj); Remove object from list and delete object itself; regardless of reference count. Int_t refCount(TObject* obj); Return reference count associated with 'obj'. RooRefCountList(). virtual ~RooRefCountList(); {}. void Add(TObject* arg); { Add(arg,1) ; }. » Last changed: Mon Dec 7 13:48:57 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRefCountList.html:6924,hash,hash,6924,root/html526/RooRefCountList.html,https://root.cern,https://root.cern/root/html526/RooRefCountList.html,1,['hash'],['hash']
Security," 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*RooLinkedList::findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidRooLinkedList::swapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*RooLinkedList::_first! Link to first element of list; Int_tRooLinkedList::_hashThreshSize threshold for hashing; RooHashTable*RooLinkedList::_htableLink! Hash table by link pointer; RooHashTable*RooLinkedList::_htableName! Hash table by name ; RooLinkedListElem*RooLinkedList::_last! Link to last element of list; TStringRooLinkedList::_name; Int_tRooLinkedList::_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRefCountList(); Default constructor construct lists with initial hash table size of 17. void Add(TObject* obj, Int_t count); Add object to list with given reference count increment; List takes ownership of object. Bool_t Remove(TObject* obj); Remove object from list and if reference count; reaches zero delete object itself as well. Bool_t RemoveAll(TObject* obj); Remove object from list and delete object itself; regardless of reference count. Int_t refCount(TObject* obj); Return reference count associated with 'obj'. RooRefCountList(). virtual ~RooRefCountList(); {}. void Add(TObject* arg); { Add(arg,1) ; }. » Last changed: Mon Jul 4 15:23:54 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRefCountList.html:6979,hash,hash,6979,root/html530/RooRefCountList.html,https://root.cern,https://root.cern/root/html530/RooRefCountList.html,1,['hash'],['hash']
Security," 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*RooLinkedList::findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidRooLinkedList::swapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*RooLinkedList::_first! Link to first element of list; Int_tRooLinkedList::_hashThreshSize threshold for hashing; RooHashTable*RooLinkedList::_htableLink! Hash table by link pointer; RooHashTable*RooLinkedList::_htableName! Hash table by name ; RooLinkedListElem*RooLinkedList::_last! Link to last element of list; TStringRooLinkedList::_name; Int_tRooLinkedList::_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRefCountList(); Default constructor construct lists with initial hash table size of 17. void Add(TObject* obj, Int_t count); Add object to list with given reference count increment; List takes ownership of object. Bool_t Remove(TObject* obj); Remove object from list and if reference count; reaches zero delete object itself as well. Bool_t RemoveAll(TObject* obj); Remove object from list and delete object itself; regardless of reference count. Int_t refCount(TObject* obj); Return reference count associated with 'obj'. RooRefCountList(). virtual ~RooRefCountList(); {}. void Add(TObject* arg); { Add(arg,1) ; }. » Last changed: Sat Oct 9 06:58:43 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRefCountList.html:6910,hash,hash,6910,root/html528/RooRefCountList.html,https://root.cern,https://root.cern/root/html528/RooRefCountList.html,1,['hash'],['hash']
Security," 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*RooLinkedList::findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidRooLinkedList::swapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*RooLinkedList::_first! Link to first element of list; Int_tRooLinkedList::_hashThreshSize threshold for hashing; RooHashTable*RooLinkedList::_htableLink! Hash table by link pointer; RooHashTable*RooLinkedList::_htableName! Hash table by name ; RooLinkedListElem*RooLinkedList::_last! Link to last element of list; TStringRooLinkedList::_name; Int_tRooLinkedList::_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRefCountList(); Default constructor construct lists with initial hash table size of 17. void Add(TObject* obj, Int_t count); Add object to list with given reference count increment; List takes ownership of object. Bool_t Remove(TObject* obj); Remove object from list and if reference count; reaches zero delete object itself as well. Bool_t RemoveAll(TObject* obj); Remove object from list and delete object itself; regardless of reference count. Int_t refCount(TObject* obj); Return reference count associated with 'obj'. RooRefCountList(). virtual ~RooRefCountList(); {}. void Add(TObject* arg); { Add(arg,1) ; }. » Last changed: Thu Nov 3 20:09:10 2011 » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRefCountList.html:7023,hash,hash,7023,root/html532/RooRefCountList.html,https://root.cern,https://root.cern/root/html532/RooRefCountList.html,1,['hash'],['hash']
Security," 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tRooAbsGenContext::isValid() const; Bool_tRooAbsGenContext::isVerbose() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinnedGenContext.html:2863,Hash,Hash,2863,root/html534/RooBinnedGenContext.html,https://root.cern,https://root.cern/root/html534/RooBinnedGenContext.html,2,['Hash'],['Hash']
Security," 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tRooAbsGenContext::isValid() const; Bool_tRooAbsGenContext::isVerbose() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinnedGenContext.html:2705,Hash,Hash,2705,root/html602/RooBinnedGenContext.html,https://root.cern,https://root.cern/root/html602/RooBinnedGenContext.html,4,['Hash'],['Hash']
Security," 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tisValid() const; Bool_tisVerbose() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsGenContext.html:3074,Hash,Hash,3074,root/html602/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html,1,['Hash'],['Hash']
Security," 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA::Types::EVariableTransformTMVA::VariableTransformBase::GetVariableTransform() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitialize(); virtual voidTObject::Inspect() constMENU ; virtual const TMVA::Event*InverseTransform(const TMVA::Event *const, Int_t cls) const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTMVA::VariableTransformBase::IsCreated() const; Bool_tTMVA::VariableTransformBase::IsEnabled() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTMVA::VariableTransformBase::IsNormalised() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; TMVA::MsgLogger&TMVA::VariableTransformBase::Log() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__VariableDecorrTransform.html:2472,Hash,Hash,2472,root/html528/TMVA__VariableDecorrTransform.html,https://root.cern,https://root.cern/root/html528/TMVA__VariableDecorrTransform.html,2,['Hash'],['Hash']
Security," 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidReset(). Data Members; public:. enum TParameter::EStatusBits { kMultiply; kMax; kMin; kFirst; kLast; kIsConst; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfName; long longfVal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t TParameter<AParamType> Merge(TCollection* in); Merge objects in the list.; Returns the number of objects that were in the list. void Reset(). const char * GetName() const; { return fName; }. const AParamType & GetVal() const; { return fVal; }. Bool_t IsConst() const; { return (TestBit(kIsConst) ? kTRUE : kFALSE); }. void SetVal(const long long& val); { fVal = val; }. void SetMergeMode(char mergemode = '+'); Merging modes:; '+' addition ('OR' for booleans) [default]; '*' multiplication ('AND' for booleans); 'M' maximum ('OR' for booleans); 'm' minimum ('AND' for booleans); 'f' first value; 'l' last value. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsSortable() const; { return kTRUE; }. Int_t Compare(const TObject* obj) const; Compare two TParameter objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp). void ls(Option_t* ) const; Print this parameter content. void Print(Option_t* ) const; Print this parameter content. cout << IsA(). » Author: Maarten Ballintijn 21/06/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TParameter_Long64_t_.html:6326,Hash,Hash,6326,root/html534/TParameter_Long64_t_.html,https://root.cern,https://root.cern/root/html534/TParameter_Long64_t_.html,2,['Hash'],['Hash']
Security," 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidReset(). Data Members; public:. enum EStatusBits { kMultiply; kMax; kMin; kFirst; kLast; kIsConst; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfName; doublefVal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t TParameter<AParamType> Merge(TCollection* in); Merge objects in the list.; Returns the number of objects that were in the list. void Reset(). const char * GetName() const; { return fName; }. const AParamType & GetVal() const; { return fVal; }. Bool_t IsConst() const; { return (TestBit(kIsConst) ? kTRUE : kFALSE); }. void SetVal(const double& val); { fVal = val; }. void SetMergeMode(char mergemode = '+'); Merging modes:; '+' addition ('OR' for booleans) [default]; '*' multiplication ('AND' for booleans); 'M' maximum ('OR' for booleans); 'm' minimum ('AND' for booleans); 'f' first value; 'l' last value. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsSortable() const; { return kTRUE; }. Int_t Compare(const TObject* obj) const; Compare two TParameter objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp). void ls(Option_t* ) const; Print this parameter content. void Print(Option_t* ) const; Print this parameter content. cout << IsA(). » Author: Maarten Ballintijn 21/06/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TParameter_double_.html:6340,Hash,Hash,6340,root/html534/TParameter_double_.html,https://root.cern,https://root.cern/root/html534/TParameter_double_.html,2,['Hash'],['Hash']
Security," 0.33333334, 0.25 , 0.2 ,; 0.16666667, 0.14285715, 0.125 , 0.11111111, 0.1 ],; dtype=float32)}; ; Read-out of the filtered RDataFrame:; {'x': ndarray([6, 7, 8, 9], dtype=int32), 'y': ndarray([0.14285715, 0.125 , 0.11111111, 0.1 ], dtype=float32)}; ; Read-out of the filtered RDataFrame with the columns option:; {'x': ndarray([6, 7, 8, 9], dtype=int32)}; ; Read-out of the filtered RDataFrame with the exclude option:; {'y': ndarray([0.14285715, 0.125 , 0.11111111, 0.1 ], dtype=float32)}; ; Read-out of C++ objects:; [<cppyy.gbl.CustomObject object at 0xe484480>; <cppyy.gbl.CustomObject object at 0xe484484>; <cppyy.gbl.CustomObject object at 0xe484488>; <cppyy.gbl.CustomObject object at 0xe48448c>; <cppyy.gbl.CustomObject object at 0xe484490>; <cppyy.gbl.CustomObject object at 0xe484494>; <cppyy.gbl.CustomObject object at 0xe484498>; <cppyy.gbl.CustomObject object at 0xe48449c>; <cppyy.gbl.CustomObject object at 0xe4844a0>; <cppyy.gbl.CustomObject object at 0xe4844a4>]; ; Access to all methods and data members of the C++ object:; Object: <cppyy.gbl.CustomObject object at 0xe484480>; Access data member: custom_object.x = 42; ; Content of the ROOT.RDataFrame as pandas.DataFrame:; custom_object x y; 0 <cppyy.gbl.CustomObject object at 0xe484480> 0 1.000000; 1 <cppyy.gbl.CustomObject object at 0xe484484> 1 0.500000; 2 <cppyy.gbl.CustomObject object at 0xe484488> 2 0.333333; 3 <cppyy.gbl.CustomObject object at 0xe48448c> 3 0.250000; 4 <cppyy.gbl.CustomObject object at 0xe484490> 4 0.200000; 5 <cppyy.gbl.CustomObject object at 0xe484494> 5 0.166667; 6 <cppyy.gbl.CustomObject object at 0xe484498> 6 0.142857; 7 <cppyy.gbl.CustomObject object at 0xe48449c> 7 0.125000; 8 <cppyy.gbl.CustomObject object at 0xe4844a0> 8 0.111111; 9 <cppyy.gbl.CustomObject object at 0xe4844a4> 9 0.100000; ; DateDecember 2018 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df026_AsNumpyArrays.py. tutorialsdataframedf026_AsNumpyArrays.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df026__AsNumpyArrays_8py.html:4928,Access,Access,4928,doc/master/df026__AsNumpyArrays_8py.html,https://root.cern,https://root.cern/doc/master/df026__AsNumpyArrays_8py.html,1,['Access'],['Access']
Security," 1 1995.Definition TUnixSystem.cxx:2970; TUnixSystem::UnixResetSignalstatic void UnixResetSignal(ESignals sig)Restore old signal handler for specified signal.Definition TUnixSystem.cxx:3821; TUnixSystem::GetServiceByNameint GetServiceByName(const char *service) overrideGet port # of internet service.Definition TUnixSystem.cxx:3171; TUnixSystem::FindFileconst char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists) overrideFind location of file ""wfil"" in a search path.Definition TUnixSystem.cxx:1927; TUnixSystem::SigAlarmInterruptsSyscallsvoid SigAlarmInterruptsSyscalls(Bool_t set) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid Di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:209138,access,access,209138,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,['access'],['access']
Security," 1) const; Int_tTArray::GetSize() const; virtual Double_tTH1::GetSkewness(Int_t axis = 1) const; virtual voidGetStats(Double_t* stats) const; Double_tTH1::GetStdDev(Int_t axis = 1) const; Double_tTH1::GetStdDevError(Int_t axis = 1) const; Stat_tTArrayD::GetSum() const; virtual Double_tTH1::GetSumOfWeights() const; virtual TArrayD*TH1::GetSumw2(); virtual const TArrayD*TH1::GetSumw2() const; virtual Int_tTH1::GetSumw2N() const; virtual Float_tTH1::GetTickLength(Option_t* axis = ""X"") const; virtual const char*TNamed::GetTitle() const; virtual Style_tTH1::GetTitleFont(Option_t* axis = ""X"") const; virtual Float_tTH1::GetTitleOffset(Option_t* axis = ""X"") const; virtual Float_tTH1::GetTitleSize(Option_t* axis = ""X"") const; virtual Double_tGetTmax() const; virtual Double_tGetTmin() const; virtual UInt_tTObject::GetUniqueID() const; TAxis*TH1::GetXaxis() const; TAxis*TH1::GetYaxis() const; TAxis*TH1::GetZaxis() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual Double_tTH3::Integral(Option_t* option = """") const; virtual Double_tTH3::Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Option_t* option = """") const; virtual Double_tTH3::IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t& err, Option_t* option = """") const; virtual Double_tTH3::Interpolate(Double_t x); virtual Double_tTH3::Interpolate(Double_t x, Double_t y); virtual Double_tTH3::Interpolate(Double_t x, Double_t y, Double_t z); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTH1::IsBinOverflow(Int_t bin) const; Bool_tTH1::IsBinUnderflow(Int_t bin) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile3D.html:13036,Hash,Hash,13036,root/html534/TProfile3D.html,https://root.cern,https://root.cern/root/html534/TProfile3D.html,1,['Hash'],['Hash']
Security," 1) const; Int_tTArray::GetSize() const; virtual Double_tTH1::GetSkewness(Int_t axis = 1) const; virtual voidGetStats(Double_t* stats) const; Double_tTH1::GetStdDev(Int_t axis = 1) const; Double_tTH1::GetStdDevError(Int_t axis = 1) const; Stat_tTArrayD::GetSum() const; virtual Double_tTH1::GetSumOfWeights() const; virtual TArrayD*TH1::GetSumw2(); virtual const TArrayD*TH1::GetSumw2() const; virtual Int_tTH1::GetSumw2N() const; virtual Float_tTH1::GetTickLength(Option_t* axis = ""X"") const; virtual const char*TNamed::GetTitle() const; virtual Style_tTH1::GetTitleFont(Option_t* axis = ""X"") const; virtual Float_tTH1::GetTitleOffset(Option_t* axis = ""X"") const; virtual Float_tTH1::GetTitleSize(Option_t* axis = ""X"") const; virtual UInt_tTObject::GetUniqueID() const; TAxis*TH1::GetXaxis() const; TAxis*TH1::GetYaxis() const; TAxis*TH1::GetZaxis() const; virtual Double_tGetZmax() const; virtual Double_tGetZmin() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual Double_tTH2::Integral(Option_t* option = """") const; virtual Double_tTH2::Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Option_t* option = """") const; virtual Double_tTH2::Integral(Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Option_t* = """") const; virtual Double_tTH2::IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Double_t& err, Option_t* option = """") const; virtual Double_tTH2::Interpolate(Double_t x); virtual Double_tTH2::Interpolate(Double_t x, Double_t y); virtual Double_tTH2::Interpolate(Double_t x, Double_t y, Double_t z); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTH1::IsBinOverflow(Int_t bin) const; Bool_tTH1::IsBinUnderflow(Int_t bin) const; virtual Bool_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile2D.html:13623,Hash,Hash,13623,root/html534/TProfile2D.html,https://root.cern,https://root.cern/root/html534/TProfile2D.html,1,['Hash'],['Hash']
Security," 1) const; Int_tTArray::GetSize() const; virtual Double_tTH1::GetSkewness(Int_t axis = 1) const; virtual voidGetStats(Double_t* stats) const; Double_tTH1::GetStdDev(Int_t axis = 1) const; Double_tTH1::GetStdDevError(Int_t axis = 1) const; Stat_tTArrayD::GetSum() const; virtual Double_tTH1::GetSumOfWeights() const; virtual TArrayD*TH1::GetSumw2(); virtual const TArrayD*TH1::GetSumw2() const; virtual Int_tTH1::GetSumw2N() const; virtual Float_tTH1::GetTickLength(Option_t* axis = ""X"") const; virtual const char*TNamed::GetTitle() const; virtual Style_tTH1::GetTitleFont(Option_t* axis = ""X"") const; virtual Float_tTH1::GetTitleOffset(Option_t* axis = ""X"") const; virtual Float_tTH1::GetTitleSize(Option_t* axis = ""X"") const; virtual UInt_tTObject::GetUniqueID() const; TAxis*TH1::GetXaxis() const; TAxis*TH1::GetYaxis() const; virtual Double_tGetYmax() const; virtual Double_tGetYmin() const; TAxis*TH1::GetZaxis() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual Double_tTH1::Integral(Option_t* option = """") const; virtual Double_tTH1::Integral(Int_t binx1, Int_t binx2, Option_t* option = """") const; virtual Double_tTH1::IntegralAndError(Int_t binx1, Int_t binx2, Double_t& err, Option_t* option = """") const; virtual Double_tTH1::Interpolate(Double_t x); virtual Double_tTH1::Interpolate(Double_t x, Double_t y); virtual Double_tTH1::Interpolate(Double_t x, Double_t y, Double_t z); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTH1::IsBinOverflow(Int_t bin) const; Bool_tTH1::IsBinUnderflow(Int_t bin) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:12957,Hash,Hash,12957,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,1,['Hash'],['Hash']
Security," 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.603058 0.0404042 4443.23 0; : ; : Elapsed time for training with 3200 events: 6.25 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.214 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.805395; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:17977,validat,validation,17977,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['validat'],['validation']
Security," 1136}; 1137 ; 1138 ; 1139FUNCTION_MAY_BE_UNUSED; 1140static ptrdiff_t; 1141mg_atomic_dec(volatile ptrdiff_t *addr); 1142{; 1143 ptrdiff_t ret;; 1144 ; 1145#if defined(_WIN64) && !defined(NO_ATOMICS); 1146 ret = InterlockedDecrement64(addr);; 1147#elif defined(_WIN32) && !defined(NO_ATOMICS); 1148 ret = InterlockedDecrement(addr);; 1149#elif defined(__GNUC__) \; 1150 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1151 && !defined(NO_ATOMICS); 1152 ret = __sync_sub_and_fetch(addr, 1);; 1153#else; 1154 mg_global_lock();; 1155 ret = (--(*addr));; 1156 mg_global_unlock();; 1157#endif; 1158 return ret;; 1159}; 1160 ; 1161 ; 1162#if defined(USE_SERVER_STATS) || defined(STOP_FLAG_NEEDS_LOCK); 1163static ptrdiff_t; 1164mg_atomic_add(volatile ptrdiff_t *addr, ptrdiff_t value); 1165{; 1166 ptrdiff_t ret;; 1167 ; 1168#if defined(_WIN64) && !defined(NO_ATOMICS); 1169 ret = InterlockedAdd64(addr, value);; 1170#elif defined(_WIN32) && !defined(NO_ATOMICS); 1171 ret = InterlockedExchangeAdd(addr, value) + value;; 1172#elif defined(__GNUC__) \; 1173 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1174 && !defined(NO_ATOMICS); 1175 ret = __sync_add_and_fetch(addr, value);; 1176#else; 1177 mg_global_lock();; 1178 *addr += value;; 1179 ret = (*addr);; 1180 mg_global_unlock();; 1181#endif; 1182 return ret;; 1183}; 1184 ; 1185 ; 1186FUNCTION_MAY_BE_UNUSED; 1187static ptrdiff_t; 1188mg_atomic_compare_and_swap(volatile ptrdiff_t *addr,; 1189 ptrdiff_t oldval,; 1190 ptrdiff_t newval); 1191{; 1192 ptrdiff_t ret;; 1193 ; 1194#if defined(_WIN64) && !defined(NO_ATOMICS); 1195 ret = InterlockedCompareExchange64(addr, newval, oldval);; 1196#elif defined(_WIN32) && !defined(NO_ATOMICS); 1197 ret = InterlockedCompareExchange(addr, newval, oldval);; 1198#elif defined(__GNUC__) \; 1199 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1200 && !defined(NO_ATOMICS); 1201 ret = __sync_val_compare_and_swap(addr, oldval, newval);; 1202#else; 1203 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:36599,Interlock,InterlockedExchangeAdd,36599,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['Interlock'],['InterlockedExchangeAdd']
Security," 1346 ; 1347 if (handler->HandleWS(arg)) {; 1348 arg->SetMethod(""WS_READY"");; 1349 ; 1350 if (handler->HandleWS(arg)); 1351 arg->SetTextContent(std::string(israw ? ""txt:"" : """") + std::to_string(arg->GetWSId()));; 1352 } else {; 1353 arg->TakeWSEngine(); // delete handle; 1354 }; 1355 ; 1356 process = arg->IsText();; 1357 } else {; 1358 TUrl url;; 1359 url.SetOptions(arg->fQuery);; 1360 url.ParseOptions();; 1361 const char *connid = url.GetValueFromOptions(""connection"");; 1362 if (connid); 1363 arg->SetWSId(std::stoul(connid));; 1364 if (url.HasOption(""close"")) {; 1365 arg->SetMethod(""WS_CLOSE"");; 1366 arg->SetTextContent(""OK"");; 1367 } else {; 1368 arg->SetMethod(""WS_DATA"");; 1369 }; 1370 ; 1371 process = handler->HandleWS(arg);; 1372 }; 1373 }; 1374 ; 1375 if (!process); 1376 arg->Set404();; 1377 ; 1378 return process;; 1379}; 1380 ; 1381////////////////////////////////////////////////////////////////////////////////; 1382/// Restrict access to specified object; 1383///; 1384/// See TRootSniffer::Restrict() for more details; 1385 ; 1386void THttpServer::Restrict(const char *path, const char *options); 1387{; 1388 fSniffer->Restrict(path, options);; 1389}; 1390 ; 1391////////////////////////////////////////////////////////////////////////////////; 1392/// Register command which can be executed from web interface; 1393///; 1394/// As method one typically specifies string, which is executed with; 1395/// gROOT->ProcessLine() method. For instance:; 1396///; 1397/// serv->RegisterCommand(""Invoke"",""InvokeFunction()"");; 1398///; 1399/// Or one could specify any method of the object which is already registered; 1400/// to the server. For instance:; 1401///; 1402/// serv->Register(""/"", hpx);; 1403/// serv->RegisterCommand(""/ResetHPX"", ""/hpx/->Reset()"");; 1404///; 1405/// Here symbols '/->' separates item name from method to be executed; 1406///; 1407/// One could specify additional arguments in the command with; 1408/// syntax like %arg1%, %arg2% and so on. For example:; 140",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:44126,access,access,44126,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['access'],['access']
Security," 1458/// structure (see TSystem.h).; 1459/// The function returns 0 in case of success and 1 if the file could; 1460/// not be stat'ed.; 1461 ; 1462int TSystem::GetPathInfo(const char *, FileStat_t &); 1463{; 1464 AbstractMethod(""GetPathInfo(const char *, FileStat_t&)"");; 1465 return 1;; 1466}; 1467 ; 1468////////////////////////////////////////////////////////////////////////////////; 1469/// Get info about a file system: fs type, block size, number of blocks,; 1470/// number of free blocks.; 1471 ; 1472int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *); 1473{; 1474 AbstractMethod(""GetFsInfo"");; 1475 return 1;; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Return a user configured or systemwide directory to create; 1480/// temporary files in.; 1481 ; 1482const char *TSystem::TempDirectory() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:46737,secur,secure,46737,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['secur'],['secure']
Security," 15 in unweighted histogram. Fig.2 shows the result; of comparison of the unweighted histogram with 217 events (minimal expected; frequency equal to one) and the weighted histogram with 500 events (minimal; expected frequency equal to 25). Fig 2. An example of comparison of the unweighted histogram with 217 events; and the weighted histogram with 500 events:; a) unweighted histogram;; b) weighted histogram;; c) normalized residuals plot;; d) normal Q-Q plot of residuals. The value of the test statistic is equal to; 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; the two histograms is rejected for 0.05 significant level. The behavior of; the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; Fig. 2d) of residuals are not regular and we can identify the outlier or; bin with a big influence on . References:. [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; Series No. 1, London.; [2] Gagunashvili, N., 2006. test for comparison; of weighted and unweighted histograms. Statistical Problems in Particle; Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; Gagunashvili,N., Comparison of weighted and unweighted histograms,; arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics.; Princeton University Press, Princeton.; [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; Biometrics 29, 205-220.; [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; test in 2xN tables. Biometrics 21, 19-33.; [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; John Wiley & Sons Inc., New York. Double_t Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; The computation routine of the Chisquare test. For the method d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:53340,Biometric,Biometric,53340,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['Biometric'],['Biometric']
Security," 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a file name.; 1551 ; 1552const char *TUnixSystem::PrependPathName(const char *dir, TString& name); 1553{; 1554 if (name.IsNull() || name == ""."") {; 1555 if (dir) {; 1556 name = dir;; 1557 if (dir[strlen(dir) - 1] != '/'); 1558 name += '/';; 1559 } else name = """";; 1560 return name.Data();; 1561 }; 1562 ; 1563 if (!dir || !dir[0]); 1564 dir = ""/"";; 1565 else if (dir[strlen(dir) - 1] != '/'); 1566 name.Prepend('/');; 1567 name.Prepend(dir);; 1568 ; 1569 return name.Data();; 1570}; 1571 ; 1572//---- Paths & Files -----------------------------------------------------------; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Returns FALSE if one can access a file using the specified access mode.; 1576/// Mode is the same as for the Unix access(2) function.; 1577/// Attention, bizarre convention of return value!!; 1578 ; 1579Bool_t TUnixSystem::AccessPathName(const char *path, EAccessMode mode); 1580{; 1581 TSystem *helper = FindHelper(path);; 1582 if (helper); 1583 return helper->AccessPathName(path, mode);; 1584 ; 1585 if (::access(StripOffProto(path, ""file:""), mode) == 0); 1586 return kFALSE;; 1587 GetLastErrorString() = GetError();; 1588 ; 1589 return kTRUE;; 1590}; 1591 ; 1592////////////////////////////////////////////////////////////////////////////////; 1593/// Copy a file. If overwrite is true and file already exists the; 1594/// file will be overwritten. Returns 0 when successful, -1 in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 159",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:48099,access,access,48099,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,['access'],['access']
Security," 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is set, deny by default */; 15451 allow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:455828,access,access,455828,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security," 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is set, deny by default */; 15452 allow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:455861,access,access,455861,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security," 1583 return helper->AccessPathName(path, mode);; 1584 ; 1585 if (::access(StripOffProto(path, ""file:""), mode) == 0); 1586 return kFALSE;; 1587 GetLastErrorString() = GetError();; 1588 ; 1589 return kTRUE;; 1590}; 1591 ; 1592////////////////////////////////////////////////////////////////////////////////; 1593/// Copy a file. If overwrite is true and file already exists the; 1594/// file will be overwritten. Returns 0 when successful, -1 in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 1597 ; 1598int TUnixSystem::CopyFile(const char *f, const char *t, Bool_t overwrite); 1599{; 1600 if (!AccessPathName(t) && !overwrite); 1601 return -2;; 1602 ; 1603 FILE *from = fopen(f, ""r"");; 1604 if (!from); 1605 return -1;; 1606 ; 1607 FILE *to = fopen(t, ""w"");; 1608 if (!to) {; 1609 fclose(from);; 1610 return -1;; 1611 }; 1612 ; 1613 const int bufsize = 1024;; 1614 char buf[bufsize];; 1615 int ret = 0;; 1616 while (!ret && !feof(from)) {; 1617 size_t numread = fread (buf, sizeof(char), bufsize, from);; 1618 size_t numwritten = fwrite(buf, sizeof(char), numread, to);; 1619 if (numread != numwritten); 1620 ret = -3;; 1621 }; 1622 ; 1623 fclose(from);; 1624 fclose(to);; 1625 ; 1626 return ret;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Rename a file. Returns 0 when successful, -1 in case of failure.; 1631 ; 1632int TUnixSystem::Rename(const char *f, const char *t); 1633{; 1634 int ret = ::rename(f, t);; 1635 GetLastErrorString() = GetError();; 1636 return ret;; 1637}; 1638 ; 1639////////////////////////////////////////////////////////////////////////////////; 1640/// Returns TRUE if the url in 'path' points to the local file system.; 1641/// This is used to avoid going through the NIC card for local operations.; 1642 ; 1643Bool_t TUnixSystem::IsPathLocal(const char *path); 1644{; 1645 TSystem *helper = FindHelper(path);; 16",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:49105,Access,AccessPathName,49105,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['Access'],['AccessPathName']
Security," 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and no init_ssl callbacks:; 16778 * Essential data to set up TLS is missing.; 16779 */; 16780 mg_cry_ctx_internal(phys_ctx,; 16781 ""Initializing SSL failed: -%s is not set"",; 16782 config_options[SSL_CERTIFICATE].name);; 16783 return 0;; 16784 }; 16785 ; 16786 /* If a certificate chain is configured, use it. */; 16787 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16788 if (chain == NULL) {; 16789 /* Default: certificate chain in PEM file */; 16790 chain = pem;; 16791 }; 16792 if ((chain != NULL) && (*chain == 0)) {; 16793 /* If the chain is an empty string, don't use it. */; 16794 chain = NULL;; 16795 }; 16796 ; 16797 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16798 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16799 return 0;; 16800 }; 16801 ; 16802 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16803}; 16804 ; 16805 ; 16806static void; 16807uninitialize_openssl(void); 16808{; 16809#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16810 ; 16811 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16812 ; 16813 /* Shutdown according to; 16814 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16815 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16816 */; 16817 CONF_modules_unload(1);; 16818#else; 16819 int i;; 16820 ; 16821 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16822 ; 16823 /* Shutdown according to; 16824 * https://wiki.openssl.org/index.php/L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:498518,certificate,certificate,498518,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['certificate'],['certificate']
Security," 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and no init_ssl callbacks:; 16779 * Essential data to set up TLS is missing.; 16780 */; 16781 mg_cry_ctx_internal(phys_ctx,; 16782 ""Initializing SSL failed: -%s is not set"",; 16783 config_options[SSL_CERTIFICATE].name);; 16784 return 0;; 16785 }; 16786 ; 16787 /* If a certificate chain is configured, use it. */; 16788 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16789 if (chain == NULL) {; 16790 /* Default: certificate chain in PEM file */; 16791 chain = pem;; 16792 }; 16793 if ((chain != NULL) && (*chain == 0)) {; 16794 /* If the chain is an empty string, don't use it. */; 16795 chain = NULL;; 16796 }; 16797 ; 16798 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16799 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16800 return 0;; 16801 }; 16802 ; 16803 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16804}; 16805 ; 16806 ; 16807static void; 16808uninitialize_openssl(void); 16809{; 16810#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16811 ; 16812 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16813 ; 16814 /* Shutdown according to; 16815 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16816 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16817 */; 16818 CONF_modules_unload(1);; 16819#else; 16820 int i;; 16821 ; 16822 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16823 ; 16824 /* Shutdown according to; 16825 * https://wiki.openssl.org/index.php/L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:498551,certificate,certificate,498551,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['certificate'],['certificate']
Security," 171 ; 172 /// Non-owning pointer to the RLoopManager at the root of this computation graph.; 173 /// The RLoopManager is guaranteed to be always in scope if fLoopManager is not a nullptr.; 174 RDFDetail::RLoopManager *fLoopManager = nullptr;; 175 SPT_t fObjPtr; ///< Shared pointer encapsulating the wrapped result; 176 /// Owning pointer to the action that will produce this result.; 177 /// Ownership is shared with other copies of this ResultPtr.; 178 std::shared_ptr<RDFInternal::RActionBase> fActionPtr;; 179 ; 180 /// Triggers the event loop in the RLoopManager; 181 void TriggerRun();; 182 ; 183 /// Get the pointer to the encapsulated result.; 184 /// Ownership is not transferred to the caller.; 185 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 186 T *Get(); 187 {; 188 if (fActionPtr != nullptr && !fActionPtr->HasRun()); 189 TriggerRun();; 190 return fObjPtr.get();; 191 }; 192 ; 193 void ThrowIfNull(); 194 {; 195 if (fObjPtr == nullptr); 196 throw std::runtime_error(""Trying to access the contents of a null RResultPtr."");; 197 }; 198 ; 199 RResultPtr(std::shared_ptr<T> objPtr, RDFDetail::RLoopManager *lm,; 200 std::shared_ptr<RDFInternal::RActionBase> actionPtr); 201 : fLoopManager(lm), fObjPtr(std::move(objPtr)), fActionPtr(std::move(actionPtr)); 202 {; 203 }; 204 ; 205public:; 206 using Value_t = T; ///< Convenience alias to simplify access to proxied type; 207 static constexpr ULong64_t kOnce = 0ull; ///< Convenience definition to express a callback must be executed once; 208 ; 209 RResultPtr() = default;; 210 RResultPtr(const RResultPtr &) = default;; 211 RResultPtr(RResultPtr &&) = default;; 212 RResultPtr &operator=(const RResultPtr &) = default;; 213 RResultPtr &operator=(RResultPtr &&) = default;; 214 explicit operator bool() const { return bool(fObjPtr); }; 215 ; 216 /// Convert a RResultPtr<T2> to a RResultPtr<T>.; 217 ///; 218 /// Useful e.g. to store a number of RResultPtr<TH1D> and RResultPtr<TH2D> in a std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:7928,access,access,7928,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['access'],['access']
Security," 18 ; 19Wrapper around an object and giving indirect access to its content; 20even if the object is not of a class in the Cint/Reflex dictionary.; 21*/; 22 ; 23#include ""TClassRef.h""; 24 ; 25 ; 26class TVirtualObject {; 27private:; 28 ; 29 TVirtualObject(const TVirtualObject&) = delete;; 30 TVirtualObject &operator=(const TVirtualObject&) = delete;; 31 ; 32public:; 33 TClassRef fClass;; 34 void *fObject;; 35 ; 36 TVirtualObject(TClass *cl) : fClass(cl), fObject(cl ? cl->New() : nullptr) { }; 37 ~TVirtualObject() { if (fClass) fClass->Destructor(fObject); }; 38 ; 39 ; 40 TClass *GetClass() const { return fClass; }; 41 void *GetObject() const { return fObject; }; 42 ; 43};; 44 ; 45#endif // ROOT_TVirtualObject; TClassRef.h; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TVirtualObjectWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualObject.h:26; TVirtualObject::fObjectvoid * fObjectDefinition TVirtualObject.h:34; TVirtualObject::GetObjectvoid * GetObject() constDefinition TVirtualObject.h:41; TVirtualObject::fClassTClassRef fClassDefinition TVirtualObject.h:33; TVirtualObject::TVirtualObjectTVirtualObject(TClass *cl)Definition TVirtualObject.h:36; TVirtualObject::GetClassTClass * GetClass() constDefinition TVirtualObject.h:40; TVirtualObject::~TVirtualObject~TVirtualObject()Definition TVirtualObject.h:37; TVirtualObject::TVirtualObjectTVirtualObject(const TVirtualObject &)=delete; TVirtualObject::operator=TVirtualObject & operator=(const TVirtualObject &)=delete. coremetaincTVirtualObject.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualObject_8h_source.html:1890,access,access,1890,doc/master/TVirtualObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualObject_8h_source.html,1,['access'],['access']
Security," 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is populated on demand. Calling; 1851/// ~~~ {.cpp}; 1852/// gROOT->GetListOfTypes()->FindObject(nameoftype);; 1853/// ~~~; 1854/// will return the TDataType corresponding to 'nameoftype'. If the; 1855/// TDataType is not already in the list itself and the type does exist,; 1856/// a new TDataType will be created and added to the list.; 1857///; 1858/// Calling; 1859/// ~~~ {.cpp}; 1860/// gROOT->GetListOfTypes()->ls(); // or Print(); 1861/// ~~~; 1862/// list only the typedefs that have been previously accessed through the; 1863/// list (plus the builtins types).; 1864 ; 1865TCollection *TROOT::GetListOfTypes(Bool_t /* load */); 1866{; 1867 if (!fInterpreter); 1868 Fatal(""GetListOfTypes"", ""fInterpreter not initialized"");; 1869 ; 1870 return fTypes;; 1871}; 1872 ; 1873////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:71246,access,access,71246,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['access'],['access']
Security," 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfile for compatibility with; 1925/// Which(const char*,const char*,EAccessMode) version.; 1926 ; 1927const char *TUnixSystem::FindFile(const char *search, TString& wfil, EAccessMode mode); 1928{; 1929 TString show;; 1930 if (gEnv->GetValue(""Root.ShowPath"", 0)); 1931 show.Form(""Which: %s ="", wfil.Data());; 1932 ; 1933 gSystem->ExpandPathName(wfil);; 1934 ; 1935 if (wfil[0] == '/') {; 1936#if defined(R__SEEK64); 1937 struct stat64 finfo;; 1938 if (access(wfil.Data(), mode) == 0 &&; 1939 stat64(wfil.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1940#else; 1941 struct stat finfo;; 1942 if (access(wfil.Data(), mode) == 0 &&; 1943 stat(wfil.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1944#endif; 1945 if (show != """"); 1946 Printf(""%s %s"", show.Data(), wfil.Data());; 1947 return wfil.Data();; 1948 }; 1949 if (show != """"); 1950 Printf(""%s <not found>"", show.Data());; 1951 wfil = """";; 1952 return nullptr;; 1953 }; 1954 ; 1955 if (!search); 1956 search = ""."";; 1957 ; 1958 TString apwd(gSystem->WorkingDirectory());; 1959 apwd += ""/"";; 1960 for (const char* ptr = search; *ptr;) {; 1961 TString name;; 1962 if (*ptr != '/' && *ptr !='$' && *ptr != '~'); 1963 name = apwd;; 1964 const char* posEndOfPart = strchr(ptr, ':');; 1965 if (posEndOfPart) {; 1966 name.Append(ptr, posEndOfPart - ptr);; 1967 ptr = posEndOfPart + 1; // skip ':'; 1968 } else {; 1969 name.Append(ptr);; 1970 ptr += strlen(ptr);; 1971 }; 1972 ; 1973 if (!name.EndsWith(""/"")); 1974 name += '/';; 1975 name += wfil;; 1976 ; 1977 gSystem->ExpandPathName(name);; 1978#if defined(R__SEEK64); 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:59838,access,access,59838,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['access'],['access']
Security," 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:4015,hash,hash,4015,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,6,['hash'],['hash']
Security," 258 PairHolder(const PairHolder& c) : first(c.first), second(c.second) {}; 259 virtual ~PairHolder() {}; 260 private:; 261 PairHolder& operator=(const PairHolder&) = delete;; 262 };; 263 ; 264 template <class T> struct Address {; 265 virtual ~Address() {}; 266 static void* address(T ref) {; 267 return const_cast<void*>(reinterpret_cast<const void*>(&ref));; 268 }; 269 };; 270 ; 271 struct SfinaeHelper {; 272 // Use SFINAE to get the size of the container; 273 ; 274 // In general we get the size of the container with the size method; 275 template <class T>; 276 static size_t GetContainerSize(const T& c) {return c.size();}; 277 ; 278 // Since forward_list does not provide a size operator, we have to; 279 // use an alternative. This has a cost of course.; 280 template <class T, class ALLOCATOR>; 281 static size_t GetContainerSize(const std::forward_list<T,ALLOCATOR>& c) {return std::distance(c.begin(),c.end());}; 282 };; 283 ; 284 /** @class ROOT::Detail::TCollectionProxyInfo::Type; 285 *; 286 * Small helper to encapsulate basic data accesses for; 287 * all STL continers.; 288 *; 289 * @author M.Frank; 290 * @version 1.0; 291 * @date 10/10/2004; 292 */; 293 template <class T> struct Type; 294 : public Address<TYPENAME T::const_reference>; 295 {; 296 typedef T Cont_t;; 297 typedef typename T::iterator Iter_t;; 298 typedef typename T::value_type Value_t;; 299 typedef Environ<Iter_t> Env_t;; 300 typedef Env_t *PEnv_t;; 301 typedef Cont_t *PCont_t;; 302 typedef Value_t *PValue_t;; 303 ; 304 virtual ~Type() {}; 305 ; 306 static inline PCont_t object(void* ptr) {; 307 return PCont_t(PEnv_t(ptr)->fObject);; 308 }; 309 static void* size(void* env) {; 310 PEnv_t e = PEnv_t(env);; 311 e->fSize = SfinaeHelper::GetContainerSize(*PCont_t(e->fObject));; 312 return &e->fSize;; 313 }; 314 static void* clear(void* env) {; 315 object(env)->clear();; 316 return nullptr;; 317 }; 318 static void* first(void* env) {; 319 PEnv_t e = PEnv_t(env);; 320 PCont_t c = PCont_t(e->fObject);; 321#if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:9655,access,accesses,9655,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['access'],['accesses']
Security," 2889 filep->access.fp = NULL;; 2890 ; 2891 if (mg_path_suspicious(conn, path)) {; 2892 return 0;; 2893 }; 2894 ; 2895 /* filep is initialized in mg_stat: all fields with memset to,; 2896 * some fields like size and modification date with values */; 2897 found = mg_stat(conn, path, &(filep->stat));; 2898 ; 2899 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2900 /* file does not exist and will not be created */; 2901 return 0;; 2902 }; 2903 ; 2904#if defined(_WIN32); 2905 {; 2906 wchar_t wbuf[UTF16_PATH_MAX];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before fopen was called.; 2937 * Maybe it has been created now. Get stat info; 2938 * like creation time now. */; 2939 found = mg_stat(conn, path, &(filep->stat));; 2940 (void)found;; 2941 }; 2942 ; 2943 /* return OK if file is opened */; 2944 return (filep->access.fp != NULL);; 2945}; 2946 ; 2947 ; 2948/* return 0 on success, just like fclose */; 2949static int; 2950mg_fclose(struct mg_file_access *fileacc); 2951{; 2952 int ret = -1;; 2953 if (fileacc != NULL) {; 2954 if (fileacc->fp != NULL) {; 2955 ret = fclose(fileacc->fp);; 2956 }; 2957 /* reset all members of fileacc */; 2958 memset(fileacc, 0, sizeof(*fileacc));; 2959 }; 2960 return ret;; 2961}; 2962#endif /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:89361,access,access,89361,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security," 2890 filep->access.fp = NULL;; 2891 ; 2892 if (mg_path_suspicious(conn, path)) {; 2893 return 0;; 2894 }; 2895 ; 2896 /* filep is initialized in mg_stat: all fields with memset to,; 2897 * some fields like size and modification date with values */; 2898 found = mg_stat(conn, path, &(filep->stat));; 2899 ; 2900 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2901 /* file does not exist and will not be created */; 2902 return 0;; 2903 }; 2904 ; 2905#if defined(_WIN32); 2906 {; 2907 wchar_t wbuf[UTF16_PATH_MAX];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before fopen was called.; 2938 * Maybe it has been created now. Get stat info; 2939 * like creation time now. */; 2940 found = mg_stat(conn, path, &(filep->stat));; 2941 (void)found;; 2942 }; 2943 ; 2944 /* return OK if file is opened */; 2945 return (filep->access.fp != NULL);; 2946}; 2947 ; 2948 ; 2949/* return 0 on success, just like fclose */; 2950static int; 2951mg_fclose(struct mg_file_access *fileacc); 2952{; 2953 int ret = -1;; 2954 if (fileacc != NULL) {; 2955 if (fileacc->fp != NULL) {; 2956 ret = fclose(fileacc->fp);; 2957 }; 2958 /* reset all members of fileacc */; 2959 memset(fileacc, 0, sizeof(*fileacc));; 2960 }; 2961 return ret;; 2962}; 2963#endif /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:89393,access,access,89393,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security," 2902 // (And will, in the future - once we rely on compiler-generated .d files.); 2903 incPath.Insert(posISysRootEnd - 1, ""/usr/include/"");; 2904 incPath.Replace(posISysRoot, 12, "":\"""");; 2905 }; 2906 }; 2907 while ( incPath.Index("" :"") != -1 ) {; 2908 incPath.ReplaceAll("" :"","":"");; 2909 }; 2910 incPath.Prepend("":.:"");; 2911 incPath.Prepend(WorkingDirectory());; 2912 ; 2913 // ======= Get the right file names for the dictionary and the shared library; 2914 TString expFileName(filename);; 2915 ExpandPathName( expFileName );; 2916 expFileName = gSystem->UnixPathName(expFileName);; 2917 TString library = expFileName;; 2918 if (! IsAbsoluteFileName(library) ); 2919 {; 2920 const char *whichlibrary = Which(incPath,library);; 2921 if (whichlibrary) {; 2922 library = whichlibrary;; 2923 delete [] whichlibrary;; 2924 } else {; 2925 ::Error(""ACLiC"",""The file %s can not be found in the include path: %s"",filename,incPath.Data());; 2926 return kFALSE;; 2927 }; 2928 } else {; 2929 if (gSystem->AccessPathName(library)) {; 2930 ::Error(""ACLiC"",""The file %s can not be found."",filename);; 2931 return kFALSE;; 2932 }; 2933 }; 2934 { // Remove multiple '/' characters, rootcling treats them as comments.; 2935 Ssiz_t pos = 0;; 2936 while ((pos = library.Index(""//"", 2, pos, TString::kExact)) != kNPOS) {; 2937 library.Remove(pos, 1);; 2938 }; 2939 }; 2940 library = gSystem->UnixPathName(library);; 2941 TString filename_fullpath = library;; 2942 ; 2943 TString file_dirname = GetDirName( filename_fullpath );; 2944 // For some probably good reason, DirName on Windows returns the 'name' of; 2945 // the directory, omitting the drive letter (even if there was one). In; 2946 // consequence the result is not usable as a 'root directory', we need to; 2947 // add the drive letter if there was one..; 2948 if (library.Length()>1 && isalpha(library[0]) && library[1]==':') {; 2949 file_dirname.Prepend(library(0,2));; 2950 }; 2951 TString file_location( file_dirname ); // Location of the script.; 2952 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:97506,Access,AccessPathName,97506,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['Access'],['AccessPathName']
Security," 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std::cout << ""\nDone!"" << std::endl;; 362 /// \endcode; 363 // clang-format on; 364 RResultPtr<T> &OnPartialResultSlot(ULong64_t everyNEvents, std::function<void(unsigned int, T &)> callback); 365 {; 366 ThrowIfNull();; 367 auto actionPtr = fActionPtr;; 368 auto c = [actionPtr, callback](unsigned int slot) {; 369 auto partialResult = static_cast<Value_t *>(actionPtr->PartialUpdate(slot));; 370 callback(slot, *partialResult);; 371 };; 372 fLoopManager->RegisterCallback(everyNEvents, std::move(c));; 373 return *this;; 374 }; 375 ; 376 // clang-format off; 377 /// Check whether the result has already been computed; 378 ///; 379 /// ~~~{.cpp}; 380 /// auto res = df.Count();; 381 /// res.IsReady(); // false, access will trigger event loop; 382 /// std::cout << *res << std::endl; // triggers event loop; 383 /// res.IsReady(); // true; 384 /// ~~~; 385 // clang-format on; 386 bool IsReady() const; 387 {; 388 if (fActionPtr == nullptr); 389 return false;; 390 return fActionPtr->HasRun();; 391 }; 392};; 393 ; 394template <typename T>; 395void RResultPtr<T>::TriggerRun(); 396{; 397 fLoopManager->Run();; 398}; 399 ; 400template <class T1, class T2>; 401bool operator==(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs); 402{; 403 return lhs.fObjPtr == rhs.fObjPtr;; 404}; 405 ; 406template <class T1, class T2>; 407bool operator!=(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs); 408{; 409 return lhs.fObjPtr != rhs.fObjPtr;; 410}; 411 ; 412template <class T1>; 413bool operator==(const RResultPtr<T1> &lhs, std::nullptr_t rhs); 414{; 415 return lhs.fObjPtr == rhs;; 416}; 417 ; 418template <class T1>; 419bool operator==(std::nullptr_t lhs, const RResultPtr<T1> &rhs); 420{; 421 return lhs == rhs.fObjPtr;; 422}; 423 ; 424template <class T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:17138,access,access,17138,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['access'],['access']
Security, 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(),MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:16965,access,access,16965,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,2,['access'],['access']
Security," 4, Option_t* option = ""br""); Draw this pave with new coordinates. void PaintPaveArc(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); Draw this pave with rounded corners. void Print(Option_t* option = """") const; Dump this pave with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetX1(Double_t x1); Set the X1 value. void SetX2(Double_t x2); Set the X2 value. void SetY1(Double_t y1); Set the Y1 value. void SetY2(Double_t y2); Set the Y2 value. void Streamer(TBuffer& ); Stream an object of class TPave. Int_t GetBorderSize() const; { return fBorderSize;}. Double_t GetCornerRadius() const; {return fCornerRadius;}. Option_t * GetName() const; {return fName.Data();}. Option_t * GetOption() const; {return fOption.Data();}. Int_t GetShadowColor() const; {return fShadowColor;}. Double_t GetX1NDC() const; {return fX1NDC;}. Double_t GetX2NDC() const; {return fX2NDC;}. Double_t GetY1NDC() const; {return fY1NDC;}. Double_t GetY2NDC() const; {return fY2NDC;}. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsSortable() const; { return kTRUE; }. void SetBorderSize(Int_t bordersize = 4); {fBorderSize = bordersize;}. void SetCornerRadius(Double_t rad = 0.20000000000000001); {fCornerRadius = rad;}. void SetName(const char* name = """"); {fName = name;}. void SetOption(Option_t* option = ""br""); {fOption = option;}. void SetShadowColor(Int_t color); {fShadowColor=color;}. void SetX1NDC(Double_t x1); {fX1NDC=x1;}. void SetX2NDC(Double_t x2); {fX2NDC=x2;}. void SetY1NDC(Double_t y1); {fY1NDC=y1;}. void SetY2NDC(Double_t y2); {fY2NDC=y2;}. » Author: Rene Brun 16/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/graf:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPave.html:13703,Hash,Hash,13703,root/html604/TPave.html,https://root.cern,https://root.cern/root/html604/TPave.html,2,['Hash'],['Hash']
Security," 4, Option_t* option = ""br""); Draw this pave with new coordinates. void PaintPaveArc(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); Draw this pave with rounded corners. void Print(Option_t* option = """") const; Dump this pave with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetX1(Double_t x1); Set the X1 value. void SetX2(Double_t x2); Set the X2 value. void SetY1(Double_t y1); Set the Y1 value. void SetY2(Double_t y2); Set the Y2 value. void Streamer(TBuffer& ); Stream an object of class TPave. Int_t GetBorderSize() const; { return fBorderSize;}. Double_t GetCornerRadius() const; {return fCornerRadius;}. Option_t * GetName() const; {return fName.Data();}. Option_t * GetOption() const; {return fOption.Data();}. Int_t GetShadowColor() const; {return fShadowColor;}. Double_t GetX1NDC() const; {return fX1NDC;}. Double_t GetX2NDC() const; {return fX2NDC;}. Double_t GetY1NDC() const; {return fY1NDC;}. Double_t GetY2NDC() const; {return fY2NDC;}. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsSortable() const; { return kTRUE; }. void SetBorderSize(Int_t bordersize = 4); {fBorderSize = bordersize;}. void SetCornerRadius(Double_t rad = 0.20000000000000001); {fCornerRadius = rad;}. void SetName(const char* name = """"); {fName = name;}. void SetOption(Option_t* option = ""br""); {fOption = option;}. void SetShadowColor(Int_t color); {fShadowColor=color;}. void SetX1NDC(Double_t x1); {fX1NDC=x1;}. void SetX2NDC(Double_t x2); {fX2NDC=x2;}. void SetY1NDC(Double_t y1); {fY1NDC=y1;}. void SetY2NDC(Double_t y2); {fY2NDC=y2;}. » Author: Rene Brun 16/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/graf:$Id$ » Last generated: 2015-06-30 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPave.html:13703,Hash,Hash,13703,root/html602/TPave.html,https://root.cern,https://root.cern/root/html602/TPave.html,2,['Hash'],['Hash']
Security," 40; // fall through; 812 case 5: k1 ^= uint64_t(tail[ 4]) << 32; // fall through; 813 case 4: k1 ^= uint64_t(tail[ 3]) << 24; // fall through; 814 case 3: k1 ^= uint64_t(tail[ 2]) << 16; // fall through; 815 case 2: k1 ^= uint64_t(tail[ 1]) << 8; // fall through; 816 case 1: k1 ^= uint64_t(tail[ 0]) << 0;; 817 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 818 };; 819 ; 820 //----------; 821 // finalization; 822 ; 823 h1 ^= len; h2 ^= len;; 824 ; 825 h1 += h2;; 826 h2 += h1;; 827 ; 828 h1 = fmix(h1);; 829 h2 = fmix(h2);; 830 ; 831 h1 += h2;; 832 h2 += h1;; 833 ; 834 ((uint64_t*)out)[0] = h1;; 835 ((uint64_t*)out)[1] = h2;; 836 }; 837 ; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Calculates hash index from any char string. (static function); 842/// - For string: i = TString::Hash(string,nstring);; 843/// - For int: i = TString::Hash(&intword,sizeof(int));; 844/// - For pointer: i = TString::Hash(&pointer,sizeof(void*));; 845///; 846/// This employs two different hash functions, depending on ntxt:; 847/// - ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; 848/// - else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/; 849 ; 850UInt_t TString::Hash(const void *txt, Int_t ntxt); 851{; 852 if (ntxt != sizeof(void*)) {; 853 uint64_t buf[2] = {0};; 854 MurmurHash3_x64_128(txt, ntxt, 0x6384BA69, buf);; 855 return (UInt_t) buf[0];; 856 } else {; 857 // simple, superfast hash for pointers and alike; 858 UInt_t ret = (UInt_t)0x6384BA69;; 859 // aligned?; 860 if (((size_t)txt) % sizeof(void*)) {; 861 UInt_t* itxt = (UInt_t*)txt;; 862 ret ^= itxt[0];; 863 if (sizeof(void*) > sizeof(UInt_t)) {; 864 ret ^= itxt[1];; 865 }; 866 } else {; 867 const unsigned char* ctxt = (const unsigned char*) txt;; 868 for (unsigned int i = 0; i < 4; ++i) {; 869 ret ^= ctxt[i] << (i * 8);; 870 }; 871 if (sizeof(void*) > sizeof(UInt_t)) {; 872 ctxt += 4;; 873 for (unsigned int i = 0; i < 4; ++i) {; 874 ret ^",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:25330,Hash,Hash,25330,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,5,"['Hash', 'hash']","['Hash', 'hash', 'hashes']"
Security," 414 if (fVersionVect); 415 for (auto &it : *fVersionVect); 416 if( version >= it.first && version <= it.second ); 417 return kTRUE;; 418 ; 419 return kFALSE;; 420}; 421 ; 422////////////////////////////////////////////////////////////////////////////////; 423/// Set the checksum string - returns kFALSE if the format is incorrect; 424 ; 425Bool_t TSchemaRule::SetChecksum( const TString& checksum ); 426{; 427 fChecksum = """";; 428 Bool_t ret = ProcessChecksum( checksum );; 429 if( ret ); 430 fChecksum = checksum;; 431 return ret;; 432}; 433 ; 434////////////////////////////////////////////////////////////////////////////////; 435/// Check if given checksum is defined in this rule; 436 ; 437Bool_t TSchemaRule::TestChecksum( UInt_t checksum ) const; 438{; 439 if( fChecksum.IsNull() ); 440 return kFALSE;; 441 ; 442 if( !fChecksumVect ); 443 ProcessChecksum( fChecksum ); // At this point the checksum string should always be correct; 444 ; 445 if (fChecksumVect); 446 for (auto &it : *fChecksumVect); 447 if( checksum == it ); 448 return kTRUE;; 449 ; 450 return kFALSE;; 451}; 452 ; 453////////////////////////////////////////////////////////////////////////////////; 454/// Set the source class of this rule (i.e. the onfile class).; 455 ; 456void TSchemaRule::SetSourceClass( const TString& classname ); 457{; 458 std::string normalizedName;; 459 TClassEdit::GetNormalizedName(normalizedName, classname);; 460 fSourceClass = normalizedName;; 461}; 462 ; 463////////////////////////////////////////////////////////////////////////////////; 464/// Get the source class of this rule (i.e. the onfile class).; 465 ; 466const char *TSchemaRule::GetSourceClass() const; 467{; 468 return fSourceClass;; 469}; 470 ; 471////////////////////////////////////////////////////////////////////////////////; 472/// Set the target class of this rule (i.e. the in memory class).; 473 ; 474void TSchemaRule::SetTargetClass( const TString& classname ); 475{; 476 std::string normalizedName;; 477 TClassEdit::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:14453,checksum,checksum,14453,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,2,['checksum'],['checksum']
Security," 44 of file THttpServer.h. ◆ fLocations. std::map<std::string, std::string> THttpServer::fLocations. protected . ! list of local directories, which could be accessed via server ; Definition at line 48 of file THttpServer.h. ◆ fMainThrdId. Long_t THttpServer::fMainThrdId {0}. protected . ! id of the thread for processing requests ; Definition at line 38 of file THttpServer.h. ◆ fMutex. std::mutex THttpServer::fMutex. protected . ! mutex to protect list with arguments ; Definition at line 57 of file THttpServer.h. ◆ fOwnThread. Bool_t THttpServer::fOwnThread {kFALSE}. protected . ! true when specialized thread allocated for processing requests ; Definition at line 40 of file THttpServer.h. ◆ fProcessingThrdId. Long_t THttpServer::fProcessingThrdId {0}. protected . ! id of the thread where events are recently processing ; Definition at line 39 of file THttpServer.h. ◆ fSniffer. std::unique_ptr<TRootSniffer> THttpServer::fSniffer. protected . ! sniffer provides access to ROOT objects hierarchy ; Definition at line 36 of file THttpServer.h. ◆ fTerminated. Bool_t THttpServer::fTerminated {kFALSE}. protected . ! termination flag, disables all requests processing ; Definition at line 37 of file THttpServer.h. ◆ fThrd. std::thread THttpServer::fThrd. protected . ! own thread ; Definition at line 41 of file THttpServer.h. ◆ fTimer. std::unique_ptr<THttpTimer> THttpServer::fTimer. protected . ! timer used to access main thread ; Definition at line 35 of file THttpServer.h. ◆ fTopName. TString THttpServer::fTopName {""ROOT""}. protected . ! name of top folder, default - ""ROOT"" ; Definition at line 45 of file THttpServer.h. ◆ fWSHandlers. std::vector<std::shared_ptr<THttpWSHandler> > THttpServer::fWSHandlers. protected . ! list of WS handlers ; Definition at line 61 of file THttpServer.h. ◆ fWSMutex. std::mutex THttpServer::fWSMutex. protected . ! mutex to protect WS handler lists ; Definition at line 60 of file THttpServer.h. ◆ fWSOnly. Bool_t THttpServer::fWSOnly {kFALSE}. protec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:41767,access,access,41767,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['access'],['access']
Security," 472 ; 473char *TObject::GetObjectInfo(Int_t px, Int_t py) const; 474{; 475 if (!gPad) return (char*)"""";; 476 static char info[64];; 477 Float_t x = gPad->AbsPixeltoX(px);; 478 Float_t y = gPad->AbsPixeltoY(py);; 479 snprintf(info,64,""x=%g, y=%g"",gPad->PadtoX(x),gPad->PadtoY(y));; 480 return info;; 481}; 482 ; 483////////////////////////////////////////////////////////////////////////////////; 484/// Returns title of object. This default method returns the class title; 485/// (i.e. description). Classes that give objects a title should override; 486/// this method.; 487 ; 488const char *TObject::GetTitle() const; 489{; 490 return IsA()->GetTitle();; 491}; 492 ; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Execute action in response of a timer timing out. This method; 496/// must be overridden if an object has to react to timers.; 497 ; 498Bool_t TObject::HandleTimer(TTimer *); 499{; 500 return kFALSE;; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Return hash value for this object.; 505///; 506/// Note: If this routine is overloaded in a derived class, this derived class; 507/// should also add; 508/// ~~~ {.cpp}; 509/// ROOT::CallRecursiveRemoveIfNeeded(*this); 510/// ~~~; 511/// Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; 512/// type of object, the transversal of THashList and THashTable containers will; 513/// will have to be done without call Hash (and hence be linear rather than; 514/// logarithmic complexity). You will also see warnings like; 515/// ~~~; 516/// Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; 517/// ~~~; 518///; 519 ; 520ULong_t TObject::Hash() const; 521{; 522 //return (ULong_t) this >> 2;; 523 const void *ptr = this;; 524 return TString::Hash(&ptr, sizeof(void*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:17559,hash,hash,17559,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['hash'],['hash']
Security," 4810 ; 4811 // Default is not matching; 4812 return kFALSE;; 4813}; 4814 ; 4815////////////////////////////////////////////////////////////////////////////////; 4816/// Resolve the file type as a function of the protocol field in 'name'; 4817///; 4818/// If defined, the string 'prefix' is added when testing the locality of; 4819/// a 'name' with network-like structure (i.e. root://host//path); if the file; 4820/// is local, on return 'prefix' will contain the actual local path of the file.; 4821 ; 4822TFile::EFileType TFile::GetType(const char *name, Option_t *option, TString *prefix); 4823{; 4824 EFileType type = kDefault;; 4825 ; 4826 TPMERegexp re(""^(root|xroot).*"", ""i"");; 4827 if (re.Match(name)) {; 4828 //; 4829 // Should be a network file ...; 4830 type = kNet;; 4831 // ... but make sure that is not local or that a remote-like connection; 4832 // is forced. Treat it as local if:; 4833 // i) the url points to the localhost, the file will be opened in; 4834 // readonly mode and the current user has read access;; 4835 // ii) the specified user is equal to the current user then open local; 4836 // TFile.; 4837 Bool_t localFile = kFALSE;; 4838 TUrl url(name);; 4839 //; 4840 // Check whether we should try to optimize for local files; 4841 Bool_t forceRemote = gEnv->GetValue(""Path.ForceRemote"", 0);; 4842 forceRemote = (forceRemote) ? kTRUE : gEnv->GetValue(""TFile.ForceRemote"", 0);; 4843 TString opts = url.GetOptions();; 4844 if (opts.Contains(""remote=1"")); 4845 forceRemote = kTRUE;; 4846 else if (opts.Contains(""remote=0"")); 4847 forceRemote = kFALSE;; 4848 if (!forceRemote) {; 4849 // Generic locality test; 4850 localFile = gSystem->IsPathLocal(name);; 4851 if (localFile) {; 4852 // Local path including the prefix; 4853 const char *fname = url.GetFileAndOptions();; 4854 TString lfname;; 4855 if (fname[0] == '/') {; 4856 if (prefix); 4857 lfname.Form(""%s%s"", prefix->Data(), fname);; 4858 else; 4859 lfname = fname;; 4860 } else if (fname[0] == '~' || fname[0] == '$') ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:177195,access,access,177195,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['access']
Security," 539 {; 540 GetCurrentNavigator()->MasterToLocal(master, local);; 541 }; 542 void MasterToLocalVect(const Double_t *master, Double_t *local) const; 543 {; 544 GetCurrentNavigator()->MasterToLocalVect(master, local);; 545 }; 546 void MasterToLocalBomb(const Double_t *master, Double_t *local) const; 547 {; 548 GetCurrentNavigator()->MasterToLocalBomb(master, local);; 549 }; 550 void MasterToTop(const Double_t *master, Double_t *top) const;; 551 void TopToMaster(const Double_t *top, Double_t *master) const;; 552 ; 553 //--- general use getters/setters; 554 TGeoMaterial *FindDuplicateMaterial(const TGeoMaterial *mat) const;; 555 TGeoVolume *FindVolumeFast(const char *name, Bool_t multi = kFALSE);; 556 TGeoMaterial *GetMaterial(const char *matname) const;; 557 TGeoMaterial *GetMaterial(Int_t id) const;; 558 TGeoMedium *GetMedium(const char *medium) const;; 559 TGeoMedium *GetMedium(Int_t numed) const;; 560 Int_t GetMaterialIndex(const char *matname) const;; 561 ; 562 //--- GDML object accessors; 563 TGDMLMatrix *GetGDMLMatrix(const char *name) const;; 564 void AddGDMLMatrix(TGDMLMatrix *mat);; 565 TGeoOpticalSurface *GetOpticalSurface(const char *name) const;; 566 void AddOpticalSurface(TGeoOpticalSurface *optsurf);; 567 TGeoSkinSurface *GetSkinSurface(const char *name) const;; 568 void AddSkinSurface(TGeoSkinSurface *surf);; 569 TGeoBorderSurface *GetBorderSurface(const char *name) const;; 570 void AddBorderSurface(TGeoBorderSurface *surf);; 571 ; 572 // TGeoShape *GetShape(const char *name) const;; 573 TGeoVolume *GetVolume(const char *name) const;; 574 TGeoVolume *GetVolume(Int_t uid) const { return (TGeoVolume *)fUniqueVolumes->At(uid); }; 575 int GetNregions() const { return fRegions->GetEntriesFast(); }; 576 TGeoRegion *GetRegion(int i) { return (TGeoRegion *)fRegions->At(i); }; 577 Int_t GetUID(const char *volname) const;; 578 Int_t GetNNodes(); 579 {; 580 if (!fNNodes); 581 CountNodes();; 582 return fNNodes;; 583 }; 584 TGeoNodeCache *GetCache() const { return Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:31549,access,accessors,31549,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['access'],['accessors']
Security," 564This is handled by the internal class THnSparseCompactBinCoord.; 565Bin data (content and coordinates) are allocated in chunks of size; 566fChunkSize; this parameter can be set when constructing a THnSparse. Each; 567chunk is represented by an object of class THnSparseArrayChunk.; 568 ; 569Translation from an n-dimensional bin coordinate to the linear index within; 570the chunks is done by GetBin(). It creates a hash from the compacted bin; 571coordinates (the hash of a bin coordinate is the compacted coordinate itself; 572if it takes less than 8 bytes, the size of a Long64_t.; 573This hash is used to lookup the linear index in the TExMap member fBins;; 574the coordinates of the entry fBins points to is compared to the coordinates; 575passed to GetBin(). If they do not match, these two coordinates have the same; 576hash - which is extremely unlikely but (for the case where the compact bin; 577coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; 578contains a chain of linear indexes with the same hash. Iterating through this; 579chain and comparing each bin coordinates with the one passed to GetBin() will; 580retrieve the matching bin.; 581*/; 582 ; 583 ; 584ClassImp(THnSparse);; 585 ; 586////////////////////////////////////////////////////////////////////////////////; 587/// Construct an empty THnSparse.; 588 ; 589THnSparse::THnSparse():; 590 fChunkSize(1024), fFilledBins(0), fCompactCoord(nullptr); 591{; 592 fBinContent.SetOwner();; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Construct a THnSparse with ""dim"" dimensions,; 597/// with chunksize as the size of the chunks.; 598/// ""nbins"" holds the number of bins for each dimension;; 599/// ""xmin"" and ""xmax"" the minimal and maximal value for each dimension.; 600/// The arrays ""xmin"" and ""xmax"" can be NULL; in that case SetBinEdges(); 601/// must be called for each dimension.; 602 ; 603THnSparse::THnSparse(const char* name, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:22058,hash,hash,22058,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hash']
Security," 637 AddCut( cut );; 638 DefaultDataSetInfo().SetSplitOptions( opt );; 639}; 640 ; 641////////////////////////////////////////////////////////////////////////////////; 642/// prepare the training and test trees; 643 ; 644void TMVA::DataLoader::PrepareTrainingAndTestTree( TCut sigcut, TCut bkgcut, const TString& splitOpt ); 645{; 646 // if event-wise data assignment, add local trees to dataset first; 647 SetInputTreesFromEventAssignTrees();; 648 ; 649 //Log() << kINFO <<""Preparing trees for training and testing...""<< Endl;; 650 AddCut( sigcut, ""Signal"" );; 651 AddCut( bkgcut, ""Background"" );; 652 ; 653 DefaultDataSetInfo().SetSplitOptions( splitOpt );; 654}; 655 ; 656////////////////////////////////////////////////////////////////////////////////; 657/// Function required to split the training and testing datasets into a; 658/// number of folds. Required by the CrossValidation and HyperParameterOptimisation; 659/// classes. The option to split the training dataset into a training set and; 660/// a validation set is implemented but not currently used.; 661 ; 662void TMVA::DataLoader::MakeKFoldDataSet(CvSplit & s); 663{; 664 s.MakeKFoldDataSet( DefaultDataSetInfo() );; 665}; 666 ; 667////////////////////////////////////////////////////////////////////////////////; 668/// Function for assigning the correct folds to the testing or training set.; 669 ; 670void TMVA::DataLoader::PrepareFoldDataSet(CvSplit & s, UInt_t foldNumber, Types::ETreeType tt); 671{; 672 s.PrepareFoldDataSet( DefaultDataSetInfo(), foldNumber, tt );; 673}; 674 ; 675 ; 676////////////////////////////////////////////////////////////////////////////////; 677/// Recombines the dataset. The precise semantics depend on the actual split.; 678///; 679/// Similar to the inverse operation of `MakeKFoldDataSet` but _will_ differ.; 680/// See documentation for each particular split for more information.; 681///; 682 ; 683void TMVA::DataLoader::RecombineKFoldDataSet(CvSplit & s, Types::ETreeType tt); 684{; 685 s.Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataLoader_8cxx_source.html:26198,validat,validation,26198,doc/master/DataLoader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataLoader_8cxx_source.html,1,['validat'],['validation']
Security," 6435 }; 6436 }; 6437 update = kFALSE;; 6438 }; 6439 temp = colon+1;; 6440 if (*temp == 0) break;; 6441 }; 6442 //// fStreamerInfo = final;; 6443 delete [] final;; 6444 delete [] save;; 6445 return;; 6446 }; 6447 ; 6448 //info is empty. Let's build the default Streamer descriptor; 6449 ; 6450 char *temp = new char[10000];; 6451 temp[0] = 0;; 6452 char local[100];; 6453 ; 6454 //add list of base classes; 6455 TIter nextb(GetListOfBases());; 6456 TBaseClass *base;; 6457 while ((base = (TBaseClass*) nextb())) {; 6458 snprintf(local,100,""%s;"",base->GetName());; 6459 strlcat(temp,local,10000);; 6460 }; 6461 ; 6462 //add list of data members and types; 6463 TIter nextd(GetListOfDataMembers());; 6464 while ((dm = (TDataMember *) nextd())) {; 6465 if (dm->IsEnum()) continue;; 6466 if (!dm->IsPersistent()) continue;; 6467 Long_t property = dm->Property();; 6468 if (property & kIsStatic) continue;; 6469 TClass *acl = TClass::GetClass(dm->GetTypeName(),update);; 6470 update = kFALSE;; 6471 if (acl) {; 6472 if (acl->GetClassVersion() == 0) continue;; 6473 }; 6474 ; 6475 // dm->GetArrayIndex() returns an empty string if it does not; 6476 // applies; 6477 const char * index = dm->GetArrayIndex();; 6478 if (strlen(index)==0); 6479 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6480 else; 6481 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6482 strlcat(temp,local,10000);; 6483 }; 6484 //fStreamerInfo = temp;; 6485 delete [] temp;; 6486*/; 6487 return nullptr;; 6488}; 6489 ; 6490////////////////////////////////////////////////////////////////////////////////; 6491/// Return true if the checksum passed as argument is one of the checksum; 6492/// value produced by the older checksum calculation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:249038,checksum,checksum,249038,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,3,['checksum'],['checksum']
Security," 6502 }; 6503 }; 6504 update = kFALSE;; 6505 }; 6506 temp = colon+1;; 6507 if (*temp == 0) break;; 6508 }; 6509 //// fStreamerInfo = final;; 6510 delete [] final;; 6511 delete [] save;; 6512 return;; 6513 }; 6514 ; 6515 //info is empty. Let's build the default Streamer descriptor; 6516 ; 6517 char *temp = new char[10000];; 6518 temp[0] = 0;; 6519 char local[100];; 6520 ; 6521 //add list of base classes; 6522 TIter nextb(GetListOfBases());; 6523 TBaseClass *base;; 6524 while ((base = (TBaseClass*) nextb())) {; 6525 snprintf(local,100,""%s;"",base->GetName());; 6526 strlcat(temp,local,10000);; 6527 }; 6528 ; 6529 //add list of data members and types; 6530 TIter nextd(GetListOfDataMembers());; 6531 while ((dm = (TDataMember *) nextd())) {; 6532 if (dm->IsEnum()) continue;; 6533 if (!dm->IsPersistent()) continue;; 6534 Long_t property = dm->Property();; 6535 if (property & kIsStatic) continue;; 6536 TClass *acl = TClass::GetClass(dm->GetTypeName(),update);; 6537 update = kFALSE;; 6538 if (acl) {; 6539 if (acl->GetClassVersion() == 0) continue;; 6540 }; 6541 ; 6542 // dm->GetArrayIndex() returns an empty string if it does not; 6543 // applies; 6544 const char * index = dm->GetArrayIndex();; 6545 if (strlen(index)==0); 6546 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6547 else; 6548 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6549 strlcat(temp,local,10000);; 6550 }; 6551 //fStreamerInfo = temp;; 6552 delete [] temp;; 6553*/; 6554 return nullptr;; 6555}; 6556 ; 6557////////////////////////////////////////////////////////////////////////////////; 6558/// Return true if the checksum passed as argument is one of the checksum; 6559/// value produced by the older checksum calculation algorithm.; 6560 ; 6561Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6562{; 6563 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6564 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6565 }; 6566 return kFALSE;; 6567}; 6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:251789,checksum,checksum,251789,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,3,['checksum'],['checksum']
Security," 652 of file MethodPyTorch.cxx. ◆ GetMulticlassValues(). std::vector< Float_t > & MethodPyTorch::GetMulticlassValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 630 of file MethodPyTorch.cxx. ◆ GetMvaValue(). Double_t MethodPyTorch::GetMvaValue ; (; Double_t * ; errLower, . Double_t * ; errUpper . ). virtual . Implements TMVA::PyMethodBase.; Definition at line 511 of file MethodPyTorch.cxx. ◆ GetMvaValues(). std::vector< Double_t > MethodPyTorch::GetMvaValues ; (; Long64_t ; firstEvt, . Long64_t ; lastEvt, . Bool_t ; logProgress . ). virtual . get all the MVA values for the events of the current Data type ; Implements TMVA::PyMethodBase.; Definition at line 533 of file MethodPyTorch.cxx. ◆ GetNumValidationSamples(). UInt_t TMVA::MethodPyTorch::GetNumValidationSamples ; (; ). private . Validation of the ValidationSize option. ; Allowed formats are 20%, 0.2 and 100 etc.; 20% and 0.2 selects 20% of the training set as validation data.; 100 selects 100 events as the validation data. Returnsnumber of samples in validation set ; Definition at line 100 of file MethodPyTorch.cxx. ◆ GetRegressionValues(). std::vector< Float_t > & MethodPyTorch::GetRegressionValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 600 of file MethodPyTorch.cxx. ◆ HasAnalysisType(). Bool_t MethodPyTorch::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ;  . ). virtual . Implements TMVA::PyMethodBase.; Definition at line 66 of file MethodPyTorch.cxx. ◆ Init(). void MethodPyTorch::Init ; (; void ; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 279 of file MethodPyTorch.cxx. ◆ ProcessOptions(). void MethodPyTorch::ProcessOptions ; (; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 152 of file MethodPyTorch.cxx. ◆ ReadModelFromFile(). void MethodPyTorch::ReadModelFromFile ; (; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 648 of file MethodPyTorch.cxx. ◆ Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyTorch.html:32216,validat,validation,32216,doc/master/classTMVA_1_1MethodPyTorch.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyTorch.html,1,['validat'],['validation']
Security," 6662/// fileprefix.h; 6663/// ~~~; 6664/// located in the current directory or in 'path/' if it is specified.; 6665/// The class generated will be named 'fileprefix'; 6666///; 6667/// ""macrofilename"" and optionally ""cutfilename"" are expected to point; 6668/// to source files which will be included by the generated skeleton.; 6669/// Method of the same name as the file(minus the extension and path); 6670/// will be called by the generated skeleton's Process method as follow:; 6671/// ~~~ {.cpp}; 6672/// [if (cutfilename())] htemp->Fill(macrofilename());; 6673/// ~~~; 6674/// ""option"" can be used select some of the optional features during; 6675/// the code generation. The possible options are:; 6676///; 6677/// - nohist : indicates that the generated ProcessFill should not fill the histogram.; 6678///; 6679/// 'maxUnrolling' controls how deep in the class hierarchy does the; 6680/// system 'unroll' classes that are not split. Unrolling a class; 6681/// allows direct access to its data members (this emulates the behavior; 6682/// of TTreeFormula).; 6683///; 6684/// The main features of this skeleton are:; 6685///; 6686/// * on-demand loading of branches; 6687/// * ability to use the 'branchname' as if it was a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:260984,access,access,260984,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security," 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Histogramming. Preparation; Start from the previously used macro (AnalyzeTree.C).; Adding a Variable; Just like for the sum of event sizes, you need to add a variable in your macro. We want to histogram the particles' fPosX; the type of the data member should thus be TH1F *. TH1F is a 1 dimensional histogram storing floats for each bin, see the documentation. Don't forget to initialize the histogram pointer to 0, again just like for the event size sum.; Creating the Histogram; You then create the object with new TH1F(""hPosX"", ""Position in X"", 20, -5, 5);; Associate error bars with this histogram (see TH1F::Sumw2()); Filling the Histogram; The goal is to fill the histogram with the value of fPosX from the tree for all particles with a momentum > 40. You will need access to the particles' total momentum and their X position. Each TTree entry has several particles; it's thus easiest to use one TTreeReaderArray each for these Double_t values, for instance TTreeReaderArray particlesMomentum(myReader, ""fParticles.fMomentum"");. The TTreeReaderArray works just like the TTreeReaderValue we have used before, but gives you access to the number of particles using particlesMomentum.GetSize() and the n-th particle using the particlesMomentum[n] operator.; The analysis happens in loops. The outer loop is iterating through the TTree entries, using the TTreeReader::Next() loop - just as before. For each TTree entry, loop over all particles of the TTree entry with a simple for loop. For each particle, check that its momentum is > 40; if it is, fill the histogram (see TH1F::Fill()) with the fPosX value of that particle.; This step involves writing some code (similar to the code you have for the event size). If you get lost (SPOILER ALERT!): the solution is at the end of this page.; Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/histogramming.html:2672,access,access,2672,d/histogramming.html,https://root.cern,https://root.cern/d/histogramming.html,1,['access'],['access']
Security," 76 of file TServerSocket.cxx. ◆ ~TServerSocket(). TServerSocket::~TServerSocket ; (; ). virtual . Destructor: cleanup authentication stuff (if any) and close. ; Definition at line 162 of file TServerSocket.cxx. Member Function Documentation. ◆ Accept(). TSocket * TServerSocket::Accept ; (; UChar_t ; opt = 0). virtual . Accept a connection on a server socket. ; Returns a full-duplex communication TSocket object. If no pending connections are present on the queue and nonblocking mode has not been enabled with SetOption(kNoBlock,1) the call blocks until a connection is present. The returned socket must be deleted by the user. The socket is also added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. In case of error 0 is returned and in case non-blocking I/O is enabled and no connections are available -1 is returned.; The opt can be used to require client authentication; valid options are; kSrvAuth = require client authentication kSrvNoAuth = force no client authentication; Example: use Opt = kSrvAuth to require client authentication.; Default options are taken from fgAcceptOpt and are initially equivalent to kSrvNoAuth; they can be changed with the static method TServerSocket::SetAcceptOptions(Opt). The active defaults can be visualized using the static method TServerSocket::ShowAcceptOptions(). ; Reimplemented in TPServerSocket.; Definition at line 204 of file TServerSocket.cxx. ◆ Authenticate(). Bool_t TServerSocket::Authenticate ; (; TSocket * ; sock). private . Check authentication request from the client on new open connection. ; Definition at line 300 of file TServerSocket.cxx. ◆ Class(). static TClass * TServerSocket::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TServerSocket::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TServerSocket::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:22651,authenticat,authentication,22651,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,4,['authenticat'],['authentication']
Security," 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(newidx, cc->GetBuffer());; 819 ; 820 // store translation between hash and bin; 821 newidx += (fBinContent.GetEntriesFast() - 1) * fChunkSize;; 822 if (!linidx) {; 823 // fBins didn't find it; 824 if (2 * GetNbins() > fBins.Capacity()); 825 fBins.Expand(3 * GetNbins());; 826 fBins.Add(hash, newidx + 1);; 827 } else {; 828 // fBins contains one, but it's the wrong one;; 829 // add entry to fBinsContinued.; 830 fBinsContinued.Add(linidx, newidx + 1);; 831 }; 832 return newidx;; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Return THnSparseCompactBinCoord object.; 837 ; 838THnSparseCompactBinCoord* THnSparse::GetCompactCoord() const; 839{; 840 if (!fCompactCoord) {; 841 Int_t *bins = new Int_t[fNdimensions];; 842 for (Int_t d = 0; d < fNdimensions; ++d); 843 bins[d] = GetAxis(d)->GetNbins();; 844 const_cast<THnSparse*>(this)->fCompactCoord; 845 = new THnSparseCompactBinCoord(fNdimension",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:30678,hash,hash,30678,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hash']
Security," 832 of file MethodPyKeras.cxx. ◆ GetMulticlassValues(). std::vector< Float_t > & MethodPyKeras::GetMulticlassValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 772 of file MethodPyKeras.cxx. ◆ GetMvaValue(). Double_t MethodPyKeras::GetMvaValue ; (; Double_t * ; errLower, . Double_t * ; errUpper . ). virtual . Implements TMVA::PyMethodBase.; Definition at line 657 of file MethodPyKeras.cxx. ◆ GetMvaValues(). std::vector< Double_t > MethodPyKeras::GetMvaValues ; (; Long64_t ; firstEvt, . Long64_t ; lastEvt, . Bool_t ; logProgress . ). virtual . get all the MVA values for the events of the current Data type ; Implements TMVA::PyMethodBase.; Definition at line 679 of file MethodPyKeras.cxx. ◆ GetNumValidationSamples(). UInt_t TMVA::MethodPyKeras::GetNumValidationSamples ; (; ). private . Validation of the ValidationSize option. ; Allowed formats are 20%, 0.2 and 100 etc.; 20% and 0.2 selects 20% of the training set as validation data.; 100 selects 100 events as the validation data. Returnsnumber of samples in validation set ; Definition at line 111 of file MethodPyKeras.cxx. ◆ GetRegressionValues(). std::vector< Float_t > & MethodPyKeras::GetRegressionValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 740 of file MethodPyKeras.cxx. ◆ HasAnalysisType(). Bool_t MethodPyKeras::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ;  . ). virtual . Implements TMVA::PyMethodBase.; Definition at line 70 of file MethodPyKeras.cxx. ◆ Init(). void MethodPyKeras::Init ; (; void ; ). virtual . Initialization function called from MethodBase::SetupMethod() Note that option string are not yet filled with their values. ; This is done before ProcessOption method or after reading from XML file ; Implements TMVA::PyMethodBase.; Definition at line 414 of file MethodPyKeras.cxx. ◆ InitKeras(). void MethodPyKeras::InitKeras ; (; ). private . Definition at line 181 of file MethodPyKeras.cxx. ◆ Proce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyKeras.html:33725,validat,validation,33725,doc/master/classTMVA_1_1MethodPyKeras.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyKeras.html,1,['validat'],['validation']
Security," 873 if( !Internal::TSchemaRuleProcessor::ProcessVersion( *it, verpair ) ); 874 {; 875 delete fVersionVect;; 876 fVersionVect = nullptr;; 877 return kFALSE;; 878 }; 879 fVersionVect->push_back( verpair );; 880 }; 881 return kTRUE;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Check if specified checksum string is correct and build checksum vector.; 886 ; 887Bool_t TSchemaRule::ProcessChecksum( const TString& checksum ) const; 888{; 889 //---------------------------------------------------------------------------; 890 // Check if we have valid list; 891 /////////////////////////////////////////////////////////////////////////////; 892 ; 893 if (!checksum[0]); 894 return kFALSE;; 895 std::string chk = (const char*)checksum;; 896 if( chk[0] != '[' || chk[chk.size()-1] != ']' ); 897 return kFALSE;; 898 ; 899 std::list<std::string> checksums;; 900 Internal::TSchemaRuleProcessor::SplitList( chk.substr( 1, chk.size()-2), checksums );; 901 ; 902 if( checksums.empty() ) {; 903 delete fChecksumVect;; 904 fChecksumVect = nullptr;; 905 return kFALSE;; 906 }; 907 ; 908 if( !fChecksumVect ); 909 fChecksumVect = new std::vector<UInt_t>;; 910 fChecksumVect->clear();; 911 ; 912 //---------------------------------------------------------------------------; 913 // Check the validity of each list element; 914 /////////////////////////////////////////////////////////////////////////////; 915 ; 916 for( const auto& checksumStr : checksums ) {; 917 auto chksum = ParseChecksum( checksumStr.c_str() );; 918 if (chksum == 0u) {; 919 delete fChecksumVect;; 920 fChecksumVect = nullptr;; 921 return kFALSE;; 922 }; 923 ; 924 fChecksumVect->push_back( chksum );; 925 }; 926 return kTRUE;; 927}; 928 ; 929////////////////////////////////////////////////////////////////////////////////; 930/// Parse the checksum in the given string. Returns either the checksum or zero; 931/// if the string is not a hex or decimal number.; 932 ; 933UInt_t TSchem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:29421,checksum,checksums,29421,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,2,['checksum'],['checksums']
Security," 9246 // Otherwise newLink and oldLink are unrelated:; 9247 Warning(""TTree::SetNotify"",; 9248 ""The tree or chain already has a TNotifyLink registered, and the new TNotifyLink `obj` does not link ""; 9249 ""to it. Setting fNotify to the new value will lead to an orphan linked list of TNotifyLinks and it is ""; 9250 ""most likely not intended. If this is the intended goal, please call SetNotify(nullptr) first to ""; 9251 ""silence this warning."");; 9252 }; 9253 }; 9254 ; 9255 fNotify = obj;; 9256}; 9257 ; 9258////////////////////////////////////////////////////////////////////////////////; 9259/// Change the name and title of this tree.; 9260 ; 9261void TTree::SetObject(const char* name, const char* title); 9262{; 9263 if (gPad) {; 9264 gPad->Modified();; 9265 }; 9266 ; 9267 // Trees are named objects in a THashList.; 9268 // We must update hashlists if we change the name; 9269 TFile *file = nullptr;; 9270 TTreeCache *pf = nullptr;; 9271 if (fDirectory) {; 9272 fDirectory->Remove(this);; 9273 if ((file = GetCurrentFile())) {; 9274 pf = GetReadCache(file);; 9275 file->SetCacheRead(nullptr,this,TFile::kDoNotDisconnect);; 9276 }; 9277 }; 9278 // This changes our hash value.; 9279 fName = name;; 9280 fTitle = title;; 9281 if (fDirectory) {; 9282 fDirectory->Append(this);; 9283 if (pf) {; 9284 file->SetCacheRead(pf,this,TFile::kDoNotDisconnect);; 9285 }; 9286 }; 9287}; 9288 ; 9289////////////////////////////////////////////////////////////////////////////////; 9290/// Enable or disable parallel unzipping of Tree buffers.; 9291 ; 9292void TTree::SetParallelUnzip(bool opt, Float_t RelSize); 9293{; 9294#ifdef R__USE_IMT; 9295 if (GetTree() == nullptr) {; 9296 LoadTree(GetReadEntry());; 9297 if (!GetTree()); 9298 return;; 9299 }; 9300 if (GetTree() != this) {; 9301 GetTree()->SetParallelUnzip(opt, RelSize);; 9302 return;; 9303 }; 9304 TFile* file = GetCurrentFile();; 9305 if (!file); 9306 return;; 9307 ; 9308 TTreeCache* pf = GetReadCache(file);; 9309 if (pf && !( opt ^ (nullptr != d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:358535,hash,hashlists,358535,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['hash'],"['hash', 'hashlists']"
Security," 965/// \return a string with several lines; 966///; 967TString TApplication::GetSetup(); 968{; 969 std::vector<TString> lines;; 970 lines.emplace_back(""```"");; 971 lines.emplace_back(TString::Format(""ROOT v%s"",; 972 gROOT->GetVersion()));; 973 lines.emplace_back(TString::Format(""Built for %s on %s"", gSystem->GetBuildArch(), gROOT->GetGitDate()));; 974 if (!strcmp(gROOT->GetGitBranch(), gROOT->GetGitCommit())) {; 975 static const char *months[] = {""January"",""February"",""March"",""April"",""May"",; 976 ""June"",""July"",""August"",""September"",""October"",; 977 ""November"",""December""};; 978 Int_t idatqq = gROOT->GetVersionDate();; 979 Int_t iday = idatqq%100;; 980 Int_t imonth = (idatqq/100)%100;; 981 Int_t iyear = (idatqq/10000);; 982 ; 983 lines.emplace_back(TString::Format(""From tag %s, %d %s %4d"",; 984 gROOT->GetGitBranch(),; 985 iday,months[imonth-1],iyear));; 986 } else {; 987 // If branch and commit are identical - e.g. ""v5-34-18"" - then we have; 988 // a release build. Else specify the git hash this build was made from.; 989 lines.emplace_back(TString::Format(""From %s@%s"",; 990 gROOT->GetGitBranch(),; 991 gROOT->GetGitCommit()));; 992 }; 993 lines.emplace_back(TString::Format(""With %s"",; 994 gSystem->GetBuildCompilerVersionStr()));; 995 lines.emplace_back(""Binary directory: ""+ gROOT->GetBinDir());; 996 lines.emplace_back(""```"");; 997 TString setup = """";; 998 for (auto& line : lines) {; 999 setup.Append(line);; 1000 setup.Append('\n');; 1001 }; 1002 setup.Chop(); // trim final `\n`; 1003 return setup;; 1004}; 1005 ; 1006////////////////////////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:37669,hash,hash,37669,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['hash'],['hash']
Security," : TDirectoryFile(), fCompress(ROOT::RCompressionSetting::EAlgorithm::kUseGlobal); 203{; 204 fCacheReadMap = new TMap();; 205 SetBit(kBinaryFile, kTRUE);; 206 ; 207 if (gDebug); 208 Info(""TFile"", ""default ctor"");; 209}; 210 ; 211////////////////////////////////////////////////////////////////////////////////; 212/// Opens or creates a local ROOT file.; 213///; 214/// \param[in] fname1 The name of the file; 215/// \param[in] option Specifies the mode in which the file is opened; 216/// \param[in] ftitle The title of the file; 217/// \param[in] compress Specifies the compression algorithm and level; 218///; 219/// It is recommended to specify fname1 as ""<file>.root"". The suffix "".root""; 220/// will be used by object browsers to automatically identify the file as; 221/// a ROOT file. If the constructor fails in any way IsZombie() will; 222/// return true. Use IsOpen() to check if the file is (still) open.; 223/// To open non-local files use the static TFile::Open() method, that; 224/// will take care of opening the files using the correct remote file; 225/// access plugin.; 226///; 227/// Option | Description; 228/// -------|------------; 229/// NEW or CREATE | Create a new file and open it for writing, if the file already exists the file is not opened.; 230/// RECREATE | Create a new file, if the file already exists it will be overwritten.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:8470,access,access,8470,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['access']
Security," : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 11200 training events and 2800 validation events; : Training Model Summary; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; dense (Dense) (None, 64) 512 ; ; dense_1 (Dense) (None, 64) 4160 ; ; dense_2 (Dense) (None, 64) 4160 ; ; dense_3 (Dense) (None, 64) 4160 ; ; dense_4 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 13122 (51.26 KB); Trainable params: 13122 (51.26 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/20; ; 1/112 [..............................] - ETA: 1:09 - loss: 0.6923 - accuracy: 0.6000␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 21/112 [====>.........................] - ETA: 0s - loss: 0.6891 - accuracy: 0.5348 ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 42/112 [==========>...................] - ETA: 0s - loss: 0.6834 - accuracy: 0.5626␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 63/112 [===============>..............] - ETA: 0s - loss: 0.6773 - accuracy: 0.5776␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 86/112 [======================>.......] - ETA: 0s - loss: 0.6765 - accuracy: 0.5751; Epoch 1: val_loss improved from inf to 0.65844, saving model to trained_model_higgs.h5; ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:27732,validat,validation,27732,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['validat'],['validation']
Security," : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 11200 training events and 2800 validation events; : Training Model Summary; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; dense (Dense) (None, 64) 512 ; ; dense_1 (Dense) (None, 64) 4160 ; ; dense_2 (Dense) (None, 64) 4160 ; ; dense_3 (Dense) (None, 64) 4160 ; ; dense_4 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 13122 (51.26 KB); Trainable params: 13122 (51.26 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/20; ; 1/112 [..............................] - ETA: 1:13 - loss: 0.6918 - accuracy: 0.5600␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 24/112 [=====>........................] - ETA: 0s - loss: 0.6860 - accuracy: 0.5275 ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 46/112 [===========>..................] - ETA: 0s - loss: 0.6806 - accuracy: 0.5572␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 67/112 [================>.............] - ETA: 0s - loss: 0.6763 - accuracy: 0.5693␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 88/112 [======================>.......] - ETA: 0s - loss: 0.6711 - accuracy: 0.5783; Epoch 1: val_loss improved from inf to 0.65278, saving model to Higgs_trained_model.h5; ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:28172,validat,validation,28172,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['validat'],['validation']
Security," ; (; Int_t ; t). inline . set node type: 1 signal node, -1 bkg leave, 0 intermediate Node ; Definition at line 163 of file DecisionTreeNode.h. ◆ SetNSigEvents(). void TMVA::DecisionTreeNode::SetNSigEvents ; (; Float_t ; s). inline . set the sum of the signal weights in the node, if traininfo defined ; Definition at line 185 of file DecisionTreeNode.h. ◆ SetNSigEvents_unboosted(). void TMVA::DecisionTreeNode::SetNSigEvents_unboosted ; (; Float_t ; s). inline . set the sum of the unboosted signal events in the node, if traininfo defined ; Definition at line 203 of file DecisionTreeNode.h. ◆ SetNSigEvents_unweighted(). void TMVA::DecisionTreeNode::SetNSigEvents_unweighted ; (; Float_t ; s). inline . set the sum of the unweighted signal events in the node, if traininfo defined ; Definition at line 194 of file DecisionTreeNode.h. ◆ SetNSValidation(). void TMVA::DecisionTreeNode::SetNSValidation ; (; Double_t ; s). inline . set number of signal events from the pruning validation sample, if traininfo defined ; Definition at line 323 of file DecisionTreeNode.h. ◆ SetNTerminal(). void TMVA::DecisionTreeNode::SetNTerminal ; (; Int_t ; n). inline . set number of terminal nodes in the subtree rooted here, if traininfo defined ; Definition at line 316 of file DecisionTreeNode.h. ◆ SetParent(). virtual void TMVA::DecisionTreeNode::SetParent ; (; Node * ; p). inlinevirtual . Reimplemented from TMVA::Node.; Definition at line 290 of file DecisionTreeNode.h. ◆ SetPurity(). void TMVA::DecisionTreeNode::SetPurity ; (; void ; ). return the S/(S+B) (purity) for the node REM: even if nodes with purity 0.01 are very PURE background nodes, they still get a small value of the purity. ; Definition at line 191 of file DecisionTreeNode.cxx. ◆ SetResponse(). void TMVA::DecisionTreeNode::SetResponse ; (; Float_t ; r). inline . set the response of the node (for regression) ; Definition at line 173 of file DecisionTreeNode.h. ◆ SetRight(). virtual void TMVA::DecisionTreeNode::SetRight ; (; Node *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html:34170,validat,validation,34170,doc/master/classTMVA_1_1DecisionTreeNode.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html,1,['validat'],['validation']
Security, ; (; Long64_t ; first). inline . Definition at line 113 of file TDSet.h. ◆ SetLookedUp(). void TDSetElement::SetLookedUp ; (; ). inline . Definition at line 139 of file TDSet.h. ◆ SetMaxProcTime(). void TDSetElement::SetMaxProcTime ; (; Float_t ; mpt). inline . Definition at line 145 of file TDSet.h. ◆ SetNum(). void TDSetElement::SetNum ; (; Long64_t ; num). inline . Definition at line 118 of file TDSet.h. ◆ SetTDSetOffset(). void TDSetElement::SetTDSetOffset ; (; Long64_t ; offset). inline . Definition at line 129 of file TDSet.h. ◆ SetValid(). void TDSetElement::SetValid ; (; ). inline . Definition at line 135 of file TDSet.h. ◆ Streamer(). void TDSetElement::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TDSetElement. ; Reimplemented from TObject.; Definition at line 1722 of file TDSet.cxx. ◆ StreamerNVirtual(). void TDSetElement::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 149 of file TDSet.h. ◆ Validate() [1/2]. void TDSetElement::Validate ; (; Bool_t ; isTree). Validate by opening the file. ; Definition at line 275 of file TDSet.cxx. ◆ Validate() [2/2]. void TDSetElement::Validate ; (; TDSetElement * ; elem). Validate by checking against another element. ; Definition at line 301 of file TDSet.cxx. Member Data Documentation. ◆ fAssocObjList. TList* TDSetElement::fAssocObjList. private . Definition at line 92 of file TDSet.h. ◆ fDataSet. TString TDSetElement::fDataSet. private . Definition at line 91 of file TDSet.h. ◆ fDirectory. TString TDSetElement::fDirectory. private . Definition at line 80 of file TDSet.h. ◆ fEntries. Long64_t TDSetElement::fEntries. private . Definition at line 88 of file TDSet.h. ◆ fEntryList. TObject* TDSetElement::fEntryList. private . Definition at line 86 of file TDSet.h. ◆ fFirst. Long64_t TDSetElement::fFirst. private . Definition at line 81 of file TDSet.h. ◆ fFriends. TList* TDSetElement::fFriends. private . Definition at line 89 of file TDSet.h. ◆ fM,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSetElement.html:22882,Validat,Validate,22882,doc/master/classTDSetElement.html,https://root.cern,https://root.cern/doc/master/classTDSetElement.html,1,['Validat'],['Validate']
Security," ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).;  . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = v(1);             ; yy = v[1];;   zz = v(2);             ; zz = v[2];;   tt = v(3);             ; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;   TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:;  ;   v.SetX(1.);        or   ; v.SetPx(1.);;   ...                              ; ...;   v.SetT(1.);             ; v.SetE(1.);; To set more the one com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLorentzVector.html:1395,Access,Access,1395,root/html528/TLorentzVector.html,https://root.cern,https://root.cern/root/html528/TLorentzVector.html,12,"['Access', 'access']","['Access', 'access']"
Security," ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.; 110 char fPrompt[64]; // Command line prompt string.; 111 //cling::DictPosition fDictPos; // dictionary context after initialization is complete.; 112 //cling::DictPosition fDictPosGlobals; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:3984,hash,hashes,3984,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['hash'],['hashes']
Security," ; Definition at line 133 of file THtml.h. ◆ DeclFileName(). static const char * THtml::TFileSysEntry::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 133 of file THtml.h. ◆ GetFullName(). virtual void THtml::TFileSysEntry::GetFullName ; (; TString & ; fullname, . Bool_t ; asIncluded . ); const. inlinevirtual . Reimplemented in THtml::TFileSysRoot.; Definition at line 117 of file THtml.h. ◆ GetLevel(). Int_t THtml::TFileSysEntry::GetLevel ; (; ); const. inline . Definition at line 128 of file THtml.h. ◆ GetName(). const char * THtml::TFileSysEntry::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 115 of file THtml.h. ◆ GetParent(). TFileSysDir * THtml::TFileSysEntry::GetParent ; (; ); const. inline . Definition at line 127 of file THtml.h. ◆ Hash(). ULong_t THtml::TFileSysEntry::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; THtml::TFileSysEntry::HashULong_t Hash() const overrideReturn hash value for this object.D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml_1_1TFileSysEntry.html:11958,Hash,Hash,11958,doc/master/classTHtml_1_1TFileSysEntry.html,https://root.cern,https://root.cern/doc/master/classTHtml_1_1TFileSysEntry.html,1,['Hash'],['Hash']
Security, ; Definition at line 322 of file TGenCollectionProxy.h. ◆ fPointers. Bool_t TGenCollectionProxy::fPointers. protected . Flag to indicate if containee has pointers (key or value) ; Definition at line 300 of file TGenCollectionProxy.h. ◆ fProxyKept. Proxies_t TGenCollectionProxy::fProxyKept. protected . Optimization: Keep proxies once they were created. ; Definition at line 318 of file TGenCollectionProxy.h. ◆ fProxyList. Proxies_t TGenCollectionProxy::fProxyList. protected . Stack of recursive proxies. ; Definition at line 317 of file TGenCollectionProxy.h. ◆ fReadMemberWise. TObjArray* TGenCollectionProxy::fReadMemberWise. mutableprotected . Array of bundle of TStreamerInfoActions to stream out (read) ; Definition at line 291 of file TGenCollectionProxy.h. ◆ fResize. Sizing_t TGenCollectionProxy::fResize. protected . Container accessors: resize container. ; Definition at line 303 of file TGenCollectionProxy.h. ◆ fSize. Method TGenCollectionProxy::fSize. protected . Container accessors: size of container. ; Definition at line 302 of file TGenCollectionProxy.h. ◆ fStaged. Staged_t TGenCollectionProxy::fStaged. protected . Optimization: Keep staged array once they were created. ; Definition at line 319 of file TGenCollectionProxy.h. ◆ fSTL_type. int TGenCollectionProxy::fSTL_type. protected . STL container type. ; Definition at line 320 of file TGenCollectionProxy.h. ◆ fTypeinfo. Info_t TGenCollectionProxy::fTypeinfo. protected . Type information. ; Definition at line 321 of file TGenCollectionProxy.h. ◆ fVal. Value* TGenCollectionProxy::fVal. protected . Descriptor of the Value_type. ; Definition at line 312 of file TGenCollectionProxy.h. ◆ fValDiff. int TGenCollectionProxy::fValDiff. protected . Offset between two consecutive value_types (memory layout). ; Definition at line 316 of file TGenCollectionProxy.h. ◆ fValOffset. int TGenCollectionProxy::fValOffset. protected . Offset from key to value (in maps) ; Definition at line 315 of file TGenCollectionProxy.h. ◆ fVa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:30933,access,accessors,30933,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['access'],['accessors']
Security," ; Definition at line 632 of file TSchemaRule.cxx. ◆ ls(). void TSchemaRule::ls ; (; Option_t * ; targetname = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). ; Reimplemented from TObject.; Definition at line 177 of file TSchemaRule.cxx. ◆ operator=(). TSchemaRule & TSchemaRule::operator= ; (; const TSchemaRule & ; rhs). Copy operator. ; Definition at line 125 of file TSchemaRule.cxx. ◆ operator==(). Bool_t TSchemaRule::operator== ; (; const TSchemaRule & ; rhs); const. Return true if the rule have the same effects. ; Definition at line 147 of file TSchemaRule.cxx. ◆ ParseChecksum(). UInt_t TSchemaRule::ParseChecksum ; (; const char * ; checksum); const. private . Parse the checksum in the given string. ; Returns either the checksum or zero if the string is not a hex or decimal number. ; Definition at line 933 of file TSchemaRule.cxx. ◆ ProcessChecksum(). Bool_t TSchemaRule::ProcessChecksum ; (; const TString & ; checksum); const. private . Check if specified checksum string is correct and build checksum vector. ; Definition at line 887 of file TSchemaRule.cxx. ◆ ProcessDeclaration(). void TSchemaRule::ProcessDeclaration ; (; TObjArray * ; array, . const TString & ; list . ). staticprivate . Split the list as a declaration into as a TObjArray of TNamed(name,type). ; Definition at line 974 of file TSchemaRule.cxx. ◆ ProcessList(). void TSchemaRule::ProcessList ; (; TObjArray * ; array, . const TString & ; list . ). staticprivate . Split the list as a comma separated list into a TObjArray of TObjString. ; Definition at line 953 of file TSchemaRule.cxx. ◆ ProcessVersion(). Bool_t TSchemaRule::ProcessVersion ; (; const TString & ; version); const. private . Check if specified version string is correct and build version vector. ; Definition at line 842 of file TSchemaRule.cxx. ◆ SetAttributes(). void TSchemaRule::SetAttributes ; (; const TString & ; attributes). Set the attribut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:23005,checksum,checksum,23005,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,2,['checksum'],['checksum']
Security," ; Definition at line 887 of file TSchemaRule.cxx. ◆ ProcessDeclaration(). void TSchemaRule::ProcessDeclaration ; (; TObjArray * ; array, . const TString & ; list . ). staticprivate . Split the list as a declaration into as a TObjArray of TNamed(name,type). ; Definition at line 974 of file TSchemaRule.cxx. ◆ ProcessList(). void TSchemaRule::ProcessList ; (; TObjArray * ; array, . const TString & ; list . ). staticprivate . Split the list as a comma separated list into a TObjArray of TObjString. ; Definition at line 953 of file TSchemaRule.cxx. ◆ ProcessVersion(). Bool_t TSchemaRule::ProcessVersion ; (; const TString & ; version); const. private . Check if specified version string is correct and build version vector. ; Definition at line 842 of file TSchemaRule.cxx. ◆ SetAttributes(). void TSchemaRule::SetAttributes ; (; const TString & ; attributes). Set the attributes code of this rule. ; Definition at line 656 of file TSchemaRule.cxx. ◆ SetChecksum(). Bool_t TSchemaRule::SetChecksum ; (; const TString & ; checksum). Set the checksum string - returns kFALSE if the format is incorrect. ; Definition at line 425 of file TSchemaRule.cxx. ◆ SetCode(). void TSchemaRule::SetCode ; (; const TString & ; code). Set the source code of this rule. ; Definition at line 640 of file TSchemaRule.cxx. ◆ SetEmbed(). void TSchemaRule::SetEmbed ; (; Bool_t ; embed). Set whether this rule should be save in the ROOT file (if true) ; Definition at line 616 of file TSchemaRule.cxx. ◆ SetFromRule(). Bool_t TSchemaRule::SetFromRule ; (; const char * ; rule). Set the content fot this object from the rule See TClass::AddRule for details on the syntax. ; Definition at line 321 of file TSchemaRule.cxx. ◆ SetInclude(). void TSchemaRule::SetInclude ; (; const TString & ; include). Set the comma separated list of header files to include to be able to compile this rule. ; Definition at line 577 of file TSchemaRule.cxx. ◆ SetReadFunctionPointer(). void TSchemaRule::SetReadFunctionPointer ; (; TSchema",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:24128,checksum,checksum,24128,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,2,['checksum'],['checksum']
Security," ; Must be overridden if a class wants to be able to compare itself with other objects. Must return -1 if this is smaller than obj, 0 if objects are equal and 1 if this is larger than obj. ; Reimplemented from TObject.; Definition at line 94 of file TParameter.h. ◆ DeclFileName(). template<class AParamType > . static const char * TParameter< AParamType >::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 119 of file TParameter.h. ◆ GetName(). template<class AParamType > . const char * TParameter< AParamType >::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 66 of file TParameter.h. ◆ GetVal(). template<class AParamType > . const AParamType & TParameter< AParamType >::GetVal ; (; ); const. inline . Definition at line 67 of file TParameter.h. ◆ Hash(). template<class AParamType > . ULong_t TParameter< AParamType >::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParameter.html:13560,Hash,Hash,13560,doc/master/classTParameter.html,https://root.cern,https://root.cern/doc/master/classTParameter.html,1,['Hash'],['Hash']
Security," ; Reimplemented from TObject.; Definition at line 3683 of file TCling.cxx. ◆ RefreshClassInfo(). void TCling::RefreshClassInfo ; (; TClass * ; cl, . const clang::NamedDecl * ; def, . bool ; alias . ). Internal function. Actually do the update of the ClassInfo when seeing. ; Definition at line 6635 of file TCling.cxx. ◆ RegisterLoadedSharedLibrary(). void TCling::RegisterLoadedSharedLibrary ; (; const char * ; name). private . Register a new shared library name with the interpreter; add it to fSharedLibs. ; Definition at line 3415 of file TCling.cxx. ◆ RegisterModule(). void TCling::RegisterModule ; (; const char * ; modulename, . const char ** ; headers, . const char ** ; includePaths, . const char * ; payloadCode, . const char * ; fwdDeclsCode, . void(*)() ; triggerFunc, . const FwdDeclArgsToKeepCollection_t & ; fwdDeclsArgToSkip, . const char ** ; classesHeaders, . Bool_t ; lateRegistration = false, . Bool_t ; hasCxxModule = false . ). finalvirtual . Inject the module named ""modulename"" into cling; load all headers. ; headers is a 0-terminated array of header files to #include after loading the module. The module is searched for in all $LD_LIBRARY_PATH entries (or PATH% on Windows). This function gets called by the static initialization of dictionary libraries. The payload code is injected ""as is"" in the interpreter. The value of 'triggerFunc' is used to find the shared library location. ; Implements TInterpreter.; Definition at line 2010 of file TCling.cxx. ◆ RegisterPrebuiltModulePath(). bool TCling::RegisterPrebuiltModulePath ; (; const std::string & ; FullPath, . const std::string & ; ModuleMapName = ""module.modulemap"" . ); const. finalvirtual . Returnstrue if the module map was loaded, false on error or if the map was already loaded. ; Implements TInterpreter.; Definition at line 1906 of file TCling.cxx. ◆ RegisterRdictForLoadPCM(). void TCling::RegisterRdictForLoadPCM ; (; const std::string & ; pcmFileNameFullPath, . llvm::StringRef * ; pcmContent . ). priva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:124854,Inject,Inject,124854,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['Inject'],['Inject']
Security," ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPShapeObj.html:2265,Hash,Hash,2265,root/html528/TGLPShapeObj.html,https://root.cern,https://root.cern/root/html528/TGLPShapeObj.html,4,['Hash'],['Hash']
Security," ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLPShapeObj.html:2265,Hash,Hash,2265,root/html530/TGLPShapeObj.html,https://root.cern,https://root.cern/root/html530/TGLPShapeObj.html,12,['Hash'],['Hash']
Security," ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPShapeObj.html:2199,Hash,Hash,2199,root/html602/TGLPShapeObj.html,https://root.cern,https://root.cern/root/html602/TGLPShapeObj.html,8,['Hash'],['Hash']
Security," ;  ; EGradientType GetGradientType () const;  Get gradient type. ;  ; Double_t GetR1 () const;  ; Double_t GetR2 () const;  Get R2. ;  ; Double_t GetRadius () const;  Get radius. ;  ; const Point & GetStart () const;  Get start. ;  ; TClass * IsA () const override;  ; void SetRadialGradient (const Point &center, Double_t radius);  Set radial gradient. ;  ; void SetStartEndR1R2 (const Point &p1, Double_t r1, const Point &p2, Double_t r2);  Set start and end R1 and R2. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  TColorGradient ();  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Color_t *colorIndices, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Double_t *colors, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  Public Member Functions inherited from TColorGradient;  TColorGradient ();  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Color_t *colorIndices, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Double_t *colors, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ; Double_t GetColorAlpha (UInt_t indx) const;  Return alpha parameter of selected color. ;  ; const Double_t * GetColorPositions () const;  Get color positions. ;  ; const Double_t * GetColors () const;  Get colors. ;  ; ECoordinateMode GetCoordinateMode () const;  Get coordinate mode. ;  ; SizeType_t GetNumberOfS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRadialGradient.html:2407,validat,validate,2407,doc/master/classTRadialGradient.html,https://root.cern,https://root.cern/doc/master/classTRadialGradient.html,1,['validat'],['validate']
Security," ;  ; TClass * IsA () const override;  ; Bool_t IsOpen () const final;  return kTRUE if file is opened and can be accessed ;  ; void MakeFree (Long64_t, Long64_t) final;  Mark unused bytes on the file. ;  ; void MakeProject (const char *, const char *=""*"", Option_t *=""new"") final;  Generate source code necessary to access the objects stored in the file. ;  ; void Map () final;  ; void Map (Option_t *) final;  List the contents of a file sequentially. ;  ; void Paint (Option_t *="""") final;  Paint all objects in the file. ;  ; void Print (Option_t *="""") const final;  Print all objects in the file. ;  ; Bool_t ReadBuffer (char *, Int_t) final;  Read a buffer from the file. ;  ; Bool_t ReadBuffer (char *, Long64_t, Int_t) final;  Read a buffer from the file at the offset 'pos' in the file. ;  ; void ReadFree () final;  Read the FREE linked list. ;  ; Int_t Recover () final;  Attempt to recover file if not correctly closed. ;  ; Int_t ReOpen (Option_t *mode) final;  Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ;  ; void ResetErrno () const final;  Method resetting the errno. ;  ; void Seek (Long64_t, ERelativeTo=kBeg) final;  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; void SetEND (Long64_t) final;  ; void SetStoreStreamerInfos (Bool_t iConvert=kTRUE) final;  If true, all correspondent to file TStreamerInfo objects will be stored in file this allows to apply schema evolution later for this file may be useful, when file used outside ROOT and TStreamerInfo objects does not required Can be changed only for newly created file. ;  ; void SetUsedDtd (Bool_t use=kTRUE) final;  Specify usage of DTD for this file. ;  ; void SetUseNamespaces (Bool_t iUseNamespaces=kTRUE) final;  Specify usage of namespaces in xml file In current implementation every instrumented class in file gets its unique namespace, which is equal to name of class and refer to root documentation page. ;  ; void SetXmlLayout (EXM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:4014,access,access,4014,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['access'],['access']
Security," ;  ; const TGWindow * GetParent () const;  ; virtual Bool_t HandleIdleEvent (TGIdleHandler *);  ; Bool_t HandleTimer (TTimer *) override;  Execute action in response of a timer timing out. ;  ; virtual void IconifyWindow ();  iconify window ;  ; virtual Bool_t IsMapped ();  Returns kTRUE if window is mapped on screen, kFALSE otherwise. ;  ; virtual void LowerWindow ();  lower window ;  ; void Print (Option_t *option="""") const override;  Print window id. ;  ; virtual void RaiseWindow ();  raise window ;  ; virtual void RequestFocus ();  request focus ;  ; virtual void SetBackgroundPixmap (Pixmap_t pixmap);  set background pixmap ;  ; virtual void SetWindowName (const char *name=nullptr);  Set window name. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionServerFrame.html:13221,Hash,Hash,13221,doc/master/classTSessionServerFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionServerFrame.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," ;  ; static GlobusAuth_t GetGlobusAuthHook ();  Static method returning the globus authorization hook (no longer supported) ;  ; static THostAuth * GetHostAuth (const char *host, const char *user="""", Option_t *opt=""R"", Int_t *Exact=nullptr);  Sets fUser=user and search fgAuthInfo for the entry pertaining to (host,user), setting fHostAuth accordingly. ;  ; static const char * GetKrb5Principal ();  Static method returning the principal to be used to init Krb5 tickets. ;  ; static Bool_t GetPromptUser ();  Static method returning the prompt user settings. ;  ; static TList * GetProofAuthInfo ();  Static method returning the list with authentication directives to be sent to proof. ;  ; static Int_t GetRSAInit ();  Static method returning the RSA initialization flag. ;  ; static const char * GetRSAPubExport (Int_t key=0);  Static method returning the RSA public keys. ;  ; static THostAuth * HasHostAuth (const char *host, const char *user, Option_t *opt=""R"");  Checks if a THostAuth with exact match for {host,user} exists in the fgAuthInfo list If opt = ""P"" use ProofAuthInfo list instead Returns pointer to it or 0. ;  ; static void InitRandom ();  Initialize random machine using seed from /dev/urandom (or current time if /dev/urandom not available). ;  ; static void MergeHostAuthList (TList *Std, TList *New, Option_t *Opt="""");  Tool for updating fgAuthInfo or fgProofAuthInfo 'nin' contains list of last input information through (re)reading of a rootauthrc-alike file. ;  ; static char * PromptPasswd (const char *prompt=""Password: "");  Static method to prompt for the user's passwd to be used for authentication to rootd or proofd. ;  ; static char * PromptUser (const char *remote);  Static method to prompt for the user name to be used for authentication to rootd or proofd. ;  ; static Int_t ReadRootAuthrc ();  Read authentication directives from $ROOTAUTHRC, $HOME/.rootauthrc or <Root_etc_dir>/system.rootauthrc and create related THostAuth objects. ;  ; static void RemoveHost",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:12849,HasH,HasHostAuth,12849,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['HasH'],['HasHostAuth']
Security," ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/core/base/src/TListOfTypes.h>. Inheritance diagram for TListOfTypes:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TListOfTypes(). TListOfTypes::TListOfTypes ; (; ). Definition at line 36 of file TListOfTypes.cxx. Member Function Documentation. ◆ FindObject() [1/3]. TObject * THashTable::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from THashTable.; Definition at line 67 of file THashTable.cxx. ◆ FindObject() [2/3]. TObject * TListOfTypes::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from THashTable.; Definition at line 42 of file TListOfTypes.cxx. ◆ FindObject() [3/3]. TObject * THashTable::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from THashTable.; Definition at line 68 of file THashTable.cxx. ◆ FindType(). TDataType * TListOfTypes::FindType ; (; const char * ; name); const. Definition at line 87 of file TListOfTypes.cxx. core/base/src/TListOfTypes.h; core/base/src/TListOfTypes.cxx. TListOfTypes. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:56 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfTypes.html:16341,hash,hash,16341,doc/master/classTListOfTypes.html,https://root.cern,https://root.cern/doc/master/classTListOfTypes.html,4,"['Hash', 'hash']","['Hash', 'hash']"
Security," ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UnregisterPopup (TGWindow *w);  Remove a popup menu from the list of popups. ;  ; void UnregisterWindow (TGWindow *w);  Remove a TGWindow from the list of windows. ;  ; void WaitFor (TGWindow *w);  Wait for window to be destroyed. ;  ; void WaitForUnmap (TGWindow *w);  Wait for window to be unmapped. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGClient.html:6117,Hash,Hash,6117,doc/master/classTGClient.html,https://root.cern,https://root.cern/doc/master/classTGClient.html,2,['Hash'],['Hash']
Security," ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; Bool_t BrowseDataSets (const char *group, const char *user, const char *dsName, UInt_t option, TObject *target);  Adds the dataset in the folder of group, user to the list in target. ;  ; Int_t ChecksumDataSet (const char *path, const char *md5path, TString &checksum);  Calculate the checksum of the indicated dataset at 'path' and save it to the appropriate file 'md5path'. ;  ; Int_t CreateLsFile (const char *group, const char *user, Long_t &mtime, TString &checksum);  Create or recreate the dataset lists for 'uri'. ;  ; Bool_t ExistsDataSet (const char *group, const char *user, const char *dsName);  Checks if the indicated dataset exits. ;  ; Int_t FillLsDataSet (const char *group, const char *user, const char *dsName, TList *out, UInt_t option);  Check for the 'ls.txt' for 'group' and 'user' and fill the path for the ls file in 'out'. ;  ; const char * GetDataSetPath (const char *group, const char *user, const char *dsName);  ; const char * GetDataSetPath (const char *group, const char *user, const char *dsName, TString &md5path, Bool_t local=kFALSE);  Returns path of the indicated dataset. ;  ; void Init ();  Do the real inititialization. ;  ; Bool_t RemoveDataSet (const char *group, const char *user, const char *dsName);  Removes the indicated dataset. ;  ; Int_t ScanDataSet (const char *group, const char *user, const char *dsName, UInt_t option=kReopen|kDebug);  See documentation of ScanDataSet(TFileCollection *dataset,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:15371,checksum,checksum,15371,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['checksum'],['checksum']
Security," ;  CTChainA chain is a collection of files containing TTree objects ;  CTChainElementA TChainElement describes a component of a TChain ;  ►CTChainIndexA Chain Index ;  CTChainIndexEntryHolds a description of indices of trees in the chain ;  CTChair;  CTChirpFileRead and write data via a Chirp server ;  CTChirpSystem;  CTCivetweb;  CTCL;  ►CTClassThe ROOT global object gROOT contains a list of all defined classes ;  CInsertTClassInRegistryRAII;  CTDeclNameRegistry;  CTNameMapNode;  CTSpinLockGuard;  CTClassDocInfo;  CTClassDocOutput;  CTClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized way to create the TClass objects ;  CTClassMenuItemDescribes one element of the context menu associated to a class The menu item may describe ;  CTClassRefTClassRef is used to implement a permanent reference to a TClass object ;  CTClassStreamer;  CTClassTableThis class registers for all classes their name, id and dictionary function in a hash table ;  CTClassTreeDraw inheritance tree and their relations for a list of classes ;  CTClonesArrayAn array of clone (identical) objects ;  CTCollectionCollection abstract base class ;  CTCollectionClassStreamerClass streamer object to implement TClassStreamer functionality for I/O emulation ;  CTCollectionMemberStreamerClass streamer object to implement TMemberStreamer functionality for I/O emulation ;  CTCollectionMethodBrowsableTCollectionMethodBrowsable extends TCollectionPropertyBrowsable by showing all methods of the collection itself ;  CTCollectionPropertyBrowsableA tiny browser helper object (and its generator) for adding a virtual (as in ""not actually part of the class"", not in C++ virtual) ""@size()"" method to a collection ;  CTCollectionProxyFactoryTCollectionProxyFactory Interface to collection proxy and streamer generator ;  CTCollectionStreamerClass streamer object to implement TClassStreamer functionality for I/O emulation ;  CTColorThe color creation and management c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:124583,hash,hash,124583,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['hash'],['hash']
Security," <atomic>; 42 ; 43#include ""RtypesCore.h""; 44 ; 45#include ""TString.h""; 46 ; 47namespace TMVA {; 48 ; 49 typedef UInt_t TMVAVersion_t;; 50 ; 51 class MsgLogger;; 52 ; 53 // message types for MsgLogger; 54 // define outside of Types class to facilite access; 55 enum EMsgType {; 56 kDEBUG = 1,; 57 kVERBOSE = 2,; 58 kINFO = 3,; 59 kWARNING = 4,; 60 kERROR = 5,; 61 kFATAL = 6,; 62 kSILENT = 7,; 63 kHEADER = 8; 64 };; 65 ; 66 enum HistType { kMVAType = 0, kProbaType = 1, kRarityType = 2, kCompareType = 3 };; 67 ; 68 //Variable Importance type; 69 enum VIType {kShort=0,kAll=1,kRandom=2};; 70 ; 71 class Types {; 72 ; 73 public:; 74 ; 75 // available MVA methods; 76 enum EMVA {; 77 kVariable = 0,; 78 kCuts ,; 79 kLikelihood ,; 80 kPDERS ,; 81 kHMatrix ,; 82 kFisher ,; 83 kKNN ,; 84 kCFMlpANN ,; 85 kTMlpANN ,; 86 kBDT ,; 87 kDT ,; 88 kRuleFit ,; 89 kSVM ,; 90 kMLP ,; 91 kBayesClassifier,; 92 kFDA ,; 93 kBoost ,; 94 kPDEFoam ,; 95 kLD ,; 96 kPlugins ,; 97 kCategory ,; 98 kDNN ,; 99 kDL ,; 100 kPyRandomForest ,; 101 kPyAdaBoost ,; 102 kPyGTB ,; 103 kPyKeras ,; 104 kPyTorch ,; 105 kC50 ,; 106 kRSNNS ,; 107 kRSVM ,; 108 kRXGB ,; 109 kCrossValidation,; 110 kMaxMethod; 111 };; 112 ; 113 // available variable transformations; 114 enum EVariableTransform {; 115 kIdentity = 0,; 116 kDecorrelated,; 117 kNormalized,; 118 kPCA,; 119 kRearranged,; 120 kGauss,; 121 kUniform,; 122 kMaxVariableTransform; 123 };; 124 ; 125 // type of analysis; 126 enum EAnalysisType {; 127 kClassification = 0,; 128 kRegression,; 129 kMulticlass,; 130 kNoAnalysisType,; 131 kMaxAnalysisType; 132 };; 133 ; 134 enum ESBType {; 135 kSignal = 0, ///< Never change this number - it is elsewhere assumed to be zero !; 136 kBackground,; 137 kSBBoth,; 138 kMaxSBType,; 139 kTrueType; 140 };; 141 ; 142 enum ETreeType {; 143 kTraining = 0,; 144 kTesting,; 145 kMaxTreeType, ///< also used as temporary storage for trees not yet assigned for testing;training...; 146 kValidation, ///< these are placeholders... currently not us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Types_8h_source.html:1881,access,access,1881,doc/master/tmva_2tmva_2inc_2TMVA_2Types_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Types_8h_source.html,1,['access'],['access']
Security," = (TBranch*)next() ) ) {; 2830 b->SetEntryOffsetLen( newdefault, true );; 2831 }; 2832 }; 2833}; 2834 ; 2835////////////////////////////////////////////////////////////////////////////////; 2836/// Set the number of entries in this branch.; 2837 ; 2838void TBranch::SetEntries(Long64_t entries); 2839{; 2840 fEntries = entries;; 2841 fEntryNumber = entries;; 2842}; 2843 ; 2844////////////////////////////////////////////////////////////////////////////////; 2845/// Set file where this branch writes/reads its buffers.; 2846/// By default the branch buffers reside in the file where the; 2847/// Tree was created.; 2848/// If the file name where the tree was created is an absolute; 2849/// path name or an URL (e.g. or root://host/...); 2850/// and if the fname is not an absolute path name or an URL then; 2851/// the path of the tree file is prepended to fname to make the; 2852/// branch file relative to the tree file. In this case one can; 2853/// move the tree + all branch files to a different location in; 2854/// the file system and still access the branch files.; 2855/// The ROOT file will be connected only when necessary.; 2856/// If called by TBranch::Fill (via TBasket::WriteFile), the file; 2857/// will be created with the option ""recreate"".; 2858/// If called by TBranch::GetEntry (via TBranch::GetBasket), the file; 2859/// will be opened in read mode.; 2860/// To open a file in ""update"" mode or with a certain compression; 2861/// level, use TBranch::SetFile(TFile *file).; 2862 ; 2863void TBranch::SetFile(TFile* file); 2864{; 2865 if (file == nullptr) file = fTree->GetCurrentFile();; 2866 fDirectory = (TDirectory*)file;; 2867 if (file == fTree->GetCurrentFile()) fFileName = """";; 2868 else fFileName = file->GetName();; 2869 ; 2870 if (file && fCompress == -1) {; 2871 fCompress = file->GetCompressionLevel();; 2872 }; 2873 ; 2874 // Apply to all existing baskets.; 2875 TIter nextb(GetListOfBaskets());; 2876 TBasket *basket;; 2877 while ((basket = (TBasket*)nextb())) {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:101652,access,access,101652,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['access'],['access']
Security," = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; TObjArray*GetRows() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeResult.html:2607,Hash,Hash,2607,root/html528/TTreeResult.html,https://root.cern,https://root.cern/root/html528/TTreeResult.html,1,['Hash'],['Hash']
Security," = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; TObjArray*GetRows() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeResult.html:2607,Hash,Hash,2607,root/html530/TTreeResult.html,https://root.cern,https://root.cern/root/html530/TTreeResult.html,3,['Hash'],['Hash']
Security," = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; TObjArray*GetRows() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeResult.html:2555,Hash,Hash,2555,root/html602/TTreeResult.html,https://root.cern,https://root.cern/root/html602/TTreeResult.html,2,['Hash'],['Hash']
Security," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; stringFilePrefixStr(string); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFitModel(RooWorkspace*, string, string, string, bool = false); voidFormatFrameForLikelihood(RooPlot* frame, string XTitle = string(""#sigma / #sigma_{SM}""), string YTitle = string(""-log likelihood"")); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; RooStats::HistFactory::HistoToWorkspaceFactoryFastHistoToWorkspaceFactoryFast(); RooStats::HistFactory::HistoToWorkspaceFactoryFastHistoToWorkspaceFactoryFast(string, string, vector<string>, double = 200, double = 20, int = 0, int = 6, TFile* = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; voidLinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<TH1*> lowHist, vector<TH1*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:3598,Hash,Hash,3598,root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['Hash'],['Hash']
Security," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; stringFilePrefixStr(string); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFitModel(RooWorkspace*, string, string, string, bool = false); voidFormatFrameForLikelihood(RooPlot* frame, string XTitle = string(""#sigma / #sigma_{SM}""), string YTitle = string(""-log likelihood"")); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; RooStats::HistFactory::HistoToWorkspaceFactoryFastHistoToWorkspaceFactoryFast(); RooStats::HistFactory::HistoToWorkspaceFactoryFastHistoToWorkspaceFactoryFast(string, string, vector<string>, double = 200, double = 20, int = 0, int = 6, TFile* = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; voidLinInterpWithConstraint(RooWorkspace* proto, TH1F* nominal, vector<TH1F*> lowHist, vector<TH1F*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:3318,Hash,Hash,3318,root/html530/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['Hash'],['Hash']
Security," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; stringFilePrefixStr(string); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFitModel(RooWorkspace*, string, string, string, bool = false); voidFormatFrameForLikelihood(RooPlot* frame, string XTitle = string(""#sigma / #sigma_{SM}""), string YTitle = string(""-log likelihood"")); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; RooStats::HistFactory::HistoToWorkspaceFactoryHistoToWorkspaceFactory(); RooStats::HistFactory::HistoToWorkspaceFactoryHistoToWorkspaceFactory(string, string, vector<string>, double = 200, double = 20, int = 0, int = 6, TFile* = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; voidLinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<TH1*> lowHist, vector<TH1*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html:3302,Hash,Hash,3302,root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['Hash'],['Hash']
Security," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; stringFilePrefixStr(string); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFitModel(RooWorkspace*, string, string, string, bool = false); voidFormatFrameForLikelihood(RooPlot* frame, string XTitle = string(""#sigma / #sigma_{SM}""), string YTitle = string(""-log likelihood"")); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; RooStats::HistFactory::HistoToWorkspaceFactoryHistoToWorkspaceFactory(); RooStats::HistFactory::HistoToWorkspaceFactoryHistoToWorkspaceFactory(string, string, vector<string>, double = 200, double = 20, int = 0, int = 6, TFile* = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; voidLinInterpWithConstraint(RooWorkspace* proto, TH1F* nominal, vector<TH1F*> lowHist, vector<TH1F*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihood",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html:3302,Hash,Hash,3302,root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html,2,['Hash'],['Hash']
Security," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TMap*GetMapOfActiveNodes() const; TMap*GetMapOfNodes() const; Int_tGetMaxWrksPerNode() const; Int_tGetMinWrksPerNode() const; Int_tGetNActives() const; virtual const char*TObject::GetName() const; Int_tGetNCores() const; Int_tGetNNodes() const; Int_tGetNWorkersCluster() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofNodes.html:2542,Hash,Hash,2542,root/html534/TProofNodes.html,https://root.cern,https://root.cern/root/html534/TProofNodes.html,1,['Hash'],['Hash']
Security," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TMap*GetMapOfActiveNodes() const; TMap*GetMapOfNodes() const; Int_tGetMaxWrksPerNode() const; Int_tGetMinWrksPerNode() const; Int_tGetNActives() const; virtual const char*TObject::GetName() const; Int_tGetNCores() const; Int_tGetNNodes() const; Int_tGetNWorkersCluster() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofNodes.html:2481,Hash,Hash,2481,root/html602/TProofNodes.html,https://root.cern,https://root.cern/root/html602/TProofNodes.html,2,['Hash'],['Hash']
Security," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDataMember*GetDataMember() const; const char*GetDefault() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; TFunction*GetMethod() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetOptions() const; virtual const char*TNamed::GetTitle() const; const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodArg.html:2693,Hash,Hash,2693,root/html528/TMethodArg.html,https://root.cern,https://root.cern/root/html528/TMethodArg.html,1,['Hash'],['Hash']
Security," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDataMember*GetDataMember() const; const char*GetDefault() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; TFunction*GetMethod() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetOptions() const; virtual const char*TNamed::GetTitle() const; const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMethodArg.html:2693,Hash,Hash,2693,root/html530/TMethodArg.html,https://root.cern,https://root.cern/root/html530/TMethodArg.html,1,['Hash'],['Hash']
Security," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; Int_tGetType() const; static EDataTypeGetType(const type_info& typeinfo); const char*GetTypeName() const; static const char*GetTypeName(EDataType type); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataType.html:2707,Hash,Hash,2707,root/html528/TDataType.html,https://root.cern,https://root.cern/root/html528/TDataType.html,1,['Hash'],['Hash']
Security," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; Int_tGetType() const; static EDataTypeGetType(const type_info& typeinfo); const char*GetTypeName() const; static const char*GetTypeName(EDataType type); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDataType.html:2707,Hash,Hash,2707,root/html530/TDataType.html,https://root.cern,https://root.cern/root/html530/TDataType.html,1,['Hash'],['Hash']
Security," = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TPair&operator=(const TPair&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TObject*fKey; TObject*fValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browse the pair. TMap& operator=(const TPair& ). TPair(TObject* key, TObject* value); { }. TPair(const TPair& a); { }. virtual ~TPair(); { }. Bool_t IsFolder() const; { return kTRUE;}. const char * GetName() const; { return fKey->GetName(); }. const char * GetTitle() const; { return fKey->GetTitle(); }. ULong_t Hash() const; { return fKey->Hash(); }. Bool_t IsEqual(const TObject* obj) const; { return fKey->IsEqual(obj); }. TObject * Key() const; { return fKey; }. TObject * Value() const; { return fValue; }. void SetValue(TObject* val); { fValue = val; }. » Author: Fons Rademakers 12/11/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-30 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPair.html:6384,Hash,Hash,6384,root/html602/TPair.html,https://root.cern,https://root.cern/root/html602/TPair.html,2,['Hash'],['Hash']
Security," = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TPair&operator=(const TPair&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TObject*fKey; TObject*fValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browse the pair. TMap& operator=(const TPair& ). TPair(TObject* key, TObject* value); { }. TPair(const TPair& a); { }. virtual ~TPair(); { }. Bool_t IsFolder() const; { return kTRUE;}. const char * GetName() const; { return fKey->GetName(); }. const char * GetTitle() const; { return fKey->GetTitle(); }. ULong_t Hash() const; { return fKey->Hash(); }. Bool_t IsEqual(const TObject* obj) const; { return fKey->IsEqual(obj); }. TObject * Key() const; { return fKey; }. TObject * Value() const; { return fValue; }. void SetValue(TObject* val); { fValue = val; }. » Author: Fons Rademakers 12/11/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-09-08 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPair.html:6384,Hash,Hash,6384,root/html604/TPair.html,https://root.cern,https://root.cern/root/html604/TPair.html,2,['Hash'],['Hash']
Security," = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoGlobalMagField(const TGeoGlobalMagField&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoGlobalMagField&operator=(const TGeoGlobalMagField&); voidUnlock(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TVirtualMagField*fFieldMagnetic field; Bool_tfLockLock flag for global field.; static TGeoGlobalMagField*fgInstanceStatic pointer to the field manager;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGlobalMagField(); Global field default constructor. ~TGeoGlobalMagField(); Global field destructor. void SetField(TVirtualMagField* field); Field setter. Deletes previous field if any. Acts only if fLock=kFALSE. TGeoGlobalMagField * Instance(); Returns always a valid static pointer to the field manager. void Lock(); Locks the global magnetic field if this is set. Cannot be unlocked. TGeoGlobalMagField(const TGeoGlobalMagField& ). TGeoGlobalMagField& operator=(const TGeoGlobalMagField& ). void Unlock(); {fLock = kFALSE;}. TVirtualMagField * GetField() const; Using SetField() makes a given field global. The field manager owns it from now on. {return fField;}. Bool_t IsLocked(); {return fLock;}. void Field(const Double_t* x, Double_t* B); Inline access to Field() method. {if (fField) fField->Field(x,B);}. » Last changed: root/geom:$Id: TGeoGlobalMagField.h 27191 2009-01-20 08:09:20Z brun $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGlobalMagField.html:6853,access,access,6853,root/html528/TGeoGlobalMagField.html,https://root.cern,https://root.cern/root/html528/TGeoGlobalMagField.html,1,['access'],['access']
Security," = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoGlobalMagField(const TGeoGlobalMagField&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoGlobalMagField&operator=(const TGeoGlobalMagField&); voidUnlock(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TVirtualMagField*fFieldMagnetic field; Bool_tfLockLock flag for global field.; static TGeoGlobalMagField*fgInstanceStatic pointer to the field manager;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGlobalMagField(); Global field default constructor. ~TGeoGlobalMagField(); Global field destructor. void SetField(TVirtualMagField* field); Field setter. Deletes previous field if any. Acts only if fLock=kFALSE. TGeoGlobalMagField * Instance(); Returns always a valid static pointer to the field manager. void Lock(); Locks the global magnetic field if this is set. Cannot be unlocked. TGeoGlobalMagField(const TGeoGlobalMagField& ). TGeoGlobalMagField& operator=(const TGeoGlobalMagField& ). void Unlock(); {fLock = kFALSE;}. TVirtualMagField * GetField() const; Using SetField() makes a given field global. The field manager owns it from now on. {return fField;}. Bool_t IsLocked(); {return fLock;}. void Field(const Double_t* x, Double_t* B); Inline access to Field() method. {if (fField) fField->Field(x,B);}. » Last changed: root/geom:$Id: TGeoGlobalMagField.h 27191 2009-01-20 08:09:20Z brun $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoGlobalMagField.html:6922,access,access,6922,root/html530/TGeoGlobalMagField.html,https://root.cern,https://root.cern/root/html530/TGeoGlobalMagField.html,1,['access'],['access']
Security," = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoGlobalMagField(const TGeoGlobalMagField&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoGlobalMagField&operator=(const TGeoGlobalMagField&); voidUnlock(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TVirtualMagField*fFieldMagnetic field; Bool_tfLockLock flag for global field.; static TGeoGlobalMagField*fgInstanceStatic pointer to the field manager;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGlobalMagField(); Global field default constructor. ~TGeoGlobalMagField(); Global field destructor. void SetField(TVirtualMagField* field); Field setter. Deletes previous field if any. Acts only if fLock=kFALSE. TGeoGlobalMagField * Instance(); Returns always a valid static pointer to the field manager. void Lock(); Locks the global magnetic field if this is set. Cannot be unlocked. TGeoGlobalMagField(const TGeoGlobalMagField& ). TGeoGlobalMagField& operator=(const TGeoGlobalMagField& ). void Unlock(); {fLock = kFALSE;}. TVirtualMagField * GetField() const; Using SetField() makes a given field global. The field manager owns it from now on. {return fField;}. Bool_t IsLocked(); {return fLock;}. void Field(const Double_t* x, Double_t* B); Inline access to Field() method. {if (fField) fField->Field(x,B);}. » Last changed: root/geom:$Id: TGeoGlobalMagField.h 27191 2009-01-20 08:09:20Z brun $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoGlobalMagField.html:6922,access,access,6922,root/html532/TGeoGlobalMagField.html,https://root.cern,https://root.cern/root/html532/TGeoGlobalMagField.html,1,['access'],['access']
Security," = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidReset(). Data Members; public:. enum EStatusBits { kMultiply; kMax; kMin; kFirst; kLast; kIsConst; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfName; floatfVal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t TParameter<AParamType> Merge(TCollection* in); Merge objects in the list.; Returns the number of objects that were in the list. void Reset(). const char * GetName() const; { return fName; }. const AParamType & GetVal() const; { return fVal; }. Bool_t IsConst() const; { return (TestBit(kIsConst) ? kTRUE : kFALSE); }. void SetVal(const float& val); { fVal = val; }. void SetMergeMode(char mergemode = '+'); Merging modes:; '+' addition ('OR' for booleans) [default]; '*' multiplication ('AND' for booleans); 'M' maximum ('OR' for booleans); 'm' minimum ('AND' for booleans); 'f' first value; 'l' last value. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsSortable() const; { return kTRUE; }. Int_t Compare(const TObject* obj) const; Compare two TParameter objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp). void ls(Option_t* ) const; Print this parameter content. void Print(Option_t* ) const; Print this parameter content. cout << IsA(). » Author: Maarten Ballintijn 21/06/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TParameter_float_.html:6322,Hash,Hash,6322,root/html534/TParameter_float_.html,https://root.cern,https://root.cern/root/html534/TParameter_float_.html,2,['Hash'],['Hash']
Security," = 9999) const; virtual TList*GetList() const; virtual TList*GetListOfKeys() const; virtual TObject*GetMother() const; virtual TDirectory*GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNbytesKeys() const; virtual Int_tGetNkeys() const; virtual void*GetObjectChecked(const char* namecycle, const char* classname); virtual void*GetObjectChecked(const char* namecycle, const TClass* cl); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual void*GetObjectUnchecked(const char* namecycle); virtual Option_t*TObject::GetOption() const; virtual const char*GetPath() const; virtual const char*GetPathStatic() const; virtual Long64_tGetSeekDir() const; virtual Long64_tGetSeekKeys() const; virtual Long64_tGetSeekParent() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TUUIDGetUUID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tIsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsWritable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TDirectory*mkdir(const char* name, const char* title = """"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual TFile*OpenFile(const char*, Option_t* = """", const char* = """", Int_t = 1, Int_t = 0); voidTObject::operator delete(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDirectory.html:3964,Hash,Hash,3964,root/html602/TDirectory.html,https://root.cern,https://root.cern/root/html602/TDirectory.html,2,['Hash'],['Hash']
Security," = fetchValue(block, ""WeightDecay"", 0.0);; 576 settings.learningRate = fetchValue(block, ""LearningRate"", 1e-5);; 577 settings.momentum = fetchValue(block, ""Momentum"", 0.3);; 578 settings.dropoutProbabilities = fetchValue(block, ""DropConfig"",; 579 std::vector<Double_t>());; 580 ; 581 TString regularization = fetchValue(block, ""Regularization"",; 582 TString (""NONE""));; 583 if (regularization == ""L1"") {; 584 settings.regularization = DNN::ERegularization::kL1;; 585 } else if (regularization == ""L2"") {; 586 settings.regularization = DNN::ERegularization::kL2;; 587 } else {; 588 settings.regularization = DNN::ERegularization::kNone;; 589 }; 590 ; 591 TString strMultithreading = fetchValue(block, ""Multithreading"",; 592 TString (""True""));; 593 if (strMultithreading.BeginsWith (""T"")) {; 594 settings.multithreading = true;; 595 } else {; 596 settings.multithreading = false;; 597 }; 598 ; 599 fTrainingSettings.push_back(settings);; 600 }; 601}; 602 ; 603////////////////////////////////////////////////////////////////////////////////; 604/// Validation of the ValidationSize option. Allowed formats are 20%, 0.2 and; 605/// 100 etc.; 606/// - 20% and 0.2 selects 20% of the training set as validation data.; 607/// - 100 selects 100 events as the validation data.; 608///; 609/// @return number of samples in validation set; 610///; 611 ; 612UInt_t TMVA::MethodDNN::GetNumValidationSamples(); 613{; 614 Int_t nValidationSamples = 0;; 615 UInt_t trainingSetSize = GetEventCollection(Types::kTraining).size();; 616 ; 617 // Parsing + Validation; 618 // --------------------; 619 if (fValidationSize.EndsWith(""%"")) {; 620 // Relative spec. format 20%; 621 TString intValStr = TString(fValidationSize.Strip(TString::kTrailing, '%'));; 622 ; 623 if (intValStr.IsFloat()) {; 624 Double_t valSizeAsDouble = fValidationSize.Atof() / 100.0;; 625 nValidationSamples = GetEventCollection(Types::kTraining).size() * valSizeAsDouble;; 626 } else {; 627 Log() << kFATAL << ""Cannot parse number \"""" << fValidati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:20813,Validat,Validation,20813,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,2,['Validat'],"['Validation', 'ValidationSize']"
Security," = kFALSE, Bool_t norm = kTRUE); constructor of spline based PDF:. PDF(const TString& name, const TH1* theHist, TMVA::KDEKernel::EKernelType ktype, TMVA::KDEKernel::EKernelIter kiter, TMVA::KDEKernel::EKernelBorder kborder, Float_t FineFactor, Bool_t norm = kTRUE); constructor of kernel based PDF:. PDF(const TString& name, const TString& options, const TString& suffix = """", TMVA::PDF* defaultPDF = 0, Bool_t norm = kTRUE). ~PDF(); destructor. void BuildPDF(const TH1* theHist). Int_t GetHistNBins(Int_t evtNum = 0). void BuildSplinePDF(); build the PDF from the original histograms. void BuildKDEPDF(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void SmoothHistogram(). void FillHistToGraph(); Simple conversion. void FillSplineToHist(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void CheckHist() const; sanity check: compare PDF with original histogram. void ValidatePDF(TH1* original = 0) const; comparison of original histogram with reference PDF. Double_t GetIntegral() const; computes normalisation. Double_t IGetVal(Double_t* , Double_t* ); static external auxiliary function (integrand). Double_t GetIntegral(Double_t xmin, Double_t xmax); computes PDF integral within given ranges. Double_t GetVal(Double_t x) const; returns value PDF(x). Double_t GetValInverse(Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; returns value PDF^{-1}(y). void FindBinInverse(const TH1* histogram, Int_t& lowerBin, Int_t& higherBin, Double_t& lowerBinValue, Double_t& higherBinValue, Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; find bin from value on ordinate. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms; if no variable index is given, it is valid for ALL the variables.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDF.html:11085,Validat,ValidatePDF,11085,root/html530/TMVA__PDF.html,https://root.cern,https://root.cern/root/html530/TMVA__PDF.html,5,['Validat'],['ValidatePDF']
Security," = kFALSE, Bool_t norm = kTRUE); constructor of spline based PDF:. PDF(const TString& name, const TH1* theHist, TMVA::KDEKernel::EKernelType ktype, TMVA::KDEKernel::EKernelIter kiter, TMVA::KDEKernel::EKernelBorder kborder, Float_t FineFactor, Bool_t norm = kTRUE); constructor of kernel based PDF:. PDF(const TString& name, const TString& options, const TString& suffix = """", TMVA::PDF* defaultPDF = 0, Bool_t norm = kTRUE). ~PDF(); destructor. void BuildPDF(const TH1* theHist). Int_t GetHistNBins(Int_t evtNum = 0). void BuildSplinePDF(); build the PDF from the original histograms. void BuildKDEPDF(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void SmoothHistogram(). void FillHistToGraph(); Simple conversion. void FillSplineToHist(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void CheckHist() const; sanity check: compare PDF with original histogram. void ValidatePDF(TH1* original = 0) const; comparison of original histogram with reference PDF. Double_t GetIntegral() const; computes normalisation. Double_t IGetVal(Double_t* , Double_t* ); static external auxiliary function (integrand). Double_t GetIntegral(Double_t xmin, Double_t xmax); computes PDF integral within given ranges. Double_t GetVal(Double_t x) const; returns value PDF(x). void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms; if no variable index is given, it is valid for ALL the variables. NSmooth <int> how often the input histos are smoothed; MinNSmooth <int> min number of smoothing iterations, for bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood out",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDF.html:10729,Validat,ValidatePDF,10729,root/html528/TMVA__PDF.html,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html,1,['Validat'],['ValidatePDF']
Security," = kTRUE) const; RooAbsPdf*getPdf(const char* catName) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); const RooAbsCategoryLValue&indexCat() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimultaneous.html:18357,Hash,Hash,18357,root/html526/RooSimultaneous.html,https://root.cern,https://root.cern/root/html526/RooSimultaneous.html,2,['Hash'],['Hash']
Security," = kTRUE) const; RooAbsPdf*getPdf(const char* catName) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); const RooAbsCategoryLValue&indexCat() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooSimultaneous.html:18683,Hash,Hash,18683,root/html530/RooSimultaneous.html,https://root.cern,https://root.cern/root/html530/RooSimultaneous.html,1,['Hash'],['Hash']
Security," = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now */; 14099 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14100 ; 14101 /* 2. if this ip has limited speed, set it for this connection */; 14102 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14103 &conn->client.rsa,; 14104 ri->local_uri);; 14105 ; 14106 /* 3. call a ""handle everything"" callback, if registered */; 14107 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14108 /* Note that since V1.7 the ""begin_request"" function is called; 14109 * before an authorization check. If an authorization check is; 14110 * required, use a request_handler instead. */; 14111 i = conn->phys_ctx->callbacks.begin_request(conn);; 14112 if (i > 0) {; 14113 /* callback already processed the request. Store the; 14114 return value as a status code for the access log. */; 14115 conn->status_code = i;; 14116 if (!conn->must_close) {; 14117 discard_unread_request_data(conn);; 14118 }; 14119 return;; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler or redirect, so the request; 14129 * is processed here */; 14130 ; 14131 /* 4. Check for CORS preflight requests and handle them (if configured).; 14132 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14133 */; 14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a response to CORS preflights only if; 14136 * access_control_allow_methods is not NULL and not an empty string.; 14137 * In this case, scripts can still handle CORS. */; 14138 const char *cors_meth_cfg =; 14139 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14140 const char *cors_or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:414247,access,access,414247,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security," = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now */; 14100 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14101 ; 14102 /* 2. if this ip has limited speed, set it for this connection */; 14103 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14104 &conn->client.rsa,; 14105 ri->local_uri);; 14106 ; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; 14112 i = conn->phys_ctx->callbacks.begin_request(conn);; 14113 if (i > 0) {; 14114 /* callback already processed the request. Store the; 14115 return value as a status code for the access log. */; 14116 conn->status_code = i;; 14117 if (!conn->must_close) {; 14118 discard_unread_request_data(conn);; 14119 }; 14120 return;; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler or redirect, so the request; 14130 * is processed here */; 14131 ; 14132 /* 4. Check for CORS preflight requests and handle them (if configured).; 14133 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14134 */; 14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a response to CORS preflights only if; 14137 * access_control_allow_methods is not NULL and not an empty string.; 14138 * In this case, scripts can still handle CORS. */; 14139 const char *cors_meth_cfg =; 14140 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14141 const char *cors_or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:414280,access,access,414280,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security," = new TGenericLoopConfig(&proxy, /* read */ kTRUE);; 3920 }; 3921 for (UInt_t i = 0; i < ndata; ++i) {; 3922 TStreamerElement *element = (TStreamerElement*) info->GetElements()->At(i);; 3923 if (!element) {; 3924 break;; 3925 }; 3926 if (element->GetType() < 0) {; 3927 // -- Skip an ignored TObject base class.; 3928 // Note: The only allowed negative value here is -1, and signifies that Build() has found a TObject; 3929 // base class and TClass::IgnoreTObjectStreamer() was called. In this case the compiled version of the; 3930 // elements omits the TObject base class element, which has to be compensated for by TTree::Bronch(); 3931 // when it is making branches for a split object.; 3932 continue;; 3933 }; 3934 if (element->TestBit(TStreamerElement::kWrite)) {; 3935 // Skip element that only for writing.; 3936 continue;; 3937 }; 3938 TStreamerBase *baseEl = dynamic_cast<TStreamerBase*>(element);; 3939 if (baseEl) {; 3940 if (!baseEl->TestBit(TStreamerElement::kWarned) && baseEl->GetErrorMessage()[0]) {; 3941 // There was a problem with the checksum, the user likely did not; 3942 // increment the version number of the derived class when the; 3943 // base class changed. Since we will be member wise streaming; 3944 // this class, let's warn the user that something is wrong.; 3945 ::Warning(""CreateReadMemberWiseActions"",""%s"",; 3946 baseEl->GetErrorMessage());; 3947 baseEl->SetBit(TStreamerElement::kWarned);; 3948 }; 3949 }; 3950 ; 3951 TStreamerInfo::TCompInfo_t *compinfo = sinfo->fCompFull[i];; 3952 ; 3953 Int_t oldType = element->GetType();; 3954 Int_t newType = element->GetNewType();; 3955 ; 3956 Int_t offset = element->GetOffset();; 3957 if (newType != oldType) {; 3958 if (newType > 0) {; 3959 if (oldType != TVirtualStreamerInfo::kCounter) {; 3960 oldType += TVirtualStreamerInfo::kConv;; 3961 }; 3962 } else {; 3963 oldType += TVirtualStreamerInfo::kSkip;; 3964 }; 3965 }; 3966 switch (SelectLooper(proxy)) {; 3967 case kAssociativeLooper:; 3968// } else if (proxy.GetCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:183532,checksum,checksum,183532,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['checksum'],['checksum']
Security," = std::unordered_map< TObject const *, TObject const * >;  ; using HashTableByName = std::unordered_map< std::string, TObject const * >;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual void Add (TObject *arg, Int_t refCount);  Insert object into collection with given reference count value. ;  ; RooLinkedListElem * createElement (TObject *obj, RooLinkedListElem *elem=nullptr);  cout << ""RooLinkedList::createElem("" << this << "") obj = "" << obj << "" elem = "" << elem << endl ; ;  ; void deleteElement (RooLinkedListElem *);  ; RooLinkedListElem * findLink (const TObject *arg) const;  Find the element link containing the given object. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooLinkedListElem * _first;  ! Link to first element of list ;  ; Int_t _hashThresh;  Size threshold for hashing. ;  ; std::unique_ptr< HashTableByLink > _htableLink;  ! Hash table by link pointer ;  ; std::unique_ptr< HashTableByName > _htableName;  ! Hash table by name ;  ; RooLinkedListElem * _last;  ! Link to last element of list ;  ; TString _name;  ; Int_t _size;  Current size of list. ;  ; bool _useNptr;  ! ;  . Private Types; typedef RooLinkedListImplDetails::Pool Pool;  memory pool for quick allocation of RooLinkedListElems ;  . Static Private Member Functions; template<bool ascending> ; static RooLinkedListElem * mergesort_impl (RooLinkedListElem *l1, const unsigned sz, RooLinkedListElem **tail=nullptr);  length 0, 1 lists are sorted ;  . Private Attributes; std::vector< RooLinkedListElem * > _at;  ! index list for quick index through At ;  . Static Private Attributes; static Pool * _pool = nullptr;  shared memory pool for allocation of RooLinkedListElems ;  . Friends; class RooFIterForLinkedList;  ; class RooLinkedList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinkedList.html:12353,hash,hashing,12353,doc/master/classRooLinkedList.html,https://root.cern,https://root.cern/doc/master/classRooLinkedList.html,1,['hash'],['hashing']
Security," > . auto ROOT::Internal::GetTheRightOp ; (; T(F::*)(T *, double *) ; opPtr); -> decltype(opPtr); . Definition at line 219 of file TF1.h. ◆ gVersionCheck(). static TVersionCheck ROOT::Internal::gVersionCheck ; (; ROOT_VERSION_CODE ; ). static . ◆ hasBeginEnd() [1/2]. template<typename > . constexpr bool ROOT::Internal::hasBeginEnd ; (;  ; ...). constexpr . Definition at line 72 of file RRangeCast.hxx. ◆ hasBeginEnd() [2/2]. template<typename T > . constexpr auto ROOT::Internal::hasBeginEnd ; (; int ; ); -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7345 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7371 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:36007,Hash,Hash,36007,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['Hash'],['Hash']
Security," > . auto ROOT::Internal::GetTheRightOp ; (; T(F::*)(T *, double *) ; opPtr); -> decltype(opPtr); . Definition at line 219 of file TF1.h. ◆ gVersionCheck(). static TVersionCheck ROOT::Internal::gVersionCheck ; (; ROOT_VERSION_CODE ; ). static . ◆ hasBeginEnd() [1/2]. template<typename > . constexpr bool ROOT::Internal::hasBeginEnd ; (;  ; ...). constexpr . Definition at line 72 of file RRangeCast.hxx. ◆ hasBeginEnd() [2/2]. template<typename T > . constexpr auto ROOT::Internal::hasBeginEnd ; (; int ; ); -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7412 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7438 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:36588,Hash,Hash,36588,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['Hash'],['Hash']
Security," > . constexpr auto ROOT::Internal::hasBeginEnd ; (; int ; ); -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7345 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7371 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch processing is enabled. ; Definition at line 447 of file TROOT.cxx. ◆ LogicalCPUBandwidthControl(). int ROOT::Internal::LogicalCPUBandwidthControl ; (; ). Returns the available number of logical cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. ◆ Minim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:36471,Hash,Hash,36471,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['Hash'],['Hash']
Security," > . constexpr auto ROOT::Internal::hasBeginEnd ; (; int ; ); -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7412 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7438 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch processing is enabled. ; Definition at line 447 of file TROOT.cxx. ◆ LogicalCPUBandwidthControl(). int ROOT::Internal::LogicalCPUBandwidthControl ; (; ). Returns the available number of logical cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. ◆ Minim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:37052,Hash,Hash,37052,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['Hash'],['Hash']
Security," >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5333,access,access,5333,root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,1,['access'],['access']
Security," >(const ROOT::Math::SVector<double,2U*(2U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,2>fRep; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5467,Access,Access,5467,root/html602/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5333,access,access,5333,root/html526/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,1,['access'],['access']
Security," >(const ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5467,Access,Access,5467,root/html602/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5333,access,access,5333,root/html526/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,1,['access'],['access']
Security," >(const ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5467,Access,Access,5467,root/html602/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5333,access,access,5333,root/html526/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,1,['access'],['access']
Security," >(const ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5467,Access,Access,5467,root/html602/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5333,access,access,5333,root/html526/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,1,['access'],['access']
Security," >(const ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5467,Access,Access,5467,root/html602/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5333,access,access,5333,root/html526/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,1,['access'],['access']
Security," >(const ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5467,Access,Access,5467,root/html602/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," ? *(T **)address : (T *)address;; 197 }; 198 ; 199 /// Return a pointer to the value of the current entry.; 200 /// Equivalent to Get().; 201 T* operator->() { return Get(); }; 202 ; 203 /// Return a reference to the value of the current entry.; 204 /// Equivalent to dereferencing the pointer returned by Get(). Behavior is undefined if no entry has been loaded yet.; 205 /// Most likely a crash will occur.; 206 T& operator*() { return *Get(); }; 207 ; 208protected:; 209 // FIXME: use IsA() instead once we have ClassDefTInline; 210 /// Get the template argument as a string.; 211 const char* GetDerivedTypeName() const override {; 212 static const std::string sElementTypeName = GetElementTypeName(typeid(T));; 213 return sElementTypeName.data();; 214 }; 215 ; 216 // FIXME: re-introduce once we have ClassDefTInline!; 217 //ClassDefT(TTreeReaderValue, 0);//Accessor to data via TTreeReader; 218};; 219 ; 220namespace cling {; 221std::string printValue(ROOT::Internal::TTreeReaderValueBase *val);; 222template <typename T>; 223std::string printValue(TTreeReaderValue<T> *val); 224{; 225 return printValue(static_cast<ROOT::Internal::TTreeReaderValueBase *>(val));; 226}; 227} // namespace cling; 228 ; 229#endif // ROOT_TTreeReaderValue; TBranchProxy.h; TDictionary.h; TString.h; ROOT::Detail::TBranchProxyBase class for all the proxy object.Definition TBranchProxy.h:74; ROOT::Internal::TTreeReaderOpaqueValueRead a value in a branch without knowledge of its type.Definition TTreeReaderValue.h:158; ROOT::Internal::TTreeReaderOpaqueValue::GetDerivedTypeNameconst char * GetDerivedTypeName() constDefinition TTreeReaderValue.h:166; ROOT::Internal::TTreeReaderOpaqueValue::TTreeReaderOpaqueValueTTreeReaderOpaqueValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:160; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; ROOT::Internal::TTreeReaderValueBase::RegisterWithTreeReadervoid RegisterWithTreeReader()Register with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:9648,Access,Accessor,9648,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,1,['Access'],['Accessor']
Security," A simple example, taken from this website: """""" TFFTComplex One of the interface classes to the FFTW package, can be used directly or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes complex input/output discrete Fourier transforms (DFT) in one or more dimensions. For the detailed information on the computed transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it: 1) Create an instance of TFFTComplex - this will allocate input and output arrays (unless an in-place transform is specified) 2) Run the Init() function with the desired flags and settings ... """""" This is simply poor design. This should look like: root::Fft, removing the T, using a namespace, using templates instead of inheritence, etc. But also, notice that you have to run an Init function. Why? That is specifically what the constructor is for. Why does everything in ROOT know how to draw itself? Why does everything in ROOT have 100 methods, for ""quick access"" to other objects that do the actual work of those methods? These are questions that should be asked. But most of all, if you aren't going to fix these problems, why bother migrating at all? You fail to treat this migration as what it actually is. You are migrating to a new language, not a new version of a language. ROOT isn't written in C++. It's written in CINT. I am just frustrated to see this happen, because I know this community can do better. Maybe I'll make a draft of some smaller changes that need to be made and submit them to the mailing list. But honestly, I'm not very hopeful about this migration. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Re: Why? . Hi Matt!; Thanks for your feedback; I'll tried to reply to each of your comments one by one. I do not disagree with all of your comments, but I might have explanations for some of them :-) Sometimes you seem to misinterpret ""backward compatibility"" (which means ""what used to work will co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:11726,access,access,11726,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['access'],['access']
Security," ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. To draw only the elements that match a selection in case of arrays,; you can also use TEntryListArray (faster in case of a more general selection).; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"", ""entrylistarray"");; tree->SetEntryList(pyplus);; tree->Draw(""fTracks.fPy"");. will draw the fPy of only the tracks that have a positive fPy,; but without redoing the selection. Note: Use tree->SetEventList(0) if you do not want use the list as input. How to obtain more info from TTree::Draw. Once TTree::Draw has been called, it is possible to access useful; information still stored in the TTree object via the following functions:; -GetSelectedRows() //return the number of values accepted by the; //selection expression. In case where no selection; //was specified, returns the number of values processed.; -GetV1() //returns a pointer to the double array of V1; -GetV2() //returns a pointer to the double array of V2; -GetV3() //returns a pointer to the double array of V3; -GetV4() //returns a pointer to the double array of V4; -GetW() //returns a pointer to the double array of Weights; //where weight equal the result of the selection expression.; where V1,V2,V3 correspond to the expressions in; TTree::Draw(""V1:V2:V3:V4"",selection);; If the expression has more than 4 component use GetVal(index). Example:; Root > ntuple->Draw(""py:px"",""pz>4"");; Root > TGraph *gr = new TGraph(ntuple->GetSelectedRows(),; ntuple->GetV2(), ntuple->GetV1());; Root > gr->Draw(""ap""); //draw graph in current pad; creates a TGraph object with a number of points corresponding to the; number of entries selected by the e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:84203,access,access,84203,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['access'],['access']
Security," AUTH information is provided in the 'options' argument; nor the environmental variables are set, we try to open the file; without providing any authentication information to the server. This; is useful when the file is set an access control that allows for; any unidentified user to read the file. Bool_t ParseOptions(Option_t* options, TString& accessKey, TString& secretKey); Extracts the S3 authentication key pair (access key and secret key); from the options. The authentication credentials can be specified in; the options provided to the constructor of this class as a string; containing: ""AUTH=<access key>:<secret key>"" and can include other; options, for instance ""NOPROXY"" for not using the HTTP proxy for; accessing this file's contents.; For instance:; ""NOPROXY AUTH=F38XYZABCDeFgHiJkLm:V+frt4re7J1euSNFnmaf8wwmI401234E7kzxZ/TTM+"". Int_t GetHead(); Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this; file. Uses TS3HTTPRequest to generate an HTTP HEAD request which includes; the authorization header expected by the S3 server. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); Overwrites TWebFile::SetMsgReadBuffer10() for setting the HTTP GET; request compliant to the authentication mechanism used by the S3; protocol. The GET request must contain an ""Authorization"" header with; the signature of the request, generated using the user's secret access; key. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf). void ProcessHttpHeader(const TString& headerLine); This method is called by the super-class TWebFile when a HTTP header; for this file is retrieved. We scan the 'Server' header to detect the; type of S3 server this file is hosted on and to determine if it is; known to support multi-range HTTP GET requests. Some S3 servers (for; instance Amazon's) do not support that feature and when they; receive a multi-range request they sent back the whole file contents.; For this class, if the server do no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:30351,authoriz,authorization,30351,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,['authoriz'],['authorization']
Security," Abort(int code=0) overrideTUnixSystemvirtual; AbstractMethod(const char *method) constTObject; AcceptConnection(int sock) overrideTUnixSystemvirtual; AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideTUnixSystemvirtual; AddDynamicPath(const char *lib) overrideTUnixSystemvirtual; AddFileHandler(TFileHandler *fh) overrideTUnixSystemvirtual; AddIncludePath(const char *includePath)TSystemvirtual; AddLinkedLibs(const char *linkedLib)TSystemvirtual; AddSignalHandler(TSignalHandler *sh) overrideTUnixSystemvirtual; AddStdExceptionHandler(TStdExceptionHandler *eh)TSystemvirtual; AddTimer(TTimer *ti) overrideTUnixSystemvirtual; AddToTObjectTable(TObject *)TObjectprivatestatic; AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) overrideTUnixSystemvirtual; AnnounceUdpService(int port, int backlog) overrideTUnixSystemvirtual; AnnounceUnixService(int port, int backlog) overrideTUnixSystemvirtual; AnnounceUnixService(const char *sockpath, int backlog) overrideTUnixSystemvirtual; AppendPad(Option_t *option="""")TObjectvirtual; BaseName(const char *pathname)TSystemvirtual; Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)TSystem; Browse(TBrowser *b)TObjectvirtual; cd(const char *path)TSysteminline; ChangeDirectory(const char *path) overrideTUnixSystemvirtual; CheckChilds()TUnixSystem; CheckDescriptors()TUnixSystem; CheckedHash()TObjectinline; CheckSignals(Bool_t sync)TUnixSystem; Chmod(const char *file, UInt_t mode) overrideTUnixSystemvirtual; Class()TUnixSystemstatic; Class_Name()TUnixSystemstatic; Class_Version()TUnixSysteminlinestatic; ClassName() constTObjectvirtual; CleanCompiledMacros()TSystemvirtual; Clear(Option_t *option="""") overrideTNamedvirtual; Clone(const char *newname="""") const overrideTNamedvirtual;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem-members.html:364,Access,AccessPathName,364,doc/master/classTUnixSystem-members.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem-members.html,1,['Access'],['AccessPathName']
Security," Abort(int code=0)TSystemvirtual; AbstractMethod(const char *method) constTObject; AcceptConnection(int sock)TSystemvirtual; AccessPathName(const char *path, EAccessMode mode=kFileExists)TSystemvirtual; AddDynamicPath(const char *pathname)TSystemvirtual; AddFileHandler(TFileHandler *fh)TSystemvirtual; AddIncludePath(const char *includePath)TSystemvirtual; AddLinkedLibs(const char *linkedLib)TSystemvirtual; AddSignalHandler(TSignalHandler *sh)TSystemvirtual; AddStdExceptionHandler(TStdExceptionHandler *eh)TSystemvirtual; AddTimer(TTimer *t)TSystemvirtual; AddToTObjectTable(TObject *)TObjectprivatestatic; AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1)TSystemvirtual; AnnounceUdpService(int port, int backlog)TSystemvirtual; AnnounceUnixService(int port, int backlog)TSystemvirtual; AnnounceUnixService(const char *sockpath, int backlog)TSystemvirtual; AppendPad(Option_t *option="""")TObjectvirtual; BaseName(const char *pathname)TSystemvirtual; Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)TSystem; Browse(TBrowser *b)TObjectvirtual; cd(const char *path)TSysteminline; ChangeDirectory(const char *path)TSystemvirtual; CheckedHash()TObjectinline; Chmod(const char *file, UInt_t mode)TSystemvirtual; Class()TSystemstatic; Class_Name()TSystemstatic; Class_Version()TSysteminlinestatic; ClassName() constTObjectvirtual; CleanCompiledMacros()TSystemvirtual; Clear(Option_t *option="""") overrideTNamedvirtual; Clone(const char *newname="""") const overrideTNamedvirtual; CloseConnection(int sock, Bool_t force=kFALSE)TSystemvirtual; Closelog()TSystemvirtual; ClosePipe(FILE *pipe)TSystemvirtual; Compare(const TObject *obj) const overrideTNamedvirtual; CompileMacro(const char *filename, Option_t *opt="""", const char *library_name="""", const char *bui",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem-members.html:330,Access,AccessPathName,330,doc/master/classTSystem-members.html,https://root.cern,https://root.cern/doc/master/classTSystem-members.html,1,['Access'],['AccessPathName']
Security," About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses Introductory Tutorials. Overview; The goal of this tutorial session is to learn how to read a tree from a ROOT file, extract some data from it, display a histogram and then fit it.;  ; Information about the ROOT classes can be found on the ROOT reference guide, and there is also a web based documentation and the Root primer and other manuals available to download.; . Meet a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/introductory-tutorials-1.html:2311,Access,Accessing,2311,d/introductory-tutorials-1.html,https://root.cern,https://root.cern/d/introductory-tutorials-1.html,6,"['Access', 'access']","['Accessing', 'access']"
Security," AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; . The picture illustrates the access of the tree and its friends with a Draw command. When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries a warning is given and the missing entries are not included in the histogram. To retrieve the list of friends from a tree use TTree::GetListOfFriends. When the tree is written to file (TTree::Write), the friends list is saved with it. And when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements of the friend list are also deleted. It is possible to declare a friend tree that has the same internal structure (same branches and leaves) as the original tree, and compare the same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.var""). Reimplem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:72337,access,access,72337,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['access'],['access']
Security," AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend’s variables were in the original tree. To specify which tree to use in the Draw method, use the syntax:; <treeName>.<branchname>.<varname>; If the variablename is enough to identify uniquely the variable, you can leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable “var” in the TTree tree versus variable v1 inTTree ft1versus variablev2in **TTree**ft2`.; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; The picture illustrates the access of the tree and its friends with a Draw command.; When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) header is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries, a warning is given and the missing entries are not included in the histogram.; Use TTree::GetListOfFriends to retrieve the list of friends from a tree.; When the tree is written to file (TTree::Write), the friends list is saved with it. Moreover, when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements of the friend list are also deleted. It is possible to declare a friend tree that has the same internal structure (same branches and leaves) as the original tree, and compare the same values by specifying the tree.; tree.Draw(""var:ft1.va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:571263,access,access,571263,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security," Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given an histogram h, one can retrieve an associated function; with: TF1 *myfunc = h->GetFunction(""myfunc"");. Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit which is return by an; automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; Int_t fitStatus = h->Fit(myFunc). If the option ""S"" is instead used, TFitResultPtr contains the TFitResult and behaves as a smart; pointer to it. For example one can do:; TFitResultPtr r = h->Fit(myFunc,""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; independently if the fit option ""S"" is used or not:; TFitResultPtr r = h->Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:82262,access,access,82262,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,3,['access'],['access']
Security," Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given an histogram h, one can retrieve an associated function; with: TF1 *myfunc = h->GetFunction(""myfunc"");. Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit which is return by an; automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; Int_t fitStatus = h->Fit(myFunc). If the option ""S"" is instead used, TFitResultPtr contains the TFitResult and behaves as a smart; pointer to it. For example one can do:; TFitResultPtr r = h->Fit(myFunc,""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; independently if the fit option ""S"" is used or not:; TFitResultPtr r = h=>Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:78992,access,access,78992,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,1,['access'],['access']
Security," Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given an histogram h, one can retrieve an associated function; with: TF1 *myfunc = h->GetFunction(""myfunc"");. Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit which is return by an; automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; Int_t fitStatus = h->Fit(myFunc). If the option ""S"" is instead used, TFitResultPtr contains the TFitResult and behaves as a smart; pointer to it. For example one can do:; TFitResultPtr r = h->Fit(myFunc,""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; indipendently if the fit option ""S"" is used or not:; TFitResultPtr r = h=>Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:77258,access,access,77258,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,2,['access'],['access']
Security," Atom_t, Int_t, Int_t); virtual Bool_tTGTextEntry::HandleDoubleClick(Event_t* event); virtual Bool_tTGFrame::HandleDragDrop(TGFrame*, Int_t, Int_t, TGLayoutHints*); virtual Bool_tTGFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tHandleFocusChange(Event_t* event); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tHandleKey(Event_t* event); virtual Bool_tTGTextEntry::HandleMotion(Event_t* event); virtual Bool_tTGTextEntry::HandleSelection(Event_t* event); virtual Bool_tTGTextEntry::HandleSelectionClear(Event_t* event); virtual Bool_tTGTextEntry::HandleSelectionRequest(Event_t* event); virtual Bool_tTGTextEntry::HandleTimer(TTimer* t); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; Bool_tTGWidget::HasFocus() const; virtual ULong_tTGObject::Hash() const; Bool_tTGTextEntry::HasMarkedText() const; Bool_tTGTextEntry::HasOwnFont() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidTGTextEntry::Home(Bool_t mark = kFALSE); virtual voidTGWindow::IconifyWindow(); virtual voidIncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGTextEntry::Insert(const char*); virtual voidTGTextEntry::InsertText(const char* text, Int_t pos); virtual voidTGFrame::Inspect() const; virtual voidInvalidInput(const char* instr)SIGNAL ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; virtual Bool_tTGFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntryField.html:12845,Hash,Hash,12845,root/html528/TGNumberEntryField.html,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html,6,['Hash'],['Hash']
Security," Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGFrame::HandleDragDrop(TGFrame*, Int_t, Int_t, TGLayoutHints*); virtual Bool_tTGFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGFrame::HandleKey(Event_t*); virtual Bool_tHandleMotion(Event_t* event); virtual Bool_tTGFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGScrollBar::HandleTimer(TTimer* t); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; Bool_tTGWidget::HasFocus() const; virtual ULong_tTGObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTGScrollBar::IsAccelerated() const; virtual Bool_tTGFrame::IsActive() const; virtual Bool_tTGFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGWindow::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHScrollBar.html:9055,Hash,Hash,9055,root/html528/TGHScrollBar.html,https://root.cern,https://root.cern/root/html528/TGHScrollBar.html,12,['Hash'],['Hash']
Security," Bool_t &touched, Bool_t &disappeared);  Check stage status of the file described by ""fileInfo"". ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TString CreateUri (const char *dsGroup=0, const char *dsUser=0, const char *dsName=0, const char *dsTree=0);  Creates URI for the dataset manger in the form '[[/dsGroup/]dsUser/]dsName[#dsObjPath]', The optional dsObjPath can be in the form [subdir/]objname]'. ;  ; static const char * DeclFileName ();  ; static Int_t FillMetaData (TFileInfo *fi, TDirectory *d, const char *rdir=""/"");  Navigate the directory 'd' (and its subdirectories) looking for TTree objects. ;  ; static TList * GetDataSetSrvMaps ();  Static getter for server mapping list. ;  ; static TList * ParseDataSetSrvMaps (const TString &srvmaps);  Create a server mapping list from the content of 'srvmaps' Return the list (owned by the caller) or 0 if no valid info could be found) ;  ; static void ProcessFile (TFileInfo *fileInfo, Int_t sopt, Bool_t checkstg, Bool_t doall, TFileStager *stager, Bool_t createStager, const char *stageopts, Bool_t dbg, Bool_t &changed, Bool_t &opened);  Locate, stage, or fully validate file ""fileInfo"". ;  ; static Int_t ScanDataSet (TFileCollection *dataset, Int_t fopt, Int_t sopt=0, Int_t ropt=0, Bool_t dbg=kFALSE, Int_t *touched=0, Int_t *opened=0, Int_t *disappeared=0, TList *flist=0, Long64_t avgsz=-1, const char *mss=0, Int_t maxfiles=-1, const char *stageopts=0);  Go through the files in the specified dataset, selecting files according to 'fopt' and doing on these files the actions described by 'sopt'. ;  ; static Int_t ScanFile (TFileInfo *fileinfo, Bool_t notify);  Open the file described by 'fileinfo' to extract the relevant meta-information. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:14269,validat,validate,14269,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,2,['validat'],['validate']
Security," Bool_t TFile::fgOnlyStaged = kFALSE. staticprotected . Before the file is opened, it is checked, that the file is staged, if not, the open fails. ; Definition at line 128 of file TFile.h. ◆ fgOpenTimeout. UInt_t TFile::fgOpenTimeout = TFile::kEternalTimeout. staticprotected . Timeout for open operations in ms - 0 corresponds to blocking i/o. ; Definition at line 127 of file TFile.h. ◆ fgReadaheadSize. Int_t TFile::fgReadaheadSize = 256000. staticprotected . Readahead buffer size. ; Definition at line 134 of file TFile.h. ◆ fgReadCalls. std::atomic< Int_t > TFile::fgReadCalls {0}. staticprotected . Number of bytes read from all TFile objects. ; Definition at line 133 of file TFile.h. ◆ fgReadInfo. Bool_t TFile::fgReadInfo = kTRUE. staticprotected . if true (default) ReadStreamerInfo is called when opening a file ; Definition at line 135 of file TFile.h. ◆ fgTsSIHashes. ROOT::Internal::RConcurrentHashColl TFile::fgTsSIHashes. staticprotected . !TS Set of hashes built from read streamer infos ; Definition at line 120 of file TFile.h. ◆ fInfoCache. TList* TFile::fInfoCache {nullptr}. protected . !Cached list of the streamer infos in this file ; Definition at line 112 of file TFile.h. ◆ fInitDone. Bool_t TFile::fInitDone {kFALSE}. protected . !True if the file has been initialized ; Definition at line 105 of file TFile.h. ◆ fIsArchive. Bool_t TFile::fIsArchive {kFALSE}. protected . !True if this is a pure archive file ; Definition at line 102 of file TFile.h. ◆ fIsPcmFile. Bool_t TFile::fIsPcmFile {kFALSE}. protected . !True if the file is a ROOT pcm file. ; Definition at line 107 of file TFile.h. ◆ fIsRootFile. Bool_t TFile::fIsRootFile {kTRUE}. protected . !True is this is a ROOT file, raw file otherwise ; Definition at line 104 of file TFile.h. ◆ fMustFlush. Bool_t TFile::fMustFlush {kTRUE}. protected . !True if the file buffers must be flushed ; Definition at line 106 of file TFile.h. ◆ fNbytesFree. Int_t TFile::fNbytesFree {0}. protected . Number of bytes for free s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:107385,hash,hashes,107385,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['hash'],['hashes']
Security," Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Default constructor. RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); Constructor. The set trackSet contains the observables to be; tracked for changes. If checkValues is true an additional; validation step is activated where the numeric values of the; tracked arguments are compared with reference values ensuring; that values have actually changed. RooChangeTracker(const RooChangeTracker& other, const char* name = 0); Copy constructor. Bool_t hasChanged(Bool_t clearState); Returns true if state has changes since last call with clearState=kTRUE; If clearState is true, changeState flag will be cleared. ~RooChangeTracker(); Destructor. RooArgSet parameters() const. TObject* clone(const char* newname) const; { return new RooChangeTracker(*this, newname); }. Double_t evaluate() const; { return 1 ; }. » Last changed: Tue Jun 30 14:32:01 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChangeTracker.html:38277,validat,validation,38277,root/html602/RooChangeTracker.html,https://root.cern,https://root.cern/root/html602/RooChangeTracker.html,1,['validat'],['validation']
Security," Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooCategoryProxy_catAccept/reject categort; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effFuncEfficiency modeling function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEfficiency.html:40391,access,access,40391,root/html534/RooEfficiency.html,https://root.cern,https://root.cern/root/html534/RooEfficiency.html,1,['access'],['access']
Security," Bool_tTString::Contains(const char* pat, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TString& pat, TString::ECaseCompare cmp = kExact) const; TStringTString::Copy() const; Int_tTString::CountChar(Int_t c) const; const char*TString::Data() const; Bool_tTString::EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Bool_tTString::EqualTo(const char* cs, TString::ECaseCompare cmp = kExact) const; Bool_tTString::EqualTo(const TString& st, TString::ECaseCompare cmp = kExact) const; virtual voidFillBuffer(char*& buffer) const; Ssiz_tTString::First(char c) const; Ssiz_tTString::First(const char* cs) const; voidTString::Form(const char* fmt); static TStringTString::Format(const char* fmt); static Ssiz_tTString::GetInitialCapacity(); static Ssiz_tTString::GetMaxWaste(); static Ssiz_tTString::GetResizeIncrement(); Bool_tTString::Gets(FILE* fp, Bool_t chop = kTRUE); UInt_tTString::Hash(TString::ECaseCompare cmp = kExact) const; static UInt_tTString::Hash(const void* txt, Int_t ntxt); Ssiz_tTString::Index(const TRegexp& pat, Ssiz_t i = 0) const; Ssiz_tTString::Index(TPRegexp& pat, Ssiz_t i = 0) const; Ssiz_tTString::Index(const char* pat, Ssiz_t i = 0, TString::ECaseCompare cmp = kExact) const; Ssiz_tTString::Index(const TString& s, Ssiz_t i = 0, TString::ECaseCompare cmp = kExact) const; Ssiz_tTString::Index(const TRegexp& pat, Ssiz_t* ext, Ssiz_t i = 0) const; Ssiz_tTString::Index(TPRegexp& pat, Ssiz_t* ext, Ssiz_t i = 0) const; Ssiz_tTString::Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Ssiz_tTString::Index(const TString& s, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; static Ssiz_tTString::InitialCapacity(Ssiz_t ic = 15); TString&TString::Insert(Ssiz_t pos, const char* s); TString&TString::Insert(Ssiz_t pos, const TString& s); TString&TString::Insert(Ssiz_t pos, const char* s, Ssiz_t extent); TString&TString::Insert(Ssiz_t pos, const TString& s, Ssiz_t extent); virtual TClass*IsA(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStringLong.html:2656,Hash,Hash,2656,root/html602/TStringLong.html,https://root.cern,https://root.cern/root/html602/TStringLong.html,2,['Hash'],['Hash']
Security," Bool_t IsLocked () const;  ; Int_t Lock ();  Locks the directory. ;  ; Int_t Unlock ();  Unlock the directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLockPath.html:1368,Hash,Hash,1368,doc/master/classTProofLockPath.html,https://root.cern,https://root.cern/doc/master/classTProofLockPath.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," Bool_t fWritable {kFALSE};  True if directory is writable. ;  ;  Protected Attributes inherited from TDirectory; TContext * fContext {nullptr};  Buffer for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TS3WebFile ();  ; Bool_t GetCredentialsFromEnv (const char *accessKeyEnv, const char *secretKeyEnv, const char *tokenEnv, TString &outAccessKey, TString &outSecretKey, TString &outToken);  Sets the access and secret keys from the environmental variables, if they are both set. ;  ; Bool_t ParseOptions (Option_t *options, TString &accessKey, TString &secretKey, TString &token);  Extracts the S3 authentication key pair (access key and secret key) from the options. ;  . Additional Inherited Members;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:42961,access,accessKey,42961,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,3,"['access', 'authenticat']","['access', 'accessKey', 'authentication']"
Security," CEF or Chromium) ; Definition at line 269 of file RWebWindow.hxx. ◆ SetRequireAuthKey(). void ROOT::RWebWindow::SetRequireAuthKey ; (; bool ; on). inline . Configure if authentication key in connection string is required. ; Definition at line 316 of file RWebWindow.hxx. ◆ SetStartDialogFunc(). void RWebWindow::SetStartDialogFunc ; (; std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> ; func). staticprivate . Configure func which has to be used for starting dialog. ; Definition at line 1953 of file RWebWindow.cxx. ◆ SetUseCurrentDir(). void ROOT::RWebWindow::SetUseCurrentDir ; (; bool ; on = true). inline . Configure if window can access local files via currentdir/ path of http server. ; Definition at line 324 of file RWebWindow.hxx. ◆ SetUserArgs(). void RWebWindow::SetUserArgs ; (; const std::string & ; args). Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ; Parameters. args- arbitrary JSON data which can be provided to client side . Definition at line 1310 of file RWebWindow.cxx. ◆ Show(). unsigned RWebWindow::Show ; (; const RWebDisplayArgs & ; args = """"). Show window in specified location. ; See alsoROOT::RWebWindowsManager::Show for more info ; Returns(future) connection id (or 0 when fails) ; Definition at line 191 of file RWebWindow.cxx. ◆ ShowWindow(). unsigned RWebWindow::ShowWindow ; (; std::shared_ptr< RWebWindow > ; window, . const RWebDisplayArgs & ; args = """" . ). static . Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ; Definition at line 1915 of file RWebWindow.cxx. ◆ StartThread(). void RWebWindow::StartThread ; (; ). Start special thread which will be used by the window to handle all callbacks One ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:48424,inject,injected,48424,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['inject'],['injected']
Security," CEF or Chromium) ; Definition at line 272 of file RWebWindow.hxx. ◆ SetRequireAuthKey(). void ROOT::RWebWindow::SetRequireAuthKey ; (; bool ; on). inline . Configure if authentication key in connection string is required. ; Definition at line 319 of file RWebWindow.hxx. ◆ SetStartDialogFunc(). void RWebWindow::SetStartDialogFunc ; (; std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> ; func). staticprivate . Configure func which has to be used for starting dialog. ; Definition at line 1995 of file RWebWindow.cxx. ◆ SetUseCurrentDir(). void ROOT::RWebWindow::SetUseCurrentDir ; (; bool ; on = true). inline . Configure if window can access local files via currentdir/ path of http server. ; Definition at line 327 of file RWebWindow.hxx. ◆ SetUserArgs(). void RWebWindow::SetUserArgs ; (; const std::string & ; args). Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ; Parameters. args- arbitrary JSON data which can be provided to client side . Definition at line 1352 of file RWebWindow.cxx. ◆ Show(). unsigned RWebWindow::Show ; (; const RWebDisplayArgs & ; args = """"). Show window in specified location. ; See alsoROOT::RWebWindowsManager::Show for more info ; Returns(future) connection id (or 0 when fails) ; Definition at line 191 of file RWebWindow.cxx. ◆ ShowWindow(). unsigned RWebWindow::ShowWindow ; (; std::shared_ptr< RWebWindow > ; window, . const RWebDisplayArgs & ; args = """" . ). static . Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ; Definition at line 1957 of file RWebWindow.cxx. ◆ StartThread(). void RWebWindow::StartThread ; (; ). Start special thread which will be used by the window to handle all callbacks One ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:47308,inject,injected,47308,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['inject'],['injected']
Security," CERN/SFT,; Jonas Hahnfeld, CERN/SFT,; Emmanouil Michalainas, CERN/SFT,; Stephan Hageboeck, CERN/SFT,; Sergey Linev, GSI,; Javier Lopez-Gomez, CERN/SFT,; Pere Mato, CERN/SFT,; Lorenzo Moneta, CERN/SFT,; Alja Mrak-Tadel, UCSD/CMS,; Axel Naumann, CERN/SFT,; Vincenzo Eduardo Padulano, CERN/SFT and UPV,; Danilo Piparo, CERN/SFT,; Fons Rademakers, CERN/SFT,; Jonas Rembser, CERN/SFT,; Andrea Sciandra, SCIPP-UCSC/Atlas,; Oksana Shadura, UNL/CMS,; Enric Tejedor Saavedra, CERN/SFT,; Christian Tacke, GSI,; Matevz Tadel, UCSD/CMS,; Vassil Vassilev, Princeton/CMS,; Wouter Verkerke, NIKHEF/Atlas,; Stefan Wunsch, CERN/SFT; General; Deprecation and Removal. RooAbsReal::evaluateBatch() has been removed in favour of the faster evaluateSpan(). See section “RooFit Libraries” for instructions on how to use RooAbsReal::evaluateSpan().; TTreeProcessorMT::SetMaxTasksPerFilePerWorker has been deprecated in favour of TTreeProcessorMT::SetTasksPerWorkerHint. Header Dependency Reduction; As always, ROOT tries to reduce the amount of code exposed through its headers. To that end, #includes were replaced by forward declarations in several headers. This might cause compilation errors (“missing definition of type…”) in your code, if that code was relying on indirect includes, instead of including the required headers itself. Please correct that simply by including the required header directly.; Core Libraries; Due to internal changes required to comply with the deprecation of Intel TBB’s task_scheduler_init and related interfaces in recent TBB versions, as of v6.24 ROOT will not honor a maximum concurrency level set with tbb::task_scheduler_init but will require instead the usage of tbb::global_control:; //tbb::task_scheduler_init init(2); // does not affect the number of threads ROOT will use anymore. tbb::global_control c(tbb::global_control::max_allowed_parallelism, 2);; ROOT::TThreadExecutor p1; // will use 2 threads; ROOT::TThreadExecutor p2(/*nThreads=*/8); // will still use 2 threads; Note ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:2963,expose,exposed,2963,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['expose'],['exposed']
Security," CI used will be the color number in colors[N],etc. If the maximum cell content is > ncolors, all cell contents are scaled to ncolors.; if ncolors <= 0 a default palette (see below) of 50 colors is defined. The colors defined in this palette are OK for coloring pads, labels.; index 0->9 : grey colors from light to dark grey; index 10->19 : ""brown"" colors; index 20->29 : ""blueish"" colors; index 30->39 : ""redish"" colors; index 40->49 : basic colors; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; if ncolors == 1 && colors == 0, a Rainbow Color map is created with 50 colors. It is kept for backward compatibility. Better palettes like kBird are recommended.; High quality predefined palettes with 255 colors are available when colors == 0. The following value of ncolors give access to:; if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a Two-Color Hue palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an Inverted Dark Body Radiator palette is used.; if ncolors = 57 and colors=0, a monotonically increasing L value palette is used.; if ncolors = 58 and colors=0, a Cubehelix palette is used; (Cf. Dave Green's ""cubehelix"" colour scheme at http://www.mrao.cam.ac.uk/~dag/CUBEHELIX/); if ncolors = 59 and colors=0, a Green Red Violet palette is used.; if ncolors = 60 and colors=0, a Blue Red Yellow palette is used.; if ncolors = 61 and colors=0, an Ocean palette is used.; if ncolors = 62 and colors=0, a Color Printable On Grey palette is used.; if ncolors = 63 and colors=0, an Alpine palette is used.; if ncolor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:68170,access,access,68170,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['access'],['access']
Security," Consume the character; 3641 liblist.get();; 3642 break;; 3643 }; 3644 }; 3645 ; 3646// depLibraries = all_libtoload;; 3647// depLibraries.ReplaceAll("" lib"","" -l"");; 3648// depLibraries.ReplaceAll(TString::Format("".%s"",fSoExt.Data()),"""");; 3649 }; 3650 ; 3651 // ======= Calculate the libraries for linking:; 3652 TString linkLibraries;; 3653 /*; 3654 this is intentionally disabled until it can become useful; 3655 if (gEnv) {; 3656 linkLibraries = gEnv->GetValue(""ACLiC.Libraries"","""");; 3657 linkLibraries.Prepend("" "");; 3658 }; 3659 */; 3660 TString linkLibrariesNoQuotes(GetLibraries("""",""SDL""));; 3661 // We need to enclose the single paths in quotes to account for paths with spaces; 3662 TString librariesWithQuotes;; 3663 TString singleLibrary;; 3664 Bool_t collectingSingleLibraryNameTokens = kFALSE;; 3665 std::unique_ptr<TObjArray> tokens( linkLibrariesNoQuotes.Tokenize("" "") );; 3666 for (auto tokenObj : *tokens) {; 3667 singleLibrary = ((TObjString*)tokenObj)->GetString();; 3668 if (singleLibrary[0]=='-' || !AccessPathName(singleLibrary)) {; 3669 if (collectingSingleLibraryNameTokens) {; 3670 librariesWithQuotes.Chop();; 3671 librariesWithQuotes += ""\"" \"""" + singleLibrary + ""\"""";; 3672 collectingSingleLibraryNameTokens = kFALSE;; 3673 } else {; 3674 librariesWithQuotes += "" \"""" + singleLibrary + ""\"""";; 3675 }; 3676 } else {; 3677 if (collectingSingleLibraryNameTokens) {; 3678 librariesWithQuotes += singleLibrary + "" "";; 3679 } else {; 3680 collectingSingleLibraryNameTokens = kTRUE;; 3681 librariesWithQuotes += "" \"""" + singleLibrary + "" "";; 3682 }; 3683 }; 3684 }; 3685 ; 3686#ifdef _MSC_VER; 3687 linkLibraries.Prepend(linkLibrariesNoQuotes);; 3688#else; 3689 linkLibraries.Prepend(librariesWithQuotes);; 3690#endif; 3691 ; 3692 // ======= Generate the build command lines; 3693 TString cmd = fMakeSharedLib;; 3694 // we do not add filename because it is already included via the dictionary(in dicth) !; 3695 // dict.Append("" "").Append(filename);; 3696 cmd.ReplaceAll(""$Source",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:124107,Access,AccessPathName,124107,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['Access'],['AccessPathName']
Security," D2, class R > . T ROOT::Math::SMatrix< T, D1, D2, R >::apply ; (; unsigned int ; i); const. inline . access the parse tree with the index starting from zero and following the C convention for the order in accessing the matrix elements. ; Same convention for general and symmetric matrices. ; Definition at line 627 of file SMatrix.icc. ◆ Array() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . T * ROOT::Math::SMatrix< T, D1, D2, R >::Array. inline . return pointer to internal array ; Definition at line 633 of file SMatrix.icc. ◆ Array() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . const T * ROOT::Math::SMatrix< T, D1, D2, R >::Array. inline . return read-only pointer to internal array ; Definition at line 630 of file SMatrix.icc. ◆ At() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . T & ROOT::Math::SMatrix< T, D1, D2, R >::At ; (; unsigned int ; i, . unsigned int ; j . ). inline . read/write access to matrix element with indices starting from 0. ; Function will check index values and it will assert if they are wrong ; Definition at line 660 of file SMatrix.icc. ◆ At() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . const T & ROOT::Math::SMatrix< T, D1, D2, R >::At ; (; unsigned int ; i, . unsigned int ; j . ); const. inline . read only access to matrix element, with indices starting from 0. ; Function will check index values and it will assert if they are wrong ; Definition at line 653 of file SMatrix.icc. ◆ begin() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . T * ROOT::Math::SMatrix< T, D1, D2, R >::begin. inline . STL iterator interface. ; Definition at line 670 of file SMatrix.icc. ◆ begin() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . const T * ROOT::Math::SMatrix< T, D1, D2, R >::begin. inline . STL const_iterator interface. ; Definition at line 680 of file SMatrix.icc. ◆ Col(). template<class T , unsigned int D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:18996,access,access,18996,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['access'],['access']
Security," Data Members; private:. ROOT::Math::PtEtaPhiE4D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const Scalar[] src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(Scalar[] dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar zz, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:11216,access,access,11216,root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,2,['access'],['access']
Security," Data Members; private:. ROOT::Math::PtEtaPhiM4D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const Scalar[] src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(Scalar[] dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar zz, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:11216,access,access,11216,root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,2,['access'],['access']
Security," Define calls. It must; 819 /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; 820 /// \param[in] inputColumns the names of the columns to be passed to the callable.; 821 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 822 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 823 ///; 824 /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; 825 /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; 826 /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; 827 /// ROOT::RDF::Experimental::VariationsFor (see the example below).; 828 ///; 829 /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; 830 /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; 831 /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; 832 /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; 833 ///; 834 /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; 835 /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; 836 /// ~~~{.cpp}; 837 /// auto nominal_hx =; 838 /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); 839 /// .Filter(""pt > k""); 840 /// .Define(""x"", someFunc, {""pt""}); 841 /// .Histo1D(""x"");; 842 ///; 843 /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 844 /// hx[""nominal""].Draw();; 845 /// hx[""pt:down""].Draw(""SAME"");; 846 /// hx[""pt:up""].Draw(""SAME"");; 847 /// ~~~; 848 /// RDataFrame computes all variations as part of a single l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:44511,access,accessed,44511,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['access'],['accessed']
Security," Define the input variables used for the MVA training; dataloader->AddVariable( ""var1"", 'F' );; dataloader->AddVariable( ""var2"", 'F' );; dataloader->AddVariable( ""var3"", 'F' );; dataloader->AddVariable( ""var4"", 'F' );; ; // You can add so-called ""Spectator variables"", which are not used in the MVA training,; // but will appear in the final ""TestTree"" produced by TMVA. This TestTree will contain the; // input variables, the response values of all trained MVAs, and the spectator variables; dataloader->AddSpectator( ""eta"" );; ; // Load the signal and background event samples from ROOT trees; TFile *input(0);; TString fname = gSystem->GetDirName(__FILE__) + ""/data/"";; if (gSystem->AccessPathName( fname + ""toy_sigbkg_categ_offset.root"")) {; // if directory data not found try using tutorials dir; fname = gROOT->GetTutorialDir() + ""/tmva/data/"";; }; if (UseOffsetMethod) fname += ""toy_sigbkg_categ_offset.root"";; else fname += ""toy_sigbkg_categ_varoff.root"";; if (!gSystem->AccessPathName( fname )) {; // first we try to find tmva_example.root in the local directory; std::cout << ""--- TMVAClassificationCategory: Accessing "" << fname << std::endl;; input = TFile::Open( fname );; }; ; if (!input) {; std::cout << ""ERROR: could not open data file: "" << fname << std::endl;; exit(1);; }; ; TTree *signalTree = (TTree*)input->Get(""TreeS"");; TTree *background = (TTree*)input->Get(""TreeB"");; ; // Global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; dataloader->AddSignalTree ( signalTree, signalWeight );; dataloader->AddBackgroundTree( background, backgroundWeight );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the tra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:30105,Access,AccessPathName,30105,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['Access'],['AccessPathName']
Security," Definition at line 189 of file THashList.cxx. ◆ DeclFileName(). static const char * THashList::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 72 of file THashList.h. ◆ Delete(). void THashList::Delete ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the list AND delete all heap based objects. ; If option=""slow"" then keep list consistent during delete. This allows recursive list operations during the delete (e.g. during the dtor of an object in this list one can still access the list to search for other not yet deleted objects). ; Implements TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 207 of file THashList.cxx. ◆ FindObject() [1/2]. TObject * THashList::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from TCollection.; Reimplemented in TListOfEnums, TListOfDataMembers, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TListOfFunctionTemplates.; Definition at line 262 of file THashList.cxx. ◆ FindObject() [2/2]. TObject * THashList::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 272 of file THashList.cxx. ◆ GetListForObject() [1/2]. const TList * THashList::GetListForObject ; (; const char * ; name); const. Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ; Definition at line 283 of file THashList.cxx. ◆ GetListForObject() [2/2]. const TList * T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:29531,hash,hash,29531,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," Double_t &xmax, Double_t &ymax, Double_t &zmax) constTF1virtual; GetSave(const Double_t *x)TF1virtual; GetTitle() const overrideTNamedinlinevirtual; GetUniqueID() constTObjectvirtual; GetVariable(const TString &name)TF1inlinevirtual; GetX(Double_t y, Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetXaxis() constTF1; GetXmax() constTF1inlinevirtual; GetXmin() constTF1inlinevirtual; GetYaxis() constTF1; GetZaxis() constTF1; GradientPar(Int_t ipar, const Double_t *x, Double_t eps=0.01)TF1virtual; GradientPar(Int_t ipar, const T *x, Double_t eps=0.01)TF1inline; GradientPar(const Double_t *x, Double_t *grad, Double_t eps=0.01)TF1virtual; GradientPar(const T *x, T *grad, Double_t eps=0.01)TF1inline; GradientParTempl(Int_t ipar, const T *x, Double_t eps=0.01)TF1inline; GradientParTempl(const T *x, T *grad, Double_t eps=0.01)TF1inline; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; HasSave() constTF1inline; Info(const char *method, const char *msgfmt,...) constTObjectvirtual; InheritsFrom(const char *classname) constTObjectvirtual; InheritsFrom(const TClass *cl) constTObjectvirtual; InitArgs(const Double_t *x, const Double_t *params)TF1virtual; InitStandardFunctions()TF1static; Inspect() constTObjectvirtual; Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)TF1virtual; IntegralError(Double_t a, Double_t b, const Double_t *params=nullptr, const Double_t *covmat=nullptr, Double_t epsilon=1.E-2)TF1virtual; IntegralError(Int_t n, const Double_t *a, const Double_t *b, const Double_t *params=nullptr, const Double_t *covmat=nullptr, Double_t epsilon=1.E-2)TF1virtual; IntegralFast(Int_t num, Double_t *x, Double_t *w, Double_t a, Double_t b, Double_t *params=nullptr, Double_t epsilon=1e-12)TF1virtual; IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1-members.html:8709,Hash,Hash,8709,doc/master/classTF1-members.html,https://root.cern,https://root.cern/doc/master/classTF1-members.html,1,['Hash'],['Hash']
Security," Double_t ApplyKernelFunction(Double_t normalized_distance); from the normalized euclidean distance calculate the distance; for a certain kernel. Double_t KernelNormalization(Double_t pdf); Calculating the normalization factor only once (might need a reset at some point.; Can the method be restarted with different params?). Double_t GetNormalizedDistance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodPDERS.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:24572,access,accessors,24572,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,1,['access'],['accessors']
Security," Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations);  Find zero of a continuous function. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCurve.html:18976,Hash,Hash,18976,doc/master/classRooCurve.html,https://root.cern,https://root.cern/doc/master/classRooCurve.html,22,"['Hash', 'hash']","['Hash', 'hash']"
Security," Double_t step, Int_t ndivisions);  Set division range. Use this method only when dividing an assembly. ;  ; void SetSpacedOut (Bool_t flag);  ; void SetVolume (TGeoVolume *vol);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateMatrix (Int_t, TGeoHMatrix &) const;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPatternFinder.html:3845,Hash,Hash,3845,doc/master/classTGeoPatternFinder.html,https://root.cern,https://root.cern/doc/master/classTGeoPatternFinder.html,2,['Hash'],['Hash']
Security," Double_t& dz) const; virtual const char*TObject::GetIconName() const; Int_tTGeoShape::GetId() const; virtual TGeoShape*GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; virtual voidGetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; virtual const char*TGeoShape::GetName() const; virtual Int_tGetNmeshVertices() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Double_t*TGeoBBox::GetOrigin() const; const char*TGeoShape::GetPointerName() const; virtual Bool_tTGeoBBox::GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; virtual Bool_tGetPointsOnSegments(Int_t, Double_t*) const; Double_tGetRhi() const; Double_tGetRlo() const; virtual const char*TNamed::GetTitle() const; static TGeoMatrix*TGeoShape::GetTransform(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual voidInspectShape() const; voidTObject::InvertBit(UInt_t f); voidTGeoShape::InvertShapeBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGeoShape::IsAssembly() const; static Bool_tTGeoShape::IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTGeoShape::IsComposite() const; static Bool_tTGeoShape::IsCrossingSemiplane(Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); virtual Bool_tIsCylType() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; static Bool_tTGeoShape::IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); virtual Bool_tTGeoBBox::IsNullBox() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoParaboloid.html:5369,Hash,Hash,5369,root/html528/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html528/TGeoParaboloid.html,3,['Hash'],['Hash']
Security," Double_t& dz) const; virtual const char*TObject::GetIconName() const; Int_tTGeoShape::GetId() const; virtual TGeoShape*GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; virtual voidGetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; virtual const char*TGeoShape::GetName() const; virtual Int_tGetNmeshVertices() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const Double_t*TGeoBBox::GetOrigin() const; const char*TGeoShape::GetPointerName() const; virtual Bool_tTGeoBBox::GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; virtual Bool_tGetPointsOnSegments(Int_t, Double_t*) const; Double_tGetRhi() const; Double_tGetRlo() const; virtual const char*TNamed::GetTitle() const; static TGeoMatrix*TGeoShape::GetTransform(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual voidInspectShape() const; voidTObject::InvertBit(UInt_t f); voidTGeoShape::InvertShapeBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGeoShape::IsAssembly() const; static Bool_tTGeoShape::IsCloseToPhi(Double_t epsil, const Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTGeoShape::IsComposite() const; static Bool_tTGeoShape::IsCrossingSemiplane(const Double_t* point, const Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); virtual Bool_tIsCylType() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; static Bool_tTGeoShape::IsInPhiRange(const Double_t* point, Double_t phi1, Double_t phi2); virtual Bool_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:6135,Hash,Hash,6135,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,3,['Hash'],['Hash']
Security," Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tTF1::GetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual Double_tTF1::GetXmax() const; virtual Double_tTF1::GetXmin() const; virtual Double_tGetXY() const; TAxis*TF1::GetYaxis() const; TAxis*TF1::GetZaxis() const; virtual Double_tTF1::GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidTF1::GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTF1::InitArgs(const Double_t* x, const Double_t* params); static voidTF1::InitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tTF1::Integral(Double_t a, Double_t b, Double_t epsrel = 9.9999999999999998E-13); virtual Double_tTF1::IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 0.01); virtual Double_tTF1::IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 0.01); virtual Double_tTF1::IntegralFast(Int_t num, Double_t* x, Double_t* w, Double_t a, Double_t b, Double_t* params = 0, Double_t epsilon = 9.9999999999999998E-13); virtual Double_tTF1::IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsrel, Double_t& relerr); virtual Double_tTF1::IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t maxpts, Double_t epsrel, Double_t epsab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF12.html:7366,Hash,Hash,7366,root/html602/TF12.html,https://root.cern,https://root.cern/root/html602/TF12.html,1,['Hash'],['Hash']
Security," Double_t* probSum = 0); virtual Double_tTH1::GetRandom() const; virtual voidGetRandom3(Double_t& x, Double_t& y, Double_t& z); virtual Double_tTH1::GetRMS(Int_t axis = 1) const; virtual Double_tTH1::GetRMSError(Int_t axis = 1) const; virtual Double_tTH1::GetSkewness(Int_t axis = 1) const; virtual voidGetStats(Double_t* stats) const; virtual Double_tTH1::GetSumOfWeights() const; virtual TArrayD*TH1::GetSumw2(); virtual const TArrayD*TH1::GetSumw2() const; virtual Int_tTH1::GetSumw2N() const; virtual Float_tTH1::GetTickLength(Option_t* axis = ""X"") const; virtual const char*TNamed::GetTitle() const; virtual Style_tTH1::GetTitleFont(Option_t* axis = ""X"") const; virtual Float_tTH1::GetTitleOffset(Option_t* axis = ""X"") const; virtual Float_tTH1::GetTitleSize(Option_t* axis = ""X"") const; virtual UInt_tTObject::GetUniqueID() const; TAxis*TH1::GetXaxis() const; TAxis*TH1::GetYaxis() const; TAxis*TH1::GetZaxis() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Option_t* option = """") const; virtual Double_tIntegral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Option_t* option = """") const; virtual Double_tIntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t& err, Option_t* option = """") const; virtual Double_tInterpolate(Double_t x); virtual Double_tInterpolate(Double_t x, Double_t y); virtual Double_tInterpolate(Double_t x, Double_t y, Double_t z); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTH1::IsBinOverflow(Int_t bin) const; Bool_tTH1::IsBinUnderflow(Int_t bin) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH3.html:10805,Hash,Hash,10805,root/html528/TH3.html,https://root.cern,https://root.cern/root/html528/TH3.html,3,['Hash'],['Hash']
Security," Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual Double_tTF1::GetXmax() const; virtual Double_tTF1::GetXmin() const; TAxis*TF1::GetYaxis() const; virtual Double_tTF2::GetYmax() const; virtual Double_tTF2::GetYmin() const; TAxis*TF1::GetZaxis() const; virtual Double_tGetZmax() const; virtual Double_tGetZmin() const; virtual Double_tTF1::GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidTF1::GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTF1::InitArgs(const Double_t* x, const Double_t* params); static voidTF1::InitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 0.000001); virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 0.000001); virtual Double_tTF1::IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); virtual Double_tTF1::IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); virtual Double_tTF1::IntegralFast(Int_t num, Double_t* x, Double_t* w, Double_t a, Double_t b, Double_t* params = 0, Double_t epsilon = 1e-12); virtual Double_tTF1::Integra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TF3.html:9382,Hash,Hash,9382,root/html530/TF3.html,https://root.cern,https://root.cern/root/html530/TF3.html,3,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; const RooAbsReal&integrand() const; const char*intRange(); RooArgSetintVars() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:14580,Hash,Hash,14580,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:15423,Hash,Hash,15423,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,1,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tisDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConstVar.html:14718,Hash,Hash,14718,root/html532/RooConstVar.html,https://root.cern,https://root.cern/root/html532/RooConstVar.html,1,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:19049,Hash,Hash,19049,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,2,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tisBinnedDistribution(const RooArgSet& obs) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tisDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:20021,Hash,Hash,20021,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,1,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tintOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tisDirec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:21658,Hash,Hash,21658,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(Int_t); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProjectedPdf.html:18837,Hash,Hash,18837,root/html532/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html532/RooProjectedPdf.html,1,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static Bool_tRooAbsReal::hideOffset(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; const RooAbsReal&integrand() const; const char*intRange(); RooArgSetintVars() const; voidTObject::InvertBit(UInt_t f); virtual voidRooAbsArg::ioStreamerPass2(); static voidRooAbsArg::ioStreamerPass2Finalize(); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isClon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:15106,Hash,Hash,15106,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,3,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static Bool_tRooAbsReal::hideOffset(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual voidRooAbsArg::ioStreamerPass2(); static voidRooAbsArg::ioStreamerPass2Finalize(); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:15984,Hash,Hash,15984,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,6,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static Bool_tRooAbsReal::hideOffset(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual voidRooAbsArg::ioStreamerPass2(); static voidRooAbsArg::ioStreamerPass2Finalize(); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:19682,Hash,Hash,19682,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,6,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static Bool_tRooAbsReal::hideOffset(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual voidRooAbsArg::ioStreamerPass2(); static voidRooAbsArg::ioStreamerPass2Finalize(); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:22746,Hash,Hash,22746,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static Bool_tRooAbsReal::hideOffset(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual voidRooAbsArg::ioStreamerPass2(); static voidRooAbsArg::ioStreamerPass2Finalize(); virtual TClass*IsA() const; virtual Bool_tisBinnedDistribution(const RooArgSet& obs) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:20631,Hash,Hash,20631,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,3,['Hash'],['Hash']
Security," Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tgetValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static Bool_tRooAbsReal::hideOffset(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(Int_t); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual voidRooAbsArg::ioStreamerPass2(); static voidRooAbsArg::ioStreamerPass2Finalize(); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProjectedPdf.html:19466,Hash,Hash,19466,root/html534/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html534/RooProjectedPdf.html,3,['Hash'],['Hash']
Security," Double_t StepBound (TQpVar *b);  calculate the largest alpha in (0,1] such that the/ nonnegative variables stay nonnegative in the given search direction. ;  ; virtual Bool_t ValidNonZeroPattern ();  Check that the variables conform to the non-zero indices. ;  ; virtual Double_t Violation ();  The amount by which the current variables violate the non-negativity constraints. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQpVar.html:4528,Hash,Hash,4528,doc/master/classTQpVar.html,https://root.cern,https://root.cern/doc/master/classTQpVar.html,2,['Hash'],['Hash']
Security," DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:39504,access,access,39504,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['access'],['access']
Security," Dtor: delete (deActivate, local/remote cleanup, list removal) all what is still active. ; Definition at line 67 of file TRootSecContext.cxx. Member Function Documentation. ◆ AsString(). const char * TRootSecContext::AsString ; (; TString & ; out). overridevirtual . Returns short string with relevant information about this security context. ; Reimplemented from TSecContext.; Definition at line 247 of file TRootSecContext.cxx. ◆ Class(). static TClass * TRootSecContext::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TRootSecContext::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TRootSecContext::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 51 of file TRootSecContext.h. ◆ CleanupSecContext(). Bool_t TRootSecContext::CleanupSecContext ; (; Bool_t ; all). overrideprivatevirtual . Ask remote client to cleanup security context 'ctx' If 'all', all sec context with the same host as ctx are cleaned. ; Reimplemented from TSecContext.; Definition at line 113 of file TRootSecContext.cxx. ◆ DeActivate(). void TRootSecContext::DeActivate ; (; Option_t * ; opt = ""CR""). overridevirtual . Set OffSet to -1 and expiring Date to default Remove from the list If Opt contains ""C"" or ""c"", ask for remote cleanup If Opt contains ""R"" or ""r"", remove from the list Default Opt=""CR"". ; Reimplemented from TSecContext.; Definition at line 79 of file TRootSecContext.cxx. ◆ DeclFileName(). static const char * TRootSecContext::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 51 of file TRootSecContext.h. ◆ GetRSAKey(). Int_t TRootSecContext::GetRSAKey ; (; ); const. inline . Definition at line 47 of file TRootSecContext.h. ◆ IsA(). TClass * TRootSecContext::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSecContext.html:14918,secur,security,14918,doc/master/classTRootSecContext.html,https://root.cern,https://root.cern/doc/master/classTRootSecContext.html,1,['secur'],['security']
Security," EDefaultUnits GetDefaultUnits()Definition TGeoManager.cxx:4314; TGeoManager::RemoveMaterialvoid RemoveMaterial(Int_t index)Remove material at given index.Definition TGeoManager.cxx:3086; TGeoManager::Matrixvoid Matrix(Int_t index, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3)Create rotation matrix named 'mat<index>'.Definition TGeoManager.cxx:1276; TGeoManager::GetElementTableTGeoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::fNtracksInt_t fNtracksDefinition TGeoManager.h:74; TGeoManager::fHashPNETHashList * fHashPNEhash list of group volumes providing fast searchDefinition TGeoManager.h:138; TGeoManager::fgVerboseLevelstatic Int_t fgVerboseLevelLock preventing a second geometry to be loaded.Definition TGeoManager.h:51; TGeoManager::Initvoid Init()Initialize manager class.Definition TGeoManager.cxx:416; TGeoManager::InitArrayPNEBool_t InitArrayPNE() constInitialize PNE array for fast access via index and unique-id.Definition TGeoManager.cxx:4214; TGeoManager::fPhysicalNodesTObjArray * fPhysicalNodesDefinition TGeoManager.h:96; TGeoManager::SizeOfvirtual ULong_t SizeOf(const TGeoNode *node, Option_t *option)computes the total size in bytes of the branch starting with node.Definition TGeoManager.cxx:3926; TGeoManager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDefinition TGeoManager.h:109; TGeoManager::Nodevoid Node(const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *upar, Int_t npar=0)Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called ...Definition TGeoManager.cxx:1353; TGeoManager::fGShapesTObjArray * fGShapesDefinition TGeoManager.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:180791,access,access,180791,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['access'],['access']
Security," Executing multiple actions in the same event loop; 444As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of; 445the filtered events.; 446By now, you should be able to easily understand what is happening:; 447~~~{.cpp}; 448RDataFrame d(""treeName"", ""file.root"");; 449auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; 450auto h2 = d.Histo1D(""pt_v"");; 451h1->Draw(); // event loop is run once here; 452h2->Draw(""SAME""); // no need to run the event loop again; 453~~~; 454RDataFrame executes all above actions by **running the event-loop only once**. The trick is that actions are not; 455executed at the moment they are called, but they are **lazy**, i.e. delayed until the moment one of their results is; 456accessed through the smart pointer. At that time, the event loop is triggered and *all* results are produced; 457simultaneously.; 458 ; 459It is therefore good practice to declare all your transformations and actions *before* accessing their results, allowing; 460RDataFrame to run the loop once and produce all results in one go.; 461 ; 462### Going parallel; 463Let's say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores.; 464The only modification required to the snippets would be the addition of this line *before* constructing the main; 465dataframe object:; 466~~~{.cpp}; 467ROOT::EnableImplicitMT();; 468~~~; 469Simple as that. More details are given [below](#parallel-execution).; 470 ; 471\anchor collections; 472## Working with collections and object selections; 473 ; 474RDataFrame reads collections as the special type [ROOT::RVec](https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html): for example, a column containing an array of floating point numbers can be read as a ROOT::RVecF. C-style arrays (with variable or static size), STL vectors and most other collection types can be read this way.; 475 ; 476RVec is a container similar to std::vec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:27980,access,accessing,27980,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['accessing']
Security," Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fCorsTHttpServerprotected; fCorsCredentialsTHttpServerprotected; fDefaultPageTHttpServerprotected; fDefaultPageContTHttpServerprotected; fDrawPageTHttpServerprotected; fDrawPageContTHttpServerprotected; fEnginesTHttpServerprotected; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; FillBuffer(char *&buffer)TNamedvirtual; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; FindWS(const char *name)THttpServer; fJSROOTTHttpServerprotected; fJSROOTSYSTHttpServerprotected; fLocationsTHttpServerprotected; fMainThrdIdTHttpServerprotected; fMutexTHttpServerprotected; fNameTNamedprotected; fOwnThreadTHttpServerprotected; fProcessingThrdIdTHttpServerprotected; fSnifferTHttpServerprotected; fTerminatedTHttpServerprotected; fThrdTHttpServerprotected; fTimerTHttpServerprotected; fTitleTNamedprotected; fTopNameTHttpServerprotected; fUniqueIDTObjectprivate; fWSHandlersTHttpServerprotected; fWSMutexTHttpServerprotected; fWSOnlyTHttpServerprotected; GetCors() constTHttpServerinline; GetCorsCredentials() constTHttpServerinline; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetIconName() constTObjectvirtual; GetItemField(const char *fullname, const char *name)THttpServer; GetMimeType(const char *path)THttpServerstatic; GetName() const overrideTNamedinlinevirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetSniffer() constTHttpServerinline; GetTitle() const overrideTNamedinlinevirtual; GetTopName() constTHttpServerinline; GetUniqueID() constTObjectvirtual; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; Hide(const char *fullname, Bool_t hide=kTRUE)THttpServer; Info(const char *method, const char *msgfmt,...) constTObjectvirtual; InheritsFrom(const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer-members.html:3739,Hash,Hash,3739,doc/master/classTHttpServer-members.html,https://root.cern,https://root.cern/doc/master/classTHttpServer-members.html,1,['Hash'],['Hash']
Security," FillTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:10994,validat,validationSample,10994,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,1,['validat'],['validationSample']
Security," FindObject instead; 248 TObject *GetSelected() const override;; 249 TVirtualPad *GetPad(Int_t subpadnumber) const override;; 250 TObject *GetPadPointer() const override { return fPadPointer; }; 251 TVirtualPad *GetPadSave() const override;; 252 TVirtualPad *GetSelectedPad() const override;; 253 Int_t GetGLDevice() override;; 254 TView *GetView() const override { return fView; }; 255 TObject *GetView3D() const override { return fPadView3D; }// Return 3D View of this TPad; 256 Int_t GetLogx() const override { return fLogx; }; 257 Int_t GetLogy() const override { return fLogy; }; 258 Int_t GetLogz() const override { return fLogz; }; 259 TVirtualPad *GetMother() const override { return fMother; }; 260 const char *GetName() const override { return fName.Data(); }; 261 const char *GetTitle() const override { return fTitle.Data(); }; 262 TCanvas *GetCanvas() const override { return fCanvas; }; 263 TVirtualPad *GetVirtCanvas() const override;; 264 TVirtualPadPainter *GetPainter() override;; 265 Int_t GetPadPaint() const override { return fPadPaint; }; 266 Int_t GetPixmapID() const override { return fPixmapID; }; 267 ULong_t Hash() const override { return fName.Hash(); }; 268 Bool_t HasCrosshair() const override;; 269 void HighLight(Color_t col=kRed, Bool_t set=kTRUE) override;; 270 Bool_t HasFixedAspectRatio() const override { return fFixedAspectRatio; }; 271 Bool_t IsBatch() const override;; 272 Bool_t IsEditable() const override { return fEditable; }; 273 Bool_t IsFolder() const override { return kTRUE; }; 274 Bool_t IsModified() const override { return fModified; }; 275 Bool_t IsRetained() const override;; 276 Bool_t IsVertical() const override { return !TestBit(kHori); }; 277 Bool_t IsWeb() const override;; 278 void ls(Option_t *option="""") const override;; 279 void Modified(Bool_t flag=true) override; // *SIGNAL*; 280 void ModifiedUpdate() override;; 281 Bool_t OpaqueMoving() const override;; 282 Bool_t OpaqueResizing() const override;; 283 Double_t PadtoX(Double_t x) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8h_source.html:14384,Hash,Hash,14384,doc/master/TPad_8h_source.html,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html,1,['Hash'],['Hash']
Security," Float_t > & MethodPyKeras::GetMulticlassValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 772 of file MethodPyKeras.cxx. ◆ GetMvaValue(). Double_t MethodPyKeras::GetMvaValue ; (; Double_t * ; errLower, . Double_t * ; errUpper . ). virtual . Implements TMVA::PyMethodBase.; Definition at line 657 of file MethodPyKeras.cxx. ◆ GetMvaValues(). std::vector< Double_t > MethodPyKeras::GetMvaValues ; (; Long64_t ; firstEvt, . Long64_t ; lastEvt, . Bool_t ; logProgress . ). virtual . get all the MVA values for the events of the current Data type ; Implements TMVA::PyMethodBase.; Definition at line 679 of file MethodPyKeras.cxx. ◆ GetNumValidationSamples(). UInt_t TMVA::MethodPyKeras::GetNumValidationSamples ; (; ). private . Validation of the ValidationSize option. ; Allowed formats are 20%, 0.2 and 100 etc.; 20% and 0.2 selects 20% of the training set as validation data.; 100 selects 100 events as the validation data. Returnsnumber of samples in validation set ; Definition at line 111 of file MethodPyKeras.cxx. ◆ GetRegressionValues(). std::vector< Float_t > & MethodPyKeras::GetRegressionValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 740 of file MethodPyKeras.cxx. ◆ HasAnalysisType(). Bool_t MethodPyKeras::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ;  . ). virtual . Implements TMVA::PyMethodBase.; Definition at line 70 of file MethodPyKeras.cxx. ◆ Init(). void MethodPyKeras::Init ; (; void ; ). virtual . Initialization function called from MethodBase::SetupMethod() Note that option string are not yet filled with their values. ; This is done before ProcessOption method or after reading from XML file ; Implements TMVA::PyMethodBase.; Definition at line 414 of file MethodPyKeras.cxx. ◆ InitKeras(). void MethodPyKeras::InitKeras ; (; ). private . Definition at line 181 of file MethodPyKeras.cxx. ◆ ProcessOptions(). void MethodPyKeras::ProcessOptions ; (; ). virtual . Func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyKeras.html:33770,validat,validation,33770,doc/master/classTMVA_1_1MethodPyKeras.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyKeras.html,1,['validat'],['validation']
Security," Float_t > & MethodPyTorch::GetMulticlassValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 630 of file MethodPyTorch.cxx. ◆ GetMvaValue(). Double_t MethodPyTorch::GetMvaValue ; (; Double_t * ; errLower, . Double_t * ; errUpper . ). virtual . Implements TMVA::PyMethodBase.; Definition at line 511 of file MethodPyTorch.cxx. ◆ GetMvaValues(). std::vector< Double_t > MethodPyTorch::GetMvaValues ; (; Long64_t ; firstEvt, . Long64_t ; lastEvt, . Bool_t ; logProgress . ). virtual . get all the MVA values for the events of the current Data type ; Implements TMVA::PyMethodBase.; Definition at line 533 of file MethodPyTorch.cxx. ◆ GetNumValidationSamples(). UInt_t TMVA::MethodPyTorch::GetNumValidationSamples ; (; ). private . Validation of the ValidationSize option. ; Allowed formats are 20%, 0.2 and 100 etc.; 20% and 0.2 selects 20% of the training set as validation data.; 100 selects 100 events as the validation data. Returnsnumber of samples in validation set ; Definition at line 100 of file MethodPyTorch.cxx. ◆ GetRegressionValues(). std::vector< Float_t > & MethodPyTorch::GetRegressionValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 600 of file MethodPyTorch.cxx. ◆ HasAnalysisType(). Bool_t MethodPyTorch::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ;  . ). virtual . Implements TMVA::PyMethodBase.; Definition at line 66 of file MethodPyTorch.cxx. ◆ Init(). void MethodPyTorch::Init ; (; void ; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 279 of file MethodPyTorch.cxx. ◆ ProcessOptions(). void MethodPyTorch::ProcessOptions ; (; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 152 of file MethodPyTorch.cxx. ◆ ReadModelFromFile(). void MethodPyTorch::ReadModelFromFile ; (; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 648 of file MethodPyTorch.cxx. ◆ ReadWeightsFromStream() [1/2]. virtual void TMVA::MethodPyTorch::ReadWei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyTorch.html:32261,validat,validation,32261,doc/master/classTMVA_1_1MethodPyTorch.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyTorch.html,1,['validat'],['validation']
Security," Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; kFileExists@ kFileExistsDefinition TSystem.h:42; kWritePermission@ kWritePermissionDefinition TSystem.h:44; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; lineTLine * lineDefinition entrylistblock_figure1.C:235; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; AuthorRene Brun ; Definition in file cernbuild.C. tutorialstreecernbuild.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/cernbuild_8C.html:4349,Access,AccessPathNamevirtual,4349,doc/master/cernbuild_8C.html,https://root.cern,https://root.cern/doc/master/cernbuild_8C.html,4,"['Access', 'access']","['AccessPathName', 'AccessPathNamevirtual', 'access']"
Security," Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tTTUBE::GetNumberOfDivisions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tTTUBE::GetRmax() const; Float_tGetRmax2() const; virtual Float_tTTUBE::GetRmin() const; Float_tGetRmin2() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCONE.html:3533,Hash,Hash,3533,root/html526/TCONE.html,https://root.cern,https://root.cern/root/html526/TCONE.html,2,['Hash'],['Hash']
Security," Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tTTUBE::GetNumberOfDivisions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tTTUBE::GetRmax() const; Float_tGetRmax2() const; virtual Float_tTTUBE::GetRmin() const; Float_tGetRmin2() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCONE.html:3533,Hash,Hash,3533,root/html530/TCONE.html,https://root.cern,https://root.cern/root/html530/TCONE.html,3,['Hash'],['Hash']
Security," Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tTTUBE::GetNumberOfDivisions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tTTUBE::GetRmax() const; Float_tGetRmax2() const; virtual Float_tTTUBE::GetRmin() const; Float_tGetRmin2() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCONE.html:3253,Hash,Hash,3253,root/html602/TCONE.html,https://root.cern,https://root.cern/root/html602/TCONE.html,2,['Hash'],['Hash']
Security," For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TNamed; 13#define ROOT_TNamed; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TNamed //; 19// //; 20// The basis for a named object (name, title). //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24 ; 25#include ""TObject.h""; 26#include ""TString.h""; 27 ; 28 ; 29class TNamed : public TObject {; 30 ; 31protected:; 32 TString fName; //object identifier; 33 TString fTitle; //object title; 34 ; 35public:; 36 TNamed(): fName(), fTitle() { }; 37 TNamed(const char *name, const char *title) : fName(name), fTitle(title) { }; 38 TNamed(const TString &name, const TString &title) : fName(name), fTitle(title) { }; 39 TNamed(const TNamed &named);; 40 TNamed& operator=(const TNamed& rhs);; 41 virtual ~TNamed();; 42 void Clear(Option_t *option ="""") override;; 43 TObject *Clone(const char *newname="""") const override;; 44 Int_t Compare(const TObject *obj) const override;; 45 void Copy(TObject &named) const override;; 46 virtual void FillBuffer(char *&buffer);; 47 const char *GetName() const override { return fName; }; 48 const char *GetTitle() const override { return fTitle; }; 49 ULong_t Hash() const override { return fName.Hash(); }; 50 Bool_t IsSortable() const override { return kTRUE; }; 51 virtual void SetName(const char *name); // *MENU*; 52 virtual void SetNameTitle(const char *name, const char *title);; 53 virtual void SetTitle(const char *title=""""); // *MENU*; 54 void ls(Option_t *option="""") const override;; 55 void Print(Option_t *option="""") const override;; 56 virtual Int_t Sizeof() const;; 57 ; 58 ClassDefOverride(TNamed,1) //The basis for a named object (name, title); 59};; 60 ; 61#endif; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TNamed_8h_source.html:1813,Hash,Hash,1813,doc/master/TNamed_8h_source.html,https://root.cern,https://root.cern/doc/master/TNamed_8h_source.html,1,['Hash'],['Hash']
Security," Functions |; Protected Attributes |; List of all members ; TUsrHit Class Reference. . Definition at line 4 of file clonesA_Event.h. Public Member Functions;  TUsrHit (Int_t ev=0);  ; virtual ~TUsrHit ();  ; virtual TClass * IsA () const;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUsrHit.html:1183,Hash,Hash,1183,doc/master/classTUsrHit.html,https://root.cern,https://root.cern/doc/master/classTUsrHit.html,2,['Hash'],['Hash']
Security," Functions |; Public Attributes |; List of all members ; TEveRecV0 Class Reference. . Definition at line 197 of file TEveVSDStructs.h. Public Member Functions;  TEveRecV0 ();  ;  ~TEveRecV0 () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveRecV0.html:1185,Hash,Hash,1185,doc/master/classTEveRecV0.html,https://root.cern,https://root.cern/doc/master/classTEveRecV0.html,2,['Hash'],['Hash']
Security," GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:101334,access,access,101334,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security," GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:101366,access,access,101366,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security," GetClassVersion has been called. . EnumeratorkNotInitialized ; kSet ; kConsistentHash . Definition at line 264 of file TClass.h. ◆ EState. enum TClass::EState. EnumeratorkNoInfo ; kForwardDeclared ; kEmulated ; kInterpreted ; kHasTClassInit ; kLoaded ; kNamespaceForMeta . Definition at line 121 of file TClass.h. ◆ EStatusBits. enum TClass::EStatusBits. EnumeratorkReservedLoading ; kHasLocalHashMember ; kIgnoreTObjectStreamer ; kUnloaded ; kIsTObject ; kIsForeign ; kStartWithTObject ; kWarned ; kHasNameMapNode . Definition at line 92 of file TClass.h. ◆ EStreamerType. enum TClass::EStreamerType. private . EnumeratorkDefault ; kEmulatedStreamer ; kTObject ; kInstrumented ; kForeign ; kExternal . Definition at line 334 of file TClass.h. Constructor & Destructor Documentation. ◆ TClass() [1/8]. TClass::TClass ; (; const TClass & ; tc). privatedelete . ◆ TClass() [2/8]. TClass::TClass ; (; ). Internal, default constructor. ; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1065 of file TClass.cxx. ◆ TClass() [3/8]. TClass::TClass ; (; const char * ; name, . Bool_t ; silent = kFALSE . ). Create a TClass object. ; This object contains the full dictionary of a class. It has list to baseclasses, datamembers and methods. Use this ctor to create a standalone TClass object. Only useful to get a temporary TClass interface to an interpreted class. Used by TTabCom.; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1103 of file TClass.cxx. ◆ TClass() [4/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1151 of file TClass.cxx. ◆ TClass() [5/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . EState ; theState, . Bool_t ; silent = kFALSE . ). Internal c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:49335,access,access,49335,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['access']
Security," GetClassVersion has been called. . EnumeratorkNotInitialized ; kSet ; kConsistentHash . Definition at line 264 of file TClass.h. ◆ EState. enum TClass::EState. EnumeratorkNoInfo ; kForwardDeclared ; kEmulated ; kInterpreted ; kHasTClassInit ; kLoaded ; kNamespaceForMeta . Definition at line 121 of file TClass.h. ◆ EStatusBits. enum TClass::EStatusBits. EnumeratorkReservedLoading ; kHasLocalHashMember ; kIgnoreTObjectStreamer ; kUnloaded ; kIsTObject ; kIsForeign ; kStartWithTObject ; kWarned ; kHasNameMapNode . Definition at line 92 of file TClass.h. ◆ EStreamerType. enum TClass::EStreamerType. private . EnumeratorkDefault ; kEmulatedStreamer ; kTObject ; kInstrumented ; kForeign ; kExternal . Definition at line 334 of file TClass.h. Constructor & Destructor Documentation. ◆ TClass() [1/8]. TClass::TClass ; (; const TClass & ; tc). privatedelete . ◆ TClass() [2/8]. TClass::TClass ; (; ). Internal, default constructor. ; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1132 of file TClass.cxx. ◆ TClass() [3/8]. TClass::TClass ; (; const char * ; name, . Bool_t ; silent = kFALSE . ). Create a TClass object. ; This object contains the full dictionary of a class. It has list to baseclasses, datamembers and methods. Use this ctor to create a standalone TClass object. Only useful to get a temporary TClass interface to an interpreted class. Used by TTabCom.; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1170 of file TClass.cxx. ◆ TClass() [4/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1218 of file TClass.cxx. ◆ TClass() [5/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . EState ; theState, . Bool_t ; silent = kFALSE . ). Internal c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:49336,access,access,49336,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['access']
Security," GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:15745,access,access,15745,root/html534/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,2,['access'],"['access', 'accessors']"
Security," GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:14139,access,access,14139,root/html534/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,2,['access'],"['access', 'accessors']"
Security," GetErrorYlow(Int_t i) const overrideTGraphAsymmErrorsvirtual; GetEX() constTGraphinlinevirtual; GetEXhigh() const overrideTGraphAsymmErrorsinlinevirtual; GetEXhighd() constTGraphinlinevirtual; GetEXlow() const overrideTGraphAsymmErrorsinlinevirtual; GetEXlowd() constTGraphinlinevirtual; GetEY() constTGraphinlinevirtual; GetEYhigh() const overrideTGraphAsymmErrorsinlinevirtual; GetEYhighd() constTGraphinlinevirtual; GetEYlow() const overrideTGraphAsymmErrorsinlinevirtual; GetEYlowd() constTGraphinlinevirtual; GetFillColor() constTAttFillinlinevirtual; GetFillStyle() constTAttFillinlinevirtual; GetFunction(const char *name) constTGraph; GetHistogram() constTGraphvirtual; GetIconName() constTObjectvirtual; GetLineColor() constTAttLineinlinevirtual; GetLineStyle() constTAttLineinlinevirtual; GetLineWidth() constTAttLineinlinevirtual; GetListOfFunctions() constTGraphinline; GetMarkerColor() constTAttMarkerinlinevirtual; GetMarkerLineWidth(Style_t style)TAttMarkerstatic; GetMarkerSize() constTAttMarkerinlinevirtual; GetMarkerStyle() constTAttMarkerinlinevirtual; GetMarkerStyleBase(Style_t style)TAttMarkerstatic; GetMaximum() constTGraphinline; GetMaxSize() constTGraphinline; GetMean(Int_t axis=1) constTGraphvirtual; GetMinimum() constTGraphinline; GetN() constTGraphinline; GetName() const overrideTNamedinlinevirtual; GetObjectInfo(Int_t px, Int_t py) const overrideTGraphvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetPoint(Int_t i, Double_t &x, Double_t &y) constTGraphvirtual; GetPointX(Int_t i) constTGraphvirtual; GetPointY(Int_t i) constTGraphvirtual; GetRMS(Int_t axis=1) constTGraphvirtual; GetTitle() const overrideTNamedinlinevirtual; GetUniqueID() constTObjectvirtual; GetX() constTGraphinline; GetXaxis() constTGraph; GetY() constTGraphinline; GetYaxis() constTGraph; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; Info(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphAsymmErrors-members.html:7423,Hash,Hash,7423,doc/master/classTGraphAsymmErrors-members.html,https://root.cern,https://root.cern/doc/master/classTGraphAsymmErrors-members.html,1,['Hash'],['Hash']
Security," GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t GetType(Int_t id) const; {return fComp[id].fType;}. Double_t GetValue(char* pointer, Int_t i, Int_t j, Int_t len) const; { return GetTypedValue<Double_t>(pointer, i, j, len); }. Double_t GetValueClones(TClonesArray* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueClones<Double_t>(clones, i, j, k, eoffset); }. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTL<Double_t>(cont, i, j, k, eoffset); }. Double_t GetValueSTLP(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTLP<Double_t>(cont, i, j, k, eoffset); }. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. void SetOnFileClassVersion(Int_t vers); {fOnFileClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first); Try to remove those functions from the public interface. Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). TStreamerElement * GetCurrentElement(). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerInfo.html:35133,checksum,checksum,35133,root/html602/TStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TStreamerInfo.html,2,['checksum'],['checksum']
Security," GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t GetType(Int_t id) const; {return fComp[id].fType;}. Double_t GetValue(char* pointer, Int_t i, Int_t j, Int_t len) const; { return GetTypedValue<Double_t>(pointer, i, j, len); }. Double_t GetValueClones(TClonesArray* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueClones<Double_t>(clones, i, j, k, eoffset); }. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTL<Double_t>(cont, i, j, k, eoffset); }. Double_t GetValueSTLP(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTLP<Double_t>(cont, i, j, k, eoffset); }. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. void SetOnFileClassVersion(Int_t vers); {fOnFileClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first); Try to remove those functions from the public interface. Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). TStreamerElement * GetCurrentElement(). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-07-31 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:28761,checksum,checksum,28761,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,2,['checksum'],['checksum']
Security," GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t GetType(Int_t id) const; {return fComp[id].fType;}. Double_t GetValue(char* pointer, Int_t i, Int_t j, Int_t len) const; { return GetTypedValue<Double_t>(pointer, i, j, len); }. Double_t GetValueClones(TClonesArray* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueClones<Double_t>(clones, i, j, k, eoffset); }. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTL<Double_t>(cont, i, j, k, eoffset); }. Double_t GetValueSTLP(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTLP<Double_t>(cont, i, j, k, eoffset); }. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. void SetOnFileClassVersion(Int_t vers); {fOnFileClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first); Try to remove those functions from the public interface. Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). TStreamerElement * GetCurrentElement(). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-07-31 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStreamerInfo.html:35079,checksum,checksum,35079,root/html604/TStreamerInfo.html,https://root.cern,https://root.cern/root/html604/TStreamerInfo.html,2,['checksum'],['checksum']
Security," GetPaintTextFormat() constTStyleinline; GetPaperSize(Float_t &xsize, Float_t &ysize) constTStyle; GetScreenFactor() constTStyleinline; GetShowEditor() constTStyleinline; GetShowEventStatus() constTStyleinline; GetShowToolBar() constTStyleinline; GetStatBorderSize() constTStyleinline; GetStatColor() constTStyleinline; GetStatFont() constTStyleinline; GetStatFontSize() constTStyleinline; GetStatFormat() constTStyleinline; GetStatH() constTStyleinline; GetStatStyle() constTStyleinline; GetStatTextColor() constTStyleinline; GetStatW() constTStyleinline; GetStatX() constTStyleinline; GetStatY() constTStyleinline; GetStripDecimals() constTStyleinline; GetTextAlign() constTAttTextinlinevirtual; GetTextAngle() constTAttTextinlinevirtual; GetTextColor() constTAttTextinlinevirtual; GetTextFont() constTAttTextinlinevirtual; GetTextSize() constTAttTextinlinevirtual; GetTextSizePercent(Float_t size)TAttTextvirtual; GetTickLength(Option_t *axis=""X"") constTStyle; GetTimeOffset() constTStyleinline; GetTitle() const overrideTNamedinlinevirtual; GetTitleAlign() constTStyleinline; GetTitleBorderSize() constTStyleinline; GetTitleColor(Option_t *axis=""X"") constTStyle; GetTitleFillColor() constTStyleinline; GetTitleFont(Option_t *axis=""X"") constTStyle; GetTitleFontSize() constTStyleinline; GetTitleH() constTStyleinline; GetTitleOffset(Option_t *axis=""X"") constTStyle; GetTitlePS() constTStyleinline; GetTitleSize(Option_t *axis=""X"") constTStyle; GetTitleStyle() constTStyleinline; GetTitleTextColor() constTStyleinline; GetTitleW() constTStyleinline; GetTitleX() constTStyleinline; GetTitleXOffset() constTStyleinline; GetTitleXSize() constTStyleinline; GetTitleY() constTStyleinline; GetTitleYOffset() constTStyleinline; GetTitleYSize() constTStyleinline; GetUniqueID() constTObjectvirtual; GetViolinScaled() constTStyleinline; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; Info(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStyle-members.html:11614,Hash,Hash,11614,doc/master/classTStyle-members.html,https://root.cern,https://root.cern/doc/master/classTStyle-members.html,1,['Hash'],['Hash']
Security," Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 7. Using the TTreeReader. Accessing Value from a TTree; Up to now we have used TTree's ability to parse TTree::Draw() expressions and the TBrowser interface. Sometimes it's better to access the values in a script, one by one. There is a traditional way of doing this (TTree::SetBranchAddress() etc) and a new, recommended one: the TTreeReader. That's what we will use later and introduce here.; The TTreeReader Concept; The TTree loads entry by entry into memory. You and the TTree need to agree what data the TTree should make available (i.e. for which branches) and what data these branches contain. First, we set up a TTreeReader object that connects our data requests to the TTree:; // Access a TTree called ""MyTree"" in the file:; TTreeReader reader(""MyTree"", file);. The TTreeReader Values and Arrays; This reader object can now be used by the data accessors. There are two types: TTreeReaderArray can iterate through collections (std::vector, TClonesArray, TList, MyType[12] - whatever) and TTreeReaderValue that doesn't. You can choose how you access the values - for our tree, all of these might make sense in different contexts:; TTreeReaderValue<float> rvMissingET(reader, ""missingET"");; // The following needs the definition of the Muon class - which is why accessing; // data member branches is much simpler.; TTreeReaderValue<std::vector<Muon>> rvMuons(reader, ""muons"");. TTreeReaderArray<float> raMuonPt(reader, ""muons.fPt"");; // Here, too we would need the definition of the Muon class.; TTreeReaderArray<Muon> raMuons(reader, ""muons"");. Accessing Data; The TTreeReader checks whether the type you specify is the type that's stored in the branch, i.e. whether it can actu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/7-using-ttreereader.html:2576,Access,Access,2576,d/7-using-ttreereader.html,https://root.cern,https://root.cern/d/7-using-ttreereader.html,1,['Access'],['Access']
Security," Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Glob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:22228,authenticat,authenticated,22228,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,5,['authenticat'],['authenticated']
Security," H1 analysis example ;  mp201_parallelHistoFill.C Parallel fill of a histogram This tutorial shows how a histogram can be filled in parallel with a multiprocess approach ;  mp_H1_lambdas.C Lambdas used to check and fit the result of the H1 analysis ;  mt001_fillHistos.CFill histograms in parallel and write them on file ;  mt101_fillNtuples.CFill n-tuples in distinct workers ;  mt102_readNtuplesFillHistosAndFit.CRead n-tuples in distinct workers, fill histograms, merge them and fit ;  mt103_fillNtupleFromMultipleThreads.CFill the same TNtuple from different threads ;  mt201_parallelHistoFill.CParallel fill of a histogram ;  mtbb001_fillHistos.CFill histograms in parallel and write them on file ;  mtbb101_fillNtuples.CFill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.CParallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:135290,authenticat,authentication,135290,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['authenticat'],['authentication']
Security," Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:24488,hash,hash,24488,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['hash'],['hash']
Security," Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t valueServer = kTRUE, Bool_t shapeServer = kFALSE, Bool_t proxyOwnsArg = kFALSE); Constructor with owner. RooRealProxy(const char* name, const char* desc, RooAbsArg* owner, RooAbsReal& ref, Bool_t valueServer = kTRUE, Bool_t shapeServer = kFALSE, Bool_t proxyOwnsArg = kFALSE); Constructor with owner and proxied real-valued object. The propagation; of value and shape dirty flags of the contained arg to the owner is; controlled by the valueServer and shapeServer flags. If ownArg is true; the proxy will take ownership of the contained arg. RooRealProxy(const char* name, RooAbsArg* owner, const RooRealProxy& other); Copy constructor. ~RooRealProxy(); Destructor. RooAbsRealLValue* lvptr() const; Return l-value pointer to contents, if contents is in fact an l-value. Bool_t setArg(RooAbsReal& newRef); Change object held in proxy into newRef. RooRealProxy(); Constructors, assignment etc. {}. RooRealProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t valueServer = kTRUE, Bool_t shapeServer = kFALSE, Bool_t proxyOwnsArg = kFALSE). TObject* Clone(const char* newName = 0) const; { return new RooRealProxy(newName,_owner,*this); }. inline operator Double_t() const; Accessors. { return _isFund?((RooAbsReal*)_arg)->_value:((RooAbsReal*)_arg)->getVal(_nset) ; }. const RooAbsReal& arg() const; { return (RooAbsReal&)*_arg ; }. RooRealProxy& operator=(const Double_t& value); LValue operations. { lvptr()->setVal(value) ; return *this ; }. Double_t min(const char* rname = 0) const; { return lvptr()->getMin(rname) ; }. Double_t max(const char* rname = 0) const; { return lvptr()->getMax(rname) ; }. » Last changed: Thu Sep 23 20:00:41 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealProxy.html:8711,Access,Accessors,8711,root/html528/RooRealProxy.html,https://root.cern,https://root.cern/root/html528/RooRealProxy.html,1,['Access'],['Accessors']
Security," Insert object at location idx in the list. Float_t AverageCollisions() const; Return the average collision rate. The higher the number the longer; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashList.html:13807,hash,hash,13807,root/html528/THashList.html,https://root.cern,https://root.cern/root/html528/THashList.html,12,"['Hash', 'hash']","['Hash', 'hash']"
Security," Int_t GetDepth() const; Returns depth of screen (number of bit planes).; Equivalent to GetPlanes(). Colormap_t GetColormap() const; Returns handle to colormap. Might be usefull in some cases where direct X11 manipulation outside; of TVirtualX is needed, e.g. GL interface. Window_t GetDefaultRootWindow() const; Returns handle to the default root window created when calling; XOpenDisplay(). Atom_t InternAtom(const char* atom_name, Bool_t only_if_exist); Returns the atom identifier associated with the specified ""atom_name""; string. If ""only_if_exists"" is False, the atom is created if it does; not exist. If the atom name is not in the Host Portable Character; Encoding, the result is implementation dependent. Uppercase and; lowercase matter; the strings ""thing"", ""Thing"", and ""thinG"" all; designate different atoms. Window_t GetParent(Window_t id) const; Returns the parent of the window ""id"". FontStruct_t LoadQueryFont(const char* font_name); Provides the most common way for accessing a font: opens (loads) the; specified font and returns a pointer to the appropriate FontStruct_t; structure. If the font does not exist, it returns NULL. FontH_t GetFontHandle(FontStruct_t fs); Returns the font handle of the specified font structure ""fs"". void DeleteFont(FontStruct_t fs); Explicitely deletes the font structure ""fs"" obtained via LoadQueryFont(). GContext_t CreateGC(Drawable_t id, GCValues_t* gval); Creates a graphics context using the provided GCValues_t *gval structure.; The mask data member of gval specifies which components in the GC are; to be set using the information in the specified values structure.; It returns a graphics context handle GContext_t that can be used with any; destination drawable or O if the creation falls. void ChangeGC(GContext_t gc, GCValues_t* gval); Changes the components specified by the mask in gval for the specified GC. GContext_t gc - specifies the GC to be changed; GCValues_t gval - specifies the mask and the values to be set; (see also the GCV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:40134,access,accessing,40134,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,6,['access'],['accessing']
Security," Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() const; virtual const char*TObject::GetTitle() const; const char*GetTXTRecord() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBonjourResolver.html:5033,Hash,Hash,5033,root/html530/TBonjourResolver.html,https://root.cern,https://root.cern/root/html530/TBonjourResolver.html,2,['Hash'],['Hash']
Security," Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidforceCacheUpdate(); virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_thasFilledCache() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tisWeighted() const; Bool_tTObject::IsZombie() const; virtual voidloadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual RooAbsDataStore*merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsDataStore.html:3645,Hash,Hash,3645,root/html534/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html,3,['Hash'],['Hash']
Security," Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoNode**GetArray() const; TGeoNode*GetCurrentNode() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; size_tGetLevel() const; const TGeoHMatrix*GetMatrix() const; size_tGetMaxLevel() const; virtual const char*TObject::GetName() const; TGeoNode*GetNode(Int_t level) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPath(TString& path) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; voidInit(TGeoNode** branch, TGeoMatrix* global, Int_t level); voidInitFromNavigator(TGeoNavigator* nav); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOutside() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; static TGeoBranchArray*MakeCopy(const TGeoBranchArray& other); static TGeoBranchArray*MakeCopyAt(const TGeoBranchArray& other, void* addr); static TGeoBranchArray*MakeInstance(size_t maxlevel); static TGeoBranchArray*MakeInstanceAt(size_t maxlevel, void* addr); voidTObject::MayNotUse(const char* meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBranchArray.html:2982,Hash,Hash,2982,root/html534/TGeoBranchArray.html,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html,2,['Hash'],['Hash']
Security," Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetCacheSize(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLearnEntries(); virtual const char*TObject::GetName() const; virtual Long64_tGetNextEvent(); virtual Int_tGetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetPackets(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual voidInvalidatePacket(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEventIter.html:2667,Hash,Hash,2667,root/html534/TEventIter.html,https://root.cern,https://root.cern/root/html534/TEventIter.html,1,['Hash'],['Hash']
Security," Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetCacheSize(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLearnEntries(); virtual const char*TObject::GetName() const; virtual Long64_tGetNextEvent(); virtual Int_tGetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetPackets(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual voidInvalidatePacket(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::opera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIter.html:2667,Hash,Hash,2667,root/html602/TEventIter.html,https://root.cern,https://root.cern/root/html602/TEventIter.html,2,['Hash'],['Hash']
Security," Int_tTEveElement::GetParentIgnoreCnt() const; Float_tGetPolygonOffset(Int_t i) const; virtual TObject*TEveElement::GetRenderObject(const TEveException& eh = ""TEveElement::GetRenderObject "") const; virtual Bool_tTEveElement::GetRnrAnything() const; virtual Bool_tTEveElement::GetRnrChildren() const; virtual Bool_tTEveElement::GetRnrSelf() const; virtual Bool_tTEveElement::GetRnrState() const; virtual UChar_tTEveElement::GetSelectedLevel() const; TRef&TEveElement::GetSource(); TObject*TEveElement::GetSourceObject() const; const char*GetText() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; void*TEveElement::GetUserData() const; TEveElement*TEveElement::GetVizModel() const; const TString&TEveElement::GetVizTag() const; virtual Bool_tTEveElement::HandleElementPaste(TEveElement* el); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tTEveElement::HasChild(TEveElement* el); Bool_tTEveElement::HasChildren() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tTEveElement::HasMainColor() const; virtual Bool_tTEveElement::HasMainTrans() const; Bool_tTEveElement::HasParents() const; virtual voidTEveElement::HighlightElement(Bool_t state); voidTEveElement::IncDenyDestroy(); virtual voidTEveElement::IncImpliedHighlighted(); virtual voidTEveElement::IncImpliedSelected(); voidTEveElement::IncParentIgnoreCnt(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTEveElement::InitMainTrans(Bool_t can_edit = kTRUE); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTEveElement::IsPickable() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; TEveElem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveText.html:8536,Hash,Hash,8536,root/html528/TEveText.html,https://root.cern,https://root.cern/root/html528/TEveText.html,1,['Hash'],['Hash']
Security," Int_tTFile::GetReadaheadSize(); virtual Int_tTFile::GetReadCalls() const; Int_tTFile::GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Long64_tTFile::GetRelOffset() const; virtual Long64_tTDirectoryFile::GetSeekDir() const; virtual Long64_tGetSeekFree() const; virtual Long64_tGetSeekInfo() const; virtual Long64_tTDirectoryFile::GetSeekKeys() const; virtual Long64_tTDirectoryFile::GetSeekParent() const; TStringTXMLSetup::GetSetupAsString(); virtual Long64_tGetSize() const; const TList*TFile::GetStreamerInfoCache(); virtual TList*GetStreamerInfoList(); virtual const char*TNamed::GetTitle() const; static TFile::EFileTypeTFile::GetType(const char* name, Option_t* option = """", TString* prefix = 0); virtual UInt_tTObject::GetUniqueID() const; TUUIDTDirectory::GetUUID() const; Int_tTFile::GetVersion() const; TXMLSetup::EXMLLayoutTXMLSetup::GetXmlLayout() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; static voidTFile::IncrementFileCounter(); virtual voidTFile::IncrementProcessIDs(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTFile::IsArchive() const; Bool_tTFile::IsBinary() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTDirectory::IsFolder() const; virtual Bool_tTDirectoryFile::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsOpen() const; Bool_tTFile::IsRaw() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTXMLSetup::IsStoreStreamerInfos() const; Bool_tTXMLSetup::IsUseDtd() const; Bool_tTXMLSetup::IsUseNamespaces() const; virtual Bool_tTDirectoryFile::IsWritable() const; Bool_tTObject::IsZombie() const; virtual voidTFile::ls(Option_t* optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:9832,Hash,Hash,9832,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,4,['Hash'],['Hash']
Security," Int_tTFile::ReadBufferViaCache(char* buf, Int_t len); voidTDirectory::RegisterContext(TDirectory::TContext* ctxt); voidSetAccessKey(const TString& accessKey); virtual voidSetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); voidSetSecretKey(const TString& secretKey); virtual Int_tTFile::SysClose(Int_t fd); virtual Int_tTFile::SysOpen(const char* pathname, Int_t flags, UInt_t mode); virtual Int_tTFile::SysRead(Int_t fd, void* buf, Int_t len); virtual Long64_tTFile::SysSeek(Int_t fd, Long64_t offset, Int_t whence); virtual Int_tTFile::SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); virtual Int_tTFile::SysSync(Int_t fd); virtual Int_tTFile::SysWrite(Int_t fd, const void* buf, Int_t len); voidTDirectory::UnregisterContext(TDirectory::TContext* ctxt); Int_tTFile::WriteBufferViaCache(const char* buf, Int_t len). private:. Bool_tGetCredentialsFromEnv(const char* accessKeyEnv, const char* secretKeyEnv, TString& outAccessKey, TString& outSecretKey); Bool_tParseOptions(Option_t* options, TString& accessKey, TString& secretKey); TS3WebFile(). Data Members; public:. static TFile::EAsyncOpenStatusTFile::kAOSFailure; static TFile::EAsyncOpenStatusTFile::kAOSInProgress; static TFile::EAsyncOpenStatusTFile::kAOSNotAsync; static TFile::EAsyncOpenStatusTFile::kAOSSuccess; static TFile::ERelativeToTFile::kBeg; static TFile::EStatusBitsTFile::kBinaryFile; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TDirectoryFile::(anonymous)TDirectoryFile::kCloseDirectory; static TFile::ERelativeToTFile::kCur; static TFile::EFileTypeTFile::kDefault; static TFile::EStatusBitsTFile::kDevNull; static TFile::ECacheActionTFile::kDisconnect; static TFile::ECacheActionTFile::kDoNotDisconnect; static TFile::ERelativeToTFile::kEnd; static TFile::EOpenTimeOutTFile::kEternalTimeout; static TFile::EFileTypeTFile::kFile; static TFile::EStatusBitsTF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:19608,access,accessKeyEnv,19608,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,4,['access'],"['accessKey', 'accessKeyEnv']"
Security," Int_tTFile::ReadBufferViaCache(char* buf, Int_t len); voidTDirectory::RegisterContext(TDirectory::TContext* ctxt); voidSetAccessKey(const TString& accessKey); virtual voidSetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); voidSetSecretKey(const TString& secretKey); virtual Int_tTFile::SysClose(Int_t fd); virtual Int_tTFile::SysOpen(const char* pathname, Int_t flags, UInt_t mode); virtual Int_tTFile::SysRead(Int_t fd, void* buf, Int_t len); virtual Long64_tTFile::SysSeek(Int_t fd, Long64_t offset, Int_t whence); virtual Int_tTFile::SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); virtual Int_tTFile::SysSync(Int_t fd); virtual Int_tTFile::SysWrite(Int_t fd, const void* buf, Int_t len); voidTDirectory::UnregisterContext(TDirectory::TContext* ctxt); Int_tTFile::WriteBufferViaCache(const char* buf, Int_t len). private:. TS3WebFile(); Bool_tGetCredentialsFromEnv(const char* accessKeyEnv, const char* secretKeyEnv, TString& outAccessKey, TString& outSecretKey); Bool_tParseOptions(Option_t* options, TString& accessKey, TString& secretKey). Data Members; public:. enum TFile::EAsyncOpenStatus { kAOSNotAsync; kAOSFailure; kAOSInProgress; kAOSSuccess; };; enum TFile::EOpenTimeOut { kInstantTimeout; kEternalTimeout; };; enum TFile::ECacheAction { kDisconnect; kDoNotDisconnect; };; enum TFile::EStatusBits { kRecovered; kHasReferences; kDevNull; kWriteError; kBinaryFile; kRedirected; };; enum TFile::ERelativeTo { kBeg; kCur; kEnd; };; enum TFile::[unnamed] { kStartBigFile; };; enum TFile::EFileType { kDefault; kLocal; kNet; kWeb; kFile; kMerge; };; enum TDirectoryFile::[unnamed] { kCloseDirectory; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TArchiveFile*TFile::fArchive!Archive file from which we re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:19789,access,accessKeyEnv,19789,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,2,['access'],"['accessKey', 'accessKeyEnv']"
Security," Int_t Update (Long64_t avgsize=-1);  Update accumulated information about the elements of the collection (e.g. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCollection.html:5565,Hash,Hash,5565,doc/master/classTFileCollection.html,https://root.cern,https://root.cern/doc/master/classTFileCollection.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzE4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar& px, ROOT::Math::PxPyPzE4D<double>::Scalar& py, ROOT::Math::PxPyPzE4D<double>::Scalar& pz, ROOT::Math::PxPyPzE4D<double>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar E() const; { return fT;}. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzE4D_double_.html:5147,access,accessors,5147,root/html526/ROOT__Math__PxPyPzE4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzE4D_double_.html,5,['access'],['accessors']
Security," List of all members ; TPackageDescription Class Reference. . Definition at line 158 of file TSessionViewer.h. Public Member Functions; const char * GetName () const override;  Returns name of object. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackageDescription.html:1229,Hash,Hash,1229,doc/master/classTPackageDescription.html,https://root.cern,https://root.cern/doc/master/classTPackageDescription.html,2,['Hash'],['Hash']
Security," List of all members ; TPacketizer::TFileStat Class Reference. . Definition at line 65 of file TPacketizer.cxx. Public Member Functions;  TFileStat (TFileNode *node, TDSetElement *elem);  ; TDSetElement * GetElement () const;  ; Long64_t GetNextEntry () const;  ; TFileNode * GetNode () const;  ; Bool_t IsDone () const;  ; void MoveNextEntry (Long64_t step);  ; void SetDone ();  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPacketizer_1_1TFileStat.html:1199,Hash,Hash,1199,doc/master/classTPacketizer_1_1TFileStat.html,https://root.cern,https://root.cern/doc/master/classTPacketizer_1_1TFileStat.html,2,['Hash'],['Hash']
Security," List of all members ; TSessionDescription Class Reference. . Definition at line 127 of file TSessionViewer.h. Public Member Functions; const char * GetName () const override;  Returns name of object. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionDescription.html:1229,Hash,Hash,1229,doc/master/classTSessionDescription.html,https://root.cern,https://root.cern/doc/master/classTSessionDescription.html,2,['Hash'],['Hash']
Security," Long_tfBinDataLength! length of binary data; TConditionfCond! condition used to wait for processing; TStringfContent! text content (if any); TStringfContentType! type of content; TStringfFileName! file name; TStringfHeader! response header like ContentEncoding, Cache-Control and so on; TStringfMethod! request method like GET or POST; TStringfPathName! item path; void*fPostData! binary data received with post request; Long_tfPostDataLength! length of binary data; TStringfQuery! additional arguments; TStringfRequestHeader! complete header, provided with request; TStringfTopName! top item name; TStringfUserName! authenticated user name (if any); Int_tfZipping! indicate if content should be zipped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpCallArg(); constructor. ~THttpCallArg(); destructor. TString AccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); method used to get or set http header in the string buffer; Header has following format:; field1 : value1\r\n; field2 : value2\r\n; Such format corresponds to header format in HTTP requests. TString CountHeader(const TString& buf, Int_t number = -1111) const; method used to counter number of headers or returns name of specified header. void SetPostData(void* data, Long_t length); set data, posted with the request; buffer should be allocated with malloc(length+1) call,; while last byte will be set to 0; Than one could use post data as null-terminated string. void SetBinData(void* data, Long_t length); set binary data, which will be returned as reply body. void SetPathAndFileName(const char* fullpath); set complete path of requested http element; For instance, it could be ""/folder/subfolder/get.bin""; Here ""/folder/subfolder/"" is element path and ""get.bin"" requested file.; One could set path and file name separately. TString GetHeader(const char* name); return specified header. void AddHeader(const char* name, const char* value); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpCallArg.html:7777,Access,AccessHeader,7777,root/html534/THttpCallArg.html,https://root.cern,https://root.cern/root/html534/THttpCallArg.html,2,['Access'],['AccessHeader']
Security," Lorentz vectors in four dimensions, based on ROOT::Math::LorentzVector, are defined by Math/Vector4D.h:. ROOT::Math::XYZTVector vector based on x,y,z,t coordinates (cartesian); ROOT::Math::PtEtaPhiEVector vector based on pt (rho),eta,phi and E (t) coordinates; ROOT::Math::PtEtaPhiMVector vector based on pt (rho),eta,phi and M (t) coordinates; ROOT::Math::PxPyPzMVector vector based on px,py,pz and M (mass) coordinates; ROOT::Math::PxPyPzEVector vector based on px,py,pz and E (energy) coordinates. The metric used for any such LorentzVector is (-,-,-,+). Operations. Constructors and Assignment; A vector can be constructed from its coordinate representation:; ROOT::Math::PtEtaPhiMVector v1(10. /*pt*/, 0.1 /*eta*/, 0.24 /*phi*/, 5 /*M*/);; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; v1@ v1Definition rootcling_impl.cxx:3701; In addition, the vector classes can be constructed from any object that implements the accessors x(), y() and z(). This can be a vector using a different coordinate system, or even an object from a different package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); qfloat * qDefinition THbookFile.cxx:89; v3@ v3Definition rootcling_impl.cxx:3703. Arithmetic Operations; The following operations are possible between vector classes, even of different coordinate system types:; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; a#define a(i)Definition RSha256.hxx:99; v2@ v2Definition rootcling_impl.cxx:3702; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous. Other Methods; The vector classes support methods for:. computation of the dot product via Dot(),; computation of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:6280,access,accessors,6280,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['access'],['accessors']
Security," Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationFoldResult;  CCrossValidationResultClass to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation ;  CCvSplit;  CCvSplitKFolds;  CCvSplitKFoldsExpr;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all the data information ;  ►CDataSetFactoryClass that contains all the data information ;  CEventStats;  CDataSetInfoClass that contains all the data information ;  CDataSetManagerClass that contains all the data information ;  CDecisionTreeImplementation of a Decision Tree ;  CDecisionTreeNode;  CDeleteFunctor_t;  CDTNodeTrainingInfo;  CEnvelopeAbstract base class for all high level ml algorithms, you can book ml methods like BDT, MLP ;  CEvent;  CExpectedErrorPruneToolA helper class to prune a decision tree using the expected error (C4.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:83715,validat,validation,83715,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,4,['validat'],['validation']
Security," Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 1. Extracting an object from a TFile. File can be local on your disk or remote accessible for instance through http:; root [0] TFile* file = TFile::Open(""http://someserver/somefile.root"");. You can list the objects inside the file using .ls:; root [1] .ls; TFile** hsimple.root Demo ROOT file with histograms; TFile* hsimple.root Demo ROOT file with histograms; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple. You can access objects inside the files by their names, either by using this name as a variable on the prompt:; root [2] hpx->Draw();. In regular code you should use TFile::GetObject():; root [3] TH1* readThis = 0;; root [4] file->GetObject(""hpx"", readThis);. Now let's try this out: get the TTree called ""MyTree"" from a file located at http://root.cern.ch/root/files/tutorials/mockupx.root Note that you don't need to download it with your browser: you just specify the http:// location as an argument to TFile::Open(). Once you have the TTree object, call Print() on it to see its structure",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/1-extracting-object-tfile.html:1977,access,accessible,1977,d/1-extracting-object-tfile.html,https://root.cern,https://root.cern/d/1-extracting-object-tfile.html,1,['access'],['accessible']
Security," Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TAuthenticate.h>. Inheritance diagram for TAuthenticate:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ ESecurity. enum TAuthenticate::ESecurity. EnumeratorkClear ; kUnsupported ; kKrb5 ; kGlobus ; kSSH ; kRfio . Definition at line 60 of file TAuthenticate.h. Constructor & Destructor Documentation. ◆ TAuthenticate(). TAuthenticate::TAuthenticate ; (; TSocket * ; sock, . const char * ; remote, . const char * ; proto, . const char * ; user = """" . ). Create authentication object. ; Definition at line 164 of file TAuthenticate.cxx. ◆ ~TAuthenticate(). virtual TAuthenticate::~TAuthenticate ; (; ). inlinevirtual . Definition at line 131 of file TAuthenticate.h. Member Function Documentation. ◆ Authenticate(). Bool_t TAuthenticate::Authenticate ; (; ). Authenticate to remote rootd or proofd server. ; Return kTRUE if authentication succeeded. ; Definition at line 369 of file TAuthenticate.cxx. ◆ AuthError(). void TAuthenticate::AuthError ; (; const char * ; where, . Int_t ; error . ). static . Print error string depending on error code. ; Definition at line 1261 of file TAuthenticate.cxx. ◆ AuthExists(). Int_t TAuthenticate::AuthExists ; (; TString ; username, . Int_t ; method, . const char * ; options, . Int_t * ; message, . Int_t * ; rflag, . CheckSecCtx_t ; checksecctx . ). Check if we have a valid established sec context in memory Retrieves relevant info and negotiates with server. ; options = ""Opt,strlen(username),username.Data()"" message = kROOTD_USER, ... ; Definition at line 2276 of file TAuthenticate.cxx. ◆ CatchTimeOut(). void TAuthenticate::CatchTimeOut ; (; ). Called in connection with a timer timeout. ; Definition at line 353 of file TAuthenticate.cxx. ◆ CheckHost(). Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:21341,Authenticat,Authenticate,21341,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['Authenticat'],['Authenticate']
Security," Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Inheritance diagram for TIconBoxThumb:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TIconBoxThumb(). TIconBoxThumb::TIconBoxThumb ; (; const char * ; name, . const TGPicture * ; spic, . const TGPicture * ; pic . ). inline . Definition at line 244 of file TRootBrowserLite.cxx. Member Function Documentation. ◆ GetName(). const char * TIconBoxThumb::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 250 of file TRootBrowserLite.cxx. ◆ Hash(). ULong_t TIconBoxThumb::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TIconBoxThumb::HashULong_t Hash() const overrideReturn hash value for this object.Definition TRootBrowserLite.cxx:249; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTIconBoxThumb.html:10441,hash,hash,10441,doc/master/classTIconBoxThumb.html,https://root.cern,https://root.cern/doc/master/classTIconBoxThumb.html,1,['hash'],['hash']
Security," Member Functions |; Public Attributes |; List of all members ; TEveHit Class Reference. . Definition at line 79 of file TEveVSDStructs.h. Public Member Functions;  TEveHit ();  ;  ~TEveHit () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveHit.html:1176,Hash,Hash,1176,doc/master/classTEveHit.html,https://root.cern,https://root.cern/doc/master/classTEveHit.html,2,['Hash'],['Hash']
Security," Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfStringwrapped TString. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t Compare(const TObject* obj) const; string compare the argument with this object. Bool_t IsEqual(const TObject* obj) const; return kTRUE if the argument has the same content as this object. TObjString(const char* s = """"); { }. TObjString(const TObjString& s); { }. ~TObjString(); { }. const char * GetName() const; { return fString; }. ULong_t Hash() const; { return fString.Hash(); }. void FillBuffer(char*& buffer); { fString.FillBuffer(buffer); }. void Print(Option_t* ) const; { Printf(""TObjString = %s"", (const char*)fString); }. Bool_t IsSortable() const; { return kTRUE; }. void ReadBuffer(char*& buffer); { fString.ReadBuffer(buffer); }. void SetString(const char* s); { fString = s; }. TString GetString() const; { return fString; }. Int_t Sizeof() const; { return fString.Sizeof(); }. » Author: Fons Rademakers 12/11/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TObjString.html:6203,Hash,Hash,6203,root/html604/TObjString.html,https://root.cern,https://root.cern/root/html604/TObjString.html,2,['Hash'],['Hash']
Security," Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfStringwrapped TString. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t Compare(const TObject* obj) const; string compare the argument with this object. Bool_t IsEqual(const TObject* obj) const; return kTRUE if the argument has the same content as this object. TObjString(const char* s = """"); { }. TObjString(const TObjString& s); { }. ~TObjString(); { }. const char * GetName() const; { return fString; }. ULong_t Hash() const; { return fString.Hash(); }. void FillBuffer(char*& buffer); { fString.FillBuffer(buffer); }. void Print(Option_t* ) const; { Printf(""TObjString = %s"", (const char*)fString); }. Bool_t IsSortable() const; { return kTRUE; }. void ReadBuffer(char*& buffer); { fString.ReadBuffer(buffer); }. void SetString(const char* s); { fString = s; }. TString GetString() const; { return fString; }. Int_t Sizeof() const; { return fString.Sizeof(); }. » Author: Fons Rademakers 12/11/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObjString.html:6203,Hash,Hash,6203,root/html602/TObjString.html,https://root.cern,https://root.cern/root/html602/TObjString.html,2,['Hash'],['Hash']
Security," N = 1> . template<unsigned int M> . ROOT::Math::KahanSum< T, N >::KahanSum ; (; KahanSum< T, M > const & ; other). inline . Constructor to create a KahanSum from another KahanSum with a different number of accumulators. ; Definition at line 157 of file Util.h. Member Function Documentation. ◆ Accumulate(). template<typename T = double, unsigned int N = 1> . template<class Iterator > . static KahanSum< T, N > ROOT::Math::KahanSum< T, N >::Accumulate ; (; Iterator ; begin, . Iterator ; end, . T ; initialValue = T{} . ). inlinestatic . Iterate over a range and return an instance of a KahanSum. ; See Add(Iterator,Iterator) for details. Parameters. [in]beginBeginning of a range. ; [in]endEnd of the range. ; [in]initialValueOptional initial value. . Definition at line 211 of file Util.h. ◆ Add() [1/3]. template<typename T = double, unsigned int N = 1> . template<class Container_t > . void ROOT::Math::KahanSum< T, N >::Add ; (; const Container_t & ; inputs). inline . Fill from a container that supports index access. ; Parameters. [in]inputsContainer with index access such as std::vector or array. . Definition at line 195 of file Util.h. ◆ Add() [2/3]. template<typename T = double, unsigned int N = 1> . template<class Iterator > . void ROOT::Math::KahanSum< T, N >::Add ; (; Iterator ; begin, . Iterator ; end . ). inline . Accumulate from a range denoted by iterators. ; This function will auto-vectorise with random-access iterators. Parameters. [in]beginBeginning of a range. Needs to be a random access iterator for automatic vectorisation, because a contiguous block of memory needs to be read. ; [in]endEnd of the range. . Definition at line 180 of file Util.h. ◆ Add() [3/3]. template<typename T = double, unsigned int N = 1> . void ROOT::Math::KahanSum< T, N >::Add ; (; T ; x). inline . Single-element accumulation. Will not vectorise. ; Definition at line 165 of file Util.h. ◆ AddIndexed(). template<typename T = double, unsigned int N = 1> . void ROOT::Math::KahanSum< T, N >",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1KahanSum.html:8266,access,access,8266,doc/master/classROOT_1_1Math_1_1KahanSum.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1KahanSum.html,1,['access'],['access']
Security," NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring). void ProcessOptions(). void AddXMLTo(void* parent); XML file writing. void ReadXML(void* pdfnode); XML file reading. TMVA::PDF* ThisPDF( void ); return global ""this"" pointer of PDF. explicit PDF(const TString& name, Bool_t norm = kTRUE). TH1* GetPDFHist() const; histogram underlying the PDF. { return fPDFHist; }. TGraph* GetGraph() const; { return fGraph; }. TH1* GetOriginalHist() const; { return fHistOriginal; }. TH1* GetSmoothedHist() const; { return fHist; }. TH1* GetNSmoothHist() const; { return fNSmoothHist; }. TSpline* GetSpline() const; accessors. { return fSpline; }. Int_t GetNBins() const; { return fHist->GetNbinsX(); }. Double_t GetXmin() const; { return fHist->GetXaxis()->GetXmin(); }. Double_t GetXmax() const; { return fHist->GetXaxis()->GetXmax(); }. TMVA::PDF::EInterpolateMethod GetInterpolMethod(); { return fInterpolMethod;}. const char* GetName() const; modified name (remove TMVA::). { return fPDFName; }. void SetReadingVersion(UInt_t rv); TMVA version control (for weight files). { fReadingVersion = rv; }. UInt_t GetReadingVersion() const; { return fReadingVersion; }. Double_t GetPdfHistBinWidth() const. Bool_t UseHistogram() const; do we use the original histogram as reference ?. { return fUseHistogram; }. PDF*& GetThisPdfThreadLocal(); static pointer to this object; This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. { TTHREAD_TLS(PDF*) fgThisPDF(nullptr); return fgThisPDF; }. » Author: Asen Christov, Andreas Hoeck",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDF.html:14140,access,accessors,14140,root/html602/TMVA__PDF.html,https://root.cern,https://root.cern/root/html602/TMVA__PDF.html,2,['access'],['accessors']
Security," Name; Intrinsic; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedList**_arr! Array of linked lists storing elements in each slot; Int_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name) const; Return the object with given name from the table. RooAbsArg* findArg(const RooAbsArg* arg) const. TObject* find(const TObject* arg) const; Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given pointers in table. ~RooHashTable(); Destructor. Int_t size() const; { return _size ; }. Int_t entries() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHashTable.html:6749,hash,hashArg,6749,root/html532/RooHashTable.html,https://root.cern,https://root.cern/root/html532/RooHashTable.html,2,['hash'],['hashArg']
Security," Name; Intrinsic; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedList**_arr! Array of linked lists storing elements in each slot; Int_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name) const; Return the object with given name from the table. TObject* find(const TObject* arg) const; Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given pointers in table. ~RooHashTable(); Destructor. Int_t size() const; { return _size ; }. ULong_t hash(const TObject* arg) const; Return hash value calculate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHashTable.html:6611,hash,hashArg,6611,root/html528/RooHashTable.html,https://root.cern,https://root.cern/root/html528/RooHashTable.html,2,['hash'],['hashArg']
Security," Name; Intrinsic; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedList**_arr! Array of linked lists storing elements in each slot; Int_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name); Return the object with given name from the table. TObject* find(const TObject* hashArg); Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given pointers in table. ~RooHashTable(); Destructor. Int_t size() const; { return _size ; }. ULong_t hash(const TObject* arg) const; Return hash value calculated by met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHashTable.html:6625,hash,hashArg,6625,root/html526/RooHashTable.html,https://root.cern,https://root.cern/root/html526/RooHashTable.html,1,['hash'],['hashArg']
Security," OpenGL; OPENGL_INCLUDE_DIR; PATH; Location where to find GL/gl.h. OPENGL_gl_LIBRARY; PATH; Full path to GL library. PCRE; PCRE_CONFIG_EXECUTABLE; PATH; Full path to pcre_config program. PostgreSQL; POSTGRESQL_INCLUDE_DIR; PATH; Directory where to find l ibpq-fe.h. POSTGRESQL_LIBRARY; PATH; Full path to pq library. Pythia 6; PYTHIA6_LIBRARY; PATH; Full path to pythia6 library. Pythia 8; PYTHIA8_DIR; ENV; Environment variable pointing to installation of Pythia8. PYTHIA8_INCLUDE_DIR; PATH; Directory where to find Pythia8/Pythia.h. PYTHIA8_LIBRARY; PATH; Full path to Pythia8 library. Python; PYTHON_EXECUTABLE; PATH; Python interpreter executable. PYTHON_INCLUDE_DIR; PATH; Directory where to find Python.h. PYTHON_LIBRARY; PATH; Full path to Python library. XROOTD; XROOTD_ROOT_DIR; PATH; Directory where to find XROOTD. Basic CMake Usage; This section explains basic aspects of CMake which you may need in your day-to-day usage.; CMake comes with extensive documentation, in the form of html files, and as online help accessible via the cmake executable itself. Execute cmake --help for further help options.; CMake allows you to specify a build tool (e.g., GNU make, Visual Studio, or Xcode). If not specified on the command line, CMake tries to guess which build tool to use, based on your environment. Once it has identified your build tool, CMake uses the corresponding Generator to create files for your build tool (e.g., Makefiles or Visual Studio or Xcode project files). You can explicitly specify the generator with the command line option -G ""Name of the generator"". To see a list of the available generators on your system, execute; $ cmake --help. This will list the generator names at the end of the help text.; Generators’ names are case-sensitive, and may contain spaces. For this reason, you should enter them exactly as they are listed in the cmake --help output, in quotes. For example, to generate project files specifically for Visual Studio 12, you can execute:; $ cmake -G ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:21217,access,accessible,21217,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['access'],['accessible']
Security," Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; Int_tGetNx() const; Int_tGetNy() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetSegmentDisplay() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGotoEntry(Long64_t e)MENU ; voidGotoFollowing()MENU ; voidGotoNext()MENU ; voidGotoPreceding()MENU ; voidGotoPrevious()MENU ; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSpider.html:4490,Hash,Hash,4490,root/html530/TSpider.html,https://root.cern,https://root.cern/root/html530/TSpider.html,3,['Hash'],['Hash']
Security," Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; Int_tGetNx() const; Int_tGetNy() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetSegmentDisplay() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGotoEntry(Long64_t e)MENU ; voidGotoFollowing()MENU ; voidGotoNext()MENU ; voidGotoPreceding()MENU ; voidGotoPrevious()MENU ; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpider.html:4358,Hash,Hash,4358,root/html602/TSpider.html,https://root.cern,https://root.cern/root/html602/TSpider.html,2,['Hash'],['Hash']
Security," Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; Bool_tTEllipse::GetNoEdges() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTEllipse::GetPhimax() const; Double_tTEllipse::GetPhimin() const; Double_tTEllipse::GetR1() const; Double_tTEllipse::GetR2() const; Double_tTEllipse::GetTheta() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tTEllipse::GetX1() const; Double_tTEllipse::GetY1() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTEllipse::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TArc.html:3331,Hash,Hash,3331,root/html526/TArc.html,https://root.cern,https://root.cern/root/html526/TArc.html,4,['Hash'],['Hash']
Security," Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; Bool_tTEllipse::GetNoEdges() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTEllipse::GetPhimax() const; Double_tTEllipse::GetPhimin() const; Double_tTEllipse::GetR1() const; Double_tTEllipse::GetR2() const; Double_tTEllipse::GetTheta() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tTEllipse::GetX1() const; Double_tTEllipse::GetY1() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTEllipse::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TArc.html:3331,Hash,Hash,3331,root/html530/TArc.html,https://root.cern,https://root.cern/root/html530/TArc.html,6,['Hash'],['Hash']
Security," Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; Bool_tTEllipse::GetNoEdges() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTEllipse::GetPhimax() const; Double_tTEllipse::GetPhimin() const; Double_tTEllipse::GetR1() const; Double_tTEllipse::GetR2() const; Double_tTEllipse::GetTheta() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tTEllipse::GetX1() const; Double_tTEllipse::GetY1() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTEllipse::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TArc.html:3288,Hash,Hash,3288,root/html602/TArc.html,https://root.cern,https://root.cern/root/html602/TArc.html,4,['Hash'],['Hash']
Security," Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tTLeaf::GetOffset() const; virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetValue(Int_t i = 0) const; virtual void*GetValuePointer() const; char*GetValueString() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidImport(TClonesArray* list, Int_t n); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTLeaf::IsOnTerminalBranch() const; virtual Bool_tTLeaf::IsRange() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTLeaf::IsUnsigned() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLeafC.html:2909,Hash,Hash,2909,root/html528/TLeafC.html,https://root.cern,https://root.cern/root/html528/TLeafC.html,1,['Hash'],['Hash']
Security," Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tTLeaf::GetOffset() const; virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetValue(Int_t i = 0) const; virtual void*GetValuePointer() const; char*GetValueString() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidImport(TClonesArray* list, Int_t n); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTLeaf::IsOnTerminalBranch() const; virtual Bool_tTLeaf::IsRange() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTLeaf::IsUnsigned() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TLeafC.html:2909,Hash,Hash,2909,root/html530/TLeafC.html,https://root.cern,https://root.cern/root/html530/TLeafC.html,2,['Hash'],['Hash']
Security," Option_t*TObject::GetOption() const; Int_tTEveElement::GetParentIgnoreCnt() const; virtual TObject*TEveElement::GetRenderObject(const TEveException& eh = ""TEveElement::GetRenderObject "") const; virtual Bool_tTEveElement::GetRnrAnything() const; virtual Bool_tTEveElement::GetRnrChildren() const; virtual Bool_tTEveElement::GetRnrSelf() const; virtual Bool_tTEveElement::GetRnrState() const; virtual UChar_tTEveElement::GetSelectedLevel() const; Bool_tGetShowTitleBar() const; TRef&TEveElement::GetSource(); TObject*TEveElement::GetSourceObject() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; void*TEveElement::GetUserData() const; TEveElement*TEveElement::GetVizModel() const; const TString&TEveElement::GetVizTag() const; virtual Bool_tTEveElement::HandleElementPaste(TEveElement* el); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tTEveElement::HasChild(TEveElement* el); Bool_tTEveElement::HasChildren() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tTEveElement::HasMainColor() const; virtual Bool_tTEveElement::HasMainTrans() const; Bool_tTEveElement::HasParents() const; virtual Bool_tTEveProjectable::HasProjecteds() const; virtual voidTEveElement::HighlightElement(Bool_t state); voidTEveElement::IncDenyDestroy(); virtual voidTEveElement::IncImpliedHighlighted(); virtual voidTEveElement::IncImpliedSelected(); voidTEveElement::IncParentIgnoreCnt(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTEveElement::InitMainTrans(Bool_t can_edit = kTRUE); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsAncestorOf(TEveWindow* win); Bool_tIsCurrent() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveWindow.html:9203,Hash,Hash,9203,root/html528/TEveWindow.html,https://root.cern,https://root.cern/root/html528/TEveWindow.html,1,['Hash'],['Hash']
Security," Option_t*TObject::GetOption() const; Int_tTEveElement::GetParentIgnoreCnt() const; virtual TObject*TEveElement::GetRenderObject(const TEveException& eh) const; virtual Bool_tTEveElement::GetRnrAnything() const; virtual Bool_tTEveElement::GetRnrChildren() const; virtual Bool_tTEveElement::GetRnrSelf() const; virtual Bool_tTEveElement::GetRnrState() const; virtual UChar_tTEveElement::GetSelectedLevel() const; Bool_tTEveWindow::GetShowTitleBar() const; TRef&TEveElement::GetSource(); TObject*TEveElement::GetSourceObject() const; TGTab*GetTab() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; void*TEveElement::GetUserData() const; TEveElement*TEveElement::GetVizModel() const; const TString&TEveElement::GetVizTag() const; virtual Bool_tTEveElement::HandleElementPaste(TEveElement* el); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tTEveElement::HasChild(TEveElement* el); Bool_tTEveElement::HasChildren() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tTEveElement::HasMainColor() const; virtual Bool_tTEveElement::HasMainTrans() const; Bool_tTEveElement::HasParents() const; virtual Bool_tTEveProjectable::HasProjecteds() const; virtual voidTEveElement::HighlightElement(Bool_t state); voidTEveElement::IncDenyDestroy(); virtual voidTEveElement::IncImpliedHighlighted(); virtual voidTEveElement::IncImpliedSelected(); voidTEveElement::IncParentIgnoreCnt(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTEveElement::InitMainTrans(Bool_t can_edit = kTRUE); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTEveWindow::IsAncestorOf(TEveWindow* win); Bool_tTEveWindow::IsCurrent() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveWindowTab.html:9411,Hash,Hash,9411,root/html530/TEveWindowTab.html,https://root.cern,https://root.cern/root/html530/TEveWindowTab.html,5,['Hash'],['Hash']
Security," PrintTable()Print the class table.Definition TClassTable.cxx:823; TClassTable::GetPragmaBitsstatic Int_t GetPragmaBits(const char *name)Returns the pragma bits as specified in the LinkDef.h file.Definition TClassTable.cxx:660; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetIDstatic Version_t GetID(const char *cname)Returns the ID of a class.Definition TClassTable.cxx:647; TClassTable::IdMap_tROOT::TMapTypeToClassRec IdMap_tDefinition TClassTable.h:43; TClassTable::SortTablestatic void SortTable()Sort the class table by ascending class ID's.Definition TClassTable.cxx:857; TClassTable::GetProtoNormstatic TProtoClass * GetProtoNorm(const char *cname)Given the class normalized name returns the TClassProto object for the class.Definition TClassTable.cxx:770; TClassTable::GetDictNormstatic DictFuncPtr_t GetDictNorm(const char *cname)Given the normalized class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:717; TClassTable::fgAlternatestatic ROOT::TClassAlt ** fgAlternateDefinition TClassTable.h:46; TClassTable::Printvoid Print(Option_t *option="""") const overridePrint the class table.Definition TClassTable.cxx:328; TClassTable::Terminatestatic void Terminate()Deletes the class table (this static class function calls the dtor).Definition TClassTable.cxx:878; TClassTable::GetProtostatic TProtoClass * GetProto(const char *cname)Given the class name returns the TClassProto object for the class.Definition TClassTable.cxx:742; TClassTable::fgTallystatic std::atomic< UInt_t > fgTallyDefinition TClassTable.h:51; TClassTable::TClassTableTClassTable()TClassTable is a singleton (i.e. only one can exist per application).Definition TClassTable.cxx:264; TClassTable::Nextstatic char * Next()Returns next class from sorted class table.Definition TClassTable.cxx:807; TClassTable::Atstatic c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:42411,hash,hash,42411,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['hash'],['hash']
Security," Public License has appeared, then you can specify; that version instead if you wish.) Do not make any other change in; these notices.; ; Once this change is made in a given copy, it is irreversible for; that copy, so the ordinary GNU General Public License applies to all; subsequent copies and derivative works made from that copy. This option is useful when you wish to copy part of the code of; the Library into a program that is not a library. 4. You may copy and distribute the Library (or a portion or; derivative of it, under Section 2) in object code or executable form; under the terms of Sections 1 and 2 above provided that you accompany; it with the complete corresponding machine-readable source code, which; must be distributed under the terms of Sections 1 and 2 above on a; medium customarily used for software interchange. If distribution of object code is made by offering access to copy; from a designated place, then offering equivalent access to copy the; source code from the same place satisfies the requirement to; distribute the source code, even though third parties are not; compelled to copy the source along with the object code. 5. A program that contains no derivative of any portion of the; Library, but is designed to work with the Library by being compiled or; linked with it, is called a ""work that uses the Library"". Such a; work, in isolation, is not a derivative work of the Library, and; therefore falls outside the scope of this License. However, linking a ""work that uses the Library"" with the Library; creates an executable that is a derivative of the Library (because it; contains portions of the Library), rather than a ""work that uses the; library"". The executable is therefore covered by this License.; Section 6 states terms for distribution of such executables. When a ""work that uses the Library"" uses material from a header file; that is part of the Library, the object code for the work may be a; derivative work of the Library even though the sour",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:14476,access,access,14476,d/license.html,https://root.cern,https://root.cern/d/license.html,2,['access'],['access']
Security," Public Member Functions;  DataSetFactory ();  constructor ;  ;  ~DataSetFactory ();  destructor ;  ; DataSet * CreateDataSet (DataSetInfo &, DataInputHandler &);  steering the creation of a new dataset ;  ; virtual TClass * IsA () const;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSetFactory.html:1485,Hash,Hash,1485,doc/master/classTMVA_1_1DataSetFactory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSetFactory.html,2,['Hash'],['Hash']
Security," Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials The End. You are done - that was the introductory tutorial!. Image by Tangopaso; If you want to go on, have a look at the ROOT Courses section!; . ‹ Using a TSelector with PROOF; up. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/end.html:2118,Access,Accessing,2118,d/end.html,https://root.cern,https://root.cern/d/end.html,3,"['Access', 'access']","['Accessing', 'access']"
Security," PyPy, there are two new approaches: cffi for C and cppyy for C++. Both are part of the standard PyPy releases. There is also already a PyROOT version for the latter (see: http://root.cern.ch/drupal/content/pypyroot).; Cheers,; Wim. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Why? . I don't understand. You wish to maintain backwards compatibility. This implies maintaining the insanity that is the equivalence of ""."" and ""->"". Not only is this wrong, this egregiously ignores performance concerns that come with dereferencing. It also ensures that people using ROOT/Cling while learning C++ will have trouble compiling their programs using actual compilers. It implies that you intend to keep the (at best) insane class hierarchy TF1 <- TF2 <- TF3 and so on. This example shows some of the major design flaws in ROOT -- a 2-dimensional function IS a 1-dimensional function? There is no abstract base class? No templates? It implies that you plan to keep the pointless T in front of all the names of ROOT, even though you will have access to namespaces (finally) and thus can move past the 1970's C practice of avoiding name collisions by a sort of weird Hungarian notation. It implies that you plan to maintain the outdated interfaces which make no use of templates. Templates are one of the most powerful features of C++, are more relevant to performance critical tasks than inheritance, and help ensure the type-safety of code (thereby ensuring the accuracy of data by helping to prevent accidental narrowing etc). It implies that you intend to continue to encourage the use of bare new and delete operators, instead of relying on the more efficient, reliable, and safe method of using RAII. Why? This begs the obvious question: why bother migrating at all? You wish to migrate to the modern and superior C++11 in order to not take advantage of its features? Why not just simply maintain ROOT5 and CINT, and just refuse to upgrade? ROOT is not a particularly good ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:9474,access,access,9474,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['access'],['access']
Security," ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLSimAnMinimizerGSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer&); ROOT::Math::GSLSimAnMinimizer&operator=(const ROOT::Math::GSLSimAnMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLSimAnnealingfSolver. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnMinimizer(int type = 0). Default constructor. virtual ~GSLSimAnMinimizer(). Destructor (no operations). GSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. bool Minimize(); method to perform the minimization. unsigned int NCalls() const; number of calls. » Author: L. Moneta Wed Dec 20 17:16:32 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLSimAnMinimizer.html:6897,validat,validated,6897,root/html602/ROOT__Math__GSLSimAnMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLSimAnMinimizer.html,1,['validat'],['validated']
Security," ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLSimAnMinimizerGSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer&); ROOT::Math::GSLSimAnMinimizer&operator=(const ROOT::Math::GSLSimAnMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLSimAnnealingfSolver. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnMinimizer(int type = 0). Default constructor. virtual ~GSLSimAnMinimizer(). Destructor (no operations). GSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. bool Minimize(); method to perform the minimization. unsigned int NCalls() const; number of calls. » Author: L. Moneta Wed Dec 20 17:16:32 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__GSLSimAnMinimizer.html:6897,validat,validated,6897,root/html604/ROOT__Math__GSLSimAnMinimizer.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__GSLSimAnMinimizer.html,1,['validat'],['validated']
Security," ROOT::Math::SVector<double,2U*(2U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,2,2>fRep; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5545,Access,Access,5545,root/html602/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5545,Access,Access,5545,root/html602/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," ROOT::Math::SVector<double,3U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,4>fRep; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5545,Access,Access,5545,root/html602/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," ROOT::Math::SVector<double,4U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,3>fRep; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5545,Access,Access,5545,root/html602/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5545,Access,Access,5545,root/html602/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,5,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5545,Access,Access,5545,root/html602/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,6,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5545,Access,Access,5545,root/html602/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,7,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5545,Access,Access,5545,root/html602/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security," ROOT::Math::SVector<double,9U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,9,7>fRep; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5545,Access,Access,5545,root/html602/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,6,"['Access', 'access']","['Access', 'access', 'accessing']"
Security, RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TP,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:81891,access,access,81891,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['access'],['access']
Security, RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:353; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TP,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:81719,access,access,81719,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['access'],['access']
Security," Rademakers 12/11/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TObjString; 13#define ROOT_TObjString; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TObjString //; 19// //; 20// Collectable string class. This is a TObject containing a TString. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TObject.h""; 25#include ""TString.h""; 26 ; 27 ; 28class TObjString : public TObject {; 29 ; 30private:; 31 TString fString; // wrapped TString; 32 ; 33public:; 34 TObjString(const char *s = """") : fString(s) { }; 35 ~TObjString();; 36 Int_t Compare(const TObject *obj) const override;; 37 TString CopyString() const { return fString; }; 38 const char *GetName() const override { return fString; }; 39 ULong_t Hash() const override { return fString.Hash(); }; 40 void FillBuffer(char *&buffer) { fString.FillBuffer(buffer); }; 41 void Print(Option_t *) const override { Printf(""TObjString = %s"", (const char*)fString); }; 42 Bool_t IsSortable() const override { return kTRUE; }; 43 Bool_t IsEqual(const TObject *obj) const override;; 44 void ReadBuffer(char *&buffer) { fString.ReadBuffer(buffer); }; 45 void SetString(const char *s) { fString = s; }; 46 const TString &GetString() const { return fString; }; 47 Int_t Sizeof() const { return fString.Sizeof(); }; 48 TString &String() { return fString; }; 49 ; 50 ClassDefOverride(TObjString,1) //Collectable string class; 51};; 52 ; 53#endif; 54 ; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; kT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObjString_8h_source.html:1389,Hash,Hash,1389,doc/master/TObjString_8h_source.html,https://root.cern,https://root.cern/doc/master/TObjString_8h_source.html,1,['Hash'],['Hash']
Security," RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::DoErrorvirtual void DoError(int level, const char *location, const char *fmt, va_list va) constInterface to ErrorHandler (protected).Definition TObject.cxx:954; TObject::HandleTimervirtual Bool_t HandleTimer(TTimer *timer)Execute action in response of a timer timing out.Definition TObject.cxx:498; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::kIsOnHeap@ kIsOnHeapobject is on heapDefinition TObject.h:81; TObject::kNotDeleted@ kNotDeletedobject has not been deletedDefinition TObject.h:82; TObject::kBitMask@ kBitMaskDefinition TObject.h:86; TObject::kZombie@ kZombieobject ctor failedDefinition TObject.h:83; TObject::kInconsistent@ kInconsistentclass overload Hash but does call RecursiveRemove in destructorDefinition TObject.h:84; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; TObject::IsSortablevirtual Bool_t IsSortable() constDefinition TObject.h:150; TObject::GetOptionvirtual Option_t * GetOption() constDefinition TObject.h:139; TObject::fgDtorOnlystatic Longptr_t fgDtorOnlyobject for which to call dtor only (i.e. no delete)Definition TObject.h:47; TObject::InvertBitvoid InvertBit(UInt_t f)Definition TObject.h:201; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8h_source.html:24647,Hash,Hash,24647,doc/master/TObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html,1,['Hash'],['Hash']
Security," Region_t regb, Region_t result);  Calculates the difference between the union and intersection of two regions. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:32350,Hash,Hash,32350,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," RegisterWithTreeReader();; 105 void NotifyNewTree(TTree* newTree);; 106 ; 107 TBranch* SearchBranchWithCompositeName(TLeaf *&myleaf, TDictionary *&branchActualType, std::string &err);; 108 virtual void CreateProxy();; 109 static const char* GetBranchDataType(TBranch* branch,; 110 TDictionary* &dict,; 111 TDictionary const *curDict);; 112 ; 113 virtual const char* GetDerivedTypeName() const = 0;; 114 ; 115 Detail::TBranchProxy* GetProxy() const { return fProxy; }; 116 ; 117 void MarkTreeReaderUnavailable() { fTreeReader = nullptr; fSetupStatus = kSetupTreeDestructed; }; 118 ; 119 /// Stringify the template argument.; 120 static std::string GetElementTypeName(const std::type_info& ti);; 121 ; 122 void ErrorAboutMissingProxyIfNeeded();; 123 ; 124 bool fHaveLeaf : 1; ///< Whether the data is in a leaf; 125 bool fHaveStaticClassOffsets : 1; ///< Whether !fStaticClassOffsets.empty(); 126 EReadStatus fReadStatus : 2; ///< Read status of this data access; 127 ESetupStatus fSetupStatus = kSetupNotSetup; ///< Setup status of this data access; 128 TString fBranchName; ///< Name of the branch to read data from.; 129 TString fLeafName;; 130 TTreeReader* fTreeReader; ///< Tree reader we belong to; 131 TDictionary* fDict; ///< Type that the branch should contain; 132 Detail::TBranchProxy* fProxy = nullptr; ///< Proxy for this branch, owned by TTreeReader; 133 TLeaf* fLeaf = nullptr;; 134 std::vector<Long64_t> fStaticClassOffsets;; 135 typedef EReadStatus (TTreeReaderValueBase::*Read_t)();; 136 Read_t fProxyReadFunc = &TTreeReaderValueBase::ProxyReadDefaultImpl; ///<! Pointer to the Read implementation to use.; 137 /**; 138 * If true, the reader will not do any type-checking against the actual; 139 * type held by the branch. Useful to just check if the current entry can; 140 * be read or not without caring about its value.; 141 * \note Only used by TTreeReaderOpaqueValue.; 142 */; 143 bool fOpaqueRead{false};; 144 ; 145 // FIXME: re-introduce once we have ClassDefInline!; 146 //Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:5663,access,access,5663,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,2,['access'],['access']
Security," Return pointer to Geometry with name. TCollection * GetListOfEnums(Bool_t load = kFALSE). TCollection * GetListOfFunctionTemplates(). TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return a dynamic list giving access to all TDataTypes (typedefs); currently defined. The list is populated on demand. Calling; gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the; TDataType is not already in the list itself and the type does exist,; a new TDataType will be created and added to the list. Calling; gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed throught the; list (plus the builtins types). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the name of the given include file corresponds to a class that; is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. void InitInterpreter(); Initialize the in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:29090,access,access,29090,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['access'],['access']
Security," Returns 0 in case of success and -1 in case of error. ; Definition at line 8258 of file TProof.cxx. ◆ Exec() [1/3]. Int_t TProof::Exec ; (; const char * ; cmd, . Bool_t ; plusMaster = kFALSE . ). Send command to be executed on the PROOF master and/or slaves. ; If plusMaster is kTRUE then exeucte on slaves and master too. Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6521 of file TProof.cxx. ◆ Exec() [2/3]. Int_t TProof::Exec ; (; const char * ; cmd, . const char * ; ord, . Bool_t ; logtomacro = kFALSE . ). Send command to be executed on node of ordinal 'ord' (use ""0"" for master). ; Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. If logtomacro is TRUE the text result of the action is saved in the fMacroLog TMacro, accessible via TMacro::GetMacroLog(); Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6589 of file TProof.cxx. ◆ Exec() [3/3]. Int_t TProof::Exec ; (; const char * ; cmd, . ESlaves ; list, . Bool_t ; plusMaster . ). private . Send command to be executed on the PROOF master and/or slaves. ; Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6533 of file TProof.cxx. ◆ ExistsDataSet(). Bool_t TProof::ExistsDataSet ; (; const char * ; dataset). virtual . Returns kTRUE if 'dataset' exists, kFALSE otherwise. ; Reimplemented in TProofLite.; Definition at line 10868 of file TProof.cxx. ◆ Feedback(). void TProof::Feedback ; (; TList * ; objs). Get list of feedback objects. ; Connect a slot to this signal to monitor the feedback object. ; Definition at line 9268 of file TProof.cxx. ◆ FinalizationDone(). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:88904,access,accessible,88904,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['access'],['accessible']
Security," Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitely specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel sockets that will; be used to connect to rootd. This option should be used on fat pipes; (i.e. high bandwidth, high latency links). The ideal number of parallel; sockets depends on the bandwidth*delay product. Generally 5-7 is a good; number.; For a descripti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:27442,access,accessable,27442,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,3,['access'],['accessable']
Security," Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel sockets that will; be used to connect to rootd. This option should be used on fat pipes; (i.e. high bandwidth, high latency links). The ideal number of parallel; sockets depends on the bandwidth*delay product. Generally 5-7 is a good; number.; For a descriptio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetFile.html:28435,access,accessable,28435,root/html534/TNetFile.html,https://root.cern,https://root.cern/root/html534/TNetFile.html,3,['access'],['accessable']
Security," Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncPtr_t GetDictNorm(const char* cname); Given the normalized class name returns the Dictionary() function of a class; (uses hash of name). TProtoClass * GetProto(const char* cname); Given the class name returns the TClassProto object for the class.; (uses hash of name). TProtoClass * GetProtoNorm(const char* cname); Given the class normalized name returns the TClassProto object for the class.; (uses hash of name). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable(). » Author: Fons Rademakers 11/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 15:39; This page has been automat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClassTable.html:9867,hash,hash,9867,root/html604/TClassTable.html,https://root.cern,https://root.cern/root/html604/TClassTable.html,1,['hash'],['hash']
Security," Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncPtr_t GetDictNorm(const char* cname); Given the normalized class name returns the Dictionary() function of a class; (uses hash of name). TProtoClass * GetProto(const char* cname); Given the class name returns the TClassProto object for the class.; (uses hash of name). TProtoClass * GetProtoNorm(const char* cname); Given the class normalized name returns the TClassProto object for the class.; (uses hash of name). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable(). » Author: Fons Rademakers 11/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-30 14:41; This page has been automat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClassTable.html:9867,hash,hash,9867,root/html602/TClassTable.html,https://root.cern,https://root.cern/root/html602/TClassTable.html,1,['hash'],['hash']
Security," ReturnsName of the file containing the class declaration ; Definition at line 115 of file TEnv.h. ◆ ExpandValue(). TString TEnvRec::ExpandValue ; (; const char * ; v). private . Replace all strings by the value defined in the shell (obtained via TSystem::Getenv()). ; Definition at line 334 of file TEnv.cxx. ◆ GetLevel(). EEnvLevel TEnvRec::GetLevel ; (; ); const. inline . Definition at line 112 of file TEnv.h. ◆ GetName(). const char * TEnvRec::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 109 of file TEnv.h. ◆ GetType(). const char * TEnvRec::GetType ; (; ); const. inline . Definition at line 111 of file TEnv.h. ◆ GetValue(). const char * TEnvRec::GetValue ; (; ); const. inline . Definition at line 110 of file TEnv.h. ◆ Hash(). ULong_t TEnvRec::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TEnvRec::HashULong_t Hash() const overrideReturn hash value for this object.Definition TEnv.h:113; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEnvRec.html:13071,hash,hash,13071,doc/master/classTEnvRec.html,https://root.cern,https://root.cern/doc/master/classTEnvRec.html,1,['hash'],['hash']
Security," ReturnsName of the file containing the class declaration ; Definition at line 156 of file TQueryResult.h. ◆ GetBytes(). Long64_t TQueryResult::GetBytes ; (; ); const. inline . Definition at line 129 of file TQueryResult.h. ◆ GetEndTime(). TDatime TQueryResult::GetEndTime ; (; ); const. inline . Definition at line 123 of file TQueryResult.h. ◆ GetEntries(). Long64_t TQueryResult::GetEntries ; (; ); const. inline . Definition at line 127 of file TQueryResult.h. ◆ GetFirst(). Long64_t TQueryResult::GetFirst ; (; ); const. inline . Definition at line 128 of file TQueryResult.h. ◆ GetInitTime(). Float_t TQueryResult::GetInitTime ; (; ); const. inline . Definition at line 139 of file TQueryResult.h. ◆ GetInputList(). TList * TQueryResult::GetInputList ; (; ). inline . Definition at line 125 of file TQueryResult.h. ◆ GetInputObject(). TObject * TQueryResult::GetInputObject ; (; const char * ; classname); const. Return first instance of class 'classname' in the input list. ; Useful to access TDSet, TEventList, ... ; Definition at line 516 of file TQueryResult.cxx. ◆ GetLibList(). const char * TQueryResult::GetLibList ; (; ); const. inline . Definition at line 134 of file TQueryResult.h. ◆ GetLogFile(). TMacro * TQueryResult::GetLogFile ; (; ); const. inline . Definition at line 131 of file TQueryResult.h. ◆ GetMergeTime(). Float_t TQueryResult::GetMergeTime ; (; ); const. inline . Definition at line 141 of file TQueryResult.h. ◆ GetNumMergers(). Int_t TQueryResult::GetNumMergers ; (; ); const. inline . Definition at line 145 of file TQueryResult.h. ◆ GetNumWrks(). Int_t TQueryResult::GetNumWrks ; (; ); const. inline . Definition at line 144 of file TQueryResult.h. ◆ GetOptions(). const char * TQueryResult::GetOptions ; (; ); const. inline . Definition at line 124 of file TQueryResult.h. ◆ GetOutputList(). TList * TQueryResult::GetOutputList ; (; ). inline . Definition at line 136 of file TQueryResult.h. ◆ GetParList(). const char * TQueryResult::GetParList ; (; ); const. i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQueryResult.html:18731,access,access,18731,doc/master/classTQueryResult.html,https://root.cern,https://root.cern/doc/master/classTQueryResult.html,1,['access'],['access']
Security," RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:36119,validat,validate,36119,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,1,['validat'],['validate']
Security," RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal the objects value. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Special version of readFromStream that disallows reading from stream. void writeToStream(ostream& os, Bool_t compact) const; Special version of writeToStream that disallows reading from stream. RooAbsCategory& dummyBlindState() const; Return reference to internal dummy RooCategory implementation; blinding state switch. Bool_t isHidden() const; If true, hiding mode is active. Double_t getHiddenVal(const RooArgSet* nset = 0) const; Bypass accessor to function value that also works in hidden mode. return getVal(nset). » Last changed: Thu Sep 23 19:58:11 2010 » Last generated: 2010-09-23 19:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsHiddenReal.html:33486,access,accessor,33486,root/html528/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html528/RooAbsHiddenReal.html,1,['access'],['accessor']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; Bool_thaveUnitNorm() const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:17929,Hash,Hash,17929,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,3,['Hash'],['Hash']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsAnaConvPdf::isDirectGenSafe(const RooAbsArg& arg) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBDecay.html:18754,Hash,Hash,18754,root/html530/RooBDecay.html,https://root.cern,https://root.cern/root/html530/RooBDecay.html,4,['Hash'],['Hash']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendPdf.html:18371,Hash,Hash,18371,root/html528/RooExtendPdf.html,https://root.cern,https://root.cern/root/html528/RooExtendPdf.html,101,['Hash'],['Hash']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tisDirectGenSafe(const RooAbsArg& arg) const; virtual Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsAnaConvPdf.html:19993,Hash,Hash,19993,root/html530/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsAnaConvPdf.html,1,['Hash'],['Hash']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsAnaConvPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBCPEffDecay.html:18874,Hash,Hash,18874,root/html530/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html530/RooBCPEffDecay.html,8,['Hash'],['Hash']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMultiVarGaussian.html:18435,Hash,Hash,18435,root/html530/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html530/RooMultiVarGaussian.html,1,['Hash'],['Hash']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsAnaConvPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBDecay.html:18417,Hash,Hash,18417,root/html526/RooBDecay.html,https://root.cern,https://root.cern/root/html526/RooBDecay.html,4,['Hash'],['Hash']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:18925,Hash,Hash,18925,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,93,['Hash'],['Hash']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tisDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:19656,Hash,Hash,19656,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,2,['Hash'],['Hash']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsAnaConvPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:18537,Hash,Hash,18537,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,8,['Hash'],['Hash']
Security," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:18098,Hash,Hash,18098,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,2,['Hash'],['Hash']
Security," RooHashTable(const RooHashTable& other); RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); virtual~RooHashTable(); voidTObject::AbstractMethod(const char* method) const; voidadd(TObject* arg, TObject* hashArg = 0); virtual voidTObject::AppendPad(Option_t* option = """"); Double_tavgCollisions() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; Int_tentries() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHashTable.html:707,Hash,HashMethod,707,root/html532/RooHashTable.html,https://root.cern,https://root.cern/root/html532/RooHashTable.html,6,"['Hash', 'hash']","['HashMethod', 'hashArg', 'hashMethod']"
Security," RooHashTable(const RooHashTable& other); RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); virtual~RooHashTable(); voidTObject::AbstractMethod(const char* method) const; voidadd(TObject* arg, TObject* hashArg = 0); virtual voidTObject::AppendPad(Option_t* option = """"); Double_tavgCollisions() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TObject*find(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHashTable.html:707,Hash,HashMethod,707,root/html526/RooHashTable.html,https://root.cern,https://root.cern/root/html526/RooHashTable.html,9,"['Hash', 'hash']","['HashMethod', 'hashArg', 'hashMethod']"
Security," Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 character is found. void WriteString(const char* s); Write string to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcess",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:40384,hash,hashsize,40384,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,7,['hash'],['hashsize']
Security," SetCoordinates(const ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar E() const; { return fT;}. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzE4D_Double32_t_.html:5499,access,accessors,5499,root/html526/ROOT__Math__PxPyPzE4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzE4D_Double32_t_.html,5,['access'],['accessors']
Security," Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; Double_tTGraph::GetMaximum() const; Int_tTGraph::GetMaxSize() const; virtual Double_tTGraph::GetMean(Int_t axis = 1) const; Double_tTGraph::GetMinimum() const; Int_tTGraph::GetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); TObject*GetObjectX() const; TObject*GetObjectY() const; virtual Option_t*TObject::GetOption() const; virtual Int_tTGraph::GetPoint(Int_t i, Double_t& x, Double_t& y) const; virtual Double_tTGraph::GetRMS(Int_t axis = 1) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetVarX() const; const char*GetVarY() const; Double_t*TGraph::GetX() const; TAxis*TGraph::GetXaxis() const; Double_t*TGraph::GetY() const; TAxis*TGraph::GetYaxis() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGraph::InitExpo(Double_t xmin = 0, Double_t xmax = 0); virtual voidTGraph::InitGaus(Double_t xmin = 0, Double_t xmax = 0); virtual voidTGraph::InitPolynom(Double_t xmin = 0, Double_t xmax = 0); virtual Int_tTGraph::InsertPoint()MENU ; virtual voidTObject::Inspect() constMENU ; virtual Double_tTGraph::Integral(Int_t first = 0, Int_t last = -1) const; Double_tIntegralHist(TH2* h, Option_t* option = """") const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGraph::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Int_tIsInside(Double_t x, Double_t y) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTranspar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCutG.html:7597,Hash,Hash,7597,root/html526/TCutG.html,https://root.cern,https://root.cern/root/html526/TCutG.html,1,['Hash'],['Hash']
Security," Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; Double_tTGraph::GetMaximum() const; Int_tTGraph::GetMaxSize() const; virtual Double_tTGraph::GetMean(Int_t axis = 1) const; Double_tTGraph::GetMinimum() const; Int_tTGraph::GetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); TObject*GetObjectX() const; TObject*GetObjectY() const; virtual Option_t*TObject::GetOption() const; virtual Int_tTGraph::GetPoint(Int_t i, Double_t& x, Double_t& y) const; virtual Double_tTGraph::GetRMS(Int_t axis = 1) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetVarX() const; const char*GetVarY() const; Double_t*TGraph::GetX() const; TAxis*TGraph::GetXaxis() const; Double_t*TGraph::GetY() const; TAxis*TGraph::GetYaxis() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGraph::InitExpo(Double_t xmin = 0, Double_t xmax = 0); virtual voidTGraph::InitGaus(Double_t xmin = 0, Double_t xmax = 0); virtual voidTGraph::InitPolynom(Double_t xmin = 0, Double_t xmax = 0); virtual Int_tTGraph::InsertPoint()MENU ; virtual voidTObject::Inspect() constMENU ; virtual Double_tTGraph::Integral(Int_t first = 0, Int_t last = -1) const; virtual Double_tIntegralHist(TH2* h, Option_t* option = """") const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGraph::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Int_tTGraph::IsInside(Double_t x, Double_t y) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAtt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCutG.html:8173,Hash,Hash,8173,root/html528/TCutG.html,https://root.cern,https://root.cern/root/html528/TCutG.html,6,['Hash'],['Hash']
Security," Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCanvas.html:47072,Access,Access,47072,root/html602/TCanvas.html,https://root.cern,https://root.cern/root/html602/TCanvas.html,2,['Access'],['Access']
Security," Such a; work, in isolation, is not a derivative work of the Library, and; therefore falls outside the scope of this License. However, linking a ""work that uses the Library"" with the Library; creates an executable that is a derivative of the Library (because it; contains portions of the Library), rather than a ""work that uses the; library"". The executable is therefore covered by this License.; Section 6 states terms for distribution of such executables. When a ""work that uses the Library"" uses material from a header file; that is part of the Library, the object code for the work may be a; derivative work of the Library even though the source code is not.; Whether this is true is especially significant if the work can be; linked without the Library, or if the work is itself a library. The; threshold for this to be true is not precisely defined by law. If such an object file uses only numerical parameters, data; structure layouts and accessors, and small macros and small inline; functions (ten lines or less in length), then the use of the object; file is unrestricted, regardless of whether it is legally a derivative; work. (Executables containing this object code plus portions of the; Library will still fall under Section 6.). Otherwise, if the work is a derivative of the Library, you may; distribute the object code for the work under the terms of Section 6.; Any executables containing that work also fall under Section 6,; whether or not they are linked directly with the Library itself.; ; 6. As an exception to the Sections above, you may also combine or; link a ""work that uses the Library"" with the Library to produce a; work containing portions of the Library, and distribute that work; under terms of your choice, provided that the terms permit; modification of the work for the customer's own use and reverse; engineering for debugging such modifications. You must give prominent notice with each copy of the work that the; Library is used in it and that the Library and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:15883,access,accessors,15883,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['access'],['accessors']
Security," T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_3_.html:6496,access,access,6496,root/html528/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security," T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_3_.html:6498,access,access,6498,root/html530/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security," T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SVector_Double32_t_3_.html:6498,access,access,6498,root/html532/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security," T1, class T2>; 401bool operator==(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs); 402{; 403 return lhs.fObjPtr == rhs.fObjPtr;; 404}; 405 ; 406template <class T1, class T2>; 407bool operator!=(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs); 408{; 409 return lhs.fObjPtr != rhs.fObjPtr;; 410}; 411 ; 412template <class T1>; 413bool operator==(const RResultPtr<T1> &lhs, std::nullptr_t rhs); 414{; 415 return lhs.fObjPtr == rhs;; 416}; 417 ; 418template <class T1>; 419bool operator==(std::nullptr_t lhs, const RResultPtr<T1> &rhs); 420{; 421 return lhs == rhs.fObjPtr;; 422}; 423 ; 424template <class T1>; 425bool operator!=(const RResultPtr<T1> &lhs, std::nullptr_t rhs); 426{; 427 return lhs.fObjPtr != rhs;; 428}; 429 ; 430template <class T1>; 431bool operator!=(std::nullptr_t lhs, const RResultPtr<T1> &rhs); 432{; 433 return lhs != rhs.fObjPtr;; 434}; 435 ; 436} // namespace RDF; 437 ; 438namespace Detail {; 439namespace RDF {; 440/// Create a RResultPtr and set its pointer to the corresponding RAction; 441/// This overload is invoked by non-jitted actions, as they have access to RAction before constructing RResultPtr.; 442template <typename T>; 443RResultPtr<T>; 444MakeResultPtr(const std::shared_ptr<T> &r, RLoopManager &lm, std::shared_ptr<RDFInternal::RActionBase> actionPtr); 445{; 446 return RResultPtr<T>(r, &lm, std::move(actionPtr));; 447}; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// \brief Retrieve a mergeable value from an RDataFrame action.; 451/// \param[in] rptr lvalue reference of an RResultPtr object.; 452/// \returns An RMergeableValue holding the result of the action, wrapped in an; 453/// `std::unique_ptr`.; 454///; 455/// This function triggers the execution of the RDataFrame computation graph.; 456/// Then retrieves an RMergeableValue object created with the result wrapped by; 457/// the RResultPtr argument. The user obtains ownership of the mergeable, which; 458/// in turn holds a copy ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:18661,access,access,18661,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['access'],['access']
Security," TASPluginGS::File2ASImage ; (; const char * ; filename). overridevirtual . read PS/EPS/PDF file and convert it to ASImage ; Reimplemented from TASImagePlugin.; Definition at line 76 of file TASPluginGS.cxx. ◆ Hash(). ULong_t TASPluginGS::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TASPluginGS::HashULong_t Hash() const overrideReturn hash value for this object.Definition TASPluginGS.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TASImagePlugin.; Definition at line 34 of file TASPluginGS.h. ◆ IsA(). TClass * TASPluginGS::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TASImagePlugin.; Definition at line 38 of file TASPluginGS.h. ◆ Streamer(). void TASPluginGS::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TASImagePlugin. ◆ Strea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASPluginGS.html:13523,Hash,Hash,13523,doc/master/classTASPluginGS.html,https://root.cern,https://root.cern/doc/master/classTASPluginGS.html,1,['Hash'],['Hash']
Security," TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void FindMomentumLimits (TEveElement *el, Bool_t recurse=kTRUE);  Loop over track elements of argument el and find highest pT and p. ;  ; Double_t RoundMomentumLimit (Double_t x);  Round the momentum limit up to a nice value. ;  ; void SanitizeMinMaxCuts ();  Set Min/Max cuts so that they are within detected limits. ;  ;  Protected Member Functions inherited from TEveElement; virtual void AnnihilateRecursively ();  Protected member function called from TEveElement::Annihilate(). ;  ; virtual void PreDeleteElement ();  Externally assigned and controlled user data. ;  ; virtual void RemoveElementsInternal ();  Remove all elements. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t fLimP;  ; Double_t fLimPt;  ; Double_t fMaxP;  ; Double_t fMaxPt;  ; Double_t fMinP;  ; Double_t fMinPt;  ; TEveTrackPropagator * fPropagator;  ; Bool_t fRecurse;  ; Bool_t fRnrLine;  ; Bool_t fRnrPoints;  ;  Protected Attributes inherited from TEveElementList; TClass * fChildClass;  ; Color_t fColor;  ;  Protected Attributes inherited from TEveElement; Bool_t fCanEditMainColor;  ; Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackList.html:35176,Sanitiz,SanitizeMinMaxCuts,35176,doc/master/classTEveTrackList.html,https://root.cern,https://root.cern/doc/master/classTEveTrackList.html,1,['Sanitiz'],['SanitizeMinMaxCuts']
Security," TAttText.h:25; TAttText::fTextSizeFloat_t fTextSizeText size.Definition TAttText.h:22; TColorThe color creation and management class.Definition TColor.h:21; TColor::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::GetBlueFloat_t GetBlue() constDefinition TColor.h:62; TColor::GetGreenFloat_t GetGreen() constDefinition TColor.h:61; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974; TGX11::SetLineColorvoid SetLineColor(Color_t cindex) overrideSet color index for lines.Definition TGX11.cxx:2276; TGX11::GetGeometryvoid GetGeometry(Int_t wid, Int_t &x, Int_t &y, UInt_t &w, UInt_t &h) overrideReturn position and size of window wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:143651,hash,hash,143651,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['hash'],['hash']
Security," TAxis.cxx:1157; TAxis::CanBeAlphanumericBool_t CanBeAlphanumeric()Definition TAxis.h:87; TAxis::fTimeFormatTString fTimeFormatDate&time format, ex: 09/12/99 12:34:00.Definition TAxis.h:42; TAxis::GetParentvirtual TObject * GetParent() constDefinition TAxis.h:128; TAxis::SetRangevirtual void SetRange(Int_t first=0, Int_t last=0)Set the viewing range for the axis using bin numbers.Definition TAxis.cxx:1052; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetBinUpEdgevirtual Double_t GetBinUpEdge(Int_t bin) constReturn up edge of bin.Definition TAxis.cxx:528; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TAxis::GetTicksvirtual const char * GetTicks() constReturn the ticks option (see SetTicks)Definition TAxis.cxx:634; TAxis::fBits2UShort_t fBits2Second bit status word.Definition TAxis.h:40; TAxis::fFirstInt_t fFirstFirst bin to display.Definition TAxis.h:38; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; bool; double; int; xDouble_t x[n]Definition legend1.C:17; v@ vDefinition rootcling_impl.cxx:3699. histhistincTAxis.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAxis_8h_source.html:24323,hash,hash,24323,doc/master/TAxis_8h_source.html,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html,1,['hash'],['hash']
Security," TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TDirectory::GetObjectvoid GetObject(const char *namecycle, T *&ptr)Get an object with proper type checking.Definition TDirectory.h:212; TF11-Dim function classDefinition TF1.h:233; TF1::Printvoid Print(Option_t *option="""") const overrideThis method must be overridden when a class wants to print itself.Definition TF1.cxx:2897; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; c1return c1Definition legend1.C:41; fit1_py.fitlabelfitlabelDefinition fit1_py.py:12; fit1Definition fit1.py:1; AuthorRene Brun ; Definition in file fit1.C. tutorialsfitfit1.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fit1_8C.html:5313,Access,AccessPathNamevirtual,5313,doc/master/fit1_8C.html,https://root.cern,https://root.cern/doc/master/fit1_8C.html,4,"['Access', 'access']","['AccessPathName', 'AccessPathNamevirtual', 'access']"
Security," TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class represents a reference.Definition TClass.h:281; TClass::fPropertystd::atomic< Long_t > fPropertyDefinition TClass.h:255; TClass::StreamerDefaultstatic void StreamerDefault(const TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:321733,checksum,checksum,321733,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,3,['checksum'],['checksum']
Security," TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERuntimePropertiesIndicates whether GetClassVersion has been called.Definition TClass.h:264; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::ERuntimeProperties::kNotInitialized@ kNotInitialized; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:55991,checksum,checksum,55991,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,3,['checksum'],['checksum']
Security," TClass.cxx:3544; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4621; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7084; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:6026; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5891; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:7044; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4701; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6561; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:555; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3994; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class represents a reference.Definition TClass.h:281; TClass::fPropertystd::atomic< Long_t > fPropertyDefinition TClass.h:255; TClass::StreamerDefaultstatic void StreamerDefault(const TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:324371,checksum,checksum,324371,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,3,['checksum'],['checksum']
Security," TClass.cxx:3544; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4621; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7084; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:6026; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5891; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:7044; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4701; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6561; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERuntimePropertiesIndicates whether GetClassVersion has been called.Definition TClass.h:264; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::ERuntimeProperties::kNotInitialized@ kNotInitialized; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:555; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3994; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:55819,checksum,checksum,55819,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,3,['checksum'],['checksum']
Security," TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::ExpandCreateFastvirtual void ExpandCreateFast(Int_t n)Expand or shrink the array to n elements and create the clone objects by calling their default ctor.Definition TClonesArray.cxx:558; TClonesArray::GetClassTClass * GetClass() constDefinition TClonesArray.h:53; TClonesArray::Classstatic TClass * Class(); TCollection::Classstatic TClass * Class(); TCollecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:285112,checksum,checksum,285112,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,2,['checksum'],['checksum']
Security," TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);; 7400 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7401 }; 7402 if (fCollectionProxy) {; 7403 return kTRUE;; 7404 }; 7405 if (fCurrentInfo.load()) {; 7406 // Emulated class, we know how to construct them via the TStreamerInfo; 7407 return kTRUE;; 7408 }; 7409 return kFALSE;; 7410}; 7411 ; 7412////////////////////////////////////////////////////////////////////////////////; 7413/// Returns true if this class has an definition and/or overload of the; 7414/// member function Hash.; 7415///; 7416/// For example to test if the class overload TObject::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 7429/// Return the wrapper around Merge.; 7430 ; 7431ROOT::MergeFunc_t TClass::GetMerge() const; 7432{; 7433 return fMerge;; 7434}; 7435 ; 7436////////////////////////////////////////////////////////////////////////////////; 7437/// Return the wrapper around Merge.; 7438 ; 7439ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7440{; 7441 return fResetAfterMerge;; 7442}; 7443 ; 7444/////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:284790,Hash,Hash,284790,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Hash'],['Hash']
Security," TClass::New is; 7448/// guarantee to succeed.; 7449/// To know if the class described by this TClass has a default constructor; 7450/// (public or not), use; 7451/// \code{.cpp}; 7452/// cl->GetProperty() & kClassHasDefaultCtor; 7453/// \endcode; 7454/// To know if the class described by this TClass has a public default; 7455/// constructor use:; 7456/// \code{.cpp}; 7457/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7458/// \endcode; 7459 ; 7460Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7461{; 7462 ; 7463 if (fNew) return kTRUE;; 7464 ; 7465 if (HasInterpreterInfo()) {; 7466 R__LOCKGUARD(gInterpreterMutex);; 7467 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7468 }; 7469 if (fCollectionProxy) {; 7470 return kTRUE;; 7471 }; 7472 if (fCurrentInfo.load()) {; 7473 // Emulated class, we know how to construct them via the TStreamerInfo; 7474 return kTRUE;; 7475 }; 7476 return kFALSE;; 7477}; 7478 ; 7479////////////////////////////////////////////////////////////////////////////////; 7480/// Returns true if this class has an definition and/or overload of the; 7481/// member function Hash.; 7482///; 7483/// For example to test if the class overload TObject::Hash use; 7484/// ~~~ {.cpp}; 7485/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7486/// ~~~; 7487 ; 7488Bool_t TClass::HasLocalHashMember() const; 7489{; 7490 if (fProperty == (-1)); 7491 Property();; 7492 return TestBit(kHasLocalHashMember);; 7493}; 7494 ; 7495////////////////////////////////////////////////////////////////////////////////; 7496/// Return the wrapper around Merge.; 7497 ; 7498ROOT::MergeFunc_t TClass::GetMerge() const; 7499{; 7500 return fMerge;; 7501}; 7502 ; 7503////////////////////////////////////////////////////////////////////////////////; 7504/// Return the wrapper around Merge.; 7505 ; 7506ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7507{; 7508 return fResetAfterMerge;; 7509}; 7510 ; 7511/////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:287541,Hash,Hash,287541,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Hash'],['Hash']
Security," TClassTable.cxx. ◆ DeclFileName(). static const char * TClassTable::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 101 of file TClassTable.h. ◆ FindElement(). TClassRec * TClassTable::FindElement ; (; const char * ; cname, . Bool_t ; insert . ). staticprivate . Find a class by name in the class table (using hash of name). ; Returns 0 if the class is not in the table. Unless arguments insert is true in which case a new entry is created and returned. cname must be the normalized name of the class. ; Definition at line 625 of file TClassTable.cxx. ◆ GetDict() [1/2]. DictFuncPtr_t TClassTable::GetDict ; (; const char * ; cname). static . Given the class name returns the Dictionary() function of a class (uses hash of name). ; Definition at line 674 of file TClassTable.cxx. ◆ GetDict() [2/2]. DictFuncPtr_t TClassTable::GetDict ; (; const std::type_info & ; info). static . Given the std::type_info returns the Dictionary() function of a class (uses hash of std::type_info::name()). ; Definition at line 692 of file TClassTable.cxx. ◆ GetDictNorm(). DictFuncPtr_t TClassTable::GetDictNorm ; (; const char * ; cname). static . Given the normalized class name returns the Dictionary() function of a class (uses hash of name). ; Definition at line 717 of file TClassTable.cxx. ◆ GetID(). Version_t TClassTable::GetID ; (; const char * ; cname). static . Returns the ID of a class. ; Definition at line 647 of file TClassTable.cxx. ◆ GetPragmaBits(). Int_t TClassTable::GetPragmaBits ; (; const char * ; name). static . Returns the pragma bits as specified in the LinkDef.h file. ; Definition at line 660 of file TClassTable.cxx. ◆ GetProto(). TProtoClass * TClassTable::GetProto ; (; const char * ; cname). static . Given the class name returns the TClassProto object for the class. ; (uses hash of name). ; Definition at line 742 of file TClassTable.cxx. ◆ GetProtoNorm(). TProtoClass * TClassTable::GetProtoNorm ; (; const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:17228,hash,hash,17228,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,1,['hash'],['hash']
Security," TDictionary * TListOfDataMembers::Find ; (; DeclId_t ; id); const. Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ; Definition at line 205 of file TListOfDataMembers.cxx. ◆ FindObject() [1/3]. TObject * THashList::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from THashList.; Definition at line 51 of file THashList.cxx. ◆ FindObject() [2/3]. TObject * TListOfDataMembers::FindObject ; (; const char * ; name); const. overridevirtual . Specialize FindObject to do search for the a data member just by name or create it if its not already in the list. ; Reimplemented from THashList.; Definition at line 182 of file TListOfDataMembers.cxx. ◆ FindObject() [3/3]. TObject * THashList::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from THashList.; Definition at line 52 of file THashList.cxx. ◆ Get() [1/2]. TDictionary * TListOfDataMembers::Get ; (; DataMemberInfo_t * ; info, . bool ; skipChecks = kFALSE . ). Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ; The skipChecks flag controls the consistency checks performed inspecting the AST. In some cases, we explicitly alter the datamembers in the typesystem with respect to the AST and therefore we must not enforce consistency. ; Definition at line 273 of file TListOfDataMembers.cxx. ◆ Get() [2/2]. TDictionary * TListOfDataMembers::Get ; (; DeclId_t ; id). Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ; Definition at line 216 of file TListOfDataMembers.cxx. ◆ GetClass(). TClass * TListOfDataMembers::GetClass ; (; ); const. inline . Definition at line 90 of file TListOfDataMembers.h.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:29468,hash,hash,29468,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," TDrawFeedback::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDrawFeedback::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDrawFeedback::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 54 of file TDrawFeedback.h. ◆ DeclFileName(). static const char * TDrawFeedback::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 54 of file TDrawFeedback.h. ◆ Feedback(). void TDrawFeedback::Feedback ; (; TList * ; objs). Display feedback. ; Definition at line 93 of file TDrawFeedback.cxx. ◆ GetName(). const char * TDrawFeedback::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 50 of file TDrawFeedback.h. ◆ Hash(). ULong_t TDrawFeedback::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TDrawFeedback::HashULong_t Hash() const overrideReturn hash value for this object.Definition TDra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDrawFeedback.html:16490,Hash,Hash,16490,doc/master/classTDrawFeedback.html,https://root.cern,https://root.cern/doc/master/classTDrawFeedback.html,1,['Hash'],['Hash']
Security," TEfficiency, TGraph2D, TChain, TTree, TDirectory, TFolder, TMacro, TRemoteObject, TROOT, TStyle, TSystemDirectory, TSystemFile, TTask, TCollection, TPair, TBrowserObject, TBaseClass, TClass, TGeoManager, TGeoNode, TGeoVolume, TGeoOverlap, TGeoTrack, TCanvas, TPad, TAxis3D, TGeometry, TNode, TRootIconList, THbookBranch, THbookFile, THbookKey, TF1, TGraph, TH1, THnBase, ROOT::Internal::THnBaseBrowsable, THStack, TMultiDimFit, TMultiGraph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, TDatabasePDG, TGenerator, TParticleClassPDG, TApplicationRemote, TProof, TProofChain, RooPlot, TBranch, TVirtualBranchBrowsable, TCollectionPropertyBrowsable, TBranchClones, TBranchElement, TBranchObject, TBranchSTL, TLeaf, TNtuple, TNtupleD, TTreePerfStats, ROOT::Experimental::XRooFit::xRooNode, and TQueryResult.; Definition at line 198 of file TObject.cxx. ◆ CheckedHash(). ULong_t TObject::CheckedHash ; (; ). inline . Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; The intent is for this routine to be called instead of directly calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; (*) The setup is consistent when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 324 of file TObject.h. ◆ Class(). static TClass * TObject::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TObject::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TObject::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 243 of file TObject.h. ◆ ClassName(). const char * TObject::ClassName ; (; ); const. virtual . Returns name of class to which ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:21484,Hash,Hash,21484,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,2,['Hash'],['Hash']
Security," TEfficiency, TGraph2D, TChain, TTree, TDirectory, TFolder, TMacro, TRemoteObject, TROOT, TStyle, TSystemDirectory, TSystemFile, TTask, TCollection, TPair, TBrowserObject, TBaseClass, TClass, TGeoManager, TGeoNode, TGeoVolume, TGeoOverlap, TGeoTrack, TCanvas, TPad, TAxis3D, TGeometry, TNode, TRootIconList, THbookBranch, THbookFile, THbookKey, TF1, TGraph, TH1, THnBase, ROOT::Internal::THnBaseBrowsable, THStack, TMultiDimFit, TMultiGraph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, TDatabasePDG, TGenerator, TParticleClassPDG, TApplicationRemote, TProof, TProofChain, RooPlot, TBranch, TVirtualBranchBrowsable, TCollectionPropertyBrowsable, TBranchClones, TBranchElement, TBranchObject, TBranchSTL, TLeaf, TNtuple, TNtupleD, TTreePerfStats, ROOT::Experimental::XRooFit::xRooNode, and TQueryResult.; Definition at line 204 of file TObject.cxx. ◆ CheckedHash(). ULong_t TObject::CheckedHash ; (; ). inline . Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; The intent is for this routine to be called instead of directly calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; (*) The setup is consistent when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 324 of file TObject.h. ◆ Class(). static TClass * TObject::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TObject::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TObject::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 243 of file TObject.h. ◆ ClassName(). const char * TObject::ClassName ; (; ); const. virtual . Returns name of class to which ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:21485,Hash,Hash,21485,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,2,['Hash'],['Hash']
Security," TEnum corresponding to the Decl 'id' or NULL if it does not exist. ;  ; Bool_t IsLoaded () const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; Bool_t IsAscending ();  ; TObject * Remove (const TObjLinkPtr_t &lnk);  ; void RemoveLast () override;  Remove the last object of the list. ;  ; virtual void Sort (Bool_t order=kSortAscending);  Sort linked list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TSeqCollection; virtual ~TSeqCollection ();  ; void Add (TObject *obj) override;  ; TClass * IsA () const override;  ; virtual Bool_t IsSorted () const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:5032,hash,hashlist,5032,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['hash'],['hashlist']
Security," TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::fClassTClass * fClassDefinition TListOfFunctionTemplates.h:40; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctionTemplates.cxx:356; TListOfFunctionTemplates::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctionTemplates.cxx:164; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::GetTFunction * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctions.cxx:262; TListOfFunctions::GetListForObjectvirtual TList * GetListForObject(const char *name) constReturn the set of overloads for this name, collecting all available ones.Definition TListOfFunctions.cxx:230; TListOfFunctions::FindObjectTObject * FindObject(const TObject *obj) const overrideFind object using its hash value (returned by its Hash() member).Definition TListOfFunctions.cxx:443; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:357742,access,access,357742,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['access'],['access']
Security," TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::ClassInfo_HasMethodvirtual Bool_t ClassInfo_HasMethod(ClassInfo_t *, const char *) constDefinition TInterpreter.h:413; TInterpreter::DataMemberInfo_Namevirtual const char * DataMemberInfo_Name(DataMemberInfo_t *) constDefinition TInterpreter.h:469; TInterpreter::DataMemberInfo_TypeNamevirtual const char * DataMemberInfo_TypeName(DataMemberInfo_t *) constDefinition TInterpreter.h:467; TInterpreter::DataMemberInfo_TypeSizevirtual int DataMemberInfo_TypeSize(DataMemberInfo_t *) constDefinition TInterpreter.h:466; TInterpreter::ClassInfo_Newvirtual void * ClassInfo_New(ClassInfo_t *) constDefinition TInterpreter.h:425; TInt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:352546,hash,hash,352546,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['hash'],['hash']
Security," TEveMacro(); TEveMacro(const TEveMacro&); TEveMacro(const char* name); virtual~TEveMacro(); voidTObject::AbstractMethod(const char* method) const; virtual TObjString*TMacro::AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTMacro::Browse(TBrowser* b); virtual TMD5*TMacro::Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExec(const char* params = ""0"", Int_t* error = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveMacro.html:745,Checksum,Checksum,745,root/html528/TEveMacro.html,https://root.cern,https://root.cern/root/html528/TEveMacro.html,4,['Checksum'],['Checksum']
Security," TEvePointSet, TGTextButton, TGGroupFrame, TGLabel, TGTextLBEntry, TGLVEntry, TGTextEntry, TRootIconList, TAxis, TKey, TMapFile, TParticle, TPrimary, TPackMgr, Axis2, TParallelCoordSelect, and TVirtualPad.; Definition at line 483 of file TObject.cxx. ◆ GetUniqueID(). UInt_t TObject::GetUniqueID ; (; ); const. virtual . Return the unique object id. ; Definition at line 457 of file TObject.cxx. ◆ HandleTimer(). Bool_t TObject::HandleTimer ; (; TTimer * ; timer). virtual . Execute action in response of a timer timing out. ; This method must be overridden if an object has to react to timers. ; Reimplemented in TGWindow, TGuiBldDragManager, TSessionViewer, TGLEventHandler, TGCommandPlugin, TGDNDManager, TGFileContainer, TGPopupMenu, TGScrollBar, TGShutter, TGTextEdit, TGTextEditor, TGTextEntry, TGTextView, TGToolTip, TGHtml, TVirtualPacketizer, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, TProofPlayerLite, and TTreeViewer.; Definition at line 493 of file TObject.cxx. ◆ Hash(). ULong_t TObject::Hash ; (; ); const. virtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:42135,Hash,Hash,42135,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['Hash'],['Hash']
Security," TEveTrackList(const char* name, TEveTrackPropagator* prop = 0); Constructor. If track-propagator argument is 0, a new default; one is created. ~TEveTrackList(); Destructor. void SetPropagator(TEveTrackPropagator* prop); Set default propagator for tracks.; This is not enforced onto the tracks themselves but this is the; propagator that is shown in the TEveTrackListEditor. void MakeTracks(Bool_t recurse = kTRUE); Regenerate the visual representations of tracks.; The momentum limits are rescanned during the same traversal. void FindMomentumLimits(Bool_t recurse = kTRUE); Loop over children and find highest pT and p of contained TEveTracks.; These are stored in members fLimPt and fLimP. void FindMomentumLimits(TEveElement* el, Bool_t recurse = kTRUE); Loop over track elements of argument el and find highest pT and p.; These are stored in members fLimPt and fLimP. Double_t RoundMomentumLimit(Double_t x); Round the momentum limit up to a nice value. void SanitizeMinMaxCuts(); Set Min/Max cuts so that they are within detected limits. void SetRnrLine(Bool_t rnr); Set rendering of track as line for the list and the elements. void SetRnrLine(Bool_t rnr, TEveElement* el); Set rendering of track as line for children of el. void SetRnrPoints(Bool_t r); Set rendering of track as points for the list and the elements. void SetRnrPoints(Bool_t r, TEveElement* el); Set rendering of track as points for children of el. void SetMainColor(Color_t c); Set main (line) color for the list and the elements. void SetLineColor(Color_t c, TEveElement* el); Set line color for children of el. void SetLineWidth(Width_t w); Set line width for the list and the elements. void SetLineWidth(Width_t w, TEveElement* el); Set line width for children of el. void SetLineStyle(Style_t s); Set line style for the list and the elements. void SetLineStyle(Style_t s, TEveElement* el); Set line style for children of el. void SetMarkerStyle(Style_t s); Set marker style for the list and the elements. void SetMarkerSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrackList.html:24042,Sanitiz,SanitizeMinMaxCuts,24042,root/html530/TEveTrackList.html,https://root.cern,https://root.cern/root/html530/TEveTrackList.html,5,['Sanitiz'],['SanitizeMinMaxCuts']
Security," TExMap(Int_t mapSize = 100); TExMap(const TExMap& map); virtual~TExMap(); voidTObject::AbstractMethod(const char* method) const; voidAdd(Long64_t key, Long64_t value); voidAdd(ULong64_t hash, Long64_t key, Long64_t value); voidAddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TExMap.html:726,hash,hash,726,root/html528/TExMap.html,https://root.cern,https://root.cern/root/html528/TExMap.html,8,['hash'],['hash']
Security," TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.012591 1.0260 [ -3.3377 5.7307 ]; : var2: 0.0016174 1.0380 [ -4.5569 5.7307 ]; : fvalue: 165.93 84.643 [ 2.0973 391.01 ]; : -----------------------------------------------------------; : Start of deep neural network training on CPU using MT, nthreads = 1; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.012591 1.0260 [ -3.3377 5.7307 ]; : var2: 0.0016174 1.0380 [ -4.5569 5.7307 ]; : fvalue: 165.93 84.643 [ 2.0973 391.01 ]; : -----------------------------------------------------------; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 2 ) Batch size = 50 Loss function = R; Layer 0 DENSE Layer: ( Input = 2 , Width = 50 ) Output = ( 1 , 50 , 50 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 50 , Width = 50 ) Output = ( 1 , 50 , 50 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 50 , Width = 50 ) Output = ( 1 , 50 , 50 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 50 , Width = 1 ) Output = ( 1 , 50 , 1 ) Activation Function = Identity; : Using 800 events for training and 200 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 33494.1; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 34747.6 33079.7 0.0192196 0.00176099 45822.6 0; : 2 Minimum Test error found - save the configuration ; : 2 | 34222.2 32417.1 0.0195047 0.0017702 45109.9 0; : 3 Minimum Test error found - save the configuration ; : 3 | 33496 31618.4 0.019",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:10805,validat,validation,10805,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['validat'],['validation']
Security," TFile.; Definition at line 254 of file TSQLFile.h. ◆ IsLongStringCode(). Int_t TSQLFile::IsLongStringCode ; (; Long64_t ; objid, . const char * ; value . ). protected . Checks if this is long string code returns 0, if not or string id. ; Definition at line 2225 of file TSQLFile.cxx. ◆ IsMySQL(). Bool_t TSQLFile::IsMySQL ; (; ); const. checks, if MySQL database ; Definition at line 467 of file TSQLFile.cxx. ◆ IsODBC(). Bool_t TSQLFile::IsODBC ; (; ); const. checks, if ODBC driver used for database connection ; Definition at line 487 of file TSQLFile.cxx. ◆ IsOpen(). Bool_t TSQLFile::IsOpen ; (; ); const. finalvirtual . return kTRUE if file is opened and can be accessed ; Reimplemented from TFile.; Definition at line 710 of file TSQLFile.cxx. ◆ IsOracle(). Bool_t TSQLFile::IsOracle ; (; ); const. checks, if Oracle database ; Definition at line 477 of file TSQLFile.cxx. ◆ IsReadAccess(). Bool_t TSQLFile::IsReadAccess ; (; ). protected . dummy, in future should check about read access to database ; Definition at line 1372 of file TSQLFile.cxx. ◆ IsTablesExists(). Bool_t TSQLFile::IsTablesExists ; (; ). protected . Checks if main keys table is existing. ; Definition at line 1318 of file TSQLFile.cxx. ◆ IsWriteAccess(). Bool_t TSQLFile::IsWriteAccess ; (; ). protected . Checkis, if lock is free in configuration tables. ; Definition at line 1326 of file TSQLFile.cxx. ◆ MakeFree(). void TSQLFile::MakeFree ; (; Long64_t ; first, . Long64_t ; last . ). inlinefinalvirtual . Mark unused bytes on the file. ; The list of free segments is in the fFree linked list. When an object is deleted from the file, the freed space is added into the FREE linked list (fFree). The FREE list consists of a chain of consecutive free segments on the file. At the same time, the first 4 bytes of the freed record on the file are overwritten by GAPSIZE where GAPSIZE = -(Number of bytes occupied by the record). ; Reimplemented from TFile.; Definition at line 231 of file TSQLFile.h. ◆ MakeProject(). voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:73741,access,access,73741,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['access']
Security," TFormula expression; RooFracRemainder Utility function calculating remainder fraction, i.e. 1-sum_i(a_i); RooFunctor Export RooAbsReal as functor; RooFunctor1DBinding RooAbsReal binding to a ROOT::Math::IBaseFunctionOneDim; RooFunctor1DPdfBinding RooAbsPdf binding to a ROOT::Math::IBaseFunctionOneDim; RooFunctorBinding RooAbsReal binding to a ROOT::Math::IBaseFunctionMultiDim; RooFunctorPdfBinding RooAbsPdf binding to a ROOT::Math::IBaseFunctionMultiDim; RooGExpModel Gauss (x) Expontial resolution model; RooGamma Gaussian PDF; RooGaussKronrodIntegrator1D 1-dimensional Gauss-Kronrod numerical integration engine; RooGaussModel Gaussian Resolution Model; RooGaussian Gaussian PDF; RooGenContext Universal context for generating toy MC data from any p.d.f; RooGenFitStudy Generate-and-Fit study module; RooGenFunction Export RooAbsReal as functor; RooGenProdProj General form of projected integral of product of PDFs, utility class for RooProdPdf; RooGenericPdf Generic PDF defined by string expression and list of variables; RooGlobalFunc ; RooGrid Utility class for RooMCIntegrator holding a multi-dimensional grid; RooHashTable Hash table; RooHist 1-dimensional histogram with error bars; RooHistConstraint Your description goes here...; RooHistError Utility class for calculating histogram errors; RooHistFunc Histogram based function; RooHistPdf Histogram based PDF; RooImproperIntegrator1D 1-dimensional improper integration engine; RooInt Container class for Int_t; RooIntegralMorph Linear shape interpolation operator p.d.f; RooIntegrator1D 1-dimensional numerical integration engine; RooIntegrator2D 2-dimensional numerical integration engine; RooIntegratorBinding Function binding representing output of numeric integrator; RooInvTransform Function binding returning inverse of other function binding; RooJeffreysPrior Sum of RooAbsReal objects; RooKeysPdf One-dimensional non-parametric kernel estimation p.d.f.; RooLandau Landau Distribution PDF; RooLegendre Legendre polynomial; RooL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:34523,Hash,Hash,34523,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['Hash'],['Hash']
Security," TGObject::~TGObject ; (; ). override . TGObject destructor. ; Definition at line 44 of file TGObject.cxx. Member Function Documentation. ◆ Class(). static TClass * TGObject::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGObject::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGObject::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 47 of file TGObject.h. ◆ DeclFileName(). static const char * TGObject::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 47 of file TGObject.h. ◆ GetClient(). TGClient * TGObject::GetClient ; (; ); const. inline . Definition at line 42 of file TGObject.h. ◆ GetId(). Handle_t TGObject::GetId ; (; ); const. inline . Definition at line 41 of file TGObject.h. ◆ Hash(). ULong_t TGObject::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TGObject::HashULong_t Hash() const overrideReturn hash value for this object.Definition TGObject.h:43; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGObject.html:11874,hash,hash,11874,doc/master/classTGObject.html,https://root.cern,https://root.cern/doc/master/classTGObject.html,1,['hash'],['hash']
Security," TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:7977,access,accessed,7977,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['access'],['accessed']
Security," TGeoNode*TGeoNode::GetDaughter(Int_t ind) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoPatternFinder*TGeoNode::GetFinder() const; virtual const char*TObject::GetIconName() const; virtual Int_tTGeoNode::GetIndex() const; virtual TGeoMatrix*GetMatrix() const; TGeoMedium*TGeoNode::GetMedium() const; TGeoVolume*TGeoNode::GetMotherVolume() const; virtual const char*TNamed::GetName() const; Int_tTGeoNode::GetNdaughters() const; TObjArray*TGeoNode::GetNodes() const; Int_tTGeoNode::GetNumber() const; virtual char*TGeoNode::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOptimalVoxels() const; virtual Option_t*TObject::GetOption() const; Int_t*TGeoNode::GetOverlaps(Int_t& novlp) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TGeoVolume*TGeoNode::GetVolume() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTGeoNode::InspectNode() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTGeoAtt::IsActive() const; Bool_tTGeoAtt::IsActiveDaughters() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTGeoNode::IsOffset() const; Bool_tTObject::IsOnHeap() const; Bool_tTGeoNode::IsOnScreen() constMENU ; Bool_tTGeoNode::IsOverlapping() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTGeoNode::IsVirtual() const; Bool_tTGeoAtt::IsVisBranch() const; Bool_tTGeoAtt::IsVisContainers() const; Bool_tTGeoNode::IsVisDaughters() const; Bool_tTGeoNode::IsVisible() const; Bool_tTGeoAtt::IsVisLeaves() const; Bool_tTGeoAtt::IsVisOnly() const; Bool_tTGeoAtt::IsVisRaytrace() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNodeMatrix.html:3325,Hash,Hash,3325,root/html528/TGeoNodeMatrix.html,https://root.cern,https://root.cern/root/html528/TGeoNodeMatrix.html,3,['Hash'],['Hash']
Security," TGeoStateInfo &td);  get the list in the next voxel crossed by a ray ;  ; void Streamer (TBuffer &) override;  Stream an object of class TGeoVoxelFinder. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Voxelize (Option_t *option="""");  Voxelize attached volume according to option If the volume is an assembly, make sure the bbox is computed. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVoxelFinder.html:4053,Hash,Hash,4053,doc/master/classTGeoVoxelFinder.html,https://root.cern,https://root.cern/doc/master/classTGeoVoxelFinder.html,2,['Hash'],['Hash']
Security," TH1F *histMLP_signal(0), *histBDTG_signal(0), *histFDAGA_signal(0), *histPDEFoam_signal(0);; 104 TH1F *histDLCPU_signal(0), *histDLGPU_signal(0);; 105 if (Use[""MLP""]); 106 histMLP_signal = new TH1F( ""MVA_MLP_signal"", ""MVA_MLP_signal"", nbin, 0., 1.1 );; 107 if (Use[""BDTG""]); 108 histBDTG_signal = new TH1F( ""MVA_BDTG_signal"", ""MVA_BDTG_signal"", nbin, 0., 1.1 );; 109 if (Use[""DL_CPU""]); 110 histDLCPU_signal = new TH1F(""MVA_DLCPU_signal"", ""MVA_DLCPU_signal"", nbin, 0., 1.1);; 111 if (Use[""DL_GPU""]); 112 histDLGPU_signal = new TH1F(""MVA_DLGPU_signal"", ""MVA_DLGPU_signal"", nbin, 0., 1.1);; 113 if (Use[""FDA_GA""]); 114 histFDAGA_signal = new TH1F( ""MVA_FDA_GA_signal"", ""MVA_FDA_GA_signal"", nbin, 0., 1.1 );; 115 if (Use[""PDEFoam""]); 116 histPDEFoam_signal = new TH1F( ""MVA_PDEFoam_signal"", ""MVA_PDEFoam_signal"", nbin, 0., 1.1 );; 117 ; 118 ; 119 TFile *input(0);; 120 TString fname = ""./tmva_example_multiclass.root"";; 121 if (!gSystem->AccessPathName( fname )) {; 122 input = TFile::Open( fname ); // check if file in local directory exists; 123 }; 124 else {; 125 TFile::SetCacheFileDir(""."");; 126 input = TFile::Open(""http://root.cern/files/tmva_multiclass_example.root"", ""CACHEREAD"");; 127 }; 128 if (!input) {; 129 std::cout << ""ERROR: could not open data file"" << std::endl;; 130 exit(1);; 131 }; 132 std::cout << ""--- TMVAMulticlassApp : Using input file: "" << input->GetName() << std::endl;; 133 ; 134 // prepare the tree; 135 // - here the variable names have to corresponds to your tree; 136 // - you can use the same variables as above which is slightly faster,; 137 // but of course you can use different ones and copy the values inside the event loop; 138 ; 139 TTree* theTree = (TTree*)input->Get(""TreeS"");; 140 std::cout << ""--- Select signal sample"" << std::endl;; 141 theTree->SetBranchAddress( ""var1"", &var1 );; 142 theTree->SetBranchAddress( ""var2"", &var2 );; 143 theTree->SetBranchAddress( ""var3"", &var3 );; 144 theTree->SetBranchAddress( ""var4"", &var4 );; 145 ; 146 std::cout << """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlassApplication_8C_source.html:4481,Access,AccessPathName,4481,doc/master/TMVAMulticlassApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlassApplication_8C_source.html,1,['Access'],['AccessPathName']
Security," THashTable object. ; Capacity is the initial hashtable capacity (i.e. number of slots), by default kInitHashTableCapacity = 17, and rehashlevel is the value at which a rehash will be triggered. I.e. when the average size of the linked lists at a slot becomes longer than rehashlevel then the hashtable will be resized and refilled to reduce the collision rate to about 1. The higher the collision rate, i.e. the longer the linked lists, the longer lookup will take. If rehashlevel=0 the table will NOT automatically be rehashed. Use Rehash() for manual rehashing. ; Definition at line 43 of file THashTable.cxx. ◆ ~THashTable(). THashTable::~THashTable ; (; ). virtual . Delete a hashtable. ; Objects are not deleted unless the THashTable is the owner (set via SetOwner()). ; Definition at line 65 of file THashTable.cxx. Member Function Documentation. ◆ Add(). void THashTable::Add ; (; TObject * ; obj). overridevirtual . Add object to the hash table. ; Its position in the table will be determined by the value returned by its Hash() function. ; Implements TCollection.; Definition at line 92 of file THashTable.cxx. ◆ AddAll(). void THashTable::AddAll ; (; const TCollection * ; col). overridevirtual . Add all objects from collection col to this collection. ; Implemented for more efficient rehashing. ; Reimplemented from TCollection.; Definition at line 138 of file THashTable.cxx. ◆ AddBefore(). void THashTable::AddBefore ; (; const TObject * ; before, . TObject * ; obj . ). Add object to the hash table. ; Its position in the table will be determined by the value returned by its Hash() function. If and only if 'before' is in the same bucket as obj, obj is added in front of 'before' within the bucket's list. ; Definition at line 112 of file THashTable.cxx. ◆ AddImpl(). void THashTable::AddImpl ; (; Int_t ; slot, . TObject * ; obj . ). inlineprivate . Helper function doing the actual add to the table give a slot and object. ; This does not take any lock. ; Definition at line 78 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:17416,Hash,Hash,17416,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['Hash'],['Hash']
Security," TInterpreter::kFatal@ kFatalDefinition TInterpreter.h:76; TIterDefinition TCollection.h:235; TIter::GetOptionOption_t * GetOption() constDefinition TCollection.h:253; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfDataMembers::Deletevoid Delete(Option_t *option="""") overrideDelete all TDataMember object files.Definition TListOfDataMembers.cxx:171; TListOfDataMembers::Unloadvoid Unload()Mark 'all func' as being unloaded.Definition TListOfDataMembers.cxx:542; TListOfDataMembers::GetTDictionary * Get(DeclId_t id)Return (after creating it if necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:216; TListOfDataMembers::Loadvoid Load()Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection.Definition TListOfDataMembers.cxx:399; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::GetTFunction * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctions.cxx:262; TListOfFunctions::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctions.cxx:162; TListOf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:138741,access,access,138741,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['access'],['access']
Security," TIterator&operator=(const TIterator& rhs); THashTableIter&operator=(const THashTableIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. bool operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. bool operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $ » Last generated: 2010-09-23 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTableIter.html:1872,hash,hashtable,1872,root/html528/THashTableIter.html,https://root.cern,https://root.cern/root/html528/THashTableIter.html,1,['hash'],['hashtable']
Security," TIterator&operator=(const TIterator& rhs); THashTableIter&operator=(const THashTableIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. bool operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. bool operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THashTableIter.html:1872,hash,hashtable,1872,root/html530/THashTableIter.html,https://root.cern,https://root.cern/root/html530/THashTableIter.html,1,['hash'],['hashtable']
Security," TIterator&operator=(const TIterator& rhs); THashTableIter&operator=(const THashTableIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. bool operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. bool operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $ » Last generated: 2011-11-03 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THashTableIter.html:1872,hash,hashtable,1872,root/html532/THashTableIter.html,https://root.cern,https://root.cern/root/html532/THashTableIter.html,1,['hash'],['hashtable']
Security," TLDAPServer(const char* host, Int_t port = LDAP_PORT, const char* binddn = 0, const char* password = 0, Int_t version = LDAP_VERSION2); virtual~TLDAPServer(); voidTObject::AbstractMethod(const char* method) const; Int_tAddEntry(TLDAPEntry& entry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteEntry(const char* dn); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TLDAPResult*GetAttributeTypes(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:420,password,password,420,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,3,['password'],['password']
Security," TMVA::CCTreeWrapper::~CCTreeWrapper ; (; ). destructor ; Definition at line 116 of file CCTreeWrapper.cxx. Member Function Documentation. ◆ CheckEvent(). Double_t TMVA::CCTreeWrapper::CheckEvent ; (; const TMVA::Event & ; e, . Bool_t ; useYesNoLeaf = false . ). return the decision tree output for an event ; Definition at line 226 of file CCTreeWrapper.cxx. ◆ GetRoot(). CCTreeNode * TMVA::CCTreeWrapper::GetRoot ; (; ). inline . Definition at line 148 of file CCTreeWrapper.h. ◆ InitTree(). void TMVA::CCTreeWrapper::InitTree ; (; CCTreeNode * ; t). initialize the node t and all its descendants ; Definition at line 123 of file CCTreeWrapper.cxx. ◆ PruneNode(). void TMVA::CCTreeWrapper::PruneNode ; (; CCTreeNode * ; t). remove the branch rooted at node t ; Definition at line 160 of file CCTreeWrapper.cxx. ◆ TestTreeQuality() [1/2]. Double_t TMVA::CCTreeWrapper::TestTreeQuality ; (; const DataSet * ; validationSample). return the misclassification rate of a pruned tree for a validation event sample using the DataSet ; Definition at line 203 of file CCTreeWrapper.cxx. ◆ TestTreeQuality() [2/2]. Double_t TMVA::CCTreeWrapper::TestTreeQuality ; (; const EventList * ; validationSample). return the misclassification rate of a pruned tree for a validation event sample using an EventList ; Definition at line 183 of file CCTreeWrapper.cxx. Member Data Documentation. ◆ fDTParent. DecisionTree* TMVA::CCTreeWrapper::fDTParent. private . ! pointer to underlying DecisionTree ; Definition at line 151 of file CCTreeWrapper.h. ◆ fQualityIndex. SeparationBase* TMVA::CCTreeWrapper::fQualityIndex. private . ! pointer to the used quality index calculator ; Definition at line 150 of file CCTreeWrapper.h. ◆ fRoot. CCTreeNode* TMVA::CCTreeWrapper::fRoot. private . ! the root node of the (wrapped) decision Tree ; Definition at line 152 of file CCTreeWrapper.h. Libraries for TMVA::CCTreeWrapper:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CCTreeWrapper.html:2866,validat,validation,2866,doc/master/classTMVA_1_1CCTreeWrapper.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CCTreeWrapper.html,1,['validat'],['validation']
Security," TMVA::DataLoader, in this object you need to configure the variables and the number of events to train/test. The class TMVA::Experimental::Classification needs a TMVA::DataLoader object, optional a TFile object to save the results and some extra options in a string like ""V:Color:Transformations=I;D;P;U;G:Silent:DrawProgressBar:ModelPersistence:Jobs=2"" where: V = verbose output Color = coloured screen output Silent = batch mode: boolean silent flag inhibiting any output from TMVA Transformations = list of transformations to test. DrawProgressBar = draw progress bar to display training and testing. ModelPersistence = to save the trained model in xml or serialized files. Jobs = number of ml methods to test/train in parallel using MultiProc, requires to call Evaluate method. Basic example. void classification(UInt_t jobs = 2); {; TMVA::Tools::Instance();; ; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName(fname)) {; input = TFile::Open(fname); // check if file in local directory exists; } else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD"");; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; ; // Register the training and test trees; ; TTree *signalTree = (TTree *)input->Get(""TreeS"");; TTree *background = (TTree *)input->Get(""TreeB"");; ; TMVA::DataLoader *dataloader = new TMVA::DataLoader(""dataset"");; ; dataloader->AddVariable(""myvar1 := var1+var2"", 'F');; dataloader->AddVariable(""myvar2 := var1-var2"", ""Expression 2"", """", 'F');; dataloader->AddVariable(""var3"", ""Variable 3"", ""units"", 'F');; dataloader->AddVariable(""var4"", ""Variable 4"", ""units"", 'F');; ; dataloader->AddSpectator(""spec1 := var1*2"", ""Spectator 1"", ""units"", 'F');; dataloader->AddSpectator(""spec2 := var1*3"", ""Spectator 2"", ""units"", 'F');; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Classification.html:1250,Access,AccessPathName,1250,doc/master/classTMVA_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Classification.html,1,['Access'],['AccessPathName']
Security," TMVA::Event*TMVA::MethodBase::GetTrainingEvent(Long64_t ievt) const; UInt_tTMVA::MethodBase::GetTrainingROOTVersionCode() const; TStringTMVA::MethodBase::GetTrainingROOTVersionString() const; UInt_tTMVA::MethodBase::GetTrainingTMVAVersionCode() const; TStringTMVA::MethodBase::GetTrainingTMVAVersionString() const; Double_tTMVA::MethodBase::GetTrainTime() const; TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true); const TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true) const; virtual UInt_tTObject::GetUniqueID() const; TStringTMVA::MethodBase::GetWeightFileName() const; Double_tTMVA::MethodBase::GetXmax(Int_t ivar) const; Double_tTMVA::MethodBase::GetXmin(Int_t ivar) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTMVA::IMethod::HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual ULong_tTObject::Hash() const; Bool_tTMVA::MethodBase::HasMVAPdfs() const; TMVA::IMethodTMVA::IMethod::IMethod(); TMVA::IMethodTMVA::IMethod::IMethod(const TMVA::IMethod&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTMVA::MethodBase::Init(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCompositeBase.html:7715,Hash,Hash,7715,root/html602/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCompositeBase.html,2,['Hash'],['Hash']
Security," TMVA::Event*TMVA::MethodBase::GetTrainingEvent(Long64_t ievt) const; UInt_tTMVA::MethodBase::GetTrainingROOTVersionCode() const; TStringTMVA::MethodBase::GetTrainingROOTVersionString() const; UInt_tTMVA::MethodBase::GetTrainingTMVAVersionCode() const; TStringTMVA::MethodBase::GetTrainingTMVAVersionString() const; Double_tTMVA::MethodBase::GetTrainTime() const; TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true); const TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true) const; virtual UInt_tTObject::GetUniqueID() const; TStringTMVA::MethodBase::GetWeightFileName() const; Double_tTMVA::MethodBase::GetXmax(Int_t ivar) const; Double_tTMVA::MethodBase::GetXmin(Int_t ivar) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTMVA::IMethod::HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual ULong_tTObject::Hash() const; Bool_tTMVA::MethodBase::HasMVAPdfs() const; TMVA::IMethodTMVA::IMethod::IMethod(); TMVA::IMethodTMVA::IMethod::IMethod(const TMVA::IMethod&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTMVA::MethodBase::Init(); voidInitANNBase(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodANNBase.html:7439,Hash,Hash,7439,root/html602/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodANNBase.html,2,['Hash'],['Hash']
Security," TMVA::Event*TMVA::MethodBase::GetTrainingEvent(Long64_t ievt) const; UInt_tTMVA::MethodBase::GetTrainingROOTVersionCode() const; TStringTMVA::MethodBase::GetTrainingROOTVersionString() const; UInt_tTMVA::MethodBase::GetTrainingTMVAVersionCode() const; TStringTMVA::MethodBase::GetTrainingTMVAVersionString() const; Double_tTMVA::MethodBase::GetTrainTime() const; TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true); const TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true) const; virtual UInt_tTObject::GetUniqueID() const; TStringTMVA::MethodBase::GetWeightFileName() const; Double_tTMVA::MethodBase::GetXmax(Int_t ivar) const; Double_tTMVA::MethodBase::GetXmin(Int_t ivar) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTMVA::IMethod::HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual ULong_tTObject::Hash() const; Bool_tTMVA::MethodBase::HasMVAPdfs() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTMVA::MethodBase::Init(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; virtual Bool_tTMVA::MethodBase::Moni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodCompositeBase.html:7527,Hash,Hash,7527,root/html530/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodCompositeBase.html,2,['Hash'],['Hash']
Security," TMVA::Event*TMVA::MethodBase::GetTrainingEvent(Long64_t ievt) const; UInt_tTMVA::MethodBase::GetTrainingROOTVersionCode() const; TStringTMVA::MethodBase::GetTrainingROOTVersionString() const; UInt_tTMVA::MethodBase::GetTrainingTMVAVersionCode() const; TStringTMVA::MethodBase::GetTrainingTMVAVersionString() const; Double_tTMVA::MethodBase::GetTrainTime() const; TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true); const TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true) const; virtual UInt_tTObject::GetUniqueID() const; TStringTMVA::MethodBase::GetWeightFileName() const; Double_tTMVA::MethodBase::GetXmax(Int_t ivar) const; Double_tTMVA::MethodBase::GetXmin(Int_t ivar) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTMVA::IMethod::HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual ULong_tTObject::Hash() const; Bool_tTMVA::MethodBase::HasMVAPdfs() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTMVA::MethodBase::Init(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; virtual Bool_tTObject::Notify(); voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodCompositeBase.html:7647,Hash,Hash,7647,root/html534/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodCompositeBase.html,1,['Hash'],['Hash']
Security," TMVA::Event*TMVA::MethodBase::GetTrainingEvent(Long64_t ievt) const; UInt_tTMVA::MethodBase::GetTrainingROOTVersionCode() const; TStringTMVA::MethodBase::GetTrainingROOTVersionString() const; UInt_tTMVA::MethodBase::GetTrainingTMVAVersionCode() const; TStringTMVA::MethodBase::GetTrainingTMVAVersionString() const; Double_tTMVA::MethodBase::GetTrainTime() const; TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true); const TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true) const; virtual UInt_tTObject::GetUniqueID() const; TStringTMVA::MethodBase::GetWeightFileName() const; Double_tTMVA::MethodBase::GetXmax(Int_t ivar) const; Double_tTMVA::MethodBase::GetXmin(Int_t ivar) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTMVA::IMethod::HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual ULong_tTObject::Hash() const; Bool_tTMVA::MethodBase::HasMVAPdfs() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTMVA::MethodBase::Init(); voidInitANNBase(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; virtual Bool_tTMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodANNBase.html:7216,Hash,Hash,7216,root/html530/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodANNBase.html,2,['Hash'],['Hash']
Security," TMVA::Event*TMVA::MethodBase::GetTrainingEvent(Long64_t ievt) const; UInt_tTMVA::MethodBase::GetTrainingROOTVersionCode() const; TStringTMVA::MethodBase::GetTrainingROOTVersionString() const; UInt_tTMVA::MethodBase::GetTrainingTMVAVersionCode() const; TStringTMVA::MethodBase::GetTrainingTMVAVersionString() const; Double_tTMVA::MethodBase::GetTrainTime() const; TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true); const TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(Bool_t takeReroutedIfAvailable = true) const; virtual UInt_tTObject::GetUniqueID() const; TStringTMVA::MethodBase::GetWeightFileName() const; Double_tTMVA::MethodBase::GetXmax(Int_t ivar) const; Double_tTMVA::MethodBase::GetXmin(Int_t ivar) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTMVA::IMethod::HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual ULong_tTObject::Hash() const; Bool_tTMVA::MethodBase::HasMVAPdfs() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTMVA::MethodBase::Init(); voidInitANNBase(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; virtual Bool_tTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodANNBase.html:7370,Hash,Hash,7370,root/html534/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodANNBase.html,1,['Hash'],['Hash']
Security," TMacro(); TMacro(const TMacro&); TMacro(const char* name, const char* title = """"); virtual~TMacro(); voidTObject::AbstractMethod(const char* method) const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMacro.html:1670,Checksum,Checksum,1670,root/html528/TMacro.html,https://root.cern,https://root.cern/root/html528/TMacro.html,4,['Checksum'],['Checksum']
Security," TMacro.cxx:171; or set via gEnv->SetValue, eg gEnv->SetValue(""TMacro.Browse"",""Print"");; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; By default TMacro.Browse="""" -if TMacro.Browse ="""" the macro is executed -if TMacro.Browse =""Print"" the macro is printed in stdout -if TMacro.Browse is of the form ""mymacro.C"" the macro void mymacro.C(TMacro *m) is called where m=this macro An example of macro.C saving the macro into a file and viewing it with emacs is shown below: void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653. Reimplemented from TObject.; Definition at line 171 of file TMacro.cxx. ◆ Checksum(). TMD5 * TMacro::Checksum ; (; ). virtual . Returns checksum of the current content. ; The returned TMD5 object must be deleted by the user. Returns 0 in case of error. ; Definition at line 192 of file TMacro.cxx. ◆ Class(). static TClass * TMacro::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMacro::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMacro::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 59 of file TMacro.h. ◆ DeclFileName(). static const char * TMacro::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 59 of file TMacro.h. ◆ Exec(). Longptr_t TMacro::Exec ; (; const char * ; params = nullptr, . Int_t * ; error = nullptr . ). virtual . Execute this macro with params, if params is 0, default parameters (set via SetParams) are used. ; error is set to an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:16712,Checksum,Checksum,16712,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['Checksum'],['Checksum']
Security," TNetFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read specified byte range from remote file via rootd daemon. ; Returns kTRUE in case of error. ; Reimplemented from TFile.; Definition at line 373 of file TNetFile.cxx. ◆ ReadBuffers(). Bool_t TNetFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). overridevirtual . Read a list of buffers given in pos[] and len[] and return it in a single buffer. ; Returns kTRUE in case of error. ; Reimplemented from TFile.; Definition at line 384 of file TNetFile.cxx. ◆ Recv(). Int_t TNetFile::Recv ; (; Int_t & ; status, . EMessageTypes & ; kind . ). protected . Return status from rootd server and message kind. ; Returns -1 in case of error otherwise 8 (sizeof 2 words, status and kind). ; Definition at line 546 of file TNetFile.cxx. ◆ ReOpen(). Int_t TNetFile::ReOpen ; (; Option_t * ; mode). overridevirtual . Reopen a file with a different access mode, like from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. ; Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore. ; Reimplemented from TFile.; Definition at line 285 of file TNetFile.cxx. ◆ Seek(). void TNetFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). overridevirtual . Set position from where to start reading. ; Reimplemented from TFile.; Definition at line 562 of file TNetFile.cxx. ◆ Streamer(). void TNetFile::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a TFile object. ; Reimplemented from TFile. ◆ StreamerNVirtual(). void TNetFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 81 of file TNetFile.h. ◆ SysClose(). Int_t TNetFile::SysClose ; (; Int_t ; fd). overrideprotectedvirtual .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:50442,access,access,50442,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['access'],['access']
Security," TNetXNGSystem(Bool_t owner = kTRUE); TNetXNGSystem(const char* url, Bool_t owner = kTRUE); virtual~TNetXNGSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tTSystem::AccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGSystem.html:756,Access,AccessPathName,756,root/html534/TNetXNGSystem.html,https://root.cern,https://root.cern/root/html534/TNetXNGSystem.html,1,['Access'],['AccessPathName']
Security," TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:142302,Hash,Hash,142302,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,6,"['Hash', 'hash']","['Hash', 'hash']"
Security," TObject * THashTable::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from TCollection.; Reimplemented in TListOfTypes.; Definition at line 251 of file THashTable.cxx. ◆ GetCheckedHashValue(). Int_t THashTable::GetCheckedHashValue ; (; TObject * ; obj); const. inlineprivate . Definition at line 93 of file THashTable.h. ◆ GetHashValue() [1/3]. Int_t THashTable::GetHashValue ; (; const char * ; str); const. inlineprivate . Definition at line 48 of file THashTable.h. ◆ GetHashValue() [2/3]. Int_t THashTable::GetHashValue ; (; const TObject * ; obj); const. inlineprivate . Definition at line 99 of file THashTable.h. ◆ GetHashValue() [3/3]. Int_t THashTable::GetHashValue ; (; TString & ; s); const. inlineprivate . Definition at line 47 of file THashTable.h. ◆ GetListForObject() [1/2]. const TList * THashTable::GetListForObject ; (; const char * ; name); const. Return the TList corresponding to object's name based hash value. ; One can iterate this list ""manually"" to find, e.g. objects with the same name. ; Definition at line 268 of file THashTable.cxx. ◆ GetListForObject() [2/2]. const TList * THashTable::GetListForObject ; (; const TObject * ; obj); const. Return the TList corresponding to object's hash value. ; One can iterate this list ""manually"" to find, e.g. identical objects. ; Definition at line 282 of file THashTable.cxx. ◆ GetObjectRef(). TObject ** THashTable::GetObjectRef ; (; const TObject * ; obj); const. overridevirtual . Return address of pointer to obj. ; Implements TCollection.; Definition at line 296 of file THashTable.cxx. ◆ GetRehashLevel(). Int_t THashTable::GetRehashLevel ; (; ); const. inline . Definition at line 72 of file THashTable.h. ◆ GetSize(). Int_t THashTable::GetSize ; (; ); const. inlineoverridevirtual . Return the capacity of the collection, i.e. ; the current total amount of space that has been allocated so far. Same as Capacity. Use GetE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:21672,hash,hash,21672,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hash']
Security," TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const RooArgList*GetAllTestStatisticsData() const; RooDataSet*GetAltDetailedOutput() const; RooStats::SamplingDistribution*GetAltDistribution() const; Bool_tGetBackGroundIsAlt() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); RooDataSet*GetFitInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; RooDataSet*GetNullDetailedOutput() const; RooStats::SamplingDistribution*GetNullDistribution() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetPValueIsRightTail() const; Double_tGetTestStatisticData() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; Bool_tHasTestStatisticData() const; RooStats::HypoTestResultHypoTestResult(const char* name = 0); RooStats::HypoTestResultHypoTestResult(const RooStats::HypoTestResult& other); RooStats::HypoTestResultHypoTestResult(const char* name, Double_t nullp, Double_t altp); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); virtual Double_tNullPValue() const; Double_tNullPValueError() const; voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestResult.html:3491,Hash,Hash,3491,root/html534/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestResult.html,3,['Hash'],['Hash']
Security," TParameter<int>::EStatusBitskLast; static TParameter<int>::EStatusBitskMax; static TParameter<int>::EStatusBitskMin; static TParameter<int>::EStatusBitskMultiply; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfName; intfVal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t TParameter<AParamType> Merge(TCollection* in); Merge objects in the list.; Returns the number of objects that were in the list. void Reset(). const char * GetName() const; { return fName; }. const AParamType & GetVal() const; { return fVal; }. Bool_t IsConst() const; { return (TestBit(kIsConst) ? kTRUE : kFALSE); }. void SetVal(const int& val); { fVal = val; }. void SetMergeMode(char mergemode = '+'); Merging modes:; '+' addition ('OR' for booleans) [default]; '*' multiplication ('AND' for booleans); 'M' maximum ('OR' for booleans); 'm' minimum ('AND' for booleans); 'f' first value; 'l' last value. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsSortable() const; { return kTRUE; }. Int_t Compare(const TObject* obj) const; Compare two TParameter objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp). void ls(Option_t* ) const; Print this parameter content. void Print(Option_t* ) const; Print this parameter content. std::cout << IsA(). » Author: Maarten Ballintijn 21/06/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 14:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParameter_int_.html:6863,Hash,Hash,6863,root/html602/TParameter_int_.html,https://root.cern,https://root.cern/root/html602/TParameter_int_.html,2,['Hash'],['Hash']
Security," TParameter<int>::EStatusBitskLast; static TParameter<int>::EStatusBitskMax; static TParameter<int>::EStatusBitskMin; static TParameter<int>::EStatusBitskMultiply; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfName; intfVal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t TParameter<AParamType> Merge(TCollection* in); Merge objects in the list.; Returns the number of objects that were in the list. void Reset(). const char * GetName() const; { return fName; }. const AParamType & GetVal() const; { return fVal; }. Bool_t IsConst() const; { return (TestBit(kIsConst) ? kTRUE : kFALSE); }. void SetVal(const int& val); { fVal = val; }. void SetMergeMode(char mergemode = '+'); Merging modes:; '+' addition ('OR' for booleans) [default]; '*' multiplication ('AND' for booleans); 'M' maximum ('OR' for booleans); 'm' minimum ('AND' for booleans); 'f' first value; 'l' last value. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsSortable() const; { return kTRUE; }. Int_t Compare(const TObject* obj) const; Compare two TParameter objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp). void ls(Option_t* ) const; Print this parameter content. void Print(Option_t* ) const; Print this parameter content. std::cout << IsA(). » Author: Maarten Ballintijn 21/06/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TParameter_int_.html:6863,Hash,Hash,6863,root/html604/TParameter_int_.html,https://root.cern,https://root.cern/root/html604/TParameter_int_.html,2,['Hash'],['Hash']
Security," TPave.h. ◆ GetY1NDC(). Double_t TPave::GetY1NDC ; (; ); const. inline . Definition at line 61 of file TPave.h. ◆ GetY2NDC(). Double_t TPave::GetY2NDC ; (; ); const. inline . Definition at line 62 of file TPave.h. ◆ Hash(). ULong_t TPave::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPave::HashULong_t Hash() const overrideReturn hash value for this object.Definition TPave.h:63; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 63 of file TPave.h. ◆ IsA(). TClass * TPave::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TBox.; Reimplemented in TPaveClass, TPaveLabel, TPaveStats, TPavesText, and TPaveText.; Definition at line 91 of file TPave.h. ◆ IsSortable(). Bool_t TPave::IsSortable ; (; ); const. inlineoverridevirtual . Reimplemented from TObject.; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPave.html:24556,Hash,Hash,24556,doc/master/classTPave.html,https://root.cern,https://root.cern/doc/master/classTPave.html,1,['Hash'],['Hash']
Security," TS3HTTPRequest &m);  Copy constructor. ;  ;  TS3HTTPRequest (EHTTPVerb httpVerb, const TString &host, const TString &bucket, const TString &objectKey, EAuthType authType, const TString &accessKey, const TString &secretKey);  Default constructor. ;  ; virtual ~TS3HTTPRequest ();  ; const TString & GetAccessKey () const;  ; TString GetAuthType () const;  ; const TString & GetBucket () const;  ; const TString & GetHost () const;  ; EHTTPVerb GetHTTPVerb () const;  ; const TString & GetObjectKey () const;  ; TString GetRequest (TS3HTTPRequest::EHTTPVerb httpVerb, Bool_t appendCRLF=kTRUE);  Returns the HTTP request ready to be sent to the server. ;  ; const TString & GetSecretKey () const;  ; const TString & GetTimeStamp () const;  ; TClass * IsA () const override;  ; TS3HTTPRequest & SetAccessKey (const TString &accessKey);  ; TS3HTTPRequest & SetAuthKeys (const TString &accessKey, const TString &secretKey);  ; TS3HTTPRequest & SetAuthType (TS3HTTPRequest::EAuthType authType);  ; TS3HTTPRequest & SetBucket (const TString &bucket);  ; TS3HTTPRequest & SetHost (const TString &host);  ; TS3HTTPRequest & SetObjectKey (const TString &objectKey);  ; TS3HTTPRequest & SetSecretKey (const TString &secretKey);  ; TS3HTTPRequest & SetSessionToken (const TString &token);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3HTTPRequest.html:2059,access,accessKey,2059,doc/master/classTS3HTTPRequest.html,https://root.cern,https://root.cern/doc/master/classTS3HTTPRequest.html,2,['access'],['accessKey']
Security," TS3HTTPRequest(); TS3HTTPRequest(const TS3HTTPRequest& m); TS3HTTPRequest(TS3HTTPRequest::EHTTPVerb httpVerb, const TString& host, const TString& bucket, const TString& objectKey, TS3HTTPRequest::EAuthType authType, const TString& accessKey, const TString& secretKey); virtual~TS3HTTPRequest(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3HTTPRequest.html:1347,access,accessKey,1347,root/html534/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html534/TS3HTTPRequest.html,1,['access'],['accessKey']
Security," TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); Int_tCreateSymLinks(TList* files); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidSetQueryRunning(TProofQueryResult* pq); Int_tSetupWorkers(Int_t opt = 0, TList* wrks = 0); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tTProof::StartSlaves(Bool_t attach = kFALSE); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidTProof::ValidateDSet(TDSet* dset).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:21156,Validat,ValidateDSet,21156,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,2,['Validat'],['ValidateDSet']
Security," TString &s2)Definition TString.h:704; TString::AdjustCapacitystatic Ssiz_t AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap)Calculate a nice capacity greater than or equal to newCap.Definition TString.cxx:1220; TString::MD5TString MD5() constReturn the MD5 digest for this string, in a string representation.Definition TString.cxx:940; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::EStripTypeEStripTypeDefinition TString.h:276; TString::kLeading@ kLeadingDefinition TString.h:276; TString::kTrailing@ kTrailingDefinition TString.h:276; TString::kBoth@ kBothDefinition TString.h:276; TString::ECaseCompareECaseCompareDefinition TString.h:277; TString::kIgnoreCase@ kIgnoreCaseDefinition TString.h:277; TString::kExact@ kExactDefinition TString.h:277; TString::IsAlphaBool_t IsAlpha() constReturns true if all characters in string are alphabetic.Definition TString.cxx:1798; TString::HashFoldCaseUInt_t HashFoldCase() constReturn a case-insensitive hash value (endian independent).Definition TString.cxx:662; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::IsAsciiBool_t IsAscii() constReturns true if all characters in string are ascii.Definition TString.cxx:1785; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::GetResizeIncrementstatic Ssiz_t GetResizeIncrement()Definition TString.cxx:1576; TString::Putsvoid Puts(FILE *fp)Write string to the stream.Definition Stringio.cxx:229; TString::SetLongCapvoid SetLongCap(Ssiz_t s)Definition TString.h:249; TString::operator+friend TString operator+(const TString &s1, const TString &s2)Use the spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8h_source.html:48482,Hash,HashFoldCase,48482,doc/master/TString_8h_source.html,https://root.cern,https://root.cern/doc/master/TString_8h_source.html,2,"['Hash', 'hash']","['HashFoldCase', 'hash']"
Security," TString& value) const;; 581 ; 582 // ========== class members ==================================================; 583 ; 584 protected:; 585 ; 586 // direct accessors; 587 Ranking* fRanking; // pointer to ranking object (created by derived classifiers); 588 std::vector<TString>* fInputVars; // vector of input variables used in MVA; 589 ; 590 // histogram binning; 591 Int_t fNbins; // number of bins in input variable histograms; 592 Int_t fNbinsMVAoutput; // number of bins in MVA output histograms; 593 Int_t fNbinsH; // number of bins in evaluation histograms; 594 ; 595 Types::EAnalysisType fAnalysisType; // method-mode : true --> regression, false --> classification; 596 ; 597 std::vector<Float_t>* fRegressionReturnVal; // holds the return-values for the regression; 598 std::vector<Float_t>* fMulticlassReturnVal; // holds the return-values for the multiclass classification; 599 ; 600 private:; 601 ; 602 // MethodCuts redefines some of the evaluation variables and histograms -> must access private members; 603 friend class MethodCuts;; 604 ; 605 ; 606 // data sets; 607 DataSetInfo& fDataSetInfo; //! the data set information (sometimes needed); 608 ; 609 Double_t fSignalReferenceCut; // minimum requirement on the MVA output to declare an event signal-like; 610 Double_t fSignalReferenceCutOrientation; // minimum requirement on the MVA output to declare an event signal-like; 611 Types::ESBType fVariableTransformType; // this is the event type (sig or bgd) assumed for variable transform; 612 ; 613 // naming and versioning; 614 TString fJobName; // name of job -> user defined, appears in weight files; 615 TString fMethodName; // name of the method (set in derived class); 616 Types::EMVA fMethodType; // type of method (set in derived class); 617 TString fTestvar; // variable used in evaluation, etc (mostly the MVA); 618 UInt_t fTMVATrainingVersion; // TMVA version used for training; 619 UInt_t fROOTTrainingVersion; // ROOT version used for training; 620 Bool_t fConstructedF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:26098,access,access,26098,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['access'],['access']
Security," TString&); const TMVA::Event*TMVA::MethodBase::GetTrainingEvent(Long64_t ievt) const; const vector<TMVA::Event*>&GetTrainingEvents() const; UInt_tTMVA::MethodBase::GetTrainingROOTVersionCode() const; TStringTMVA::MethodBase::GetTrainingROOTVersionString() const; UInt_tTMVA::MethodBase::GetTrainingTMVAVersionCode() const; TStringTMVA::MethodBase::GetTrainingTMVAVersionString() const; Double_tTMVA::MethodBase::GetTrainTime() const; TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler(); const TMVA::TransformationHandler&TMVA::MethodBase::GetTransformationHandler() const; Double_tGetTreeEveFrac() const; virtual UInt_tTObject::GetUniqueID() const; TStringTMVA::MethodBase::GetWeightFileName() const; Double_tTMVA::MethodBase::GetXmax(Int_t ivar) const; Double_tTMVA::MethodBase::GetXmin(Int_t ivar) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tHasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t); virtual ULong_tTObject::Hash() const; Bool_tTMVA::MethodBase::HasMVAPdfs() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodRuleFitMethodRuleFit(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::Method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodRuleFit.html:7626,Hash,Hash,7626,root/html528/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html,1,['Hash'],['Hash']
Security," TString::GetShortSize ; (; ); const. inlineprivate . Definition at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz_t ; i = 0, . ECaseCompare ; cmp = kExact . ); const. inline . Definition at line 651 of file TString.h. ◆ Index() [2/8]. Ssiz_t TString::Index ; (; const char * ; pattern, . Ssiz_t ; plen, . Ssiz_t ; startIndex, . ECaseCompare ; cmp . ); const. Search for a string in the TString. ; Plen is the length of pattern, startIndex is the index from which to start and cmp selects the type of case-comparison. ; Definition at line 901 of file TString.cxx. ◆ Index() [3/8]. Ssiz_t TString::Index ; (; const TRegexp & ; r, . Ssiz_t * ; extent, . Ssiz_t ; start = 0 . ); const. Find the first occurrence of the regexp in string and return the position, or -1 if there is no match. ; Extent is length of the matched string and start is the offset at which the matching should start. Please, see the War",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTString.html:34416,Hash,HashFoldCase,34416,doc/master/classTString.html,https://root.cern,https://root.cern/doc/master/classTString.html,2,['Hash'],['HashFoldCase']
Security," TString tsTitle (bool inWords=false) const;  ; std::shared_ptr< const RooFitResult > ufit (bool readOnly=false);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNLLVar_1_1xRooHypoPoint.html:3890,Hash,Hash,3890,doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNLLVar_1_1xRooHypoPoint.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNLLVar_1_1xRooHypoPoint.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:21125,access,accessed,21125,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['access'],['accessed']
Security," The caller should check the validity by calling IsValid(); 502 } else {; 503 fSize = fType->Size();; 504 }; 505 }; 506}; 507 ; 508////////////////////////////////////////////////////////////////////////////////; 509/// Return true if the Value has been properly initialized.; 510 ; 511Bool_t TGenCollectionProxy::Value::IsValid(); 512{; 513 ; 514 ; 515 return fSize != std::string::npos;; 516}; 517 ; 518void TGenCollectionProxy::Value::DeleteItem(void* ptr); 519{; 520 // Delete an item.; 521 ; 522 if ( ptr && fCase&kIsPointer ) {; 523 if ( fDelete ) {; 524 (*fDelete)(ptr);; 525 }; 526 else if ( fType ) {; 527 fType->Destructor(ptr);; 528 }; 529 else {; 530 ::operator delete(ptr);; 531 }; 532 }; 533}; 534 ; 535/**; 536 \class TGenCollectionProxy TGenCollectionProxy.cxx; 537 \ingroup IO; 538 ; 539 Proxy around an arbitrary container, which implements basic; 540 functionality and iteration.; 541 ; 542 The purpose of this implementation; 543 is to shield any generated dictionary implementation from the; 544 underlying streamer/proxy implementation and only expose; 545 the creation functions.; 546 ; 547 In particular this is used to implement splitting and abstract; 548 element access of any container. Access to compiled code is necessary; 549 to implement the abstract iteration sequence and functionality like; 550 size(), clear(), resize(). resize() may be a void operation.; 551*/; 552 ; 553////////////////////////////////////////////////////////////////////////////////; 554/// Build a proxy for an emulated container.; 555 ; 556TGenCollectionProxy::TGenCollectionProxy(const TGenCollectionProxy& copy); 557 : TVirtualCollectionProxy(copy.fClass),; 558 fTypeinfo(copy.fTypeinfo); 559{; 560 fEnv = 0;; 561 fName = copy.fName;; 562 fPointers = copy.fPointers;; 563 fSTL_type = copy.fSTL_type;; 564 fSize.call = copy.fSize.call;; 565 fNext.call = copy.fNext.call;; 566 fFirst.call = copy.fFirst.call;; 567 fClear.call = copy.fClear.call;; 568 fResize = copy.fResize;; 569 fDestruct = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:16228,expose,expose,16228,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['expose'],['expose']
Security," This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TImagePlugin(). TImagePlugin::TImagePlugin ; (; const char * ; ext). inline . Definition at line 28 of file TImagePlugin.h. ◆ ~TImagePlugin(). TImagePlugin::~TImagePlugin ; (; ). inlineoverride . Definition at line 29 of file TImagePlugin.h. Member Function Documentation. ◆ Class(). static TClass * TImagePlugin::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TImagePlugin::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TImagePlugin::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 39 of file TImagePlugin.h. ◆ DeclFileName(). static const char * TImagePlugin::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 39 of file TImagePlugin.h. ◆ Hash(). ULong_t TImagePlugin::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TImagePlugin::HashULong_t Hash() const overrideReturn hash value for this object.Definition TImage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImagePlugin.html:11134,Hash,Hash,11134,doc/master/classTImagePlugin.html,https://root.cern,https://root.cern/doc/master/classTImagePlugin.html,1,['Hash'],['Hash']
Security," This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void SetUpSSL (const char *cafile, const char *capath, const char *ucert, const char *ukey);  Set up the static configuration variables. ;  ;  Static Public Member Functions inherited from TSocket; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TSocket * CreateAuthSocket (const char *url, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server. ;  ; static TSocket * CreateAuthSocket (const char *user, const char *host, Int_t port, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ;  ; static const char * DeclFileName ();  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static ULong64_t GetSocketBytesRecv ();  Get total number of bytes received via all sockets. ;  ; static ULong64_t GetSocketBytesSent ();  Get total number of bytes sent via all sockets. ;  ; static void NetError (const char *where, Int_t error);  Print error string depending on error code. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSSLSocket.html:14126,authenticat,authenticates,14126,doc/master/classTSSLSocket.html,https://root.cern,https://root.cern/doc/master/classTSSLSocket.html,1,['authenticat'],['authenticates']
Security," This method can then be used only when the bin content represents counts (i.e. errors are sqrt(N) ).; The likelihood method has the advantage of treating correctly the empty bins and use them in the; fit procedure.; In the chi2 method the empty bins are skipped and not considered in the fit.; The likelihood method, although a bit slower, it is the recommended method in case of low; bin statistics, where the chi2 method may give incorrect results. Fitting a histogram of dimension N with a function of dimension N-1. It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; In this case the option ""Integral"" is not allowed and each cell has; equal weight. Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given an histogram h, one can retrieve an associated function; with: TF1 *myfunc = h->GetFunction(""myfunc"");. Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit which is return by an; automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; Int_t fitStatus = h->Fit(myFunc). If the option ""S"" is instead used, TFitResultPtr contains the TFitResult and behaves as a smart; pointer to it. For example one can do:; TFitResultPtr r = h->Fit(myFunc,""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:76702,Access,Access,76702,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['Access'],['Access']
Security," Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have to be tracked matches the size in pixels of the pad, the time required by this algorithm is proportional to the pad size. On the other hand, the speed is quite acceptable for the default ROOT pad size and the images produced by using this technique have high quality. Since the algorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad. myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; 18.7.3.1 Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):; 1. TGeoShape *clip1, *clip2, ...; One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; 2. gGeoManager->SetClippingShape(clip1);; One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);. Perfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1011834,validat,validation,1011834,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['validat'],['validation']
Security," Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have to be tracked matches the size in pixels of the pad, the time required by this algorithm is proportional to the pad size. On the other hand, the speed is quite acceptable for the default ROOT pad size and the images produced by using this technique have high quality. Since the algorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad; myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:113255,validat,validation,113255,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['validat'],['validation']
Security," UInt_t nFisherVars, UInt_t* mapVarInFisher); TMVA::Node*TMVA::BinaryTree::GetLeftDaughter(TMVA::Node* n); UInt_tTMVA::BinaryTree::GetNNodes() const; TMVA::Node*GetNode(ULong_t sequence, UInt_t depth); Double_tGetNodePurityLimit() const; Double_tGetPruneStrength() const; voidGetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars); TMVA::Node*TMVA::BinaryTree::GetRightDaughter(TMVA::Node* n); virtual TMVA::DecisionTreeNode*GetRoot() const; Double_tGetSumWeights(const TMVA::DecisionTree::EventList* validationSample) const; UInt_tTMVA::BinaryTree::GetTotalTreeDepth() const; Int_tGetTreeID(); vector<Double_t>GetVariableImportance(); Double_tGetVariableImportance(UInt_t ivar); virtual TClass*IsA() const; TMVA::DecisionTree&operator=(const TMVA::DecisionTree&); virtual voidTMVA::BinaryTree::Print(ostream& os) const; voidPruneNode(TMVA::DecisionTreeNode* node); voidPruneNodeInPlace(TMVA::DecisionTreeNode* node); Double_tPruneTree(TMVA::DecisionTree::EventList* validationSample = NULL); virtual voidTMVA::BinaryTree::Read(istream& istr, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidTMVA::BinaryTree::ReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetAnalysisType(TMVA::Types::EAnalysisType t); voidSetMinLinCorrForFisher(Double_t min); voidSetNodePurityLimit(Double_t p); voidSetPairNegWeightsInNode(); voidSetParentTreeInNodes(TMVA::Node* n = NULL); voidSetPruneMethod(TMVA::DecisionTree::EPruneMethod m = kCostComplexityPruning); voidSetPruneStrength(Double_t p); voidTMVA::BinaryTree::SetRoot(TMVA::Node* r); voidTMVA::BinaryTree::SetTotalTreeDepth(Int_t depth); voidTMVA::BinaryTree::SetTotalTreeDepth(TMVA::Node* n = NULL); voidSetTreeID(Int_t treeID); voidSetUseExclusiveVars(Bool_t t = kTRUE); voidSetUseFisherCuts(Bool_t t = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Double_tTestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__DecisionTree.html:4409,validat,validationSample,4409,root/html530/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html530/TMVA__DecisionTree.html,2,['validat'],['validationSample']
Security," UInt_t nFisherVars, UInt_t* mapVarInFisher); TMVA::Node*TMVA::BinaryTree::GetLeftDaughter(TMVA::Node* n); UInt_tTMVA::BinaryTree::GetNNodes() const; TMVA::Node*GetNode(ULong_t sequence, UInt_t depth); Double_tGetNodePurityLimit() const; Double_tGetPruneStrength() const; voidGetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars); TMVA::Node*TMVA::BinaryTree::GetRightDaughter(TMVA::Node* n); virtual TMVA::DecisionTreeNode*GetRoot() const; Double_tGetSumWeights(const TMVA::DecisionTree::EventList* validationSample) const; UInt_tTMVA::BinaryTree::GetTotalTreeDepth() const; Int_tGetTreeID(); vector<Double_t>GetVariableImportance(); Double_tGetVariableImportance(UInt_t ivar); virtual TClass*IsA() const; TMVA::DecisionTree&operator=(const TMVA::DecisionTree&); virtual voidTMVA::BinaryTree::Print(ostream& os) const; voidPruneNode(TMVA::DecisionTreeNode* node); voidPruneNodeInPlace(TMVA::DecisionTreeNode* node); Double_tPruneTree(TMVA::DecisionTree::EventList* validationSample = NULL); virtual voidTMVA::BinaryTree::Read(istream& istr, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidTMVA::BinaryTree::ReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetAnalysisType(TMVA::Types::EAnalysisType t); voidSetMinLinCorrForFisher(Double_t min); voidSetNodePurityLimit(Double_t p); voidSetParentTreeInNodes(TMVA::Node* n = NULL); voidSetPruneMethod(TMVA::DecisionTree::EPruneMethod m = kCostComplexityPruning); voidSetPruneStrength(Double_t p); voidTMVA::BinaryTree::SetRoot(TMVA::Node* r); voidTMVA::BinaryTree::SetTotalTreeDepth(Int_t depth); voidTMVA::BinaryTree::SetTotalTreeDepth(TMVA::Node* n = NULL); voidSetTreeID(Int_t treeID); voidSetUseExclusiveVars(Bool_t t = kTRUE); voidSetUseFisherCuts(Bool_t t = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Double_tTestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; Double_tTra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:4409,validat,validationSample,4409,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,1,['validat'],['validationSample']
Security," UInt_t GetSignalEntries () const;  ; virtual TClass * IsA () const;  ; std::vector< TreeInfo >::const_iterator Sbegin () const;  ; std::vector< TreeInfo >::const_iterator Send () const;  ; const TreeInfo & SignalTreeInfo (Int_t i) const;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataInputHandler.html:3644,Hash,Hash,3644,doc/master/classTMVA_1_1DataInputHandler.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataInputHandler.html,2,['Hash'],['Hash']
Security," Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); Create a TClass object. This object does not contain anything. We mimic; the case of a class fwd declared in the interpreter. TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. This copies the ClassInfo (i.e. does *not* take ownership of it). TClass(const char* name, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); Initialize a TClass object. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:25897,access,access,25897,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['access'],['access']
Security," Vector Expression ;  ; — STL-like interface —; iterator begin ();  STL iterator interface. ;  ; iterator end ();  STL iterator interface. ;  ; const_iterator begin () const;  STL const_iterator interface. ;  ; const_iterator end () const;  STL const_iterator interface. ;  ; template<class InputIterator > ; void SetElements (InputIterator begin, InputIterator end);  set vector elements copying the values iterator size must match vector size ;  ; template<class InputIterator > ; void SetElements (InputIterator begin, unsigned int size);  set vector elements copying the values size must be <= vector size ;  ; — Operators —; bool operator== (const T &rhs) const;  element wise comparison ;  ; bool operator!= (const T &rhs) const;  element wise comparison ;  ; bool operator== (const SVector< T, D > &rhs) const;  element wise comparison ;  ; bool operator!= (const SVector< T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator== (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator!= (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; bool operator> (const T &rhs) const;  element wise comparison ;  ; bool operator< (const T &rhs) const;  element wise comparison ;  ; bool operator> (const SVector< T, D > &rhs) const;  element wise comparison ;  ; bool operator< (const SVector< T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator> (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator< (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; const T & operator[] (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & operator() (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & At (unsigned int i) const;  read-only access of vector elements with check on index. Index starts from 0. ;  ; T & operator[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:4781,access,access,4781,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['access'],['access']
Security," Version_t fModified{1}; ///<!; 63 ; 64 /// The painter of this canvas, bootstrapping the graphics connection.; 65 /// Unmapped canvases (those that never had `Draw()` invoked) might not have; 66 /// a painter.; 67 std::unique_ptr<Internal::RVirtualCanvasPainter> fPainter; ///<!; 68 ; 69 /// indicate if Show() method was called before; 70 bool fShown{false}; ///<!; 71 ; 72 /// indicate if Update() method was called before; 73 bool fUpdated{false}; ///<!; 74 ; 75 /// Disable copy construction for now.; 76 RCanvas(const RCanvas &) = delete;; 77 ; 78 /// Disable assignment for now.; 79 RCanvas &operator=(const RCanvas &) = delete;; 80 ; 81 // Increment modify counter; 82 uint64_t IncModified() { return ++fModified; }; 83 ; 84public:; 85 static std::shared_ptr<RCanvas> Create(const std::string &title);; 86 ; 87 /// Create a temporary RCanvas; for long-lived ones please use Create().; 88 RCanvas() : RPadBase(""canvas"") {}; 89 ; 90 ~RCanvas() override = default;; 91 ; 92 const RCanvas *GetCanvas() const override { return this; }; 93 ; 94 /// Access to the top-most canvas, if any (non-const version).; 95 RCanvas *GetCanvas() override { return this; }; 96 ; 97 /// Set canvas pixel size - width and height; 98 void SetSize(int width, int height); 99 {; 100 fWidth = width;; 101 fHeight = height;; 102 }; 103 ; 104 /// Set canvas width; 105 void SetWidth(int width) { fWidth = width; }; 106 ; 107 /// Set canvas height; 108 void SetHeight(int height) { fHeight = height; }; 109 ; 110 /// Get canvas width; 111 int GetWidth() const { return fWidth; }; 112 ; 113 /// Get canvas height; 114 int GetHeight() const { return fHeight; }; 115 ; 116 /// Display the canvas.; 117 void Show(const std::string &where = """");; 118 ; 119 /// returns true if Show() method was called; 120 bool IsShown() const { return fShown; }; 121 ; 122 /// clear IsShown() flag; 123 void ClearShown() { fShown = false; }; 124 ; 125 /// Returns window name used to display canvas; 126 std::string GetWindowAddr() const;; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8hxx_source.html:3436,Access,Access,3436,doc/master/RCanvas_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8hxx_source.html,1,['Access'],['Access']
Security," What kind of analysis type can handle the CNN; 1091Bool_t MethodDL::HasAnalysisType(Types::EAnalysisType type, UInt_t numberClasses, UInt_t /*numberTargets*/); 1092{; 1093 if (type == Types::kClassification && numberClasses == 2) return kTRUE;; 1094 if (type == Types::kMulticlass) return kTRUE;; 1095 if (type == Types::kRegression) return kTRUE;; 1096 ; 1097 return kFALSE;; 1098}; 1099 ; 1100////////////////////////////////////////////////////////////////////////////////; 1101/// Validation of the ValidationSize option. Allowed formats are 20%, 0.2 and; 1102/// 100 etc.; 1103/// - 20% and 0.2 selects 20% of the training set as validation data.; 1104/// - 100 selects 100 events as the validation data.; 1105///; 1106/// @return number of samples in validation set; 1107///; 1108UInt_t TMVA::MethodDL::GetNumValidationSamples(); 1109{; 1110 Int_t nValidationSamples = 0;; 1111 UInt_t trainingSetSize = GetEventCollection(Types::kTraining).size();; 1112 ; 1113 // Parsing + Validation; 1114 // --------------------; 1115 if (fNumValidationString.EndsWith(""%"")) {; 1116 // Relative spec. format 20%; 1117 TString intValStr = TString(fNumValidationString.Strip(TString::kTrailing, '%'));; 1118 ; 1119 if (intValStr.IsFloat()) {; 1120 Double_t valSizeAsDouble = fNumValidationString.Atof() / 100.0;; 1121 nValidationSamples = GetEventCollection(Types::kTraining).size() * valSizeAsDouble;; 1122 } else {; 1123 Log() << kFATAL << ""Cannot parse number \"""" << fNumValidationString; 1124 << ""\"". Expected string like \""20%\"" or \""20.0%\""."" << Endl;; 1125 }; 1126 } else if (fNumValidationString.IsFloat()) {; 1127 Double_t valSizeAsDouble = fNumValidationString.Atof();; 1128 ; 1129 if (valSizeAsDouble < 1.0) {; 1130 // Relative spec. format 0.2; 1131 nValidationSamples = GetEventCollection(Types::kTraining).size() * valSizeAsDouble;; 1132 } else {; 1133 // Absolute spec format 100 or 100.0; 1134 nValidationSamples = valSizeAsDouble;; 1135 }; 1136 } else {; 1137 Log() << kFATAL << ""Cannot parse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:42517,Validat,Validation,42517,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['Validat'],['Validation']
Security," WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionNoCheckSum(UInt_t* start = 0, UInt_t* bcnt = 0); Read class version from I/O buffer, when the caller knows for sure that; there is no checksum written/involved. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferFile.html:39450,checksum,checksum,39450,root/html534/TBufferFile.html,https://root.cern,https://root.cern/root/html534/TBufferFile.html,3,['checksum'],['checksum']
Security," XML file. If the constructor fails in any way IsZombie() will return true. Use IsOpen() to check if the file is (still) open.; If option = NEW or CREATE create a new file and open it for writing, if the file already exists the file is not opened. = RECREATE create a new file, if the file already exists it will be overwritten. = 2xoo create a new file with specified xml settings for more details see TXMLSetup class = UPDATE open an existing file for writing. if no file exists, it is created. = READ open an existing file for reading.; For more details see comments for TFile::TFile() constructor; TXMLFile does not support TTree objects ; Definition at line 116 of file TXMLFile.cxx. ◆ ~TXMLFile(). TXMLFile::~TXMLFile ; (; ). override . destructor of TXMLFile object ; Definition at line 355 of file TXMLFile.cxx. Member Function Documentation. ◆ AddXmlComment(). Bool_t TXMLFile::AddXmlComment ; (; const char * ; comment). Add comment line on the top of the xml document This line can only be seen in xml editor and cannot be accessed later with TXMLFile methods. ; Definition at line 964 of file TXMLFile.cxx. ◆ AddXmlLine(). Bool_t TXMLFile::AddXmlLine ; (; const char * ; line). Add just one line on the top of xml document For instance, line can contain special xml processing instructions Line should has correct xml syntax that later it can be decoded by xml parser To be parsed later by TXMLFile again, this line should contain either xml comments or xml processing instruction. ; Definition at line 998 of file TXMLFile.cxx. ◆ AddXmlStyleSheet(). Bool_t TXMLFile::AddXmlStyleSheet ; (; const char * ; href, . const char * ; type = ""text/css"", . const char * ; title = nullptr, . int ; alternate = -1, . const char * ; media = nullptr, . const char * ; charset = nullptr . ). Adds style sheet definition on the top of xml document Creates <?xml-stylesheet alternate=""yes"" title=""compact"" href=""small-base.css"" type=""text/css""?> Attributes href and type must be supplied, other attribute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:48952,access,accessed,48952,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['access'],['accessed']
Security," [#12527] - MacOS build fails if configured without cocoa; [#12492] - The problem with building ROOT v6-26-10 in debug mode on ubuntu 20.04; [#12230] - Wrong conversion from Numpy Array to std.vector when using the wrong type; [#12091] - TSpline SaveAs not using equidistant and loss of precision; [#11924] - PyROOT: wrong overload resolution for C++ functions from python; [#11901] - Binary distribution for Ubutu 22.04 is broken (on WSL2); [#11750] - FindXROOTD adds libraries to link against irrespective of xrootd version used; [#11746] - TH2::Fill(const char namex, const char namey, Double_t w) doesn’t update fTsumwxy; [#11743] - CMake >= 3.24 fails to build LZMA: WARNING: ‘aclocal-1.15’ is missing on your system.; [#11673] - [ntuple] Consider making REntry::AddValue() publicly accessible; [#11667] - [cling] GetClassSharedLibs fails to find several classes; [#11653] - TFile plugins :: pass meta4 extension files to TNetXNGFile and process it; [#11596] - cppyy does not retrieve correct size of type when pythonizing vector; [#11484] - roottest/root/meta/genreflex/ROOT-5768 needs to be enabled; [#11411] - PyROOT Python list of strings -> std::initializer_list< std::string > conversion is broken; [#11395] - Migrate to pcre2; [#11353] - Compiled program with libNew.so crash; [#11304] - WW option for fit functions as the W option; [#11238] - an old bug in ROOT v6 TAB completion ?; [#11197] - Build github release into version release procedure; [#11190] - ROOT compiled with -Ddev=ON crashes when type # in ROOT session; [#11021] - [Fit Panel] Fitting to Gaus + Pol0 in two steps is unnecessarily hard; [#10891] - [RF] Deletion order of objects in RooFit/RooStats tutorials should not matter in Python; [#10871] - [DF][ntuple] Better task splitting with RDF+RNTuple; [#10866] - ACLiC flags parsing for compiler command line options broken in certain cases; [#10684] - PyROOT Cannot use SofieFunctor in Python; [#10664] - [ntuple] Expose fixed-size arrays as RVecs in RDF datasource; [#1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:34727,access,accessible,34727,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['access'],['accessible']
Security," [#7164] - TGSpeedo mean value calculation; [#7195] - ROOT crash when parameter by value passed to slot: StrDup; [#7240] - [RF] Batch mode returns broken logarithms when -DVDT=OFF; [#7180] - TGCommandLinePlugin Up-Down Arrows and Tab Keys; [#7181] - RDataFrame Snapshot of friend trees; [#7258] - [RF] Update crystal ball shapes in RooFit; [#7086] - [DF] Section of RDF reference guide about RDF+RVec; [#7182] - Range not considered when computing integral of RooParamHistFunc; [#7547] - [DF] Crash in lazy jitted Snapshot; [#7010] - fifo in $CWD causes TCanvas to hang on macOS; [#7676] - hadd reverses order of object cycles; [#6343] - Problem with using namespace std in generated dictionary files; [#7657] - New dictionary-related crash in 6.24.00-patches; [#7718] - PyROOT in root 6.24 branch hangs while loading CMSSW library; [#7090] - Apple M1: bug in jitting argument of type short; [#6802] - Allow to pass Bearer token authentication header to Davix client; [#7345] - Issue building built-in libafterimage; [#6812] - root REPL problem with unsigned num assigned to a not declared item; [#7292] - compilation fails on xrootd: _STAT_VER was not declared; [#7481] - String parse error in RooSimPdfBuilder.cxx; [#7433] - Segmentation fault after quitting Cling in CUDA mode; [#7239] - [RF] Use integral of PDF curves for pull plots and residuals; [#7390] - Must not forward declare template specialization with enumerator as template arg; [#7454] - [RF][Docs] Breaking changes of batch computation interface not documented in release notes; [#7558] - AfterImage compilation broken with binutils 2.36; [#7507] - [tree] Possible error in TLeaf::GetLeafCounter; [#7361] - RooFit backend library: force to specific architecture; [#7362] - Incremental build problems; [#7319] - [Hist] Wrong computation in TH3::GetCovariance for diagonal elements; [#7206] - Unable to build with builtin_cling=OFF for LLVM 9; [#7157] - RooFFTConvPdf doesn’t work with RooProdPdf; [#7076] - RNTuple, parallel unzip te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:45240,authenticat,authentication,45240,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['authenticat'],['authentication']
Security," [1/2]. TMVA::IMethod * TMVA::ClassifierFactory::Create ; (; const std::string & ; name, . const TString & ; job, . const TString & ; title, . DataSetInfo & ; dsi, . const TString & ; option . ). creates the method if needed based on the method name using the creator function the factory has stored ; Definition at line 89 of file ClassifierFactory.cxx. ◆ Create() [2/2]. TMVA::IMethod * TMVA::ClassifierFactory::Create ; (; const std::string & ; name, . DataSetInfo & ; dsi, . const TString & ; weightfile = """" . ). creates the method if needed based on the method name using the creator function the factory has stored ; Definition at line 114 of file ClassifierFactory.cxx. ◆ DestroyInstance(). void TMVA::ClassifierFactory::DestroyInstance ; (; ). static . destroy the singleton instance ; Definition at line 58 of file ClassifierFactory.cxx. ◆ Instance(). TMVA::ClassifierFactory & TMVA::ClassifierFactory::Instance ; (; ). static . access to the ClassifierFactory singleton creates the instance if needed ; Definition at line 48 of file ClassifierFactory.cxx. ◆ List(). const std::vector< std::string > TMVA::ClassifierFactory::List ; (; ); const. returns a vector of the method type names of registered methods ; Definition at line 136 of file ClassifierFactory.cxx. ◆ operator=(). const ClassifierFactory & TMVA::ClassifierFactory::operator= ; (; const ClassifierFactory & ; ). private . ◆ Print(). void TMVA::ClassifierFactory::Print ; (; ); const. prints the registered method type names ; Definition at line 149 of file ClassifierFactory.cxx. ◆ Register(). Bool_t TMVA::ClassifierFactory::Register ; (; const std::string & ; name, . Creator ; creator . ). registers a classifier creator function under the method type name ; Definition at line 66 of file ClassifierFactory.cxx. ◆ Unregister(). Bool_t TMVA::ClassifierFactory::Unregister ; (; const std::string & ; name). unregisters a classifier type name ; Definition at line 80 of file ClassifierFactory.cxx. Member Data Documentation. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ClassifierFactory.html:3951,access,access,3951,doc/master/classTMVA_1_1ClassifierFactory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ClassifierFactory.html,1,['access'],['access']
Security," [2/2]. Bool_t TDataSetManagerFile::ExistsDataSet ; (; const char * ; uri). overridevirtual . Checks if the indicated dataset exits. ; Reimplemented from TDataSetManager.; Definition at line 1947 of file TDataSetManagerFile.cxx. ◆ FillLsDataSet(). Int_t TDataSetManagerFile::FillLsDataSet ; (; const char * ; group, . const char * ; user, . const char * ; dsname, . TList * ; out, . UInt_t ; option . ). protected . Check for the 'ls.txt' for 'group' and 'user' and fill the path for the ls file in 'out'. ; If 'dsname' is defined, open the file and extract the relevant line. Return 0 on success, -1 on failure ; Definition at line 943 of file TDataSetManagerFile.cxx. ◆ GetDataSet() [1/2]. TFileCollection * TDataSetManagerFile::GetDataSet ; (; const char * ; group, . const char * ; user, . const char * ; dsName, . UInt_t ; option = 0, . TMD5 ** ; checksum = 0 . ). Returns the dataset <dsName> of user <user> in group <group>. ; If checksum is non-zero, it will contain the pointer to a TMD5 sum object with the checksum of the file, has to be deleted by the user. If option has the bi kReadShort set, the shortobject is read, that does not contain the list of files. This is much faster. ; Definition at line 1015 of file TDataSetManagerFile.cxx. ◆ GetDataSet() [2/2]. TFileCollection * TDataSetManagerFile::GetDataSet ; (; const char * ; uri, . const char * ; srv = 0 . ). overridevirtual . Utility function used in various methods for user dataset upload. ; Reimplemented from TDataSetManager.; Definition at line 1874 of file TDataSetManagerFile.cxx. ◆ GetDataSetPath() [1/2]. const char * TDataSetManagerFile::GetDataSetPath ; (; const char * ; group, . const char * ; user, . const char * ; dsName . ). protected . ◆ GetDataSetPath() [2/2]. const char * TDataSetManagerFile::GetDataSetPath ; (; const char * ; group, . const char * ; user, . const char * ; dsName, . TString & ; md5path, . Bool_t ; local = kFALSE . ). protected . Returns path of the indicated dataset. ; The extension is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:25484,checksum,checksum,25484,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,2,['checksum'],['checksum']
Security," \( \gamma = 0.5772156649\dots\) is Euler's constant.; The parameters are:; 0: Norm: Normalization constant; 1: x0: Location parameter; 2: xi: Width parameter; 3: kappa: Parameter \(\kappa\) of the Vavilov distribution; 4: beta2: Parameter \(\beta^2\) of the Vavilov distribution. Benno List, June 2010 ; Definition at line 72 of file VavilovAccuratePdf.h. Public Member Functions;  VavilovAccuratePdf ();  Default constructor. ;  ;  VavilovAccuratePdf (const double *p);  Constructor with parameter values. ;  ;  ~VavilovAccuratePdf () override;  Destructor. ;  ; IBaseFunctionOneDim * Clone () const override;  Return a clone of the object. ;  ; double DoEval (double x) const override;  Evaluate the function. ;  ; double DoEvalPar (double x, const double *p) const override;  Evaluate the function, using parameters p. ;  ; unsigned int NPar () const override;  Return the number of Parameters. ;  ; std::string ParameterName (unsigned int i) const override;  Return the name of the i-th parameter (starting from zero) ;  ; const double * Parameters () const override;  Access the parameter values. ;  ; void SetParameters (const double *p) override;  Set the parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  . Private Attributes; double fP [5];  . Additional Inherited Members;  Public T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovAccuratePdf.html:1899,Access,Access,1899,doc/master/classROOT_1_1Math_1_1VavilovAccuratePdf.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovAccuratePdf.html,1,['Access'],['Access']
Security," a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return a dynamic list giving access to all TDataTypes (typedefs); currently defined. The list is populated on demand. Calling; gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the; TDataType is not already in the list itself and the type does exist,; a new TDataType will be created and added to the list. Calling; gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed throught the; list (plus the builtins types). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the name of the given include file corresponds to a class that; is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. void InitInterpreter(); Initialize the interpreter. Should be called only after main(),; to make sure LLVM/Clang is fully initialized. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:29532,access,accessed,29532,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['access'],['accessed']
Security," a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37261,Access,Access,37261,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,"['Access', 'access']","['Access', 'accessed']"
Security," a PROOF slave object using the connection opened via s. ; Used to avoid double opening when an attempt via TXSlave found a remote proofd. ; Definition at line 259 of file TSlave.cxx. ◆ Interrupt(). void TSlave::Interrupt ; (; Int_t ; type). protectedvirtual . Send interrupt OOB byte to master or slave servers. ; Returns 0 if ok, -1 in case of error ; Definition at line 510 of file TSlave.cxx. ◆ IsA(). TClass * TSlave::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TSlaveLite.; Definition at line 167 of file TSlave.h. ◆ IsSortable(). Bool_t TSlave::IsSortable ; (; ); const. inlineoverridevirtual . Reimplemented from TObject.; Definition at line 122 of file TSlave.h. ◆ IsValid(). virtual Bool_t TSlave::IsValid ; (; ); const. inlinevirtual . Definition at line 150 of file TSlave.h. ◆ OldAuthSetup(). Int_t TSlave::OldAuthSetup ; (; Bool_t ; master, . TString ; wconf . ). private . Setup authentication related stuff for old versions. ; Provided for backward compatibility. ; Definition at line 403 of file TSlave.cxx. ◆ operator=(). void TSlave::operator= ; (; const TSlave & ; ). inlineprivate . Definition at line 72 of file TSlave.h. ◆ Ping(). Int_t TSlave::Ping ; (; ). protectedvirtual . Ping the remote master or slave servers. ; Returns 0 if ok, -1 in case of error ; Definition at line 493 of file TSlave.cxx. ◆ Print(). void TSlave::Print ; (; Option_t * ; option = """"); const. overridevirtual . Printf info about slave. ; Reimplemented from TObject.; Reimplemented in TSlaveLite.; Definition at line 340 of file TSlave.cxx. ◆ SendCoordinator(). TObjString * TSlave::SendCoordinator ; (; Int_t ; kind, . const char * ; msg = 0, . Int_t ; int2 = 0 . ). protectedvirtual . Send message to intermediate coordinator. ; Only meaningful when there is one, i.e. in XPD framework ; Definition at line 643 of file TSlave.cxx. ◆ SendGroupPriority(). virtual Int_t TSlave::SendGroupPriority ; (; const char * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:20745,authenticat,authentication,20745,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['authenticat'],['authentication']
Security," a name; return -1 if variable is not found. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fOptions.PrintLevel(); }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fOptions.MaxFunctionCalls(); }. unsigned int MaxIterations() const; max iterations. { return fOptions.MaxIterations(); }. double Tolerance() const; absolute tolerance. { return fOptions.Tolerance(); }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fOptions.Precision(); }. int Strategy() const; strategy. { return fOptions.Strategy(); }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fOptions.ErrorDef(); }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. void SetPrintLevel(int level); set print level. { fOptions.SetPrintLevel(level); }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { if (maxfcn > 0) fOptions.SetMaxFunctionCalls(maxfcn); }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { if (maxiter > 0) fOptions.SetMaxIterations(maxiter); }. void SetTolerance(double tol); set the tolerance. { fOptions.SetTolerance(tol); }. void SetPrecision(double prec); set in the minimizer the objective function evaluation precision; ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. default case). { fOptions.SetPrecision(prec); }. void SetStrategy(int strategyLevel); set the strategy. { fOptions.SetStrategy(strategyLevel); }. void SetErrorDef(double up); set scale for calculating the errors. { fOptions.SetErrorDef(up); }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:12854,validat,validation,12854,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,3,['validat'],['validation']
Security," a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)activate associate tree branch ;  ; std::map< std::string, value_type > & stateNames ();  Access the map of state names to index numbers. ;  ; const std::map< std::string, value_type > & stateNames () const;  Access the map of state names to index numbers. ;  ; void syncCache (const RooArgSet *set=nullptr) override;  Explicitly synchronize RooAbsCategory internal cache. ;  ; virtual bool isValid (const RooCatType &value) const;  Check if given state is defined for this object. ;  ; const RooCatType * defineType (const char *label);  ; const RooCatType * defineType (const char *label, int index);  ; const RooCatType * defineTypeUnchecked (const char *label, value_type index);  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinningCategory.html:36790,Access,Access,36790,doc/master/classRooBinningCategory.html,https://root.cern,https://root.cern/doc/master/classRooBinningCategory.html,6,['Access'],['Access']
Security," a new wrapper around 'Merge'. ; Definition at line 6969 of file TClass.cxx. ◆ SetNew(). void TClass::SetNew ; (; ROOT::NewFunc_t ; newFunc). Install a new wrapper around 'new'. ; Definition at line 6985 of file TClass.cxx. ◆ SetNewArray(). void TClass::SetNewArray ; (; ROOT::NewArrFunc_t ; newArrayFunc). Install a new wrapper around 'new []'. ; Definition at line 6993 of file TClass.cxx. ◆ SetResetAfterMerge(). void TClass::SetResetAfterMerge ; (; ROOT::ResetAfterMergeFunc_t ; resetFunc). Install a new wrapper around 'ResetAfterMerge'. ; Definition at line 6977 of file TClass.cxx. ◆ SetRuntimeProperties(). void TClass::SetRuntimeProperties ; (; ). private . Internal routine to set calculate the class properties that can only be known at run-time, for example whether the Hash member function and the destructor are consistent. ; Definition at line 6194 of file TClass.cxx. ◆ SetStreamerFunc(). void TClass::SetStreamerFunc ; (; ClassStreamerFunc_t ; strm). Set a wrapper/accessor function around this class custom streamer. ; Definition at line 6922 of file TClass.cxx. ◆ SetStreamerImpl(). void TClass::SetStreamerImpl ; (; ). private . Internal routine to set fStreamerImpl based on the value of fStreamerType. ; Definition at line 6215 of file TClass.cxx. ◆ SetStreamerInfo(). TVirtualStreamerInfo * TClass::SetStreamerInfo ; (; Int_t ; version, . const char * ; info = """" . ). Info is a string describing the names and types of attributes written by the class Streamer function. ; If info is an empty string (when called by TObject::StreamerInfo) the default Streamer info string is build. This corresponds to the case of an automatically generated Streamer. In case of user defined Streamer function, it is the user responsibility to implement a StreamerInfo function (override TObject::StreamerInfo). The user must call IsA()->SetStreamerInfo(info) from this function. ; Definition at line 6373 of file TClass.cxx. ◆ SetUnloaded(). void TClass::SetUnloaded ; (; ). Call this method to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:119191,access,accessor,119191,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['accessor']
Security," a new wrapper around 'Merge'. ; Definition at line 7036 of file TClass.cxx. ◆ SetNew(). void TClass::SetNew ; (; ROOT::NewFunc_t ; newFunc). Install a new wrapper around 'new'. ; Definition at line 7052 of file TClass.cxx. ◆ SetNewArray(). void TClass::SetNewArray ; (; ROOT::NewArrFunc_t ; newArrayFunc). Install a new wrapper around 'new []'. ; Definition at line 7060 of file TClass.cxx. ◆ SetResetAfterMerge(). void TClass::SetResetAfterMerge ; (; ROOT::ResetAfterMergeFunc_t ; resetFunc). Install a new wrapper around 'ResetAfterMerge'. ; Definition at line 7044 of file TClass.cxx. ◆ SetRuntimeProperties(). void TClass::SetRuntimeProperties ; (; ). private . Internal routine to set calculate the class properties that can only be known at run-time, for example whether the Hash member function and the destructor are consistent. ; Definition at line 6261 of file TClass.cxx. ◆ SetStreamerFunc(). void TClass::SetStreamerFunc ; (; ClassStreamerFunc_t ; strm). Set a wrapper/accessor function around this class custom streamer. ; Definition at line 6989 of file TClass.cxx. ◆ SetStreamerImpl(). void TClass::SetStreamerImpl ; (; ). private . Internal routine to set fStreamerImpl based on the value of fStreamerType. ; Definition at line 6282 of file TClass.cxx. ◆ SetStreamerInfo(). TVirtualStreamerInfo * TClass::SetStreamerInfo ; (; Int_t ; version, . const char * ; info = """" . ). Info is a string describing the names and types of attributes written by the class Streamer function. ; If info is an empty string (when called by TObject::StreamerInfo) the default Streamer info string is build. This corresponds to the case of an automatically generated Streamer. In case of user defined Streamer function, it is the user responsibility to implement a StreamerInfo function (override TObject::StreamerInfo). The user must call IsA()->SetStreamerInfo(info) from this function. ; Definition at line 6440 of file TClass.cxx. ◆ SetUnloaded(). void TClass::SetUnloaded ; (; ). Call this method to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:119192,access,accessor,119192,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['accessor']
Security," a python file MyPyClass.py like this: print 'creating class MyPyClass ... '; ; class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'; ; def gime( self, what ):; return what; one can load a python module, and use the class. Casts are necessary as the type information can not be otherwise derived. root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] std::string s = (char*)m.gime( ""aap"" );; root [9] s; (class TString)""aap""; TPython::LoadMacrostatic void LoadMacro(const char *name)Execute the give python script as if it were a macro (effectively an execfile in main),...Definition TPython.cxx:305; TStringBasic string class.Definition TString.h:139; mTMarker mDefinition textangle.C:8; It is possible to switch between interpreters by calling TPython::Prompt() on the Cling side, while returning with ^D (EOF). State is preserved between successive switches.; The API part provides (direct) C++ access to the bindings functionality of PyROOT. It allows verifying that you deal with a PyROOT python object in the first place (CPPInstance_Check for CPPInstance and any derived types, as well as CPPInstance_CheckExact for CPPInstance's only); and it allows conversions of void* to an CPPInstance and vice versa. ; Definition at line 44 of file TPython.h. Static Public Member Functions; static const TPyReturn Eval (const char *expr) R__DEPRECATED(6;  Evaluate a python expression (e.g. ;  ; static Bool_t Exec (const char *cmd, std::any *result=nullptr, std::string const &resultName=""_anyresult"");  Executes a Python command within the current Python environment. ;  ; static void ExecScript (const char *name, int argc=0, const char **argv=nullptr);  Execute a python stand-alone script, with argv CLI arguments. ;  ; static Bool_t Import (const char *name);  Import the named python module and create Cling equivalents for its classes and methods. ;  ; static void LoadMacro (const char *name);  Ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPython.html:2681,access,access,2681,doc/master/classTPython.html,https://root.cern,https://root.cern/doc/master/classTPython.html,1,['access'],['access']
Security," a random place.; 4405 return;; 4406 }; 4407 ; 4408 // STL container sub-branch (contains the elements).; 4409 fNdata = fBranchCount->GetNdata();; 4410 if (!fNdata) {; 4411 return;; 4412 }; 4413 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,fNdata);; 4414 ; 4415 TStreamerInfo *info = GetInfoImp();; 4416 if (info == nullptr) return;; 4417 ; 4418 TVirtualCollectionProxy *proxy = GetCollectionProxy();; 4419 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 4420 ; 4421 TVirtualCollectionIterators *iter = fBranchCount->fIterators;; 4422 b.ApplySequenceVecPtr(*fReadActionSequence,iter->fBegin,iter->fEnd);; 4423}; 4424 ; 4425////////////////////////////////////////////////////////////////////////////////; 4426/// Read leaves into i/o buffers for this branch.; 4427/// Case of a data member within a collection (fType == 41).; 4428 ; 4429void TBranchElement::ReadLeavesCollectionMember(TBuffer& b); 4430{; 4431 ValidateAddress();; 4432 if (fObject == nullptr); 4433 {; 4434 // We have nowhere to copy the data (probably because the data member was; 4435 // 'dropped' from the current schema) so let's no copy it in a random place.; 4436 return;; 4437 }; 4438 ; 4439 // STL container sub-branch (contains the elements).; 4440 fNdata = fBranchCount->GetNdata();; 4441 if (!fNdata) {; 4442 return;; 4443 }; 4444 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,fNdata);; 4445 ; 4446 TStreamerInfo *info = GetInfoImp();; 4447 if (info == nullptr) return;; 4448 // Since info is not null, fReadActionSequence is not null either.; 4449 ; 4450 // Still calling PushPop for the legacy entries.; 4451 TVirtualCollectionProxy *proxy = GetCollectionProxy();; 4452 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 4453 ; 4454 TVirtualCollectionIterators *iter = fBranchCount->fIterators;; 4455 b.ApplySequence(*fReadActionSequence,iter->fBegin,iter->fEnd);; 4456}; 4457 ; 4458////////////////////////////////////////////////////////////////////////////////; 4459/// Read ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:163889,Validat,ValidateAddress,163889,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['Validat'],['ValidateAddress']
Security," a temporary object storing the intermediate result is automatically created when evaluating the expression. ; Definition at line 628 of file SVector.icc. ◆ operator!=() [1/3]. template<class T , unsigned int D> . bool ROOT::Math::SVector< T, D >::operator!= ; (; const SVector< T, D > & ; rhs); const. inline . element wise comparison ; Definition at line 266 of file SVector.icc. ◆ operator!=() [2/3]. template<class T , unsigned int D> . bool ROOT::Math::SVector< T, D >::operator!= ; (; const T & ; rhs); const. inline . element wise comparison ; Definition at line 261 of file SVector.icc. ◆ operator!=() [3/3]. template<class T , unsigned int D> . template<class A > . bool ROOT::Math::SVector< T, D >::operator!= ; (; const VecExpr< A, T, D > & ; rhs); const. inline . element wise comparison ; Definition at line 272 of file SVector.icc. ◆ operator()() [1/2]. template<class T , unsigned int D> . T & ROOT::Math::SVector< T, D >::operator() ; (; unsigned int ; i). inline . read/write access of vector elements. Index starts from 0. ; Definition at line 591 of file SVector.icc. ◆ operator()() [2/2]. template<class T , unsigned int D> . const T & ROOT::Math::SVector< T, D >::operator() ; (; unsigned int ; i); const. inline . read-only access of vector elements. Index starts from 0. ; Definition at line 585 of file SVector.icc. ◆ operator*=(). template<class T , unsigned int D> . SVector< T, D > & ROOT::Math::SVector< T, D >::operator*= ; (; const T & ; rhs). self multiplication with a scalar ; Definition at line 428 of file SVector.icc. ◆ operator+=() [1/3]. template<class T , unsigned int D> . SVector< T, D > & ROOT::Math::SVector< T, D >::operator+= ; (; const SVector< T, D > & ; rhs). self addition with another vector ; Definition at line 379 of file SVector.icc. ◆ operator+=() [2/3]. template<class T , unsigned int D> . SVector< T, D > & ROOT::Math::SVector< T, D >::operator+= ; (; const T & ; rhs). self addition with a scalar ; Definition at line 371 of file SVector.icc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:15955,access,access,15955,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['access'],['access']
Security," a=1.)TColorstatic; GetColor(ULong_t pixel)TColorstatic; GetColorBright(Int_t color)TColorstatic; GetColorByName(const char *colorname)TColorstatic; GetColorDark(Int_t color)TColorstatic; GetColorPalette(Int_t i)TColorstatic; GetColorTransparent(Int_t color, Float_t a)TColorstatic; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFirstFreeColorIndex()TColorstatic; GetFreeColorIndex()TColorstatic; GetGrayscale() constTColorinlinevirtual; GetGreen() constTColorinline; GetHLS(Float_t &h, Float_t &l, Float_t &s) constTColorinlinevirtual; GetHue() constTColorinline; GetIconName() constTObjectvirtual; GetLight() constTColorinline; GetLinearGradient(Double_t angle, const std::vector< Int_t > &colors, const std::vector< Double_t > &positions={})TColorstatic; GetName() const overrideTNamedinlinevirtual; GetNumber() constTColorinline; GetNumberOfColors()TColorstatic; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetPalette()TColorstatic; GetPixel() constTColor; GetRadialGradient(Double_t r, const std::vector< Int_t > &colors, const std::vector< Double_t > &positions={})TColorstatic; GetRed() constTColorinline; GetRGB(Float_t &r, Float_t &g, Float_t &b) constTColorinlinevirtual; GetSaturation() constTColorinline; GetTitle() const overrideTNamedinlinevirtual; GetUniqueID() constTObjectvirtual; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; HLS2RGB(Float_t h, Float_t l, Float_t s, Float_t &r, Float_t &g, Float_t &b)TColorstatic; HLS2RGB(Int_t h, Int_t l, Int_t s, Int_t &r, Int_t &g, Int_t &b)TColorstatic; HLStoRGB(Float_t h, Float_t l, Float_t s, Float_t &r, Float_t &g, Float_t &b)TColorinlinestatic; HLStoRGB1(Float_t rn1, Float_t rn2, Float_t huei)TColorprivatestatic; HSV2RGB(Float_t h, Float_t s, Float_t v, Float_t &r, Float_t &g, Float_t &b)TColorstatic; Info(const char *method, const char *msgfmt,...) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor-members.html:4271,Hash,Hash,4271,doc/master/classTColor-members.html,https://root.cern,https://root.cern/doc/master/classTColor-members.html,1,['Hash'],['Hash']
Security," able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, you should be able to see two threads calculating Pi with the given number of intervals as precision.; 23.2.4 TThread in More Details; Cling is not thread safe yet, and it will block the execution of the threads until it has finished executing.; 23.2.4.1 Asynchronous Actions; Different threads can work simultaneously with the same object. Some actions can be dangerous. For example, when two threads create a histogram object, ROOT allocates memory and puts them to the same collection. If it happens at the same time, the results are undetermined. To avoid this problem, the user has to synchronize these actions with:; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; The code between Lock() and UnLock() will be performed uninterrupted. No other threads can perform actions or access objects/collections while it is being executed. The methods TThread::Lock()and TThread::UnLock() internally use a global TMutex instance for locking.; The user may also define their own TMutex MyMutex instance and may locally protect their asynchronous actions by calling MyMutex.Lock() and MyMutex.UnLock().; 23.2.4.2 Synchronous Actions: TCondition; To synchronize the actions of different threads you can use the TCondition class, which provides a signaling mechanism. The TCondition instance must be accessible by all threads that need to use it, i.e. it should be a global object (or a member of the class which owns the threaded methods, see below). To create a TCondition object, a TMutex instance is required for the Wait and TimedWait locking methods. One can pass the address of an external mutex to the TCondition constructor:; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; If zero is passed, TCondition creates and uses its own internal mutex:; TCondition MyCondition(0);; You can n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1107778,access,access,1107778,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security," added to 'badlist', if; the latter is defined. By default availableOnly is false. void SetSrvMaps(TList* srvmaps = 0); Set (or unset) the list for mapping servers coordinate for files.; Reinitialize the related iterator if needed.; Used by TProof. Bool_t Add(TFileInfo* fileinfo, const char* meta = 0); Add file described by 'fi' to list of files to be analyzed.; The argument 'meta' can be used to specify a subsets in the; file as described in the metadata of TFileInfo. By default the first one; is taken. Int_t ExportFileList(const char* filepath, Option_t* opt = """"); Export TDSetElements files as list of TFileInfo objects in file; 'fpath'. If the file exists already the action fails, unless; 'opt == ""F""'.; Return 0 on success, -1 otherwise. void AddFriend(TDSet* friendset, const char* alias); Add friend dataset to this set. Only possible if the TDSet type is; a TTree or derived class. The friendset will be owned by this class; and deleted in its destructor. void Reset(); Reset or initialize access to the elements. Long64_t GetEntries(Bool_t isTree, const char* filename, const char* path, TString& objname); Returns number of entries in tree or objects in file. Returns -1 in; case of error. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success.; This function accepts a TCut objects as argument.; Use the operator+ to concatenate cuts.; Example:; dset.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success.; For more see TTree::Draw(). void StartViewer(); Start the TTreeViewer on this TTree. TTree* GetTreeHeader(TProof* proof); Returns a tree header conta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDSet.html:13149,access,access,13149,root/html528/TDSet.html,https://root.cern,https://root.cern/root/html528/TDSet.html,6,['access'],['access']
Security," added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. The opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TServerSocket.html:13543,authenticat,authentication,13543,root/html530/TServerSocket.html,https://root.cern,https://root.cern/root/html530/TServerSocket.html,5,['authenticat'],['authentication']
Security," all [class|function|global|typedef];; This pragma statement turns on or off the dictionary generation for all classes, structures, namespaces, global variables, global functions and typedefs seen so far by Cling. Example:; // some C++ header definition; #ifdef __ROOTCLING__; // turns off dictionary generation for all; #pragma link off all class;; #pragma link off all function;; #pragma link off all global;; #pragma link off all typedef;; #endif; The next pragma statement selectively turns on or off the dictionary generation for the specified classs, struct, union, enum or namespace:; #pragma link; [C|C++|off][class|class+protected|; struct|union|enum|namespace][name];; The Dictionary of all public members of class and struct will be generated. If the ‘class+protected’ flag is used, the dictionary for protected members will also be generated. However, dictionary for protected constructor and destructor will not be generated. This ’ class+protected ’ flag will help you only for plain protected member access, but not for virtual function resolution.; If you use the ‘namespace’ flag, it is recommended to add also:; #pragma link C++ nestedclass;; #pragma link C++ nestedtypedef;; The behavior of ‘class’, ‘struct’ and ‘namespace’ flag are identical. Example:; // some C++ header definition; #ifdef __ROOTCLING__; #pragma link off all class;; #pragma link C++ class A;; #pragma link C++ class B;; #pragma link C++ class C<int>;; #pragma link C++ class+protected D;; #pragma link C++ namespace project1;; #pragma link C++ nestedclass;; #pragma link C++ nestedtypedef;; #endif; The next pragma statement selectively turns on or off the dictionary generation for global variables and typedef.; #pragma link [C|C++|off] [global|typedef] [name];; Example:; // some C/C++ header definition; #ifdef __ROOTCLING__; #pragma link off all global;; #pragma link off all typedef;; #pragma link C++ global a;; #pragma link C++ typedef Int_t;; #endif; This pragma statement turns on the dictionary gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:829325,access,access,829325,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security," all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Types |; Private Member Functions |; List of all members ; TKey Class ReferenceInput/Output Library. ; Book space in a file, create I/O buffers, to fill them, (un)compress them. ; The TKey class includes functions to book space in a file, to create I/O buffers, to fill these buffers, to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must be created. The key structure contains all the information to uniquely identify a persistent object in a file. . Data Member Explanation . fNbytes Number of bytes for the compressed object and key. . fObjlen Length of uncompressed object. . fDatime Date/Time when the object was written. . fKeylen Number of bytes for the key structure. . fCycle Cycle number of the object. . fSeekKey Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. . fSeekPdir Pointer to the directory supporting this object. . fClassName Object class name. . fName Name of the object. . fTitle Title of the object. . In the 16 highest bits of fSeekPdir is encoded a pid offset. This offset is to be added to the pid index stored in the TRef object and the referenced TObject.; The TKey class is used by ROOT to:; Write an object in the current directory; Write a new ntuple buffer. The structure of a file is shown in TFile::TFile. The structure of a directory is shown in TDirectoryFile::TDirectoryFile. The TKey class is used by the TBasket class. See also TTree. ; Definition at line 28 of file TKey.h. Public Member Functions;  TKey ();  TKey default constructor. ;  ;  TKey (const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory *motherDir);  Create a TKey object with the specified name, title for the given class. ;  ;  TKey (const TObject *obj, const char *name, Int_t bufsize, TDirectory *m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:1147,integrity,integrity,1147,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['integrity'],['integrity']
Security," all other parameters which is most strongly correlated with i. ; Minimizer must overload method if implemented ; Reimplemented in ROOT::Minuit2::Minuit2Minimizer, and TMinuitMinimizer.; Definition at line 161 of file Minimizer.cxx. ◆ Hesse(). bool ROOT::Math::Minimizer::Hesse ; (; ). virtual . perform a full calculation of the Hessian matrix for error calculation ; Reimplemented in TMinuitMinimizer, and ROOT::Minuit2::Minuit2Minimizer.; Definition at line 185 of file Minimizer.cxx. ◆ IsFixedVariable(). bool ROOT::Math::Minimizer::IsFixedVariable ; (; unsigned int ; ivar); const. virtual . query if an existing variable is fixed (i.e. ; considered constant in the minimization) note that by default all variables are not fixed ; Reimplemented in ROOT::Math::BasicMinimizer, ROOT::Minuit2::Minuit2Minimizer, and TMinuitMinimizer.; Definition at line 102 of file Minimizer.cxx. ◆ IsValidError(). bool ROOT::Math::Minimizer::IsValidError ; (; ); const. inline . return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ; Definition at line 320 of file Minimizer.h. ◆ MaxFunctionCalls(). unsigned int ROOT::Math::Minimizer::MaxFunctionCalls ; (; ); const. inline . max number of function calls ; Definition at line 294 of file Minimizer.h. ◆ MaxIterations(). unsigned int ROOT::Math::Minimizer::MaxIterations ; (; ); const. inline . max iterations ; Definition at line 297 of file Minimizer.h. ◆ MinGradient(). virtual const double * ROOT::Math::Minimizer::MinGradient ; (; ); const. inlinevirtual . return pointer to gradient values at the minimum ; Reimplemented in TFumiliMinimizer, ROOT::Math::GeneticMinimizer, ROOT::Math::GSLMinimizer, ROOT::Math::GSLNLSMinimizer, TLinearMinimizer, TMinuitMinimizer, and ROOT::Minuit2::Minuit2Minimizer.; Definition at line 225 of file Minimizer.h. ◆ Minimize(). virtual bool ROOT::Math::Minimizer::Minimize ; (; ). pure virtual . method to perform the minimization ; Implemented in TFumiliMinimizer, ROOT::Math::Genetic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:21079,validat,validation,21079,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['validat'],['validation']
Security," all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CAddress< std::vector< Bool_t, A > >;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< Bool_t, A > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t, A > >;  CIterators;  CTFutureImpl;  CTRangeStaticCastTRangeStaticCast is an adaptater class that allows the typed iteration through a TCollection ;  ►CTSchemaRuleSet;  CTMatches;  ►CTStatusBitsChecker;  CRegistry;  CTTypedIterTTypedIter is a typed version of TIter ;  ►NExecutorUtilsThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CRArgsMenuItem;  CRCheckedMenuItem;  CRHistBinIterIterates over the bins of a RHist or RHistImpl ;  CRHistBinPtrPoints to a histogram bin (or actually a RHistBinRef) ;  CRHistBinRefRepresents a bin reference ;  CRHistBinStatConst view on a bin's statistical data ;  CRHistDataA RHist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:17210,access,accesses,17210,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,2,['access'],['accesses']
Security," an elaborate thread management is in place, e.g. in presence of stream of operations or ""processing slots"", it is also possible to manually select the correct object pointer explicitly. ; Definition at line 151 of file TThreadedObject.hxx. Public Member Functions; template<class ... ARGS> ;  TThreadedObject (ARGS &&... args);  Construct the TThreadedObject and the ""model"" of the thread private objects. ;  ;  TThreadedObject (const TThreadedObject &)=delete;  ; template<class... ARGS> ;  TThreadedObject (TNumSlots initSlots, ARGS &&... args);  Construct the TThreadedObject with initSlots empty slots and the ""model"" of the thread private objects. ;  ; std::shared_ptr< T > Get ();  Access the pointer corresponding to the current slot. ;  ; std::shared_ptr< T > GetAtSlot (unsigned i);  Access a particular processing slot. ;  ; T * GetAtSlotRaw (unsigned i) const;  Access a particular slot which corresponds to a single thread. ;  ; std::shared_ptr< T > GetAtSlotUnchecked (unsigned i) const;  Access a particular slot which corresponds to a single thread. ;  ; unsigned GetNSlots () const;  Return the number of currently available slot. ;  ; std::shared_ptr< T > Merge (TThreadedObjectUtils::MergeFunctionType< T > mergeFunction=TThreadedObjectUtils::MergeTObjects< T >);  Merge all the thread private objects. ;  ; T * operator-> ();  Access the wrapped object and allow to call its methods. ;  ; void SetAtSlot (unsigned i, std::shared_ptr< T > v);  Set the value of a particular slot. ;  ; std::unique_ptr< T > SnapshotMerge (TThreadedObjectUtils::MergeFunctionType< T > mergeFunction=TThreadedObjectUtils::MergeTObjects< T >);  Merge all the thread private objects. ;  . Static Public Attributes; static constexpr const TNumSlots fgMaxSlots {64};  The initial number of empty processing slots that a TThreadedObject is constructed with by default. ;  . Private Member Functions; unsigned GetThisSlotNumber ();  Get the slot number for this threadID, make a slot if needed. ;  . Private ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:1920,Access,Access,1920,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,2,['Access'],['Access']
Security," an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Touch ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPServerSocket.html:6530,Hash,Hash,6530,doc/master/classTPServerSocket.html,https://root.cern,https://root.cern/doc/master/classTPServerSocket.html,10,"['Hash', 'hash']","['Hash', 'hash']"
Security," and BrowseDataSet. Available options (to be .or.ed): kPrint print the dataset content kQuotaUpdate update quotas kExport use export naming kList get a list of dataset names; NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. ; Definition at line 577 of file TDataSetManagerFile.cxx. ◆ CheckLocalCache(). Int_t TDataSetManagerFile::CheckLocalCache ; (; const char * ; group, . const char * ; user, . const char * ; dsName = ""ls"", . UInt_t ; option = 0 . ). private . Check if the local cache information for group, user, dsName is up-to-date If not, make the relevant updates Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. ; Definition at line 1085 of file TDataSetManagerFile.cxx. ◆ ChecksumDataSet(). Int_t TDataSetManagerFile::ChecksumDataSet ; (; const char * ; path, . const char * ; md5path, . TString & ; checksum . ). protected . Calculate the checksum of the indicated dataset at 'path' and save it to the appropriate file 'md5path'. ; The MD5 string is returned in 'md5sum'. Return 0 on success, -1 on error. ; Definition at line 1512 of file TDataSetManagerFile.cxx. ◆ Class(). static TClass * TDataSetManagerFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDataSetManagerFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDataSetManagerFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TDataSetManagerFile.h. ◆ ClearCache(). Int_t TDataSetManagerFile::ClearCache ; (; const char * ; uri = 0). overridevirtual . Clear cached information matching uri. ; Reimplemented from TDataSetManager.; Definition at line 1253 of file TDataSetManagerFile.cxx. ◆ CreateLsFile(). Int_t TDataSetManagerFile::CreateLsFile ; (; const char * ; group, . const char * ; user, . Long_t & ; mtime, . TString & ; checksum . ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:22707,checksum,checksum,22707,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['checksum'],['checksum']
Security," and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware; *-* of all TMath functions.; -; -. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFormula.html:3008,access,access,3008,root/html528/TFormula.html,https://root.cern,https://root.cern/root/html528/TFormula.html,6,['access'],['access']
Security," and a drawing area) ;  CTCastorFileA TNetFile interfaced to the Castor storage backend ;  CTChainA chain is a collection of files containing TTree objects ;  CTChainElementA TChainElement describes a component of a TChain ;  ►CTChainIndexA Chain Index ;  CTChainIndexEntryHolds a description of indices of trees in the chain ;  CTChair;  CTCivetweb;  CTCL;  ►CTClassThe ROOT global object gROOT contains a list of all defined classes ;  CInsertTClassInRegistryRAII;  CTDeclNameRegistry;  CTNameMapNode;  CTClassDocInfo;  CTClassDocOutput;  CTClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized way to create the TClass objects ;  CTClassMenuItemDescribes one element of the context menu associated to a class The menu item may describe ;  CTClassRefTClassRef is used to implement a permanent reference to a TClass object ;  CTClassStreamer;  CTClassTableThis class registers for all classes their name, id and dictionary function in a hash table ;  CTClassTreeDraw inheritance tree and their relations for a list of classes ;  CTClonesArrayAn array of clone (identical) objects ;  CTCollectionCollection abstract base class ;  CTCollectionClassStreamerClass streamer object to implement TClassStreamer functionality for I/O emulation ;  CTCollectionMemberStreamerClass streamer object to implement TMemberStreamer functionality for I/O emulation ;  CTCollectionMethodBrowsableTCollectionMethodBrowsable extends TCollectionPropertyBrowsable by showing all methods of the collection itself ;  CTCollectionPropertyBrowsableA tiny browser helper object (and its generator) for adding a virtual (as in ""not actually part of the class"", not in C++ virtual) ""@size()"" method to a collection ;  CTCollectionProxyFactoryTCollectionProxyFactory Interface to collection proxy and streamer generator ;  CTCollectionStreamerClass streamer object to implement TClassStreamer functionality for I/O emulation ;  CTColorThe color creation and management c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:138953,hash,hash,138953,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['hash'],['hash']
Security," and drop data container. ; Definition at line 64 of file TGDNDManager.h. Public Member Functions;  TDNDData (Atom_t dt=kNone, void *d=nullptr, Int_t len=0, Atom_t act=kNone);  ;  ~TDNDData () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDNDData.html:1328,Hash,Hash,1328,doc/master/classTDNDData.html,https://root.cern,https://root.cern/doc/master/classTDNDData.html,2,['Hash'],['Hash']
Security, and its elements. ; Needed for backward compatibility in talking to old client / masters. ; Definition at line 1874 of file TDSet.cxx. ◆ SplitEntryList(). void TDSet::SplitEntryList ; (; ). private . for browsing purposes ; Splits the main entry (or event) list into sub-lists for the elements of thet data set. ; Definition at line 1941 of file TDSet.cxx. ◆ StartViewer(). void TDSet::StartViewer ; (; ). virtual . Start the TTreeViewer on this TTree. ; Definition at line 1520 of file TDSet.cxx. ◆ Streamer(). void TDSet::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TDSet. ; Reimplemented from TObject.; Reimplemented in TDSetProxy.; Definition at line 1813 of file TDSet.cxx. ◆ StreamerNVirtual(). void TDSet::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 262 of file TDSet.h. ◆ Validate() [1/2]. void TDSet::Validate ; (; ). Validate the TDSet by opening files. ; Definition at line 1589 of file TDSet.cxx. ◆ Validate() [2/2]. void TDSet::Validate ; (; TDSet * ; dset). Validate the TDSet against another TDSet. ; Only validates elements in common from input TDSet. ; Definition at line 1668 of file TDSet.cxx. Member Data Documentation. ◆ fCurrent. TDSetElement* TDSet::fCurrent. protected . iterator on fElements ; Definition at line 182 of file TDSet.h. ◆ fDir. TString TDSet::fDir. protected . Definition at line 177 of file TDSet.h. ◆ fElements. THashList* TDSet::fElements. protected . Definition at line 180 of file TDSet.h. ◆ fEntryList. TObject* TDSet::fEntryList. private . Definition at line 168 of file TDSet.h. ◆ fIsTree. Bool_t TDSet::fIsTree. private . Definition at line 167 of file TDSet.h. ◆ fIterator. TIter* TDSet::fIterator. protected . Definition at line 181 of file TDSet.h. ◆ fObjName. TString TDSet::fObjName. protected . Definition at line 179 of file TDSet.h. ◆ fProofChain. TProofChain* TDSet::fProofChain. private . entry (or event) list for processing ; Definition at line 169 of file T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSet.html:29837,Validat,Validate,29837,doc/master/classTDSet.html,https://root.cern,https://root.cern/doc/master/classTDSet.html,1,['Validat'],['Validate']
Security," and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws"", 'rdfsampleinfo_.GetD(""sumws"")'); df = df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ; # We must further apply an MC correction for the ZZ decay due to missing gg->ZZ processes.; ROOT.gInterpreter.Declare(; """"""; float scale(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }; """"""; ); ; df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); ; # Select events for the analysis; ROOT.gInterpreter.Declare(; """"""; using ROOT::RVecF;; using ROOT::RVecI;; bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:1630,Access,Access,1630,doc/master/df106__HiggsToFourLeptons_8py.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html,1,['Access'],['Access']
Security," and the slot indices. A good practice consists in copying the pointer onto the stack and proceed with the loop as shown in this work item (psudo-code) which will be sent to different threads: auto workItem = [](){; auto objPtr = tthreadedObject.Get();; for (auto i : ROOT::TSeqI(1000)) {; // tthreadedObject->FastMethod(i); // don't do this! Inefficient!; objPtr->FastMethod(i);; }; }; ROOT::TSeqA pseudo container class which is a generator of indices.Definition TSeq.hxx:67; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. Definition at line 280 of file TThreadedObject.hxx. ◆ GetAtSlot(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::GetAtSlot ; (; unsigned ; i). inline . Access a particular processing slot. ; This method is thread-safe as long as concurrent calls request different slots (i.e. pass a different argument) and no thread accesses slot i via the arrow operator, so mixing usage of GetAtSlot with usage of the arrow operator can be dangerous. ; Definition at line 202 of file TThreadedObject.hxx. ◆ GetAtSlotRaw(). template<class T > . T * ROOT::TThreadedObject< T >::GetAtSlotRaw ; (; unsigned ; i); const. inline . Access a particular slot which corresponds to a single thread. ; This overload is faster than the GetAtSlotUnchecked method but the caller is responsible to make sure that the slot exists, to check that the contained object is initialized and that the returned pointer will not outlive the TThreadedObject that returned it, which maintains ownership of the actual object. ; Definition at line 260 of file TThreadedObject.hxx. ◆ GetAtSlotUnchecked(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::GetAtSlotUnchecked ; (; unsigned ; i); const. inline . Access a particular slot which corresponds to a single thread. ; This is in general faster than the GetAtSlot method but it is responsibility of the caller to make sure t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:5950,access,accesses,5950,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,2,['access'],['accesses']
Security," and/or slaves.; If plusMaster is kTRUE then exeucte on slaves and master too.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t Exec(const char *cmd, ESlaves list, Bool_t plusMaster); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); Send command to be executed on node of ordinal 'ord' (use ""0"" for master).; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster.; If logtomacro is TRUE the text result of the action is saved in the fMacroLog; TMacro, accessible via TMacro::GetMacroLog();; Returns -1 in case of error, >=0 in case of succes. Int_t SendCommand(const char* cmd, TProof::ESlaves list = kActive); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command, however commands; like "".x file.C"" or "".L file.C"" will not cause the file.C to be; transfered to the PROOF cluster. In that case use TProof::Exec().; Returns the status send by the remote server as part of the; kPROOF_LOGDONE message. Typically this is the return code of the; command on the remote side. Returns -1 in case of error. TString Getenv(const char* env, const char* ord = ""0""); Get value of environment variable 'env' on node 'ord'. Int_t GetRC(const char* RCenv, Int_t& env, const char* ord = ""0""); Get into 'env' the value of integer RC env variable 'rcenv' on node 'ord'. Int_t GetRC(const char* RCenv, Double_t& env, const char* ord = ""0""); Get into 'env' the value of double RC env variable 'rcenv' on node 'ord'. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:62312,access,accessible,62312,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['access'],['accessible']
Security," as a result of repaint() or update(), or because the widget; was obscured and has now been uncovered, or for many other reasons. void SetSizeHint(const QSize& size); sets the preferred size of the widget. QSize sizeHint() const; returns the preferred size of the widget. QSize minimumSizeHint() const; returns the smallest size the widget can have. QSizePolicy sizePolicy() const; returns a QSizePolicy; a value describing the space requirements. void EmitTestedSignal(). void SetBit(UInt_t f, Bool_t set); Set or unset the user status bits as specified in f. TQtWidgetBuffer & SetBuffer(); Create (if needed) and return the buffer. QPixmap * GetOffScreenBuffer() const; return the current widget buffer;. TCanvas * GetCanvas() const. { return fCanvas; }. const TQtWidgetBuffer * GetBuffer() const. bool PaintingActive() const. void SetRootID(QWidget* wrapper). { fWrapper = wrapper;}. QWidget * GetRootID() const. { return fWrapper;}. Int_t GetEvent() const. Proxy methods to access the TCanvas selected TObject; and last processed event. { return GetCanvas()->GetEvent(); }. Int_t GetEventX() const. { return GetCanvas()->GetEventX(); }. Int_t GetEventY() const. { return GetCanvas()->GetEventY(); }. TObject * GetSelected() const. { return GetCanvas()->GetSelected(); }. Int_t GetSelectedX() const. { return GetCanvas()->GetSelectedX(); }. Int_t GetSelectedY() const. { return GetCanvas()->GetSelectedY(); }. TVirtualPad * GetSelectedPad() const. { return GetCanvas()->GetSelectedPad(); }. UInt_t GetAllBits() const; ----- bit manipulation. { return fBits; }. void SetAllBits(UInt_t f); { fBits = f; }. void SetBit(UInt_t f); { fBits |= f & kBitMask; }. void ResetBit(UInt_t f); { fBits &= ~(f & kBitMask); }. Bool_t TestBit(UInt_t f) const; { return (Bool_t) ((fBits & f) != 0); }. Int_t TestBits(UInt_t f) const; { return (Int_t) (fBits & f); }. void InvertBit(UInt_t f); { fBits ^= f & kBitMask; }. TQtCanvasPainter * CanvasDecorator(); { return fCanvasDecorator; }. void SetCanvasDecorator(TQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtWidget.html:13402,access,access,13402,root/html528/TQtWidget.html,https://root.cern,https://root.cern/root/html528/TQtWidget.html,5,['access'],['access']
Security," as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate ROOT::v5::TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to ROOT::v5::TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to ROOT::v5::TFormula. If name passed by ROOT::v5::TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to ROOT::v5::TFormula. If name passed by ROOT::v5::TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Tue Jun 2 15:30:55 2015 » Last generated: 2015-06-02 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooFormula.html:24242,access,accessor,24242,root/html604/RooFormula.html,https://root.cern,https://root.cern/root/html604/RooFormula.html,1,['access'],['accessor']
Security," as the friend list information. Example specification file JSON:; The following is an example of the dataset specification JSON file formatting: {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {""lumi"": 1.0, }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {""lumi"": 0.5, }; },; ...; },; }. Definition at line 1906 of file RDataFrame.cxx. ◆ VariationsFor() [1/2]. template<typename T > . RResultMap< T > ROOT::RDF::Experimental::VariationsFor ; (; RResultPtr< T > ; resPtr). Produce all required systematic variations for the given result. ; Parameters. [in]resPtrThe result for which variations should be produced. . ReturnsA RResultMap object with full variation names as strings (e.g. ""pt:down"") and the corresponding varied results as values.; A given input RResultPtr<T> produces a corresponding RResultMap<T> with a ""nominal"" key that will return a value identical to the one contained in the original RResultPtr. Other keys correspond to the varied values of this result, one for each variation that the result depends on. VariationsFor does not trigger the event loop. The event loop is only triggered upon first access to a valid key, similarly to what happens with RResultPtr.; If the result does not depend, directly or indirectly, from any registered systematic variation, the returned RResultMap will contain only the ""nominal"" key.; See RDataFrame's Vary method for more information and example usages.; NoteCurrently, producing variations for the results of Display, Report and Snapshot actions is not supported. ; Definition at line 219 of file RDFHelpers.hxx. ◆ VariationsFor() [2/2]. ROOT::RDF::Experimental::SnapshotPtr_t ROOT::RDF::Experimental::VariationsFor ; (; SnapshotPtr_t ; resPtr). Definition at line 135 of file RDFHelpers.cxx. ROOTRDFExperimental. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF_1_1Experimental.html:6179,access,access,6179,doc/master/namespaceROOT_1_1RDF_1_1Experimental.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF_1_1Experimental.html,1,['access'],['access']
Security," associated to this mapfile. void Add(const TObject* obj, const char* name = """"); Add an object to the list of objects to be stored in shared memory.; To place the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents of TMapFile. Bool_t cd(const char* path = 0); Cd to associated directory,. void ls(Option_t* option = """") const; List contents of TMapFile. void SumBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMapFile.html:11685,access,access,11685,root/html528/TMapFile.html,https://root.cern,https://root.cern/root/html528/TMapFile.html,6,['access'],['access']
Security," assume ""OK"" */; 13976 return 1;; 13977}; 13978 ; 13979 ; 13980static void; 13981experimental_websocket_client_close_wrapper(const struct mg_connection *conn,; 13982 void *cbdata); 13983{; 13984 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13985 if (pcallbacks->connection_close) {; 13986 pcallbacks->connection_close(conn);; 13987 }; 13988}; 13989#endif; 13990 ; 13991 ; 13992/* Decrement recount of handler. conn must not be NULL, handler_info may be NULL; 13993 */; 13994static void; 13995release_handler_ref(struct mg_connection *conn,; 13996 struct mg_handler_info *handler_info); 13997{; 13998 if (handler_info != NULL) {; 13999 /* Use context lock for ref counter */; 14000 mg_lock_context(conn->phys_ctx);; 14001 handler_info->refcount--;; 14002 mg_unlock_context(conn->phys_ctx);; 14003 }; 14004}; 14005 ; 14006 ; 14007/* This is the heart of the Civetweb's logic.; 14008 * This function is called when the request is read, parsed and validated,; 14009 * and Civetweb must decide what action to take: serve a file, or; 14010 * a directory, or call embedded function, etcetera. */; 14011static void; 14012handle_request(struct mg_connection *conn); 14013{; 14014 struct mg_request_info *ri = &conn->request_info;; 14015 char path[UTF8_PATH_MAX];; 14016 int uri_len, ssl_index;; 14017 int is_found = 0, is_script_resource = 0, is_websocket_request = 0,; 14018 is_put_or_delete_request = 0, is_callback_resource = 0,; 14019 is_template_text_file = 0;; 14020 int i;; 14021 struct mg_file file = STRUCT_FILE_INITIALIZER;; 14022 mg_request_handler callback_handler = NULL;; 14023 struct mg_handler_info *handler_info = NULL;; 14024 struct mg_websocket_subprotocols *subprotocols;; 14025 mg_websocket_connect_handler ws_connect_handler = NULL;; 14026 mg_websocket_ready_handler ws_ready_handler = NULL;; 14027 mg_websocket_data_handler ws_data_handler = NULL;; 14028 mg_websocket_close_handler ws_close_handler = NULL;; 14029 void *callback_data = NULL;; 14030 mg_authorization",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:409917,validat,validated,409917,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['validat'],['validated']
Security," assume ""OK"" */; 13977 return 1;; 13978}; 13979 ; 13980 ; 13981static void; 13982experimental_websocket_client_close_wrapper(const struct mg_connection *conn,; 13983 void *cbdata); 13984{; 13985 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13986 if (pcallbacks->connection_close) {; 13987 pcallbacks->connection_close(conn);; 13988 }; 13989}; 13990#endif; 13991 ; 13992 ; 13993/* Decrement recount of handler. conn must not be NULL, handler_info may be NULL; 13994 */; 13995static void; 13996release_handler_ref(struct mg_connection *conn,; 13997 struct mg_handler_info *handler_info); 13998{; 13999 if (handler_info != NULL) {; 14000 /* Use context lock for ref counter */; 14001 mg_lock_context(conn->phys_ctx);; 14002 handler_info->refcount--;; 14003 mg_unlock_context(conn->phys_ctx);; 14004 }; 14005}; 14006 ; 14007 ; 14008/* This is the heart of the Civetweb's logic.; 14009 * This function is called when the request is read, parsed and validated,; 14010 * and Civetweb must decide what action to take: serve a file, or; 14011 * a directory, or call embedded function, etcetera. */; 14012static void; 14013handle_request(struct mg_connection *conn); 14014{; 14015 struct mg_request_info *ri = &conn->request_info;; 14016 char path[UTF8_PATH_MAX];; 14017 int uri_len, ssl_index;; 14018 int is_found = 0, is_script_resource = 0, is_websocket_request = 0,; 14019 is_put_or_delete_request = 0, is_callback_resource = 0,; 14020 is_template_text_file = 0;; 14021 int i;; 14022 struct mg_file file = STRUCT_FILE_INITIALIZER;; 14023 mg_request_handler callback_handler = NULL;; 14024 struct mg_handler_info *handler_info = NULL;; 14025 struct mg_websocket_subprotocols *subprotocols;; 14026 mg_websocket_connect_handler ws_connect_handler = NULL;; 14027 mg_websocket_ready_handler ws_ready_handler = NULL;; 14028 mg_websocket_data_handler ws_data_handler = NULL;; 14029 mg_websocket_close_handler ws_close_handler = NULL;; 14030 void *callback_data = NULL;; 14031 mg_authorization",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:409950,validat,validated,409950,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['validat'],['validated']
Security," at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set by the user when the tree is initialized, but currently they are set automatically to: InnerLowWaterMark = ceiling(Order/2); LeafLowWaterMark = Order - 1; TBtree::OrderInt_t Order()Definition TBtree.h:96; If the tree is only filled, then all the nodes will be at least 2/3 full. They will almost all be exactly 2/3 full if the elements are added to the tree in order (either increasing or decreasing). [Knuth says McCreight's experiments showed almost 100% memory utilization. I don't see how that can be given the algorithms that Knuth gives. McCreight must have used a different scheme for balancing. [No, he used a different scheme for splitting: he did a two-way split instead of the three way split as we do here. Which means that McCreight does better on insertion of ordered data, but we should do better on insertion of random data.]]; It must also be noted that B-trees were designed for DISK access algorithms, not necessarily in-memory sorting, as we intend it to be used here. However, if the order is kept small (< 6?) any inefficiency is negligible for in-memory sorting. Knuth points out that balanced trees are actually preferable for memory sorting. I'm not sure that I believe this, but it's interesting. Also, deleting elements from balanced binary trees, being beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees are good enough.; A B-tree is declared to be of a certain ORDER (3 by default). This number determines the number of keys contained in any interior node of the tree. Each interior node will contain ORDER keys, and therefore ORDER+1 pointers to sub-trees. The keys are numbered and indexed 1 to ORDER while the pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the sub-tree of all elements that are less than key[1]. Ptr[1] points to the sub-tree that contains all the elements greater than key[1] and less than key[2]. etc. The array of pointer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBtree.html:2890,access,access,2890,doc/master/classTBtree.html,https://root.cern,https://root.cern/doc/master/classTBtree.html,1,['access'],['access']
Security," at line 159 of file TClassEdit.h. ◆ IsDefAlloc() [1/2]. bool TClassEdit::IsDefAlloc ; (; const char * ; alloc, . const char * ; classname . ). return whether or not 'allocname' is the STL default allocator for type 'classname' ; Definition at line 621 of file TClassEdit.cxx. ◆ IsDefAlloc() [2/2]. bool TClassEdit::IsDefAlloc ; (; const char * ; alloc, . const char * ; keyclassname, . const char * ; valueclassname . ). return whether or not 'allocname' is the STL default allocator for a key of type 'keyclassname' and a value of type 'valueclassname' ; Definition at line 670 of file TClassEdit.cxx. ◆ IsDefComp(). bool TClassEdit::IsDefComp ; (; const char * ; comp, . const char * ; classname . ). return whether or not 'compare' is the STL default comparator for type 'classname' ; Definition at line 821 of file TClassEdit.cxx. ◆ IsDefHash(). bool TClassEdit::IsDefHash ; (; const char * ; hashname, . const char * ; classname . ). return whether or not 'hashname' is the STL default hash for type 'classname' ; Definition at line 839 of file TClassEdit.cxx. ◆ IsDefPred(). bool TClassEdit::IsDefPred ; (; const char * ; predname, . const char * ; classname . ). return whether or not 'predname' is the STL default predicate for type 'classname' ; Definition at line 830 of file TClassEdit.cxx. ◆ IsInterpreterDetail(). bool TClassEdit::IsInterpreterDetail ; (; const char * ; type). Return true if the type is one the interpreter details which are only forward declared (ClassInfo_t etc..) ; Definition at line 1322 of file TClassEdit.cxx. ◆ IsStdArray(). bool TClassEdit::IsStdArray ; (; std::string_view ; name). inline . Definition at line 183 of file TClassEdit.h. ◆ IsStdClass(). bool TClassEdit::IsStdClass ; (; const char * ; type). return true if the class belongs to the std namespace ; Definition at line 1418 of file TClassEdit.cxx. ◆ IsStdPair(). bool TClassEdit::IsStdPair ; (; std::string_view ; name). inline . Definition at line 184 of file TClassEdit.h. ◆ IsStdPairBase(). bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTClassEdit.html:11687,hash,hashname,11687,doc/master/namespaceTClassEdit.html,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html,2,['hash'],"['hash', 'hashname']"
Security," at line 53 of file TFTP.h. ◆ TFTP() [2/3]. TFTP::TFTP ; (; const TFTP & ; ). privatedelete . ◆ TFTP() [3/3]. TFTP::TFTP ; (; const char * ; url, . Int_t ; par = 1, . Int_t ; wsize = kDfltWindowSize, . TSocket * ; sock = nullptr . ). Open connection to host specified by the url using par parallel sockets. ; The url has the form: [root[s,k]://]host[:port]. If port is not specified the default rootd port (1094) will be used. Using wsize one can specify the tcp window size. Normally this is not needed when using parallel sockets. An existing connection (TSocket *sock) can also be used to establish the FTP session. ; Definition at line 74 of file TFTP.cxx. ◆ ~TFTP(). TFTP::~TFTP ; (; ). virtual . TFTP dtor. Send close message and close socket. ; Definition at line 149 of file TFTP.cxx. Member Function Documentation. ◆ AccessPathName(). Bool_t TFTP::AccessPathName ; (; const char * ; path, . EAccessMode ; mode = kFileExists, . Bool_t ; print = kFALSE . ). Returns kFALSE if one can access a file using the specified access mode. ; Mode is the same as for the Unix access(2) function. Attention, bizarre convention of return value!! ; Definition at line 1111 of file TFTP.cxx. ◆ Ascii(). void TFTP::Ascii ; (; ). inline . Definition at line 107 of file TFTP.h. ◆ ascii(). void TFTP::ascii ; (; ). inline . Definition at line 123 of file TFTP.h. ◆ bin(). void TFTP::bin ; (; ). inline . Definition at line 122 of file TFTP.h. ◆ Binary(). void TFTP::Binary ; (; ). inline . Definition at line 106 of file TFTP.h. ◆ bye(). void TFTP::bye ; (; ). inline . Definition at line 121 of file TFTP.h. ◆ cd(). void TFTP::cd ; (; const char * ; dir); const. inline . Definition at line 113 of file TFTP.h. ◆ ChangeDirectory(). Int_t TFTP::ChangeDirectory ; (; const char * ; dir); const. Change the remote directory. ; If the remote directory contains a .message file and it is < 1024 characters then the contents is echoed back. Returns 0 in case of success and -1 in case of failure. ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFTP.html:14715,access,access,14715,doc/master/classTFTP.html,https://root.cern,https://root.cern/doc/master/classTFTP.html,2,['access'],['access']
Security," at line 60 of file TWebSnapshot.h. Public Member Functions;  TPadWebSnapshot (bool readonly=true, bool setids=true, bool batchmode=false);  ; TClass * IsA () const override;  ; bool IsBatchMode () const;  ; bool IsReadOnly () const;  ; bool IsSetObjectIds () const;  ; TWebSnapshot & NewPrimitive (TObject *obj=nullptr, const std::string &opt="""", const std::string &suffix="""");  Create new entry in list of primitives. ;  ; TWebSnapshot & NewSpecials ();  Create new entry in list of primitives in the front. ;  ; TPadWebSnapshot & NewSubPad ();  Create new entry for subpad. ;  ; void SetActive (bool on=true);  ; void SetHasExecs (bool on=true);  ; void SetWithoutPrimitives (bool on=true);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TWebSnapshot;  ~TWebSnapshot () override;  destructor ;  ; Int_t GetKind () const;  ; const char * GetObjectID () const;  ; TObject * GetSnapshot () const;  ; TClass * IsA () const override;  ; void SetObjectID (const std::string &id);  ; void SetObjectIDAsPtr (void *ptr, const std::string &suffix="""");  Use pointer to assign object id - TString::Hash. ;  ; void SetOption (const std::string &opt);  ; void SetSnapshot (Int_t kind, TObject *snapshot, Bool_t owner=kFALSE);  SetUse pointer to assign object id - TString::Hash. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPadWebSnapshot.html:1524,Hash,Hash,1524,doc/master/classTPadWebSnapshot.html,https://root.cern,https://root.cern/doc/master/classTPadWebSnapshot.html,1,['Hash'],['Hash']
Security," at line 68 of file TFTP.h. Constructor & Destructor Documentation. ◆ TFTP() [1/3]. TFTP::TFTP ; (; ). inlineprivate . Definition at line 53 of file TFTP.h. ◆ TFTP() [2/3]. TFTP::TFTP ; (; const TFTP & ; ). privatedelete . ◆ TFTP() [3/3]. TFTP::TFTP ; (; const char * ; url, . Int_t ; par = 1, . Int_t ; wsize = kDfltWindowSize, . TSocket * ; sock = nullptr . ). Open connection to host specified by the url using par parallel sockets. ; The url has the form: [root[s,k]://]host[:port]. If port is not specified the default rootd port (1094) will be used. Using wsize one can specify the tcp window size. Normally this is not needed when using parallel sockets. An existing connection (TSocket *sock) can also be used to establish the FTP session. ; Definition at line 74 of file TFTP.cxx. ◆ ~TFTP(). TFTP::~TFTP ; (; ). virtual . TFTP dtor. Send close message and close socket. ; Definition at line 149 of file TFTP.cxx. Member Function Documentation. ◆ AccessPathName(). Bool_t TFTP::AccessPathName ; (; const char * ; path, . EAccessMode ; mode = kFileExists, . Bool_t ; print = kFALSE . ). Returns kFALSE if one can access a file using the specified access mode. ; Mode is the same as for the Unix access(2) function. Attention, bizarre convention of return value!! ; Definition at line 1111 of file TFTP.cxx. ◆ Ascii(). void TFTP::Ascii ; (; ). inline . Definition at line 107 of file TFTP.h. ◆ ascii(). void TFTP::ascii ; (; ). inline . Definition at line 123 of file TFTP.h. ◆ bin(). void TFTP::bin ; (; ). inline . Definition at line 122 of file TFTP.h. ◆ Binary(). void TFTP::Binary ; (; ). inline . Definition at line 106 of file TFTP.h. ◆ bye(). void TFTP::bye ; (; ). inline . Definition at line 121 of file TFTP.h. ◆ cd(). void TFTP::cd ; (; const char * ; dir); const. inline . Definition at line 113 of file TFTP.h. ◆ ChangeDirectory(). Int_t TFTP::ChangeDirectory ; (; const char * ; dir); const. Change the remote directory. ; If the remote directory contains a .message file and it ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFTP.html:14581,Access,AccessPathName,14581,doc/master/classTFTP.html,https://root.cern,https://root.cern/doc/master/classTFTP.html,1,['Access'],['AccessPathName']
Security," at line 79 of file TListOfDataMembers.h. ◆ Load(). void TListOfDataMembers::Load ; (; ). Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 399 of file TListOfDataMembers.cxx. ◆ MapObject(). void TListOfDataMembers::MapObject ; (; TObject * ; obj). private . Add a pair<id, object> to the map of data members and their ids. ; Definition at line 50 of file TListOfDataMembers.cxx. ◆ operator=(). TListOfDataMembers & TListOfDataMembers::operator= ; (; const TListOfDataMembers & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfDataMembers::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from THashList.; Definition at line 353 of file TListOfDataMembers.cxx. ◆ Remove() [1/2]. TObject * TListOfDataMembers::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Reimplemented from THashList.; Definition at line 366 of file TListOfDataMembers.cxx. ◆ Remove() [2/2]. TObject * TListOfDataMembers::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from THashList.; Definition at line 382 of file TListOfDataMembers.cxx. ◆ SetClass(). void TListOfDataMembers::SetClass ; (; TClass * ; cl). inline . Definition at line 91 of file TListOfDataMembers.h. ◆ Streamer(). void TListOfDataMembers::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TListOfDataMembers. ; Reimplemented from THashList.; Definition at line 484 of file TListOfDataMembers.cxx. ◆ StreamerNVirtual(). void TListOfDataMembers::StreamerNVirtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:31726,hash,hash,31726,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['hash'],['hash']
Security," attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TVectorD_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Int_t_ixmax; Int_t_ixmin; Int_t_iymax; Int_t_iymin; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TMatrixD_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DMomentMorphFunction.html:34623,access,access,34623,root/html534/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo2DMomentMorphFunction.html,1,['access'],['access']
Security," automatically identified as such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void recalculateCache(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& b); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:15408,access,access,15408,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,1,['access'],['access']
Security," automatically identified as such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:16469,access,access,16469,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,3,['access'],['access']
Security," b);  Returns an index of the closest color. ;  ; virtual Int_t * GetRootColors ();  Returns a list of ROOT colors. ;  ; TClass * IsA () const override;  ; TImagePalette & operator= (const TImagePalette &palette);  Assignment operator. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImagePalette.html:3417,Hash,Hash,3417,doc/master/classTImagePalette.html,https://root.cern,https://root.cern/doc/master/classTImagePalette.html,2,['Hash'],['Hash']
Security," b);; 144 return *this;; 145 }; 146 ; 147 ; 148 /**; 149 get internal data into 2 Scalar numbers.; 150 These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector; 151 */; 152 void GetCoordinates( Scalar& a, Scalar& b) const; 153 { fCoordinates.GetCoordinates(a, b); }; 154 ; 155 ; 156 /**; 157 set the values of the vector from the cartesian components (x,y); 158 (if the vector is held in polar coordinates,; 159 then (x, y) are converted to that form); 160 */; 161 PositionVector2D<CoordSystem, Tag>& SetXY (Scalar a, Scalar b) {; 162 fCoordinates.SetXY (a,b);; 163 return *this;; 164 }; 165 ; 166 // ------------------- Equality -----------------; 167 ; 168 /**; 169 Exact equality; 170 */; 171 bool operator==(const PositionVector2D & rhs) const {; 172 return fCoordinates==rhs.fCoordinates;; 173 }; 174 bool operator!= (const PositionVector2D & rhs) const {; 175 return !(operator==(rhs));; 176 }; 177 ; 178 // ------ Individual element access, in various coordinate systems ------; 179 ; 180 /**; 181 Dimension; 182 */; 183 unsigned int Dimension() const { return fDimension; };; 184 ; 185 /**; 186 Cartesian X, converting if necessary from internal coordinate system.; 187 */; 188 Scalar X() const { return fCoordinates.X(); }; 189 ; 190 /**; 191 Cartesian Y, converting if necessary from internal coordinate system.; 192 */; 193 Scalar Y() const { return fCoordinates.Y(); }; 194 ; 195 /**; 196 Polar R, converting if necessary from internal coordinate system.; 197 */; 198 Scalar R() const { return fCoordinates.R(); }; 199 ; 200 /**; 201 Polar phi, converting if necessary from internal coordinate system.; 202 */; 203 Scalar Phi() const { return fCoordinates.Phi(); }; 204 ; 205 /**; 206 Magnitute squared ( r^2 in spherical coordinate); 207 */; 208 Scalar Mag2() const { return fCoordinates.Mag2();}; 209 ; 210 ; 211 // It is physically meaningless to speak of the unit vector corresponding; 212 // to a point.; 213 ; 214 // ------ Setting individual elements presen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2PositionVector2D_8h_source.html:5592,access,access,5592,doc/master/GenVector_2PositionVector2D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2PositionVector2D_8h_source.html,1,['access'],['access']
Security," b, UChar_t a=255);  Set color of the frame. ;  ; void SetFrameFill (Bool_t f);  ; void SetFrameWidth (Float_t f);  ; void SetQuadByPoints (const Float_t *pointArr, Int_t nPoints);  Setup frame with explicitly given corner coordinates. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveFrameBox.html:4024,Hash,Hash,4024,doc/master/classTEveFrameBox.html,https://root.cern,https://root.cern/doc/master/classTEveFrameBox.html,2,['Hash'],['Hash']
Security, backward compatibility in talking to old client / masters. ; Definition at line 1874 of file TDSet.cxx. ◆ SplitEntryList(). void TDSet::SplitEntryList ; (; ). private . for browsing purposes ; Splits the main entry (or event) list into sub-lists for the elements of thet data set. ; Definition at line 1941 of file TDSet.cxx. ◆ StartViewer(). void TDSet::StartViewer ; (; ). virtual . Start the TTreeViewer on this TTree. ; Definition at line 1520 of file TDSet.cxx. ◆ Streamer(). void TDSet::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TDSet. ; Reimplemented from TObject.; Reimplemented in TDSetProxy.; Definition at line 1813 of file TDSet.cxx. ◆ StreamerNVirtual(). void TDSet::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 262 of file TDSet.h. ◆ Validate() [1/2]. void TDSet::Validate ; (; ). Validate the TDSet by opening files. ; Definition at line 1589 of file TDSet.cxx. ◆ Validate() [2/2]. void TDSet::Validate ; (; TDSet * ; dset). Validate the TDSet against another TDSet. ; Only validates elements in common from input TDSet. ; Definition at line 1668 of file TDSet.cxx. Member Data Documentation. ◆ fCurrent. TDSetElement* TDSet::fCurrent. protected . iterator on fElements ; Definition at line 182 of file TDSet.h. ◆ fDir. TString TDSet::fDir. protected . Definition at line 177 of file TDSet.h. ◆ fElements. THashList* TDSet::fElements. protected . Definition at line 180 of file TDSet.h. ◆ fEntryList. TObject* TDSet::fEntryList. private . Definition at line 168 of file TDSet.h. ◆ fIsTree. Bool_t TDSet::fIsTree. private . Definition at line 167 of file TDSet.h. ◆ fIterator. TIter* TDSet::fIterator. protected . Definition at line 181 of file TDSet.h. ◆ fObjName. TString TDSet::fObjName. protected . Definition at line 179 of file TDSet.h. ◆ fProofChain. TProofChain* TDSet::fProofChain. private . entry (or event) list for processing ; Definition at line 169 of file TDSet.h. ◆ fSrvMaps. TList* TDSet,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSet.html:29867,Validat,Validate,29867,doc/master/classTDSet.html,https://root.cern,https://root.cern/doc/master/classTDSet.html,1,['Validat'],['Validate']
Security," based on user-defined conditions. |; 105| Range() | Filter rows based on entry number (single-thread only). |; 106| Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; 107| RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; 108| RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; 109| Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |; 110 ; 111 ; 112### Actions; 113Actions aggregate data into a result. Each one is described in more detail in the reference guide.; 114 ; 115In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; 116 ; 117Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; 118produce many different results in one event loop. Instant actions trigger the event loop instantly.; 119 ; 120 ; 121| **Lazy action** | **Description** |; 122|------------------|-----------------|; 123| Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; 124| Book() | Book execution of a custom action using a user-defined helper object. |; 125| Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; 126| Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; 127| Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; 128| Fill() | Fill a user-defined object with the val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:6969,access,accessed,6969,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['accessed']
Security," be known to the ROOT interpreter.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Examples; See this tutorial for an example implementation of an action helper.; It is also possible to inspect the code used by built-in RDataFrame actions at ActionHelpers.hxx. ; Definition at line 2984 of file RInterface.hxx. ◆ Cache() [1/4]. template<typename Proxied , typename DataSource = void> . template<typename... ColumnTypes> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; const ColumnNames_t & ; columnList). inline . Save selected columns in memory. ; Template Parameters. ColumnTypesvariadic list of branch/column types. . Parameters. [in]columnListcolumns to be cached in memory. . Returnsa RDataFrame that wraps the cached dataset.; This action returns a new RDataFrame object, completely detached from the originating RDataFrame. The new dataframe only contains the cached columns and stores their content in memory for fast, zero-copy subsequent access.; Use Cache if you know you will only need a subset of the (Filtered) data that fits in memory and that will be accessed many times.; NoteCache will refuse to process columns with names of the form #columnname. These are special columns made available by some data sources (e.g. RNTupleDS) that represent the size of column columnname, and are not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an Alias(): df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""}). Example usage:; Types and columns specified: auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; double; Types inferred and columns specified (this invocation relies on jitting): auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; Types inferred and columns selected with a regexp (this invocation relies on jitting): auto cache_all_cols_df = df.Cache(myRegexp);. Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:42385,access,access,42385,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['access'],['access']
Security," be overridden if an object has to react to timers. ; Reimplemented in TGWindow, TGuiBldDragManager, TSessionViewer, TGraphTime, TGLEventHandler, TGCommandPlugin, TGDNDManager, TGFileContainer, TGPopupMenu, TGScrollBar, TGShutter, TGTextEdit, TGTextEditor, TGTextEntry, TGTextView, TGToolTip, TGHtml, TVirtualPacketizer, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, TProofPlayerLite, and TTreeViewer.; Definition at line 498 of file TObject.cxx. ◆ Hash(). ULong_t TObject::Hash ; (; ); const. virtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:520; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:42459,Hash,Hash,42459,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['Hash'],['Hash']
Security," be the address of a pointer).; 2349/// For more flexibility use 'Branch'. Use Bronch only in (rare); 2350/// cases (likely to be legacy cases) where both the new and old; 2351/// implementation of Branch needs to be used at the same time.; 2352///; 2353/// This function is far more powerful than the old Branch; 2354/// function. It supports the full C++, including STL and has; 2355/// the same behaviour in split or non-split mode. classname does; 2356/// not have to derive from TObject. The function is based on; 2357/// the new TStreamerInfo.; 2358///; 2359/// Build a TBranchElement for an object of class classname.; 2360///; 2361/// addr is the address of a pointer to an object of class; 2362/// classname. The class dictionary must be available (ClassDef; 2363/// in class header).; 2364///; 2365/// Note: See the comments in TBranchElement::SetAddress() for a more; 2366/// detailed discussion of the meaning of the addr parameter.; 2367///; 2368/// This option requires access to the library where the; 2369/// corresponding class is defined. Accessing one single data; 2370/// member in the object implies reading the full object.; 2371///; 2372/// By default the branch buffers are stored in the same file as the Tree.; 2373/// use TBranch::SetFile to specify a different file; 2374///; 2375/// IMPORTANT NOTE about branch names:; 2376///; 2377/// And in general, in case two or more master branches contain subbranches; 2378/// with identical names, one must add a ""."" (dot) character at the end; 2379/// of the master branch name. This will force the name of the subbranches; 2380/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2381/// This situation happens when the top level object; 2382/// has two or more members referencing the same class.; 2383/// For example, if a Tree has two branches B1 and B2 corresponding; 2384/// to objects of the same class MyClass, one can do:; 2385/// ~~~ {.cpp}; 2386/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2387/// ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:93776,access,access,93776,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security," be used unless there is no other option.; 11.5.6.1 The dictionaries; The most convenient place to specify the conversion rules is a dictionary. One can do that either in a LinkDef file or in the selection xml file being fed to genreflex. The syntax of the rules is the following:. For dictionaries created from a LinkDef file:. #pragma read \; sourceClass=""ClassA"" \; source=""double m_a; double m_b; double m_c"" \; version=""[4-5,7,9,12-]"" \; checksum=""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }"". For REFLEX dictionaries:. <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; The variables in the rules have the following meaning:. sourceClass. The field defines the on-disk class that is the input for the rule. source. A semicolon-separated list of values defining the source class data members that need to be cached and accessible via object proxy when the rule is executed. The values are either the names of the data members or the type-name pairs (separated by a space). If types are specified then the ondisk structure can be generated and used in the code snippet defined by the user. version. A list of versions of the source class that can be an input for this rule",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:500463,checksum,checksum,500463,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['checksum'],['checksum']
Security," been loaded,; 2960 // let's see if it is there.; 2961 const TList *list = file->GetStreamerInfoCache();; 2962 localBaseInfo = list ? (TStreamerInfo*)list->FindObject(localBase->GetName()) : 0;; 2963 }; 2964 if (!localBaseInfo) {; 2965 TString msg;; 2966 msg.Form("" The StreamerInfo of the base class %s (of class %s) read from %s%s\n""; 2967 "" refers to a checksum (%x) that can not be found neither in memory nor in the file.\n"",; 2968 otherBaseClass->GetName(), localClass.Data(),; 2969 file ? ""file "" : """", file ? file->GetName() : """",; 2970 localBase->GetBaseCheckSum(); 2971 );; 2972 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2973 otherBase->SetErrorMessage(msg);; 2974 continue;; 2975 }; 2976 if (localBaseInfo->CompareContent(otherBaseClass,0,kFALSE,kFALSE,file) ) {; 2977 // They are equivalent, no problem.; 2978 continue;; 2979 }; 2980 TString msg;; 2981 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 2982 "" has the same version (=%d) as the active class but a different checksum.\n""; 2983 "" You should update the version to ClassDef(%s,%d).\n""; 2984 "" The objects on this file might not be readable because:\n""; 2985 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the checksum value %x for this base class (%s)."",; 2986 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2987 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetCheckSum(),; 2988 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 2989 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2990 otherBase->SetErrorMessage(msg);; 2991 }; 2992 } else {; 2993 TStreamerBase *localBase = dynamic_cast<TStreamerBase*>(el);; 2994 TStreamerBase *otherBase = dynamic_cast<TStreamerBase*>(infoel);; 2995 if (!localBase || !other",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:119016,checksum,checksum,119016,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['checksum'],['checksum']
Security," been moved to BranchOld).; NOTE: The 'Bronch' method supports only one possible calls signature (where the object type has to be specified explicitly and the address must be the address of a pointer). For more flexibility use 'Branch'. Use Bronch only in (rare) cases (likely to be legacy cases) where both the new and old implementation of Branch needs to be used at the same time.; This function is far more powerful than the old Branch function. It supports the full C++, including STL and has the same behaviour in split or non-split mode. classname does not have to derive from TObject. The function is based on the new TStreamerInfo.; Build a TBranchElement for an object of class classname.; addr is the address of a pointer to an object of class classname. The class dictionary must be available (ClassDef in class header).; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the addr parameter.; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:96431,access,access,96431,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['access'],['access']
Security," before, the per-event analysis happens in Process(). Here again, you need to get the tree entry before you can access the corresponding data members of your selector.; Fitting and Drawing the Histogram; Here again, once the histogram is filled, fit it with a pol2 using TH1::Fit(""pol2"").; See the documentation of TSelector on where to do the fitting, i.e. which function of your selector gets called after the whole tree has been processed. You should first fit and then draw, to see the fit together with the histogram.; At the end, you should get the same result than the figure 6 in Histogramming; If, for any reason, you don't manage to get it working, you can download the working selector file here: FullEventDataSelector.C (or; wget http://root-mirror.github.io/training/intro/FullEventDataSelector.C); Note: You will have to use it that way:; EventTree->Process(""FullEventDataSelector.C""). . ‹ Accessing a TTree With a TSelector; up; Using a TSelector with PROOF ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/histogramming-selector.html:4441,Access,Accessing,4441,d/histogramming-selector.html,https://root.cern,https://root.cern/d/histogramming-selector.html,3,"['Access', 'access']","['Accessing', 'access']"
Security," bin; x1[m] = h1.GetBinContent(k + 1, l + 1) + gRandom->Gaus(0, pixelNoise);; x2[m] = h2.GetBinContent(k + 1, l + 1) + gRandom->Gaus(0, pixelNoise);; }; }; sgn.Fill();; bkg.Fill();; }; sgn.Write();; bkg.Write();; ; Info(""MakeImagesTree"", ""Signal and background tree with images data written to the file %s"", f.GetName());; sgn.Print();; bkg.Print();; f.Close();; }; ; /// @brief Run the TMVA CNN Classification example; /// @param nevts : number of signal/background events. Use by default a low value (1000); /// but increase to at least 5000 to get a good result; /// @param opt : vector of bool with method used (default all on if available). The order is:; /// - TMVA CNN; /// - Keras CNN; /// - TMVA DNN; /// - TMVA BDT; /// - PyTorch CNN; void TMVA_CNN_Classification(int nevts = 1000, std::vector<bool> opt = {1, 1, 1, 1, 1}); {; ; int imgSize = 16 * 16;; TString inputFileName = ""images_data_16x16.root"";; ; bool fileExist = !gSystem->AccessPathName(inputFileName);; ; // if file does not exists create it; if (!fileExist) {; MakeImagesTree(nevts, 16, 16);; }; ; bool useTMVACNN = (opt.size() > 0) ? opt[0] : false;; bool useKerasCNN = (opt.size() > 1) ? opt[1] : false;; bool useTMVADNN = (opt.size() > 2) ? opt[2] : false;; bool useTMVABDT = (opt.size() > 3) ? opt[3] : false;; bool usePyTorchCNN = (opt.size() > 4) ? opt[4] : false;; #ifndef R__HAS_TMVACPU; #ifndef R__HAS_TMVAGPU; Warning(""TMVA_CNN_Classification"",; ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for CNN"");; useTMVACNN = false;; #endif; #endif; ; bool writeOutputFile = true;; ; #ifdef R__USE_IMT; int num_threads = 4; // use by default 4 threads if value is not set before; // switch off MT in OpenBLAS to avoid conflict with tbb; gSystem->Setenv(""OMP_NUM_THREADS"", ""1"");; ; // do enable MT running; if (num_threads >= 0) {; ROOT::EnableImplicitMT(num_threads);; }; #endif; ; TMVA::Tools::Instance();; ; ; std::cout << ""Running with nthreads = "" << ROOT::GetThreadPoolSize() << s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:47860,Access,AccessPathName,47860,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['Access'],['AccessPathName']
Security," bit unsigned integer (ULong64_t). By default, a variable will be copied to the buffer with the number of; bytes specified in the type descriptor character. However, if the type; consists of 2 characters, the second character is an integer that; specifies the number of bytes to be used when copying the variable; to the output buffer. Example:; X ; variable X, type Float_t; Y/I : variable Y, type Int_t; Y/I2 ; variable Y, type Int_t converted to a 16 bits integer. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (eg 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. *. TBranch(TBranch *parent, const char* name, void* address, const char* leaflist, Int_t basketsize, Int_t compress); Create a Branch*-*-; *-* =====================. * address is the address of the first item of a structure; or the address of a pointer to an object (see example).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranch.html:13507,access,access,13507,root/html526/TBranch.html,https://root.cern,https://root.cern/root/html526/TBranch.html,1,['access'],['access']
Security," bit unsigned integer (ULong64_t). By default, a variable will be copied to the buffer with the number of; bytes specified in the type descriptor character. However, if the type; consists of 2 characters, the second character is an integer that; specifies the number of bytes to be used when copying the variable; to the output buffer. Example:; X ; variable X, type Float_t; Y/I : variable Y, type Int_t; Y/I2 ; variable Y, type Int_t converted to a 16 bits integer. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (eg 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. *. TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch*-*-; *-* =====================. * address is the address of the first item of a structure; or the address of a pointer to an object (see example).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranch.html:13841,access,access,13841,root/html528/TBranch.html,https://root.cern,https://root.cern/root/html528/TBranch.html,1,['access'],['access']
Security," blank canvas).; 2274 template <typename X = RDFDetail::RInferredType, typename Y = RDFDetail::RInferredType,; 2275 typename EXL = RDFDetail::RInferredType, typename EXH = RDFDetail::RInferredType,; 2276 typename EYL = RDFDetail::RInferredType, typename EYH = RDFDetail::RInferredType>; 2277 RResultPtr<::TGraphAsymmErrors>; 2278 GraphAsymmErrors(std::string_view x = """", std::string_view y = """", std::string_view exl = """",; 2279 std::string_view exh = """", std::string_view eyl = """", std::string_view eyh = """"); 2280 {; 2281 auto graph = std::make_shared<::TGraphAsymmErrors>();; 2282 const std::vector<std::string_view> columnViews = {x, y, exl, exh, eyl, eyh};; 2283 const auto userColumns = RDFInternal::AtLeastOneEmptyString(columnViews); 2284 ? ColumnNames_t(); 2285 : ColumnNames_t(columnViews.begin(), columnViews.end());; 2286 ; 2287 const auto validatedColumns = GetValidatedColumnNames(6, userColumns);; 2288 ; 2289 // We build a default name and title based on the input columns; 2290 const auto g_name = validatedColumns[1] + ""_vs_"" + validatedColumns[0];; 2291 const auto g_title = validatedColumns[1] + "" vs "" + validatedColumns[0];; 2292 graph->SetNameTitle(g_name.c_str(), g_title.c_str());; 2293 graph->GetXaxis()->SetTitle(validatedColumns[0].c_str());; 2294 graph->GetYaxis()->SetTitle(validatedColumns[1].c_str());; 2295 ; 2296 return CreateAction<RDFInternal::ActionTags::GraphAsymmErrors, X, Y, EXL, EXH, EYL, EYH>(validatedColumns, graph,; 2297 graph, fProxiedPtr);; 2298 }; 2299 ; 2300 ////////////////////////////////////////////////////////////////////////////; 2301 /// \brief Fill and return a one-dimensional profile (*lazy action*).; 2302 /// \tparam V1 The type of the column the values of which are used to fill the profile. Inferred if not present.; 2303 /// \tparam V2 The type of the column the values of which are used to fill the profile. Inferred if not present.; 2304 /// \param[in] model The model to be considered to build the new return value.; 2305 /// \para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:128302,validat,validatedColumns,128302,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,5,['validat'],['validatedColumns']
Security," bool ROOT::Math::SMatrix< T, D1, D2, R >::operator!= ; (; const SMatrix< T, D1, D2, R > & ; rhs); const. inline . element wise comparison ; Definition at line 332 of file SMatrix.icc. ◆ operator!=() [3/3]. template<class T , unsigned int D1, unsigned int D2, class R > . bool ROOT::Math::SMatrix< T, D1, D2, R >::operator!= ; (; const T & ; rhs); const. inline . element wise comparison ; Definition at line 327 of file SMatrix.icc. ◆ operator()() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . T & ROOT::Math::SMatrix< T, D1, D2, R >::operator() ; (; unsigned int ; i, . unsigned int ; j . ). inline . read/write access to matrix element with indices starting from 0 ; Definition at line 644 of file SMatrix.icc. ◆ operator()() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . const T & ROOT::Math::SMatrix< T, D1, D2, R >::operator() ; (; unsigned int ; i, . unsigned int ; j . ); const. inline . read only access to matrix element, with indices starting from 0 ; Definition at line 639 of file SMatrix.icc. ◆ operator*=() [1/3]. template<class T , unsigned int D1, unsigned int D2, class R > . template<class A , class R2 > . SMatrix< T, D1, D2, R > & ROOT::Math::SMatrix< T, D1, D2, R >::operator*= ; (; const Expr< A, T, D1, D2, R2 > & ; rhs). multiplication with a compatible matrix expression (it is a real matrix multiplication) ; Definition at line 276 of file SMatrix.icc. ◆ operator*=() [2/3]. template<class T , unsigned int D1, unsigned int D2, class R > . template<class R2 > . SMatrix< T, D1, D2, R > & ROOT::Math::SMatrix< T, D1, D2, R >::operator*= ; (; const SMatrix< T, D1, D2, R2 > & ; rhs). multiplication with another compatible matrix (it is a real matrix multiplication) Note that this operation does not avid to create a temporary to store intermediate result ; Definition at line 268 of file SMatrix.icc. ◆ operator*=() [3/3]. template<class T , unsigned int D1, unsigned int D2, class R > . SMatrix< T, D1, D2, R > & ROOT::Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:27585,access,access,27585,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['access'],['access']
Security," boolQWidget::acceptDrops() const; QStringQWidget::accessibleDescription() const; QStringQWidget::accessibleName() const; QList<QAction*>QWidget::actions() const; voidQWidget::activateWindow(); voidQWidget::addAction(QAction* action); voidQWidget::addActions(QList<QAction*> actions); voidQWidget::adjustSize(); boolQWidget::autoFillBackground() const; QPalette::ColorRoleQWidget::backgroundRole() const; QSizeQWidget::baseSize() const; boolQObject::blockSignals(bool b); QWidget*QWidget::childAt(const QPoint& p) const; QWidget*QWidget::childAt(int x, int y) const; const QObjectList&QObject::children() const; QRectQWidget::childrenRect() const; QRegionQWidget::childrenRegion() const; voidQWidget::clearFocus(); voidQWidget::clearMask(); boolQWidget::close(); intQPaintDevice::colorCount() const; boolQObject::connect(const QObject* sender, const char* signal, const char* member, Qt::ConnectionType type = Qt::AutoConnection) const; static boolQObject::connect(const QObject* sender, const char* signal, const QObject* receiver, const char* member, Qt::ConnectionType = Qt::AutoConnection); static boolQObject::connect(const QObject* sender, const QMetaMethod& signal, const QObject* receiver, const QMetaMethod& method, Qt::ConnectionType type = Qt::AutoConnection); QMarginsQWidget::contentsMargins() const; QRectQWidget::contentsRect() const; Qt::ContextMenuPolicyQWidget::contextMenuPolicy() const; voidQWidget::createWinId(); QCursorQWidget::cursor() const; voidQObject::deleteLater(); intQPaintDevice::depth() const; virtual intQWidget::devType() const; boolQObject::disconnect(const QObject* receiver, const char* member = 0); boolQO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQRootCanvas.html:408,access,accessibleDescription,408,root/html602/TQRootCanvas.html,https://root.cern,https://root.cern/root/html602/TQRootCanvas.html,4,['access'],"['accessibleDescription', 'accessibleName']"
Security," bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooChangeTracker.h>. Inheritance diagram for RooChangeTracker:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooChangeTracker() [1/3]. RooChangeTracker::RooChangeTracker ; (; ). default . ◆ RooChangeTracker() [2/3]. RooChangeTracker::RooChangeTracker ; (; const char * ; name, . const char * ; title, . const RooArgSet & ; trackSet, . bool ; checkValues = false . ). Constructor. ; The set trackSet contains the observables to be tracked for changes. If checkValues is true an additional validation step is activated where the numeric values of the tracked arguments are compared with reference values ensuring that values have actually changed. ; Definition at line 52 of file RooChangeTracker.cxx. ◆ RooChangeTracker() [3/3]. RooChangeTracker::RooChangeTracker ; (; const RooChangeTracker & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 88 of file RooChangeTracker.cxx. Member Function Documentation. ◆ Class(). static TClass * RooChangeTracker::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooChangeTracker::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooChangeTracker::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 49 of file RooChangeTracker.h. ◆ clone(). TObject * RooChangeTracker::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 30 of file RooChangeTracker.h. ◆ DeclFileName(). st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChangeTracker.html:61165,validat,validation,61165,doc/master/classRooChangeTracker.html,https://root.cern,https://root.cern/doc/master/classRooChangeTracker.html,1,['validat'],['validation']
Security," branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooSetProxy_compSetDSet proxy for denominator components ; RooSetProxy_compSetNSet proxy for numerator components ; RooArgSet*_compSetOwnedDOwner of denominator components; RooArgSet*_compSetOwnedNOwner of numerator components ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenProdProj.html:33940,access,access,33940,root/html534/RooGenProdProj.html,https://root.cern,https://root.cern/root/html534/RooGenProdProj.html,1,['access'],['access']
Security," branches addresses,; 6628/// - A skeleton for the entry loop.; 6629///; 6630/// To use this function:; 6631///; 6632/// - Open your Tree file (eg: TFile f(""myfile.root"");); 6633/// - T->MakeCode(""MyAnalysis.C"");; 6634///; 6635/// where T is the name of the TTree in file myfile.root; 6636/// and MyAnalysis.C the name of the file created by this function.; 6637///; 6638/// NOTE: Since the implementation of this function, a new and better; 6639/// function TTree::MakeClass() has been developed.; 6640 ; 6641Int_t TTree::MakeCode(const char* filename); 6642{; 6643 Warning(""MakeCode"", ""MakeCode is obsolete. Use MakeClass or MakeSelector instead"");; 6644 ; 6645 GetPlayer();; 6646 if (!fPlayer) return 0;; 6647 return fPlayer->MakeCode(filename);; 6648}; 6649 ; 6650////////////////////////////////////////////////////////////////////////////////; 6651/// Generate a skeleton analysis class for this Tree using TBranchProxy.; 6652///; 6653/// TBranchProxy is the base of a class hierarchy implementing an; 6654/// indirect access to the content of the branches of a TTree.; 6655///; 6656/// ""proxyClassname"" is expected to be of the form:; 6657/// ~~~ {.cpp}; 6658/// [path/]fileprefix; 6659/// ~~~; 6660/// The skeleton will then be generated in the file:; 6661/// ~~~ {.cpp}; 6662/// fileprefix.h; 6663/// ~~~; 6664/// located in the current directory or in 'path/' if it is specified.; 6665/// The class generated will be named 'fileprefix'; 6666///; 6667/// ""macrofilename"" and optionally ""cutfilename"" are expected to point; 6668/// to source files which will be included by the generated skeleton.; 6669/// Method of the same name as the file(minus the extension and path); 6670/// will be called by the generated skeleton's Process method as follow:; 6671/// ~~~ {.cpp}; 6672/// [if (cutfilename())] htemp->Fill(macrofilename());; 6673/// ~~~; 6674/// ""option"" can be used select some of the optional features during; 6675/// the code generation. The possible options are:; 6676///; 6677/// ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:259749,access,access,259749,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security," branches, use TChain::SetBranchStatus to activate a branch.; Int_t nevent = chain.GetEntries();; for (Int_t i=0;i<nevent;i++) {; // read complete accepted event in memory; chain.GetEvent(i);; // Fill histogram with number of segments; hnseg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; 12.24.1 TChain::AddFriend. ATChain has a list of friends similar to a tree (see TTree::AddFriend). You can add a friend to a chain with the TChain::AddFriend method. With TChain::GetListOfFriends you can retrieve the list of friends. The next example has four chains each has 20 ROOT trees from 20 ROOT files.; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain.; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; The parameter is the name of friend chain (the name of a chain is always the name of the tree from which it was created). The original chain has access to all variables in its friends. We can use the TChain::Draw method as if the values in the friends were in the original chain. To specify the chain to use in the Draw method, use:; <chainname>.<branchname>.<varname>; If the variable name is enough to identify uniquely the variable, you can leave out the chain and/or branch name. For example, this generates a 3-d scatter plot of variable “var” in the TChain ch versus variable v1 inTChain t1 versus variable v2 in TChaint2.; ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriendconnects the trees in the chain. When a chain is deleted, its friend elements are also deleted. The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see TTree::AddFriends(). A full example of a tree and friends is in Example #3 ($ROOTS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:654151,access,access,654151,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security," browsable elements - combines several different elements together. More...;  ; class  RHolder;  Basic class for object holder of any kind. More...;  ; class  RItem;  Representation of single item in the browser. More...;  ; class  RLevelIter;  Iterator over single level hierarchy like any array, keys list, ... More...;  ; class  RProvider;  Provider of different browsing methods for supported classes. More...;  ; class  RShared;  ; class  RSysDirLevelIter;  Iterator over files in in sub-directory. More...;  ; class  RSysFile;  ; class  RSysFileItem;  Representation of single item in the file browser. More...;  ; class  RUnique;  ; class  RWrapper;  Wrapper for other element - to provide different name. More...;  ; class  TGeoBrowseProvider;  Provider for TGeo browsing. More...;  ; class  TGeoManagerElement;  Representing TGeoManager in browsables. More...;  ; class  TGeoNodeElement;  Representing TGeoNode in browsables. More...;  ; class  TGeoVolumeElement;  Representing TGeoVolume in browsables. More...;  ; class  TGeoVolumeIter;  Iterating over nodes in the volume. More...;  ; class  TKeyItem;  Representation of single item in the file browser for object from TKey. More...;  ; class  TObjectElement;  Access to TObject basic properties for RBrowsable. More...;  ; class  TObjectHolder;  Holder of TObject instance. More...;  ; class  TObjectItem;  Representation of single item in the file browser for generic TObject object. More...;  . Typedefs; using RElementPath_t = std::vector< std::string >;  . Variables; ROOT::Browsable::TGeoBrowseProvider newTGeoBrowseProvider;  . Typedef Documentation. ◆ RElementPath_t. using ROOT::Browsable::RElementPath_t = typedef std::vector<std::string>. Definition at line 20 of file RElement.hxx. Variable Documentation. ◆ newTGeoBrowseProvider. ROOT::Browsable::TGeoBrowseProvider ROOT::Browsable::newTGeoBrowseProvider. ROOTBrowsable. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Browsable.html:1591,Access,Access,1591,doc/master/namespaceROOT_1_1Browsable.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Browsable.html,1,['Access'],['Access']
Security," buf_in, calculate (""decompact""); 203/// the bin coordinates and return them in coord_out.; 204 ; 205void THnSparseCoordCompression::SetCoordFromBuffer(const Char_t* buf_in,; 206 Int_t* coord_out) const; 207{; 208 for (Int_t i = 0; i < fNdimensions; ++i) {; 209 const Int_t offset = fBitOffsets[i] / 8;; 210 Int_t shift = fBitOffsets[i] % 8;; 211 Int_t nbits = fBitOffsets[i + 1] - fBitOffsets[i];; 212 const UChar_t* pbuf = (const UChar_t*) buf_in + offset;; 213 coord_out[i] = *pbuf >> shift;; 214 Int_t subst = (Int_t) -1;; 215 subst = subst << nbits;; 216 nbits -= (8 - shift);; 217 shift = 8 - shift;; 218 for (Int_t n = 0; n * 8 < nbits; ++n) {; 219 ++pbuf;; 220 coord_out[i] += *pbuf << shift;; 221 shift += 8;; 222 }; 223 coord_out[i] &= ~subst;; 224 }; 225}; 226 ; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Given the cbin coordinates coord_in, calculate (""compact""); 230/// the bin coordinates and return them in buf_in.; 231/// Return the hash value.; 232 ; 233ULong64_t THnSparseCoordCompression::SetBufferFromCoord(const Int_t* coord_in,; 234 Char_t* buf_out) const; 235{; 236 if (fCoordBufferSize <= 8) {; 237 ULong64_t l64buf = 0;; 238 for (Int_t i = 0; i < fNdimensions; ++i) {; 239 l64buf += ((ULong64_t)((UInt_t)coord_in[i])) << fBitOffsets[i];; 240 }; 241 memcpy(buf_out, &l64buf, sizeof(Long64_t));; 242 return l64buf;; 243 }; 244 ; 245 // else: doesn't fit into a Long64_t:; 246 memset(buf_out, 0, fCoordBufferSize);; 247 for (Int_t i = 0; i < fNdimensions; ++i) {; 248 const Int_t offset = fBitOffsets[i] / 8;; 249 const Int_t shift = fBitOffsets[i] % 8;; 250 ULong64_t val = coord_in[i];; 251 ; 252 Char_t* pbuf = buf_out + offset;; 253 *pbuf += 0xff & (val << shift);; 254 val = val >> (8 - shift);; 255 while (val) {; 256 ++pbuf;; 257 *pbuf += 0xff & val;; 258 val = val >> 8;; 259 }; 260 }; 261 ; 262 return GetHashFromBuffer(buf_out);; 263}; 264 ; 265/*; 266/////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:8268,hash,hash,8268,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hash']
Security," build the project, it generates the files needed by your build tool (GNU make, Ninja, Visual Studio, etc) for building ROOT. The classic build with configure/make is is still available but it will not be evolving with the new features of ROOT.; We added full support for C++14.; Minor changes in the build system:. Renamed build option POSTGRESQL_LIBRARIES to POSTGRESQL_LIBRARY; Added build option builtin_openssl to build OpenSSL internally. This is specially needed for the latest Mac OSX (El Capitan). Patch Releases; Release 6.06/02; Core. Make TListOfFunctions::Get thread-safe; Make TPluginManager thread-safe ROOT-7927; Properly handle the case of an executable with a space in its full pathname when search for linked in library. This fixes ROOT-8019. Dictionaries. Fix ROOT-7879: Prevent LinkDef files to be listed in a rootmap file and use (as the user actually expects) the header files #included in the linkdef file, if any, as the top level headers. Interpreter. Ignore access check when evaluating ROOT-7426. Meta Library; Add a new mode for TClass::SetCanSplit (2) which indicates that this class and any derived class should not be split. This included a rework the mechanism checking the base classes. Instead of using InheritsFrom, which lead in some cases, including the case where the class derived from an STL collection, to spurrious autoparsing (to look at the base class of the collection!), we use a custom walk through the tree of base classes that checks their value of fCanSplit. This also has the side-effect of allowing the extension of the concept ‘base class that prevent its derived class from being split’ to any user class. This fixes ROOT-7972.; TTree. Do not automatically setup read cache during TTree::Fill(). This fixes ROOT-8031.; Fast Cloning We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address ROOT-5078. It can be controlled from the TTreeCloner, TTree::CopyE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:24723,access,access,24723,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['access'],['access']
Security," but rather practical.) Range protection is built in, consequently for substitution one should use rather use a=b than explicit loop! ;  ; void Print (Option_t *option) const override;  Printout of all vector components on ""std::cout"". ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoamVect.html:2775,Hash,Hash,2775,doc/master/classTFoamVect.html,https://root.cern,https://root.cern/doc/master/classTFoamVect.html,2,['Hash'],['Hash']
Security," but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; In addition, histograms and trees are automatically deleted when the current directory is closed. This will automatically take care of the clean up. See “Input/Output”.; 7.2.1 Executing a Script From a Script; You may want to execute a script conditionally inside another script. To do it you need to call the interpreter and you can do that with TROOT::ProcessLine(). The example $ROOTSYS/tutorials/tree/cernstaff.C calls a script to build the root file if it does not exist:; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ProcessLine takes a parameter, which is a pointer to an int or to a TInterpreter::EErrorCode to let you access the interpreter error code after an attempt to interpret. This will contain the error as defined in enum TInterpreter::EErrorCode with TInterpreter::kSuccess being the value for a successful execution.; 7.2.2 Executing a Script From the Invocation; Instead if starting ROOT and running a script on the prompt you can also pass it to ROOT in its invocation:; $ root -l -b 'myCode.C(""some String"", 12)'; The exact kind of quoting depends on your shell; the one shown here works for bash-like shells.; ROOT can evaluate any expression as part of the invocation; another version of the previous example can be spelled like this:; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; 7.3 C++ Extensions To Ease Scripting; In the next example, we demonstrate three of the most important extensions ROOT and Cling make to C++. Start ROOT in the directory $ROOTSYS/tutorials (make sure to have first run .x hsimple.C):; root [0] f = new TFile(""hsimple.roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:265166,access,access,265166,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security," byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooAbsData::ErrorType_etypeError type store in associated RooDataHist; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooChi2Var::FuncMode_funcModeFunction, P.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:38251,access,access,38251,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,1,['access'],['access']
Security," byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Double_t_cutOffCutoff parameter for running product; RooArgSet_defNormSetDefault normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Int_t_extendedIndexIndex of extended PDF (if any) ; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAICRegistry_genCode! Registry of composite direct generator codes; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:42165,access,access,42165,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,1,['access'],['access']
Security," bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use int or Int_t, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse(), IsFolder()). 2.6 Global Variables; ROOT has a set of global variables that apply to the session. For example, gDirectory always holds the current directory, and gStyle holds the current style.; All global variables begin with “g” followed by a capital letter.; 2.6.1 gROOT; The single instance of TROOT is accessible via the global gROOT and holds information relative to the current session. By using the gROOT pointer, you get the access to every object created in a ROOT program. The TROOT object has several lists pointing to the main ROOT objects. During a ROOT session, the gROOT keeps a series of collections to manage objects. They can be accessed via gROOT::GetListOf... methods.; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:59233,Hash,Hash,59233,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Access', 'Hash']","['Access', 'Hash']"
Security," c++;; 2864 }; 2865#endif; 2866 ; 2867 /* Nothing suspicious found */; 2868 return 0;; 2869}; 2870 ; 2871 ; 2872/* mg_fopen will open a file either in memory or on the disk.; 2873 * The input parameter path is a string in UTF-8 encoding.; 2874 * The input parameter mode is MG_FOPEN_MODE_*; 2875 * On success, fp will be set in the output struct mg_file.; 2876 * All status members will also be set.; 2877 * The function returns 1 on success, 0 on error. */; 2878static int; 2879mg_fopen(const struct mg_connection *conn,; 2880 const char *path,; 2881 int mode,; 2882 struct mg_file *filep); 2883{; 2884 int found;; 2885 ; 2886 if (!filep) {; 2887 return 0;; 2888 }; 2889 filep->access.fp = NULL;; 2890 ; 2891 if (mg_path_suspicious(conn, path)) {; 2892 return 0;; 2893 }; 2894 ; 2895 /* filep is initialized in mg_stat: all fields with memset to,; 2896 * some fields like size and modification date with values */; 2897 found = mg_stat(conn, path, &(filep->stat));; 2898 ; 2899 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2900 /* file does not exist and will not be created */; 2901 return 0;; 2902 }; 2903 ; 2904#if defined(_WIN32); 2905 {; 2906 wchar_t wbuf[UTF16_PATH_MAX];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:88971,access,access,88971,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security," c++;; 2865 }; 2866#endif; 2867 ; 2868 /* Nothing suspicious found */; 2869 return 0;; 2870}; 2871 ; 2872 ; 2873/* mg_fopen will open a file either in memory or on the disk.; 2874 * The input parameter path is a string in UTF-8 encoding.; 2875 * The input parameter mode is MG_FOPEN_MODE_*; 2876 * On success, fp will be set in the output struct mg_file.; 2877 * All status members will also be set.; 2878 * The function returns 1 on success, 0 on error. */; 2879static int; 2880mg_fopen(const struct mg_connection *conn,; 2881 const char *path,; 2882 int mode,; 2883 struct mg_file *filep); 2884{; 2885 int found;; 2886 ; 2887 if (!filep) {; 2888 return 0;; 2889 }; 2890 filep->access.fp = NULL;; 2891 ; 2892 if (mg_path_suspicious(conn, path)) {; 2893 return 0;; 2894 }; 2895 ; 2896 /* filep is initialized in mg_stat: all fields with memset to,; 2897 * some fields like size and modification date with values */; 2898 found = mg_stat(conn, path, &(filep->stat));; 2899 ; 2900 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2901 /* file does not exist and will not be created */; 2902 return 0;; 2903 }; 2904 ; 2905#if defined(_WIN32); 2906 {; 2907 wchar_t wbuf[UTF16_PATH_MAX];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:89003,access,access,89003,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security," call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:13119,authenticat,authentication,13119,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,2,['authenticat'],['authentication']
Security," called by TChain::LoadTree when a new Tree is loaded. ;  ;  Public Member Functions inherited from TVirtualTreePlayer;  TVirtualTreePlayer ();  ;  ~TVirtualTreePlayer () override;  Common destructor. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:6533,Hash,Hash,6533,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,2,['Hash'],['Hash']
Security," calls SetUri with a complete URI. ;  ;  TUri (const TString &uri);  Constructor that calls SetUri with a complete URI. ;  ;  TUri (const TUri &uri);  TUri copy ctor. ;  ; virtual ~TUri ();  ; const TString GetAuthority () const;  Returns the authority part of the instance: ;  ; const TString GetFragment () const;  ; const TString GetHierPart () const;  ; const TString GetHost () const;  ; const TString GetPath () const;  ; const TString GetPort () const;  ; const TString GetQuery () const;  ; const TString GetRelativePart () const;  relative-part = ""//"" authority path-abempty ;  ; const TString GetScheme () const;  ; const TString GetUri () const;  Returns the whole URI - an implementation of chapter 5.3 component recomposition. ;  ; const TString GetUserInfo () const;  ; Bool_t HasAuthority () const;  ; Bool_t HasFragment () const;  ; Bool_t HasHierPart () const;  ; Bool_t HasHost () const;  ; Bool_t HasPath () const;  ; Bool_t HasPort () const;  ; Bool_t HasQuery () const;  ; Bool_t HasRelativePart () const;  ; Bool_t HasScheme () const;  ; Bool_t HasUserInfo () const;  ; TClass * IsA () const override;  ; Bool_t IsAbsolute () const;  Returns kTRUE if instance qualifies as absolute-URI absolute-URI = scheme "":"" hier-part [ ""?"" query ] cf. ;  ; Bool_t IsReference () const;  Returns kTRUE if instance qualifies as URI-reference URI-reference = URI / relative-ref cf. ;  ; Bool_t IsRelative () const;  Returns kTRUE if instance qualifies as relative-ref relative-ref = relative-part [ ""?"" query ] [ ""#"" fragment ] cf. ;  ; Bool_t IsSortable () const override;  ; Bool_t IsUri () const;  Returns kTRUE if instance qualifies as URI URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ] cf. ;  ; void Normalise ();  Syntax based normalisation according to RFC chapter 6.2.2. ;  ; TUri & operator= (const TUri &rhs);  TUri assignment operator. ;  ; void Print (Option_t *option="""") const override;  Display function,. ;  ; void Reset ();  Initialize this URI object. ;  ; Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUri.html:1521,HasH,HasHierPart,1521,doc/master/classTUri.html,https://root.cern,https://root.cern/doc/master/classTUri.html,2,['HasH'],"['HasHierPart', 'HasHost']"
Security," can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:7760,password,password,7760,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['password'],['password']
Security," can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $ » Last generated: 2010-09-23 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTable.html:11459,hash,hashtable,11459,root/html528/THashTable.html,https://root.cern,https://root.cern/root/html528/THashTable.html,4,"['Hash', 'hash']","['Hash', 'hash', 'hashtable']"
Security," can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THashTable.html:11532,hash,hashtable,11532,root/html530/THashTable.html,https://root.cern,https://root.cern/root/html530/THashTable.html,4,"['Hash', 'hash']","['Hash', 'hash', 'hashtable']"
Security," can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $ » Last generated: 2011-11-03 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THashTable.html:11532,hash,hashtable,11532,root/html532/THashTable.html,https://root.cern,https://root.cern/root/html532/THashTable.html,4,"['Hash', 'hash']","['Hash', 'hash', 'hashtable']"
Security," capacity. If nc != current capacity Clone() the string; in a string with the desired capacity. int CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; Compare a string to char *cs2. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. V.Perev. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard characters ""[]*?"". TString& Prepend(char c, Ssiz_t rep = 1); Prepend characters to self. TString & Replace(Ssiz_t pos, Ssiz_t n, const char* s, Ssiz_t ns); Remove at most n1 characters from self beginning at pos,; and replace them with the first n2 characters of cs. TString& ReplaceAll(const char* s1, Ssiz_t ls1, const char* s2, Ssiz_t ls2); Find & Replace ls1 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TString.html:10094,Hash,Hash,10094,root/html528/TString.html,https://root.cern,https://root.cern/root/html528/TString.html,1,['Hash'],['Hash']
Security," char *);  ; virtual Bool_t SetVUInt (Int_t, const std::vector< UInt_t >, const char *, const char *);  ; virtual Bool_t SetVULong64 (Int_t, const std::vector< ULong64_t >, const char *, const char *);  ; virtual Bool_t StoreResult ()=0;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLStatement.html:6224,Hash,Hash,6224,doc/master/classTSQLStatement.html,https://root.cern,https://root.cern/doc/master/classTSQLStatement.html,2,['Hash'],['Hash']
Security," char *, Option_t *="""", Bool_t=kFALSE);  ; virtual Bool_t Rmdir (const char *="""", Option_t *="""", Bool_t=kFALSE);  ; virtual void Shell ();  ; virtual void Stderr ();  ; virtual void Stdout ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual TGridJob * Submit (const char *);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGrid.html:2764,Hash,Hash,2764,doc/master/classTGrid.html,https://root.cern,https://root.cern/doc/master/classTGrid.html,2,['Hash'],['Hash']
Security," char *fname=nullptr, const char *cmd=nullptr, Int_t pos=1, Int_t subpos=-1)TBrowserinline; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteDefaultAction(TObject *obj)TBrowser; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fContextMenuTBrowserprotected; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; FillBuffer(char *&buffer)TNamedvirtual; fImpTBrowserprotected; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fLastSelectedObjectTBrowserprivate; fNameTNamedprotected; fNeedRefreshTBrowserprotected; fTimerTBrowserprotected; fTitleTNamedprotected; fUniqueIDTObjectprivate; GetBrowserImp() constTBrowserinline; GetContextMenu() constTBrowserinline; GetDrawOption() const overrideTBrowserinlinevirtual; GetDtorOnly()TObjectstatic; GetIconName() constTObjectvirtual; GetName() const overrideTNamedinlinevirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetRefreshFlag() constTBrowserinline; GetSelected() constTBrowserinline; GetTitle() const overrideTNamedinlinevirtual; GetUniqueID() constTObjectvirtual; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; Iconify()TBrowserinline; Info(const char *method, const char *msgfmt,...) constTObjectvirtual; InheritsFrom(const char *classname) constTObjectvirtual; InheritsFrom(const TClass *cl) constTObjectvirtual; InitGraphics()TBrowserprotected; Inspect() constTObjectvirtual; InvertBit(UInt_t f)TObjectinline; IsA() const overrideTBrowserinlinevirtual; IsDestructed() constTObjectinline; IsEqual(const TObject *obj) constTObjectvirtual; IsFolder() constTObjectvirtual; IsOnHeap() constTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBrowser-members.html:3139,Hash,Hash,3139,doc/master/classTBrowser-members.html,https://root.cern,https://root.cern/doc/master/classTBrowser-members.html,1,['Hash'],['Hash']
Security," char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:11847,Hash,Hash,11847,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,6,['Hash'],['Hash']
Security," char *name, const char *title, TCollection *collection=nullptr)Create a new folder and add it to the list of folders of this folder, return a pointer to the created...Definition TFolder.cxx:182; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TGlobalMappedFunction::GetEarlyRegisteredGlobalsstatic TList & GetEarlyRegisteredGlobals()Returns list collected globals Used to storeTGlobalMappedFunctions from other libs,...Definition TGlobal.cxx:189; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; TGuiFactoryThis ABC is a factory for GUI components.Definition TGuiFactory.h:42; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreter::RegisterModulevirtual void RegisterModule(const char *, const char **, const char **, const char *, const char *, void(*)(), const FwdDeclArgsToKeepCollection_t &fwdDeclArgsToKeep, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false)=0; TInterpreter::Resetvirtual void Reset()=0; TInterpreter::Initializevirtual void Initialize()=0; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::SaveContextvirtual void SaveContext()=0; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TInterpreter::kFatal@ kFatalDefinition TInterpreter.h:76; TIterDefinition TCollection.h:23",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:136839,hash,hash,136839,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['hash'],['hash']
Security," char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; UInt_t ParseChecksum (const char *checksum) const;  Parse the checksum in the given string. ;  ; Bool_t ProcessChecksum (const TString &checksum) const;  Check if specified checksum string is correct and build checksum vector. ;  ; Bool_t ProcessVersion (const TString &version) const;  Check if specified version string is correct and build version vector. ;  . Static Private Member Functions; static void ProcessDeclaration (TObjArray *array, const TString &list);  Split the list as a declaration into as a TObjArray of TNamed(name,type). ;  ; static void ProcessList (TObjArray *array, const TString &list);  Split the list as a comma separated list into a TObjArray of TObjString. ;  . Private Attributes; TString fAttributes;  ; TString fChecksum;  Source version vector (for searching purposes) ;  ; std::vector< UInt_t > * fChecksumVect;  ; TString fCode;  Includes vector. ;  ; Bool_t fEmbed;  ; TString fInclude;  Source data member vector (for searching purposes) ;  ; TObjArray * fIncludeVect;  ; ReadFuncPtr_t fReadFuncPtr;  ; ReadRawFuncPtr_t fReadRawFuncPtr;  Conversion function pointer for read rule. ;  ; RuleType_t fRuleType;  Conversion f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:14239,checksum,checksum,14239,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,6,['checksum'],['checksum']
Security," char * ; stateName . ); const. Check if the state is in the given range. ; If no range is specified (i.e., the default range), all category states count as being in range. This overload requires a name lookup. Recommend to use the category index with RooCategory::isStateInRange(const char*, RooAbsCategory::value_type) const. ; Definition at line 414 of file RooCategory.cxx. ◆ isStateInRange() [2/2]. bool RooCategory::isStateInRange ; (; const char * ; rangeName, . RooAbsCategory::value_type ; stateIndex . ); const. Check if the state is in the given range. ; If no range is specified either as argument or if no range has been defined for this category (i.e., the default range is meant), all category states count as being in range. ; Definition at line 396 of file RooCategory.cxx. ◆ operator=(). RooCategory & RooCategory::operator= ; (; const RooCategory & ; ). delete . ◆ operator[](). RooAbsCategory::value_type & RooCategory::operator[] ; (; const std::string & ; stateName). Access a named state. ; If a state with this name doesn't exist yet, the state is assigned the next available positive integer. Parameters. [in]stateNameName of the state to be accessed. . ReturnsReference to the category index. If no state exists, it will be created on the fly. ; Definition at line 256 of file RooCategory.cxx. ◆ readFromStream(). bool RooCategory::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from given stream. ; If token is a decimal digit, try to find a corresponding state for it. If that succeeds, the state denoted by this index is used. Otherwise, interpret it as a label. ; Reimplemented from RooAbsCategory.; Definition at line 288 of file RooCategory.cxx. ◆ recomputeShape(). void RooCategory::recomputeShape ; (; ). inlineoverrideprotectedvirtual . This category's shape does not depend on others, and does not need recomputing. ; Implements RooAbsCategory.; Definition at line 124 of file RooCat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:60656,Access,Access,60656,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['Access'],['Access']
Security," char* filename); Generate skeleton function for this Tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name; - Connection of the Tree file; - Declaration of Tree variables; - Setting of branches addresses; - A skeleton for the entry loop. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""anal.C"");; where T is the name of the Tree in file myfile.root; and anal.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy.; TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:42844,access,access,42844,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['access'],['access']
Security," char* filename); Generate skeleton function for this Tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name; - Connection of the Tree file; - Declaration of Tree variables; - Setting of branches addresses; - A skeleton for the entry loop. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""anal.C"");; where T is the name of the Tree in file myfile.root; and anal.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy.; TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'.; If the fileprefix contains a period, the right side of the period; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreePlayer.html:16876,access,access,16876,root/html530/TTreePlayer.html,https://root.cern,https://root.cern/root/html530/TTreePlayer.html,5,['access'],['access']
Security," char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooHashTable&operator=(const RooHashTable&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tremove(TObject* arg, TObject* hashArg = 0); Bool_treplace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); voidTObject::ResetBit(UInt_t f); RooHashTable(const RooHashTable& other); RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; Int_tsize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHashTable.html:4449,hash,hashMethod,4449,root/html602/RooHashTable.html,https://root.cern,https://root.cern/root/html602/RooHashTable.html,2,['hash'],['hashMethod']
Security," char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfBranchingRatiobranching ratio ( < 1); TArrayIfDaughtersPDG codes of the daughters; Int_tfMatrixElementCodematrix element for this decay mode; Int_tfNumberchannel number. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecayChannel(); default constructor. TDecayChannel(Int_t Number, Int_t MatrixElementCode, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); constructor. ~TDecayChannel(). TDecayChannel(); ****** constructors and destructor. Int_t Number(); ****** accessors. { return fNumber; }. Int_t MatrixElementCode(); { return fMatrixElementCode; }. Int_t NDaughters(); { return fDaughters.fN; }. Double_t BranchingRatio(); { return fBranchingRatio; }. Int_t DaughterPdgCode(Int_t i); { return fDaughters.fArray[i]; }. » Author: P.Murat 15/02/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id: TDecayChannel.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecayChannel.html:5856,access,accessors,5856,root/html528/TDecayChannel.html,https://root.cern,https://root.cern/root/html528/TDecayChannel.html,1,['access'],['accessors']
Security," char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfBranchingRatiobranching ratio ( < 1); TArrayIfDaughtersPDG codes of the daughters; Int_tfMatrixElementCodematrix element for this decay mode; Int_tfNumberchannel number. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecayChannel(); default constructor. TDecayChannel(Int_t Number, Int_t MatrixElementCode, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); constructor. ~TDecayChannel(). TDecayChannel(); ****** constructors and destructor. Int_t Number(); ****** accessors. { return fNumber; }. Int_t MatrixElementCode(); { return fMatrixElementCode; }. Int_t NDaughters(); { return fDaughters.fN; }. Double_t BranchingRatio(); { return fBranchingRatio; }. Int_t DaughterPdgCode(Int_t i); { return fDaughters.fArray[i]; }. » Author: P.Murat 15/02/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id: TDecayChannel.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDecayChannel.html:5925,access,accessors,5925,root/html530/TDecayChannel.html,https://root.cern,https://root.cern/root/html530/TDecayChannel.html,1,['access'],['accessors']
Security," char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfBranchingRatiobranching ratio ( < 1); TArrayIfDaughtersPDG codes of the daughters; Int_tfMatrixElementCodematrix element for this decay mode; Int_tfNumberchannel number. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecayChannel(); default constructor. TDecayChannel(Int_t Number, Int_t MatrixElementCode, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); constructor. ~TDecayChannel(). TDecayChannel(); ****** constructors and destructor. Int_t Number(); ****** accessors. { return fNumber; }. Int_t MatrixElementCode(); { return fMatrixElementCode; }. Int_t NDaughters(); { return fDaughters.fN; }. Double_t BranchingRatio(); { return fBranchingRatio; }. Int_t DaughterPdgCode(Int_t i); { return fDaughters.fArray[i]; }. » Author: P.Murat 15/02/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id: TDecayChannel.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecayChannel.html:5925,access,accessors,5925,root/html532/TDecayChannel.html,https://root.cern,https://root.cern/root/html532/TDecayChannel.html,1,['access'],['accessors']
Security," char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterrupt(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActive(TSocket* s) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:5240,Hash,Hash,5240,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,4,['Hash'],['Hash']
Security," char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterrupt(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActive(TSocket* s) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:5177,Hash,Hash,5177,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,2,['Hash'],['Hash']
Security," char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual voidInspectObject()MENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileDrawMap.html:4503,Hash,Hash,4503,root/html528/TFileDrawMap.html,https://root.cern,https://root.cern/root/html528/TFileDrawMap.html,1,['Hash'],['Hash']
Security," char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual voidInspectObject()MENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFileDrawMap.html:4503,Hash,Hash,4503,root/html530/TFileDrawMap.html,https://root.cern,https://root.cern/root/html530/TFileDrawMap.html,3,['Hash'],['Hash']
Security," char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual voidInspectObject()MENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::opera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileDrawMap.html:4383,Hash,Hash,4383,root/html602/TFileDrawMap.html,https://root.cern,https://root.cern/root/html602/TFileDrawMap.html,2,['Hash'],['Hash']
Security," char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooDataSet*RooAbsGenContext::generate(Int_t nEvents = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tRooAbsGenContext::isValid() const; Bool_tRooAbsGenContext::isVerbose() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddGenContext.html:3215,Hash,Hash,3215,root/html526/RooAddGenContext.html,https://root.cern,https://root.cern/root/html526/RooAddGenContext.html,12,['Hash'],['Hash']
Security," char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooDataSet*RooAbsGenContext::generate(Int_t nEvents = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tRooAbsGenContext::isValid() const; Bool_tRooAbsGenContext::isVerbose() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddGenContext.html:3215,Hash,Hash,3215,root/html530/RooAddGenContext.html,https://root.cern,https://root.cern/root/html530/RooAddGenContext.html,6,['Hash'],['Hash']
Security," char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseFitterBase(const TMVA::FitterBase&); TMVA::FitterBaseFitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; Int_tGetNpars() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&TMVA::Configurable::GetOptions() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__FitterBase.html:3110,Hash,Hash,3110,root/html602/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html602/TMVA__FitterBase.html,2,['Hash'],['Hash']
Security," char* objname, TString& itemname); TRootSnifferScanRec&operator=(const TRootSnifferScanRec&); Bool_tScanOnlyFields() const; voidSetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); Bool_tSetResult(void* obj, TClass* cl, TDataMember* member = 0); voidSetRootClass(TClass* cl); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRootSnifferScanRec(); TRootSnifferScanRec(const TRootSnifferScanRec&). Data Members; protected:. Bool_tfHasMore! indicates that potentially there are more items can be found; TStringfItemName! name of current item; TListfItemsNames! list of created items names, need to avoid duplication; Int_tfLevel! current level of hierarchy; UInt_tfMask! defines operation kind; Bool_tfNodeStarted! indicate if node was started; Int_tfNumChilds! number of childs; Int_tfNumFields! number of fields; TRootSnifferScanRec*fParent! pointer on parent record; Int_tfRestriction! restriction 0 - default, 1 - read-only, 2 - full access; const char*fSearchPath! current path searched; TRootSnifferStore*fStore! object to store results; static TRootSnifferScanRec::(anonymous)kActions; static TRootSnifferScanRec::(anonymous)kCheckChilds; static TRootSnifferScanRec::(anonymous)kExpand; static TRootSnifferScanRec::(anonymous)kOnlyFields; static TRootSnifferScanRec::(anonymous)kScan; static TRootSnifferScanRec::(anonymous)kSearch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSnifferScanRec(); constructor. ~TRootSnifferScanRec(); destructor. void SetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); record field for current element. void BeforeNextChild(); indicates that new child for current element will be started. void MakeItemName(const char* objname, TString& itemname); constructs item name from object name; if special symbols like '/', '#', ':', '&', '?' are used in object name; they wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootSnifferScanRec.html:2027,access,access,2027,root/html604/TRootSnifferScanRec.html,https://root.cern,https://root.cern/root/html604/TRootSnifferScanRec.html,1,['access'],['access']
Security," char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBlockFromCache(const char*, Int_t); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFPBlock*GetPendingBlock(); TThread*GetThread() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetWaitTime(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFilePrefetch.html:2561,Hash,Hash,2561,root/html530/TFilePrefetch.html,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html,1,['Hash'],['Hash']
Security," char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLResult.html:2351,Hash,Hash,2351,root/html528/TMySQLResult.html,https://root.cern,https://root.cern/root/html528/TMySQLResult.html,1,['Hash'],['Hash']
Security," char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMySQLResult.html:2351,Hash,Hash,2351,root/html530/TMySQLResult.html,https://root.cern,https://root.cern/root/html530/TMySQLResult.html,3,['Hash'],['Hash']
Security," char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMySQLResult.html:2288,Hash,Hash,2288,root/html602/TMySQLResult.html,https://root.cern,https://root.cern/root/html602/TMySQLResult.html,2,['Hash'],['Hash']
Security," char*GetDataSet() const; const char*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t istree = kTRUE, Bool_t openfile = kTRUE); TObject*GetEntryList() const; TFileInfo*GetFileInfo(const char* type = ""TTree""); const char*GetFileName() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; TList*GetListOfAssocObjs() const; virtual TList*GetListOfFriends() const; Float_tGetMaxProcTime() const; const char*GetMsd() const; virtual const char*TNamed::GetName() const; Long64_tGetNum() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); const char*GetObjName() const; virtual Option_t*TObject::GetOption() const; Long64_tGetTDSetOffset() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Bool_tGetValid() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; Int_tLookup(Bool_t force = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Int_tMergeElement(TDSetElement* elem); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDSetElement.html:3926,Hash,Hash,3926,root/html534/TDSetElement.html,https://root.cern,https://root.cern/root/html534/TDSetElement.html,1,['Hash'],['Hash']
Security," char*GetDataSet() const; const char*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t istree = kTRUE, Bool_t openfile = kTRUE); TObject*GetEntryList() const; TFileInfo*GetFileInfo(const char* type = ""TTree""); const char*GetFileName() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; TList*GetListOfAssocObjs() const; virtual TList*GetListOfFriends() const; Float_tGetMaxProcTime() const; const char*GetMsd() const; virtual const char*TNamed::GetName() const; Long64_tGetNum() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); const char*GetObjName() const; virtual Option_t*TObject::GetOption() const; Long64_tGetTDSetOffset() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Bool_tGetValid() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; Int_tLookup(Bool_t force = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Int_tMergeElement(TDSetElement* elem); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDSetElement.html:3707,Hash,Hash,3707,root/html602/TDSetElement.html,https://root.cern,https://root.cern/root/html602/TDSetElement.html,2,['Hash'],['Hash']
Security," char ; escchar . ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. ◆ Form(). char * Form ; (; const char * ; fmt, .  ; ... . ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. ◆ Format(). static char * Format ; (; const char * ; format, . va_list ; ap . ). static . Format a string in a circular formatting buffer (using a printf style format descriptor). ; Definition at line 2442 of file TString.cxx. ◆ Hash(). UInt_t Hash ; (; const char * ; str). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. ◆ Mash(). static void Mash ; (; UInt_t & ; hash, . UInt_t ; chars . ). inlinestatic . Utility used by Hash(). ; Definition at line 566 of file TString.cxx. ◆ MemIsEqual(). static int MemIsEqual ; (; const char * ; p, . const char * ; q, . Ssiz_t ; n . ). static . Returns false if strings are not equal. ; Definition at line 885 of file TString.cxx. ◆ operator+() [1/5]. TString operator+ ; (; char ; c, . const TString & ; s . ). Add string to char. ; Definition at line 1557 of file TString.cxx. ◆ operator+() [2/5]. TString operator+ ; (; const char * ; cs, . const TString & ; s . ). Use the special concatenation constructor. ; Definition at line 1533 of file TString.cxx. ◆ operator+() [3/5]. TString operator+ ; (; const TString & ; s, . char ; c . ). Add char to string. ; Definition at line 1549 of file TString.cxx. ◆ operator+() [4/5]. TString operator+ ; (; const TString & ; s, . const char * ; cs . ). Use the special concatenation constructor. ; Definition at line 1525 of file TString.cxx. ◆ operator+() [5/5]. TString operator+ ; (; const TString & ; s1, . const TString & ; s2 . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx.html:5268,Hash,Hash,5268,doc/master/TString_8cxx.html,https://root.cern,https://root.cern/doc/master/TString_8cxx.html,1,['Hash'],['Hash']
Security," class ; Definition at line 47 of file TGObject.h. ◆ DeclFileName(). static const char * TGObject::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 47 of file TGObject.h. ◆ GetClient(). TGClient * TGObject::GetClient ; (; ); const. inline . Definition at line 42 of file TGObject.h. ◆ GetId(). Handle_t TGObject::GetId ; (; ); const. inline . Definition at line 41 of file TGObject.h. ◆ Hash(). ULong_t TGObject::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TGObject::HashULong_t Hash() const overrideReturn hash value for this object.Definition TGObject.h:43; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 43 of file TGObject.h. ◆ IsA(). TClass * TGObject::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGObject.html:12411,Hash,Hash,12411,doc/master/classTGObject.html,https://root.cern,https://root.cern/doc/master/classTGObject.html,1,['Hash'],['Hash']
Security," class cls. ;  ; ShowMembersFunc_t GetShowMembersWrapper () const;  ; EState GetState () const;  ; TClassStreamer * GetStreamer () const;  Return the Streamer Class allowing streaming (if any). ;  ; ClassStreamerFunc_t GetStreamerFunc () const;  Get a wrapper/accessor function around this class custom streamer (member function). ;  ; TVirtualStreamerInfo * GetStreamerInfo (Int_t version=0, Bool_t isTransient=kFALSE) const;  returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ;  ; TVirtualStreamerInfo * GetStreamerInfoAbstractEmulated (Int_t version=0) const;  For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ;  ; const TObjArray * GetStreamerInfos () const;  ; const std::type_info * GetTypeInfo () const;  ; Bool_t HasConsistentHashMember ();  Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ;  ; Bool_t HasCustomStreamerMember () const;  The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ;  ; Bool_t HasDataMemberInfo () const;  ; Bool_t HasDefaultConstructor (Bool_t testio=kFALSE) const;  Return true if we have access to a constructor usable for I/O. ;  ; Bool_t HasDictionary () const;  Check whether a class has a dictionary or not. ;  ; Bool_t HasInterpreterInfo () const;  ; Bool_t HasInterpreterInfoInMemory () const;  ; Bool_t HasLocalHashMember () const;  Returns true if this class has an definition and/or overload of the member function Hash. ;  ; void IgnoreTObjectStreamer (Bool_t ignore=kTRUE);  When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call TObject::Streamer. ;  ; Bool_t Inherit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:15439,Hash,Hash,15439,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,3,['Hash'],['Hash']
Security," class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(const char *title)Change (i.e. set) the title of the TNamed.Definition TClass.cxx:6269; TClass::GetShowMembersWrapperShowMembersFunc_t GetShowMembersWrappe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:70370,access,accessible,70370,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['access'],['accessible']
Security," class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(const char *title)Change (i.e. set) the title of the TNamed.Definition TClass.cxx:6269; TClass::SetMemberStreamervoid SetMemberStreamer(const char *name, M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:335241,access,accessible,335241,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['accessible']
Security," class cls.Definition TClass.cxx:3690; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2250; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:4040; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4209; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3941; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:7052; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1887; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2314; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(const char *title)Change (i.e. set) the title of the TNamed.Definition TClass.cxx:6336; TClass::GetShowMembersWrapperShowMembersFunc_t GetShowMembersWrappe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:70198,access,accessible,70198,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['access'],['accessible']
Security," class cls.Definition TClass.cxx:3690; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2250; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:4040; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4209; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3941; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:7052; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1887; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2314; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(const char *title)Change (i.e. set) the title of the TNamed.Definition TClass.cxx:6336; TClass::SetMemberStreamervoid SetMemberStreamer(const char *name, M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:337879,access,accessible,337879,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['accessible']
Security," class data table. ;  ; TSQLResult * GetClassData () const;  ; TSQLRow * GetObjectRow (Long64_t objid);  Returns single sql row with object data for that class. ;  ; TSQLClassInfo * GetSqlInfo () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLObjectDataPool.html:1603,Hash,Hash,1603,doc/master/classTSQLObjectDataPool.html,https://root.cern,https://root.cern/doc/master/classTSQLObjectDataPool.html,2,['Hash'],['Hash']
Security," class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t WriteFile (Int_t cycle=1, TFile *f=nullptr);  Write the encoded object supported by this key. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:6496,Hash,Hash,6496,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,8,"['Hash', 'hash']","['Hash', 'hash']"
Security," class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:63726,access,access,63726,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['access'],['access']
Security, class; TMatrixTColumn_const<float> Template of General Matrix Column Access class; TMatrixTCramerInv ; TMatrixTDiag<double> Template of General Matrix Diagonal Access class; TMatrixTDiag<float> Template of General Matrix Diagonal Access class; TMatrixTDiag_const<double> Template of General Matrix Diagonal Access class; TMatrixTDiag_const<float> Template of General Matrix Diagonal Access class; TMatrixTFlat<double> Template of General Matrix Flat Representation class; TMatrixTFlat<float> Template of General Matrix Flat Representation class; TMatrixTFlat_const<double> Template of General Matrix Flat Representation class; TMatrixTFlat_const<float> Template of General Matrix Flat Representation class; TMatrixTLazy<double> Template of Lazy Matrix class; TMatrixTLazy<float> Template of Lazy Matrix class; TMatrixTRow<double> Template of General Matrix Row Access class; TMatrixTRow<float> Template of General Matrix Row Access class; TMatrixTRow_const<double> Template of General Matrix Row Access class; TMatrixTRow_const<float> Template of General Matrix Row Access class; TMatrixTSparse<double> Template of Sparse Matrix class; TMatrixTSparse<float> Template of Sparse Matrix class; TMatrixTSparseDiag<double> Template of Sparse Matrix Diagonal Access class; TMatrixTSparseDiag<float> Template of Sparse Matrix Diagonal Access class; TMatrixTSparseDiag_const<double> Template of Sparse Matrix Diagonal Access class; TMatrixTSparseDiag_const<float> Template of Sparse Matrix Diagonal Access class; TMatrixTSparseRow<double> Template of Sparse Matrix Row Access class; TMatrixTSparseRow<float> Template of Sparse Matrix Row Access class; TMatrixTSparseRow_const<double> Template of Sparse Matrix Row Access class; TMatrixTSparseRow_const<float> Template of Sparse Matrix Row Access class; TMatrixTSub<double> Template of Sub Matrix Access class; TMatrixTSub<float> Template of Sub Matrix Access class; TMatrixTSub_const<double> Template of Sub Matrix Access class; TMatrixTSub_const<float> Temp,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:101087,Access,Access,101087,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,6,['Access'],['Access']
Security," classes and link them with current ROOT session. ;  ; bool compiledOK () const;  ; TClass * IsA () const override;  ; std::string listOfClassNames () const;  Return STL string with last of class names contained in the code repository. ;  ; void Streamer (TBuffer &) override;  Custom streamer for the workspace. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace_1_1CodeRepo.html:1915,Hash,Hash,1915,doc/master/classRooWorkspace_1_1CodeRepo.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace_1_1CodeRepo.html,2,['Hash'],['Hash']
Security," classes can be stored in ROOT containers. However, the TObject class provides some member functions that allow you to tune the behavior of objects in containers. For example, by default two objects are considered equal if their pointers point to the same address. This might be too strict for some classes where equality is already achieved if some or all of the data members are equal. By overriding the following TObject member functions, you can change the behavior of objects in collections:. IsEqual()is used by the FindObject()collection method. By default, IsEqual() compares the two object pointers.; Compare()returns -1, 0 or 1 depending if the object is smaller, equal or larger than the other object. By default, a TObject has not a valid Compare() method.; IsSortable()returns true if the class is sort able (i.e. if it has a valid Compare() method). By default, a TObject is not sort able.; Hash()returns a hash value. It needs to be implemented if an object has to be stored in a collection using a hashing technique, like THashTable, THashList and TMap. By default, Hash() returns the address of the object. It is essential to choose a good hash function. The example below shows how to use and override these member functions.; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; 16.5 The TIter Generic Iterator; As stated above, the TIterator class is abstract; it is not possible to create TIterator objects. However, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:847876,hash,hashing,847876,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['hash'],['hashing']
Security," classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static const char *handVerified[] = {; 7350 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7351 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7370 ; 7371Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7372{; 7373 return clRef.HasConsistentHashMember();; 7374}; 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstruc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:283026,Hash,Hash,283026,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Hash'],['Hash']
Security," classes, those classes should be; 7415 // cross-checked in testHashRecursiveRemove.cxx; 7416 static const char *handVerified[] = {; 7417 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7418 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7419 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7420 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7421 ""TQClass"", ""TGlobal"" };; 7422 ; 7423 if (cname && cname[0]) {; 7424 for (auto cursor : handVerified) {; 7425 if (strcmp(cname, cursor) == 0); 7426 return true;; 7427 }; 7428 }; 7429 return false;; 7430}; 7431 ; 7432////////////////////////////////////////////////////////////////////////////////; 7433/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7434/// classes in the class hierarchy that overload TObject::Hash do call; 7435/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7436/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7437 ; 7438Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7439{; 7440 return clRef.HasConsistentHashMember();; 7441}; 7442 ; 7443////////////////////////////////////////////////////////////////////////////////; 7444/// Return true if we have access to a constructor usable for I/O. This is; 7445/// typically the default constructor but can also be a constructor specifically; 7446/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7447/// argument). In other words, if this routine returns true, TClass::New is; 7448/// guarantee to succeed.; 7449/// To know if the class described by this TClass has a default constructor; 7450/// (public or not), use; 7451/// \code{.cpp}; 7452/// cl->GetProperty() & kClassHasDefaultCtor; 7453/// \endcode; 7454/// To know if the class described by this TClass has a public default; 7455/// constructor use:; 7456/// \code{.cpp}; 7457/// gInterpreter->ClassInfo_HasDefaultConstruc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:285777,Hash,Hash,285777,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Hash'],['Hash']
Security," cls = 0, . Bool_t ; randomisedTree = kFALSE, . Int_t ; useNvars = 0, . Bool_t ; usePoissonNvars = kFALSE, . UInt_t ; nMaxDepth = 9999999, . Int_t ; iSeed = fgRandomSeed, . Float_t ; purityLimit = 0.5, . Int_t ; treeID = 0 . ). constructor specifying the separation type, the min number of events in a no that is still subjected to further splitting, the number of bins in the grid used in applying the cut for the node splitting. ; Definition at line 150 of file DecisionTree.cxx. ◆ DecisionTree() [3/3]. TMVA::DecisionTree::DecisionTree ; (; const DecisionTree & ; d). copy constructor that creates a true copy, i.e. ; a completely independent tree the node copy will recursively copy all the nodes ; Definition at line 200 of file DecisionTree.cxx. ◆ ~DecisionTree(). TMVA::DecisionTree::~DecisionTree ; (; void ; ). virtual . destructor ; Definition at line 236 of file DecisionTree.cxx. Member Function Documentation. ◆ ApplyValidationSample(). void TMVA::DecisionTree::ApplyValidationSample ; (; const EventConstList * ; validationSample); const. run the validation sample through the (pruned) tree and fill in the nodes the variables NSValidation and NBValidadtion (i.e. ; how many of the Signal and Background events from the validation sample. This is then later used when asking for the ""tree quality"" .. ; Definition at line 1029 of file DecisionTree.cxx. ◆ BuildTree(). UInt_t TMVA::DecisionTree::BuildTree ; (; const EventConstList & ; eventSample, . DecisionTreeNode * ; node = nullptr . ). building the decision tree by recursively calling the splitting of one (root-) node into two daughter nodes (returns the number of nodes) ; Definition at line 377 of file DecisionTree.cxx. ◆ CheckEvent(). Double_t TMVA::DecisionTree::CheckEvent ; (; const TMVA::Event * ; e, . Bool_t ; UseYesNoLeaf = kFALSE . ); const. the event e is put into the decision tree (starting at the root node) and the output is NodeType (signal) or (background) of the final node (basket) in which the given events e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:15106,validat,validationSample,15106,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['validat'],['validationSample']
Security," collection of TDataType designed to hold the typedef information and numerical type information. ; The collection is populated on demand.; Besides the built-in types (int, float) a typedef is explicitly added to the collection (and thus visible via ls or Print) only if it is requested explicitly. ; Definition at line 30 of file TListOfTypes.h. Public Member Functions;  TListOfTypes ();  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; TDataType * FindType (const char *name) const;  ;  Public Member Functions inherited from THashTable;  THashTable (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashTable object. ;  ; virtual ~THashTable ();  Delete a hashtable. ;  ; void Add (TObject *obj) override;  Add object to the hash table. ;  ; void AddAll (const TCollection *col) override;  Add all objects from collection col to this collection. ;  ; void AddBefore (const TObject *before, TObject *obj);  Add object to the hash table. ;  ; Float_t AverageCollisions () const;  ; void Clear (Option_t *option="""") override;  Remove all objects from the table. ;  ; Int_t Collisions (const char *name) const;  Returns the number of collisions for an object with a certain name (i.e. ;  ; Int_t Collisions (TObject *obj) const;  Returns the number of collisions for an object (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the table AND delete all heap based objects. ;  ; Bool_t Empty () const;  ; const TList * GetListForObject (const char *name) const;  Return the TList corresponding to object's name based hash value. ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the TList corresponding to object's hash value. ;  ; TObject ** GetObjectRef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfTypes.html:1285,hash,hash,1285,doc/master/classTListOfTypes.html,https://root.cern,https://root.cern/doc/master/classTListOfTypes.html,1,['hash'],['hash']
Security," collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfEnums::FindTEnum * Find(DeclId_t id) constReturn the TEnum corresponding to the Decl 'id' or NULL if it does not exist.Definition TListOfEnums.cxx:179; TListOfEnums::GetTEnum * Get(DeclId_t id, const char *name)Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'.Definition TListOfEnums.cxx:205; TListOfEnums::GetClassTClass * GetClass() constDefinition TListOfEnums.h:62; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::GetTFunctionTemplate * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctionTemplates.cxx:253; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::FindTFunction * Find(DeclId_t id) constReturn the TMethod or TFunction describing the function corresponding to the Decl 'id'.Definition TListOfFunctions.cxx:250; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMemFileA TMemFile is like a normal TFile except that it reads and writes only from memory.Definition TMemFile.h:19; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberInspector::GetParentconst char * GetParent() constDefinition TMemberInspector.cxx:75; TMemberInspector::Inspectvirtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr)Definition TMemberInspector.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:472091,access,access,472091,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['access'],['access']
Security," collection. ;  ; Bool_t AssertClass (TClass *cl) const;  Make sure all objects in this collection inherit from class cl. ;  ; TIter begin () const;  ; void Browse (TBrowser *b) override;  Browse this collection (called by TBrowser). ;  ; Int_t Capacity () const;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an collection using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TCollection objects. ;  ; Bool_t Contains (const char *name) const;  ; Bool_t Contains (const TObject *obj) const;  ; void Draw (Option_t *option="""") override;  Draw all objects in this collection. ;  ; void Dump () const override;  Dump all objects in this collection. ;  ; TIter end () const;  ; virtual Int_t GetEntries () const;  ; virtual Int_t GetSize () const;  Return the capacity of the collection, i.e. ;  ; virtual Int_t GrowBy (Int_t delta) const;  Increase the collection's capacity by delta slots. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsArgNull (const char *where, const TObject *obj) const;  Returns true if object is a null pointer. ;  ; virtual Bool_t IsEmpty () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsOwner () const;  ; Bool_t IsSortable () const override;  ; R__ALWAYS_INLINE Bool_t IsUsingRWLock () const;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:13264,Hash,Hash,13264,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,6,"['Hash', 'hash']","['Hash', 'hash']"
Security," color scheme is essential for making results easy to understand and interpret. Factors like colorblindness and converting colors to grayscale for publications can impact accessibility. Furthermore, results should be aesthetically pleasing. The following three color schemes, recommended by M. Petroff in arXiv:2107.02270v2 and available on GitHub under the MIT License, meet these criteria.; These three color schemes are available as color sets with 6, 8, and 10 colors, named kP[6, 8, 10]ColorName. For example, kP6Red represents the red color within the P6 color scheme (P for Petroff or Preferred). The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings. It also demonstrates that they are effective in grayscale. Grayscale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using TCanvas::SetGrayscale(). Note that in grayscale mode, access via RGB will return grayscale values according to ITU standards (and close to b&w printer gray-scales), while access via HLS returns de-saturated gray-scales. The image below shows the ROOT color wheel in grayscale mode.; {; auto w = new TColorWheel();; auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; cw->GetCanvas()->SetGrayscale();; w->SetCanvas(cw);; w->Draw();; }. Color palettes; It is often very useful to represent a variable with a color map. The concept of ""color palette"" allows to do that. One color palette is active at any time. This ""current palette"" is set using:; gStyle->SetPalette(...);; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; This function has two parameters: the number of colors in the palette and an array of containing the indices of colors in the palette. The following small example demonstrates how to define and use the color palette:; {; auto c1 = new TCanvas(""c1"",""c1"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:7091,access,access,7091,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,2,['access'],['access']
Security," command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call.; One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be requested to enter arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:4377,access,accessed,4377,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['access'],['accessed']
Security," comparison ;  ; template<class A > ; bool operator!= (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; bool operator> (const T &rhs) const;  element wise comparison ;  ; bool operator< (const T &rhs) const;  element wise comparison ;  ; bool operator> (const SVector< T, D > &rhs) const;  element wise comparison ;  ; bool operator< (const SVector< T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator> (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator< (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; const T & operator[] (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & operator() (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & At (unsigned int i) const;  read-only access of vector elements with check on index. Index starts from 0. ;  ; T & operator[] (unsigned int i);  read/write access of vector elements. Index starts from 0. ;  ; T & operator() (unsigned int i);  read/write access of vector elements. Index starts from 0. ;  ; T & At (unsigned int i);  read/write access of vector elements with check on index. Index starts from 0. ;  ; SVector< T, D > & operator+= (const T &rhs);  self addition with a scalar ;  ; SVector< T, D > & operator-= (const T &rhs);  self subtraction with a scalar ;  ; SVector< T, D > & operator*= (const T &rhs);  self multiplication with a scalar ;  ; SVector< T, D > & operator/= (const T &rhs);  self division with a scalar ;  ; SVector< T, D > & operator+= (const SVector< T, D > &rhs);  self addition with another vector ;  ; SVector< T, D > & operator-= (const SVector< T, D > &rhs);  self subtraction with another vector ;  ; template<class A > ; SVector< T, D > & operator+= (const VecExpr< A, T, D > &rhs);  self addition with a vector expression ;  ; template<class A > ; SVector< T, D > & operator-= (const VecExpr< A, T, D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:5109,access,access,5109,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['access'],['access']
Security," compile this rule.Definition TSchemaRule.cxx:577; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; ROOT::TSchemaRule::GetSourceconst TObjArray * GetSource() constGet the list of source members as a TObjArray of TNamed object, with the name being the member name a...Definition TSchemaRule.cxx:560; ROOT::TSchemaRule::SetReadFunctionPointervoid SetReadFunctionPointer(ReadFuncPtr_t ptr)Set the pointer to the function to be run for the rule (if it is a read rule).Definition TSchemaRule.cxx:708; ROOT::TSchemaRule::lsvoid ls(Option_t *option="""") const overrideThe ls function lists the contents of a class on stdout.Definition TSchemaRule.cxx:177; ROOT::TSchemaRule::fChecksumVectstd::vector< UInt_t > * fChecksumVectDefinition TSchemaRule.h:104; ROOT::TSchemaRule::fEmbedBool_t fEmbedDefinition TSchemaRule.h:114; ROOT::TSchemaRule::ParseChecksumUInt_t ParseChecksum(const char *checksum) constParse the checksum in the given string.Definition TSchemaRule.cxx:933; ROOT::TSchemaRule::ProcessListstatic void ProcessList(TObjArray *array, const TString &list)Split the list as a comma separated list into a TObjArray of TObjString.Definition TSchemaRule.cxx:953; ROOT::TSchemaRule::fAttributesTString fAttributesDefinition TSchemaRule.h:118; ROOT::TSchemaRule::operator==Bool_t operator==(const TSchemaRule &rhs) constReturn true if the rule have the same effects.Definition TSchemaRule.cxx:147; ROOT::TSchemaRule::SetFromRuleBool_t SetFromRule(const char *rule)Set the content fot this object from the rule See TClass::AddRule for details on the syntax.Definition TSchemaRule.cxx:321; ROOT::TSchemaRule::Clearvoid Clear(Option_t *="""") overrideZero out this rule object.Definition TSchemaRule.cxx:297; ROOT::TSchemaRule::TestVersionBool_t TestVersion(Int_t version) constCheck if given version number is defined in this rule.Definition TSchemaRule.cxx:402; ROOT::TSchemaRu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:39108,checksum,checksum,39108,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,4,['checksum'],['checksum']
Security," compress Specifies the compression algorithm and level; 218///; 219/// It is recommended to specify fname1 as ""<file>.root"". The suffix "".root""; 220/// will be used by object browsers to automatically identify the file as; 221/// a ROOT file. If the constructor fails in any way IsZombie() will; 222/// return true. Use IsOpen() to check if the file is (still) open.; 223/// To open non-local files use the static TFile::Open() method, that; 224/// will take care of opening the files using the correct remote file; 225/// access plugin.; 226///; 227/// Option | Description; 228/// -------|------------; 229/// NEW or CREATE | Create a new file and open it for writing, if the file already exists the file is not opened.; 230/// RECREATE | Create a new file, if the file already exists it will be overwritten.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member of an archive, in which case it is; 243/// specified as:; 244///; 245/// multi.zip#file.root or multi.zip#0; 246///; 247/// which will open file.root which is a member of the file multi.zip; 248/// archive or member 1 from the archive. For more on archive file; 249/// support see the TArchiveFile class.; 250/// TFile and its remote access plugins can also be used to open any; 251/// file, i.e. also non ROOT files, using:; 252///; 253/// file.tar?filetype=raw; 254///; 255/// This is convenient because the many remote file access plugins allo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:8946,access,access,8946,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['access']
Security," const char * TStatsFeedback::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TStatsFeedback::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 44 of file TStatsFeedback.h. ◆ DeclFileName(). static const char * TStatsFeedback::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 44 of file TStatsFeedback.h. ◆ Feedback(). void TStatsFeedback::Feedback ; (; TList * ; objs). Display feedback. ; Definition at line 74 of file TStatsFeedback.cxx. ◆ GetName(). const char * TStatsFeedback::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 41 of file TStatsFeedback.h. ◆ Hash(). ULong_t TStatsFeedback::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatsFeedback.html:16201,hash,hash,16201,doc/master/classTStatsFeedback.html,https://root.cern,https://root.cern/doc/master/classTStatsFeedback.html,1,['hash'],['hash']
Security," const char *file, Int_t line);  Global function to register the implementation file and line of a class template (i.e. ;  ; void RemoveClass (const char *cname);  Global function called by the dtor of a class's init class (see the ClassImp macro). ;  ; void ResetClassVersion (TClass *, const char *, Short_t);  Global function to update the version number. ;  ; template<class RootClass > ; Short_t SetClassVersion (RootClass *);  ; std::vector< std::string > Split (std::string_view str, std::string_view delims, bool skipEmpty);  Splits a string at each character in delims. ;  ; static void StrReplace (std::string &proc, const std::string &pat, const std::string &tr);  Replace all accurances of given string with other string. ;  ; template<typename value_type > ; void ToHumanReadableSize (value_type bytes, Bool_t si, Double_t *coeff, const char **units);  Return the size expressed in 'human readable' format. ;  ; static Bool_t ValidateRule (const std::map< std::string, std::string > &rule, std::string &error_string);  Validate if the user specified rules are correct. ;  ; static void WriteAutoVariables (const std::list< std::string > &target, const SourceTypeList_t &source, MembersTypeMap_t &members, std::string &className, std::string &mappedName, std::ostream &output);  Write down the sources. ;  ; void WriteReadRawRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for ReadRaw rule, the function name is being written to rule[""funcname""]. ;  ; void WriteReadRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for Read rule, the function name is being written to rule[""funcname""]. ;  ; void WriteSchemaList (std::list< SchemaRuleMap_t > &rules, const std::string &listName, std::ostream &output);  Write schema rules. ;  . Variables; R__EXTERN TVirtualRWMutex * gCoreMutex = nullp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:12888,Validat,ValidateRule,12888,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,2,['Validat'],"['Validate', 'ValidateRule']"
Security," const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  ;  Protected Member Functions inherited from TGWidget;  TGWidget (const TGWidget &tgw);  ; Int_t ClearFlags (Int_t flags);  ; TGWidget & operator= (const TGWidget &tgw);  ; Int_t SetFlags (Int_t flags);  . Protected Attributes; TGViewFrame * fCanvas;  frame containing the text ;  ; Atom_t fClipboard;  clipboard property ;  ; TGRectangle fExposedRegion;  exposed area ;  ; TGHScrollBar * fHsb;  horizontal scrollbar ;  ; TGLongPosition fMousePos;  position of mouse ;  ; Int_t fScrolling;  scrolling direction ;  ; TGLongPosition fScrollVal;  scroll value ;  ; TGDimension fVirtualSize;  the current virtual window size ;  ; TGLongPosition fVisible;  position of visible region ;  ; TGVScrollBar * fVsb;  vertical scrollbar ;  ; TGGC fWhiteGC;  graphics context used for scrolling generates GraphicsExposure events ;  ; UInt_t fXMargin;  x margin ;  ; UInt_t fYMargin;  y margin ;  ;  Protected Attributes inherited from TGCompositeFrame; Bool_t fLayoutBroken;  no layout manager is used ;  ; TGLayoutManager * fLayoutManager;  layout manager ;  ; TList * fList;  container of frame elements ;  ; Bool_t fMapSubwindows;  kTRUE - map subwindows ;  ; Int_t fMustCleanup;  cleanup mode (see EFrameCleanup) ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGView.html:29773,expose,exposed,29773,doc/master/classTGView.html,https://root.cern,https://root.cern/doc/master/classTGView.html,1,['expose'],['exposed']
Security," const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch);  Find the method with a given prototype. ;  ; Int_t GetClassSize () const;  ; Version_t GetClassVersion () const;  ; TVirtualCollectionProxy * GetCollectionProxy () const;  Return the proxy describing the collection (if any). ;  ; ROOT::ESTLType GetCollectionType () const;  Return the 'type' of the STL the TClass is representing. ;  ; const char * GetContextMenuTitle () const;  ; TVirtualStreamerInfo * GetConversionStreamerInfo (const char *onfile_classname, Int_t version) const;  Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. ;  ; TVirtualStreamerInfo * GetConversionStreamerInfo (const TClass *onfile_cl, Int_t version) const;  Return a Conversion StreamerInfo from the class represented by cl for version number 'version' to this class, if any. ;  ; ClassConvStreamerFunc_t GetConvStreamerFunc () const;  Get a wrapper/accessor function around this class custom conversion streamer (member function). ;  ; TVirtualStreamerInfo * GetCurrentStreamerInfo ();  ; TDataMember * GetDataMember (const char *datamember) const;  Return pointer to datamember object with name ""datamember"". ;  ; Longptr_t GetDataMemberOffset (const char *membername) const;  return offset for member name. ;  ; Short_t GetDeclFileLine () const;  ; const char * GetDeclFileName () const;  Return name of the file containing the declaration of this class. ;  ; ROOT::DelFunc_t GetDelete () const;  Return the wrapper around delete ThiObject. ;  ; ROOT::DelArrFunc_t GetDeleteArray () const;  Return the wrapper around delete [] ThiObject. ;  ; ROOT::DesFunc_t GetDestructor () const;  Return the wrapper around the destructor. ;  ; ROOT::DirAutoAdd_t GetDirectoryAutoAdd () const;  Return the wrapper around the directory auto add function. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; UInt_t GetHeapInstanceCount () const;  ; S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:9866,access,accessor,9866,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,3,['access'],['accessor']
Security," const char * GetName () const override;  Returns name of object. ;  ; Longptr_t GetOffset () const;  ; Bool_t IsExecuting () const;  ; void ls (Option_t *opt="""") const override;  The ls function lists the contents of a class on stdout. ;  ; void Print (Option_t *opt="""") const override;  Print info about slot. ;  ; CallFunc_t * StartExecuting ();  Mark the slot as executing. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQSlot.html:2807,Hash,Hash,2807,doc/master/classTQSlot.html,https://root.cern,https://root.cern/doc/master/classTQSlot.html,2,['Hash'],['Hash']
Security," const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GenSamplingDistribution(const char* asciiFilePat = 0) const; RooStats::ConfidenceBelt*GetConfidenceBelt(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual RooStats::ConfInterval*GetInterval() const; virtual RooStats::ConfInterval*GetInterval(const char* asciiFilePat) const; virtual RooStats::ConfInterval*GetIntervalUsingList() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; RooStats::NeymanConstructionNeymanConstruction(); RooStats::NeymanConstructionNeymanConstruction(const RooStats::NeymanConstruction&); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__NeymanConstruction.html:4670,Hash,Hash,4670,root/html526/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html526/RooStats__NeymanConstruction.html,1,['Hash'],['Hash']
Security," const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetContourList(Double_t contour); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph2DPainter.html:2321,Hash,Hash,2321,root/html528/TGraph2DPainter.html,https://root.cern,https://root.cern/root/html528/TGraph2DPainter.html,1,['Hash'],['Hash']
Security," const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetContourList(Double_t contour); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraph2DPainter.html:2321,Hash,Hash,2321,root/html530/TGraph2DPainter.html,https://root.cern,https://root.cern/root/html530/TGraph2DPainter.html,3,['Hash'],['Hash']
Security," const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetContourList(Double_t contour); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraph2DPainter.html:2224,Hash,Hash,2224,root/html602/TGraph2DPainter.html,https://root.cern,https://root.cern/root/html602/TGraph2DPainter.html,2,['Hash'],['Hash']
Security," const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TClass*GetResClass() const; TDataMember*GetResMember() const; Int_tGetResNumChilds() const; void*GetResPtr() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsXml() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSnifferStore.html:2515,Hash,Hash,2515,root/html602/TRootSnifferStore.html,https://root.cern,https://root.cern/root/html602/TRootSnifferStore.html,1,['Hash'],['Hash']
Security," const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1F*GetTH1F(const RooStats::SamplingDistribution* samplDist = __null); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__SamplingDistPlot.html:3300,Hash,Hash,3300,root/html602/RooStats__SamplingDistPlot.html,https://root.cern,https://root.cern/root/html602/RooStats__SamplingDistPlot.html,1,['Hash'],['Hash']
Security," const char* solid, TGeoMatrix* matrix); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TGeoMatrix*fMatrix!matrix of reflected solid; const char*fNameS!reflected solid name; const char*fSolid!solid name being reflected. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDMLRefl(const char* name, const char* solid, TGeoMatrix* matrix); this constructor method stores the values brought in as params. TGeoMatrix* GetMatrix(); this accessor method returns the matrix. TGDMLRefl(). virtual ~TGDMLRefl(); {}. TGDMLRefl(const char* name, const char* solid, TGeoMatrix* matrix). » Last changed: Tue Jun 30 14:50:28 2015 » Last generated: 2015-06-30 14:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDMLRefl.html:6139,access,accessor,6139,root/html602/TGDMLRefl.html,https://root.cern,https://root.cern/root/html602/TGDMLRefl.html,1,['access'],['accessor']
Security," const char*TObject::GetIconName() const; TString&GetKeywordValue(const char* keyword); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; struct HDURecord*GetRecord(const char* keyword); Int_tGetRecordNumber() const; Int_tGetTabNColumns() const; Int_tGetTabNRows() const; TVectorD*GetTabRealVectorCell(Int_t rownum, Int_t colnum); TVectorD*GetTabRealVectorCell(Int_t rownum, const char* colname); TObjArray*GetTabRealVectorCells(Int_t colnum); TObjArray*GetTabRealVectorCells(const char* colname); TVectorD*GetTabRealVectorColumn(Int_t colnum); TVectorD*GetTabRealVectorColumn(const char* colname); TObjArray*GetTabStringColumn(Int_t colnum); TObjArray*GetTabStringColumn(const char* colname); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFITSHDU.html:3124,Hash,Hash,3124,root/html602/TFITSHDU.html,https://root.cern,https://root.cern/root/html602/TFITSHDU.html,2,['Hash'],['Hash']
Security," const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:31873,Hash,Hash,31873,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,8,['Hash'],['Hash']
Security," const; Bool_tGetCurrentReflection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; THashList*GetListOfMaterials() const; THashList*GetListOfMatrices() const; TList*GetListOfNodes() const; THashList*GetListOfShapes() const; TMaterial*GetMaterial(const char* name) const; TMaterial*GetMaterialByNumber(Int_t number) const; virtual const char*TNamed::GetName() const; TNode*GetNode(const char* name) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TRotMatrix*GetRotMatrix(const char* name) const; TRotMatrix*GetRotMatrixByNumber(Int_t number) const; TShape*GetShape(const char* name) const; TShape*GetShapeByNumber(Int_t number) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidLocal2Master(Double_t* local, Double_t* master); virtual voidLocal2Master(Float_t* local, Float_t* master); virtual voidls(Option_t* option = ""rsn2"") const; virtual voidMaster2Local(Double_t* master, Double_t* local); virtual voidMaster2Local(Float_t* master, Float_t* local); voidTObject::MayNotUse(const char* method) const; virtual voidNode(const char* name, const char* title, const char* shapename, Double_t x = 0, Double_t y = 0, Double_t z = 0, const char* matrixname",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeometry.html:5022,Hash,Hash,5022,root/html528/TGeometry.html,https://root.cern,https://root.cern/root/html528/TGeometry.html,6,['Hash'],['Hash']
Security," const; Float_tGetCorruptedPercentage() const; const char*GetDefaultTreeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFileCollection*GetFilesOnServer(const char* server); TMap*GetFilesPerServer(const char* exclude = 0); virtual const char*TObject::GetIconName() const; THashList*GetList(); TFileInfoMeta*GetMetaData(const char* meta = 0) const; virtual const char*TNamed::GetName() const; Long64_tGetNCorruptFiles() const; Long64_tGetNFiles() const; Long64_tGetNStagedFiles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetStagedPercentage() const; TFileCollection*GetStagedSubset(); virtual const char*TNamed::GetTitle() const; Long64_tGetTotalEntries(const char* tree) const; Long64_tGetTotalSize() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Long64_tMerge(TCollection* list); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCollection.html:3307,Hash,Hash,3307,root/html528/TFileCollection.html,https://root.cern,https://root.cern/root/html528/TFileCollection.html,1,['Hash'],['Hash']
Security," const; Get the source code of this rule. void SetAttributes(const TString& attributes); Set the attributes code of this rule. const char * GetAttributes() const; Get the attributes code of this rule. Bool_t HasTarget(const TString& target) const; Return true if one of the rule's data member target is 'target'. Bool_t HasSource(const TString& source) const; Return true if one of the rule's data member source is 'source'. void SetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); Set the pointer to the function to be run for the rule (if it is a read rule). void SetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); Set the pointer to the function to be run for the rule (if it is a raw read rule). void SetRuleType(ROOT::TSchemaRule::RuleType_t type); Set the type of the rule. Bool_t IsAliasRule() const; Return kTRUE if the rule is a strict renaming of one of the data member of the class. Bool_t IsRenameRule() const; Return kTRUE if the rule is a strict renaming of the class to a new name. Bool_t Conflicts(const ROOT::TSchemaRule* rule) const; Check if this rule conflicts with the given one. Bool_t ProcessVersion(const TString& version) const; Check if specified version string is correct and build version vector. Bool_t ProcessChecksum(const TString& checksum) const; Check if specified checksum string is correct and build checksum vector. void ProcessList(TObjArray* array, const TString& list); Split the list as a comma separated list into a TObjArray of TObjString. void ProcessDeclaration(TObjArray* array, const TString& list); Split the list as a declaration into as a TObjArray of TNamed(name,type). ReadFuncPtr_t GetReadFunctionPointer() const. ReadRawFuncPtr_t GetReadRawFunctionPointer() const. RuleType_t GetRuleType() const. » Last changed: root/core:$Id$ » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__TSchemaRule.html:12328,checksum,checksum,12328,root/html534/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html534/ROOT__TSchemaRule.html,3,['checksum'],['checksum']
Security," const; Int_tTBranch::GetMaxBaskets() const; TBranch*TBranch::GetMother() const; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual const char*GetObjClassName(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchObject.html:4967,Hash,Hash,4967,root/html528/TBranchObject.html,https://root.cern,https://root.cern/root/html528/TBranchObject.html,1,['Hash'],['Hash']
Security," const; Int_tTBranch::GetMaxBaskets() const; TBranch*TBranch::GetMother() const; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual const char*GetObjClassName(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBranchObject.html:5115,Hash,Hash,5115,root/html530/TBranchObject.html,https://root.cern,https://root.cern/root/html530/TBranchObject.html,3,['Hash'],['Hash']
Security," const; Int_tTBranch::GetMaxBaskets() const; TBranch*TBranch::GetMother() const; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual const char*GetObjClassName(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBranchObject.html:4695,Hash,Hash,4695,root/html602/TBranchObject.html,https://root.cern,https://root.cern/root/html602/TBranchObject.html,2,['Hash'],['Hash']
Security," const; Int_tTStreamerElement::GetNewType() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTStreamerElement::GetOffset() const; virtual Option_t*TObject::GetOption() const; ROOT::TSchemaRule::ReadFuncPtr_tGetReadFunc(); ROOT::TSchemaRule::ReadRawFuncPtr_tGetReadRawFunc(); voidTStreamerElement::GetSequenceType(TString& type) const; virtual Int_tTStreamerElement::GetSize() const; TMemberStreamer*TStreamerElement::GetStreamer() const; virtual const char*TNamed::GetTitle() const; Int_tTStreamerElement::GetTObjectOffset() const; Int_tTStreamerElement::GetType() const; const char*TStreamerElement::GetTypeName() const; const char*TStreamerElement::GetTypeNameBasic() const; virtual UInt_tTObject::GetUniqueID() const; Double_tTStreamerElement::GetXmax() const; Double_tTStreamerElement::GetXmin() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTStreamerElement::HasCounter() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTStreamerElement::Init(TObject* obj = 0); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTStreamerElement::IsaPointer() const; virtual Bool_tTStreamerElement::IsBase() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTStreamerElement::IsOldFormat(const char* newTypeName); Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTStreamerElement::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerArtificial.html:3636,Hash,Hash,3636,root/html534/TStreamerArtificial.html,https://root.cern,https://root.cern/root/html534/TStreamerArtificial.html,1,['Hash'],['Hash']
Security," const; Int_tTStreamerElement::GetNewType() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTStreamerElement::GetOffset() const; virtual Option_t*TObject::GetOption() const; ROOT::TSchemaRule::ReadFuncPtr_tGetReadFunc(); ROOT::TSchemaRule::ReadRawFuncPtr_tGetReadRawFunc(); voidTStreamerElement::GetSequenceType(TString& type) const; virtual Int_tTStreamerElement::GetSize() const; TMemberStreamer*TStreamerElement::GetStreamer() const; virtual const char*TNamed::GetTitle() const; Int_tTStreamerElement::GetTObjectOffset() const; Int_tTStreamerElement::GetType() const; const char*TStreamerElement::GetTypeName() const; const char*TStreamerElement::GetTypeNameBasic() const; virtual UInt_tTObject::GetUniqueID() const; Double_tTStreamerElement::GetXmax() const; Double_tTStreamerElement::GetXmin() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTStreamerElement::HasCounter() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTStreamerElement::Init(TObject* obj = 0); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTStreamerElement::IsaPointer() const; virtual Bool_tTStreamerElement::IsBase() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTStreamerElement::IsOldFormat(const char* newTypeName); Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTStreamerElement::IsTransient() const; Bool_tTObject::IsZombie() const; virtual voidTStreamerElement::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerArtificial.html:3571,Hash,Hash,3571,root/html602/TStreamerArtificial.html,https://root.cern,https://root.cern/root/html602/TStreamerArtificial.html,2,['Hash'],['Hash']
Security," const; Long_tExecPlugin(Int_t nargs); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClass() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; Int_tLoadPlugin(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPluginHandler.html:5347,Hash,Hash,5347,root/html528/TPluginHandler.html,https://root.cern,https://root.cern/root/html528/TPluginHandler.html,1,['Hash'],['Hash']
Security," const; Long_tExecPlugin(Int_t nargs); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClass() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; Int_tLoadPlugin(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPluginHandler.html:5347,Hash,Hash,5347,root/html530/TPluginHandler.html,https://root.cern,https://root.cern/root/html530/TPluginHandler.html,3,['Hash'],['Hash']
Security," const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:11308,access,access,11308,root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,5,['access'],['access']
Security," const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5695,access,access,5695,root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,1,['access'],['access']
Security," const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5695,access,access,5695,root/html526/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,1,['access'],['access']
Security," const; ROOT::Math::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5585,access,access,5585,root/html526/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,1,['access'],['access']
Security," const; ROOT::Math::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5585,access,access,5585,root/html526/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,1,['access'],['access']
Security," const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5695,access,access,5695,root/html526/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,1,['access'],['access']
Security," const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5695,access,access,5695,root/html526/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,1,['access'],['access']
Security," const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5695,access,access,5695,root/html526/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,1,['access'],['access']
Security," const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5695,access,access,5695,root/html526/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,1,['access'],['access']
Security," const; ROOT::Math::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5616,access,access,5616,root/html526/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,1,['access'],['access']
Security," const; const TEnumConstant*GetConstant(const char* name) const; const TSeqCollection*GetConstants() const; TDictionary::DeclId_tGetDeclId() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TEnum*GetEnum(const type_info& ti, TEnum::ESearchAction sa = kALoadAndInterpLookup); static TEnum*GetEnum(const char* enumName, TEnum::ESearchAction sa = kALoadAndInterpLookup); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetQualifiedName() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsValid(); Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEnum.html:2851,Hash,Hash,2851,root/html602/TEnum.html,https://root.cern,https://root.cern/root/html602/TEnum.html,2,['Hash'],['Hash']
Security," const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl(Bool_t withDeflt = kFALSE) const; const char*GetUser() const; const char*GetValueFromOptions(const char* key) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasOption(const char* key) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUrl.html:2910,Hash,Hash,2910,root/html534/TUrl.html,https://root.cern,https://root.cern/root/html534/TUrl.html,1,['Hash'],['Hash']
Security," const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl(Bool_t withDeflt = kFALSE) const; const char*GetUser() const; const char*GetValueFromOptions(const char* key) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasOption(const char* key) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUrl.html:2849,Hash,Hash,2849,root/html602/TUrl.html,https://root.cern,https://root.cern/root/html602/TUrl.html,2,['Hash'],['Hash']
Security," const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl(Bool_t withDeflt = kFALSE) const; const char*GetUser() const; const char*GetValueFromOptions(const char* key) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUrl.html:2910,Hash,Hash,2910,root/html528/TUrl.html,https://root.cern,https://root.cern/root/html528/TUrl.html,1,['Hash'],['Hash']
Security," const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl(Bool_t withDeflt = kFALSE) const; const char*GetUser() const; const char*GetValueFromOptions(const char* key) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TUrl.html:2910,Hash,Hash,2910,root/html530/TUrl.html,https://root.cern,https://root.cern/root/html530/TUrl.html,2,['Hash'],['Hash']
Security," const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLast() const; TList*THashList::GetListForObject(const char* name) const; TList*THashList::GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual TEnum*GetObject(const char*) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTCollection::GrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTCollection::Hash() const; virtual Int_tIndexOf(const TObject* obj) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTCollection::IsArgNull(const char* where, const TObject* obj) const; Bool_tTList::IsAscending(); virtual Bool_tTCollection::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTCollection::IsFolder() const; Bool_tTListOfEnums::IsLoaded() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tTObject::IsZombie() const; virtual TObject*Last() const; Int_tTSeqCollection::LastIndex() const; virtual TObjLink*LastLink() const; virtual voidTCollection::ls(Option_t* option =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnumsWithLock.html:3983,Hash,Hash,3983,root/html602/TListOfEnumsWithLock.html,https://root.cern,https://root.cern/root/html602/TListOfEnumsWithLock.html,2,['Hash'],['Hash']
Security," const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPhi() const; virtual Float_tGetTheta() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPARA.html:3523,Hash,Hash,3523,root/html528/TPARA.html,https://root.cern,https://root.cern/root/html528/TPARA.html,1,['Hash'],['Hash']
Security," const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPhi() const; virtual Float_tGetTheta() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPARA.html:3523,Hash,Hash,3523,root/html530/TPARA.html,https://root.cern,https://root.cern/root/html530/TPARA.html,3,['Hash'],['Hash']
Security," const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPhi() const; virtual Float_tGetTheta() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPARA.html:3348,Hash,Hash,3348,root/html602/TPARA.html,https://root.cern,https://root.cern/root/html602/TPARA.html,2,['Hash'],['Hash']
Security," const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tTLeaf::GetOffset() const; virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetValue(Int_t i = 0) const; virtual void*GetValuePointer() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidImport(TClonesArray* list, Int_t n); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTLeaf::IsOnTerminalBranch() const; virtual Bool_tTLeaf::IsRange() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTLeaf::IsUnsigned() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLeafD.html:2903,Hash,Hash,2903,root/html528/TLeafD.html,https://root.cern,https://root.cern/root/html528/TLeafD.html,4,['Hash'],['Hash']
Security," const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tTLeaf::GetOffset() const; virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetValue(Int_t i = 0) const; virtual void*GetValuePointer() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidImport(TClonesArray* list, Int_t n); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTLeaf::IsOnTerminalBranch() const; virtual Bool_tTLeaf::IsRange() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTLeaf::IsUnsigned() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TLeafD.html:2903,Hash,Hash,2903,root/html530/TLeafD.html,https://root.cern,https://root.cern/root/html530/TLeafD.html,6,['Hash'],['Hash']
Security," const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* server = 0); virtual TMap*GetDataSets(const char* uri, UInt_t = TDataSetManager::kExport); static TList*GetDataSetSrvMaps(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetGroupQuota(const char* group); virtual TMap*GetGroupQuotaMap(); virtual Long64_tGetGroupUsed(const char* group); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TMap*GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::opera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManager.html:3190,Hash,Hash,3190,root/html528/TDataSetManager.html,https://root.cern,https://root.cern/root/html528/TDataSetManager.html,1,['Hash'],['Hash']
Security," const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* server = 0); virtual TMap*GetDataSets(const char* uri, UInt_t = TDataSetManager::kExport); static TList*GetDataSetSrvMaps(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetGroupQuota(const char* group); virtual TMap*GetGroupQuotaMap(); virtual Long64_tGetGroupUsed(const char* group); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TMap*GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDataSetManager.html:3190,Hash,Hash,3190,root/html530/TDataSetManager.html,https://root.cern,https://root.cern/root/html530/TDataSetManager.html,3,['Hash'],['Hash']
Security," const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* server = 0); virtual TMap*GetDataSets(const char* uri, UInt_t = TDataSetManager::kExport); static TList*GetDataSetSrvMaps(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetGroupQuota(const char* group); virtual TMap*GetGroupQuotaMap(); virtual Long64_tGetGroupUsed(const char* group); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TMap*GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDataSetManager.html:3315,Hash,Hash,3315,root/html602/TDataSetManager.html,https://root.cern,https://root.cern/root/html602/TDataSetManager.html,2,['Hash'],['Hash']
Security," const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*TSecContext::GetContext() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeTSecContext::GetExpDate() const; const char*TSecContext::GetHost() const; virtual const char*TObject::GetIconName() const; const char*TSecContext::GetID() const; Int_tTSecContext::GetMethod() const; const char*TSecContext::GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTSecContext::GetOffSet() const; virtual Option_t*TObject::GetOption() const; Int_tGetRSAKey() const; TList*TSecContext::GetSecContextCleanup() const; virtual const char*TObject::GetTitle() const; const char*TSecContext::GetToken() const; virtual UInt_tTObject::GetUniqueID() const; const char*TSecContext::GetUser() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTSecContext::IsActive() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootSecContext.html:3158,Hash,Hash,3158,root/html528/TRootSecContext.html,https://root.cern,https://root.cern/root/html528/TRootSecContext.html,1,['Hash'],['Hash']
Security," const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*TSecContext::GetContext() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeTSecContext::GetExpDate() const; const char*TSecContext::GetHost() const; virtual const char*TObject::GetIconName() const; const char*TSecContext::GetID() const; Int_tTSecContext::GetMethod() const; const char*TSecContext::GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTSecContext::GetOffSet() const; virtual Option_t*TObject::GetOption() const; Int_tGetRSAKey() const; TList*TSecContext::GetSecContextCleanup() const; virtual const char*TObject::GetTitle() const; const char*TSecContext::GetToken() const; virtual UInt_tTObject::GetUniqueID() const; const char*TSecContext::GetUser() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTSecContext::IsActive() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* pt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRootSecContext.html:3158,Hash,Hash,3158,root/html530/TRootSecContext.html,https://root.cern,https://root.cern/root/html530/TRootSecContext.html,3,['Hash'],['Hash']
Security," const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*TSecContext::GetContext() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeTSecContext::GetExpDate() const; const char*TSecContext::GetHost() const; virtual const char*TObject::GetIconName() const; const char*TSecContext::GetID() const; Int_tTSecContext::GetMethod() const; const char*TSecContext::GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTSecContext::GetOffSet() const; virtual Option_t*TObject::GetOption() const; Int_tGetRSAKey() const; TList*TSecContext::GetSecContextCleanup() const; virtual const char*TObject::GetTitle() const; const char*TSecContext::GetToken() const; virtual UInt_tTObject::GetUniqueID() const; const char*TSecContext::GetUser() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTSecContext::IsActive() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSecContext.html:2812,Hash,Hash,2812,root/html602/TRootSecContext.html,https://root.cern,https://root.cern/root/html602/TRootSecContext.html,2,['Hash'],['Hash']
Security," const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPoint() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Int_tGetN() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual voidGetPoint(Int_t n, Float_t& x, Float_t& y, Float_t& z) const; virtual voidGetPoint(Int_t n, Double_t& x, Double_t& y, Double_t& z) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Int_tMerge(TCollection* list); virtual voidTAttMarker::Modify(); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPolyMarker3D.html:3598,Hash,Hash,3598,root/html528/TPolyMarker3D.html,https://root.cern,https://root.cern/root/html528/TPolyMarker3D.html,1,['Hash'],['Hash']
Security," const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPoint() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Int_tGetN() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual voidGetPoint(Int_t n, Float_t& x, Float_t& y, Float_t& z) const; virtual voidGetPoint(Int_t n, Double_t& x, Double_t& y, Double_t& z) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Int_tMerge(TCollection* list); virtual voidTAttMarker::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPolyMarker3D.html:3598,Hash,Hash,3598,root/html530/TPolyMarker3D.html,https://root.cern,https://root.cern/root/html530/TPolyMarker3D.html,3,['Hash'],['Hash']
Security," const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPoint() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Int_tGetN() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual voidGetPoint(Int_t n, Float_t& x, Float_t& y, Float_t& z) const; virtual voidGetPoint(Int_t n, Double_t& x, Double_t& y, Double_t& z) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Int_tMerge(TCollection* list); virtual voidTAttMarker::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPolyMarker3D.html:3313,Hash,Hash,3313,root/html602/TPolyMarker3D.html,https://root.cern,https://root.cern/root/html602/TPolyMarker3D.html,2,['Hash'],['Hash']
Security," const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static RooCFunction2Map<double,unsigned int,double>&fmap(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; const char*name() const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction2Ref_double_unsigned_int_double_.html:3146,Hash,Hash,3146,root/html526/RooCFunction2Ref_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction2Ref_double_unsigned_int_double_.html,2,['Hash'],['Hash']
Security," const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static RooCFunction2Map<double,unsigned int,double>&fmap(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; const char*name() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction2Ref_double_unsigned_int_double_.html:3146,Hash,Hash,3146,root/html530/RooCFunction2Ref_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction2Ref_double_unsigned_int_double_.html,3,['Hash'],['Hash']
Security," const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static RooCFunction2Map<double,unsigned int,double>&fmap(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; const char*name() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Ref_double_unsigned_int_double_.html:2864,Hash,Hash,2864,root/html602/RooCFunction2Ref_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Ref_double_unsigned_int_double_.html,2,['Hash'],['Hash']
Security," const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfEdges() const; TList*GetListOfNodes() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; Int_tLayout(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphStruct.html:4536,Hash,Hash,4536,root/html528/TGraphStruct.html,https://root.cern,https://root.cern/root/html528/TGraphStruct.html,1,['Hash'],['Hash']
Security," const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfEdges() const; TList*GetListOfNodes() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; Int_tLayout(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraphStruct.html:4536,Hash,Hash,4536,root/html530/TGraphStruct.html,https://root.cern,https://root.cern/root/html530/TGraphStruct.html,3,['Hash'],['Hash']
Security," const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfEdges() const; TList*GetListOfNodes() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; Int_tLayout(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphStruct.html:4483,Hash,Hash,4483,root/html602/TGraphStruct.html,https://root.cern,https://root.cern/root/html602/TGraphStruct.html,2,['Hash'],['Hash']
Security," const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const RooAbsNumGenerator*getProtoSampler(const char* name); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; static RooNumGenFactory&instance(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumGenFactory.html:2886,Hash,Hash,2886,root/html526/RooNumGenFactory.html,https://root.cern,https://root.cern/root/html526/RooNumGenFactory.html,2,['Hash'],['Hash']
Security," const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const RooAbsNumGenerator*getProtoSampler(const char* name); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; static RooNumGenFactory&instance(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumGenFactory.html:2886,Hash,Hash,2886,root/html530/RooNumGenFactory.html,https://root.cern,https://root.cern/root/html530/RooNumGenFactory.html,3,['Hash'],['Hash']
Security," const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const RooAbsNumGenerator*getProtoSampler(const char* name); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; static RooNumGenFactory&instance(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumGenFactory.html:2886,Hash,Hash,2886,root/html602/RooNumGenFactory.html,https://root.cern,https://root.cern/root/html602/RooNumGenFactory.html,2,['Hash'],['Hash']
Security," const; voidTObject::MakeZombie(); virtual voidTHttpEngine::Process(); voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const. » Last changed: Tue Jun 30 14:40:54 2015 » Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCivetweb.html:7601,authenticat,authentication,7601,root/html602/TCivetweb.html,https://root.cern,https://root.cern/root/html602/TCivetweb.html,2,['authenticat'],['authentication']
Security," const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static voidOptimize(Bool_t opt = kTRUE); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidSetCanDelete(Bool_t opt = kTRUE); virtual voidSetCheckSum(UInt_t checksum); virtual voidSetClass(TClass* cl); virtual voidSetClassVersion(Int_t vers); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetFactory(TVirtualStreamerInfo* factory); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); static Bool_tSetStreamMemberWise(Bool_t enable = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagFile(TFile* fFile); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVirtualStreamerInfo(); TVirtualStreamerInfo(TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualStreamerInfo.html:6447,checksum,checksum,6447,root/html602/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TVirtualStreamerInfo.html,2,['checksum'],['checksum']
Security," const;  element wise comparison ;  ; bool operator< (const T &rhs) const;  element wise comparison ;  ; template<class R2 > ; bool operator> (const SMatrix< T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; template<class R2 > ; bool operator< (const SMatrix< T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; template<class A , class R2 > ; bool operator> (const Expr< A, T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; template<class A , class R2 > ; bool operator< (const Expr< A, T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; const T & operator() (unsigned int i, unsigned int j) const;  read only access to matrix element, with indices starting from 0 ;  ; T & operator() (unsigned int i, unsigned int j);  read/write access to matrix element with indices starting from 0 ;  ; const T & At (unsigned int i, unsigned int j) const;  read only access to matrix element, with indices starting from 0. ;  ; T & At (unsigned int i, unsigned int j);  read/write access to matrix element with indices starting from 0. ;  ; SMatrixRow_const operator[] (unsigned int i) const;  read only access to matrix element, with indices starting from 0 : m[i][j] ;  ; SMatrixRow operator[] (unsigned int i);  read/write access to matrix element with indices starting from 0 : m[i][j] ;  ; SMatrix< T, D1, D2, R > & operator+= (const T &rhs);  addition with a scalar ;  ; template<class R2 > ; SMatrix< T, D1, D2, R > & operator+= (const SMatrix< T, D1, D2, R2 > &rhs);  addition with another matrix of any compatible representation ;  ; template<class A , class R2 > ; SMatrix< T, D1, D2, R > & operator+= (const Expr< A, T, D1, D2, R2 > &rhs);  addition with a compatible matrix expression ;  ; SMatrix< T, D1, D2, R > & operator-= (const T &rhs);  subtraction with a scalar ;  ; template<class R2 > ; SMatrix< T, D1, D2, R > & operator-= (const SMatrix< T, D1, D2, R2 > &rhs);  subtraction with another matrix of any compatible representation ;  ; template<class A , clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:6248,access,access,6248,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['access'],['access']
Security," const;  returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ;  ; TVirtualStreamerInfo * GetStreamerInfoAbstractEmulated (Int_t version=0) const;  For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ;  ; const TObjArray * GetStreamerInfos () const;  ; const std::type_info * GetTypeInfo () const;  ; Bool_t HasConsistentHashMember ();  Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ;  ; Bool_t HasCustomStreamerMember () const;  The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ;  ; Bool_t HasDataMemberInfo () const;  ; Bool_t HasDefaultConstructor (Bool_t testio=kFALSE) const;  Return true if we have access to a constructor usable for I/O. ;  ; Bool_t HasDictionary () const;  Check whether a class has a dictionary or not. ;  ; Bool_t HasInterpreterInfo () const;  ; Bool_t HasInterpreterInfoInMemory () const;  ; Bool_t HasLocalHashMember () const;  Returns true if this class has an definition and/or overload of the member function Hash. ;  ; void IgnoreTObjectStreamer (Bool_t ignore=kTRUE);  When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call TObject::Streamer. ;  ; Bool_t InheritsFrom (const char *cl) const override;  Return kTRUE if this class inherits from a class with name ""classname"". ;  ; Bool_t InheritsFrom (const TClass *cl) const override;  Return kTRUE if this class inherits from class cl. ;  ; void InterpretedShowMembers (void *obj, TMemberInspector &insp, Bool_t isTransient);  Do a ShowMembers() traversal of all members and base classes' members using the reflection information f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:15808,access,access,15808,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,3,['access'],['access']
Security," constTGeoManagerinline; GetNumThreads()TGeoManagerstatic; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOpticalSurface(const char *name) constTGeoManager; GetOption() constTObjectinlinevirtual; GetPainter() constTGeoManagerinline; GetPaintVolume() constTGeoManagerinline; GetParallelWorld() constTGeoManagerinline; GetParentTrackOfId(Int_t id) constTGeoManager; GetParticleName() constTGeoManagerinline; GetPath() constTGeoManager; GetPdgName(Int_t pdg) constTGeoManager; GetPhysicalNode(Int_t i) constTGeoManagerinline; GetProperty(const char *name, Bool_t *error=nullptr) constTGeoManager; GetProperty(size_t i, TString &name, Bool_t *error=nullptr) constTGeoManager; GetRegion(int i)TGeoManagerinline; GetRTmode() constTGeoManagerinline; GetSafeDistance() constTGeoManagerinline; GetSafeLevel() constTGeoManager; GetSkinSurface(const char *name) constTGeoManager; GetStackLevel() constTGeoManagerinline; GetStep() constTGeoManagerinline; GetTitle() const overrideTNamedinlinevirtual; GetTmax() constTGeoManagerinline; GetTminTmax(Double_t &tmin, Double_t &tmax) constTGeoManager; GetTopNode() constTGeoManagerinline; GetTopVolume() constTGeoManagerinline; GetTrack(Int_t index)TGeoManagerinline; GetTrackIndex(Int_t id) constTGeoManager; GetTrackOfId(Int_t id) constTGeoManager; GetUID(const char *volname) constTGeoManager; GetUniqueID() constTObjectvirtual; GetUserPaintVolume() constTGeoManagerinline; GetVerboseLevel()TGeoManagerstatic; GetVirtualLevel()TGeoManager; GetVisDensity() constTGeoManagerinline; GetVisLevel() constTGeoManager; GetVisOption() constTGeoManager; GetVolume(const char *name) constTGeoManager; GetVolume(Int_t uid) constTGeoManagerinline; GotoSafeLevel()TGeoManager; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; Import(const char *filename, const char *name="""", Option_t *option="""")TGeoManagerstatic; Info(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager-members.html:13554,Hash,Hash,13554,doc/master/classTGeoManager-members.html,https://root.cern,https://root.cern/doc/master/classTGeoManager-members.html,1,['Hash'],['Hash']
Security," constTGeoMaterial; GetConstProperty(Int_t i, Bool_t *error=nullptr) constTGeoMaterial; GetConstPropertyRef(const char *property) constTGeoMaterial; GetConstPropertyRef(Int_t i) constTGeoMaterialinline; GetDefaultColor() constTGeoMaterialvirtual; GetDensity() constTGeoMaterialinlinevirtual; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetElement() constTGeoMaterial; GetElement(Int_t i) constTGeoMaterialvirtual; GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t i=0)TGeoMaterialvirtual; GetFillColor() constTAttFillinlinevirtual; GetFillStyle() constTAttFillinlinevirtual; GetFWExtension() constTGeoMaterialinline; GetIconName() constTObjectvirtual; GetIndex()TGeoMaterial; GetIntLen() constTGeoMaterialinlinevirtual; GetName() const overrideTNamedinlinevirtual; GetNconstProperties() constTGeoMaterialinline; GetNelements() constTGeoMaterialinlinevirtual; GetNproperties() constTGeoMaterialinline; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetPointerName() constTGeoMaterial; GetPressure() constTGeoMaterialinline; GetProperties() constTGeoMaterialinline; GetProperty(const char *name) constTGeoMaterial; GetProperty(Int_t i) constTGeoMaterial; GetPropertyRef(const char *property) constTGeoMaterial; GetPropertyRef(Int_t i) constTGeoMaterialinline; GetRadLen() constTGeoMaterialinlinevirtual; GetSpecificActivity(Int_t) constTGeoMaterialinlinevirtual; GetState() constTGeoMaterialinline; GetTemperature() constTGeoMaterialinline; GetTitle() const overrideTNamedinlinevirtual; GetTransparency() constTGeoMaterialinline; GetUniqueID() constTObjectvirtual; GetUserExtension() constTGeoMaterialinline; GetZ() constTGeoMaterialinlinevirtual; GrabFWExtension() constTGeoMaterial; GrabUserExtension() constTGeoMaterial; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; Info(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoMaterial-members.html:5100,Hash,Hash,5100,doc/master/classTGeoMaterial-members.html,https://root.cern,https://root.cern/doc/master/classTGeoMaterial-members.html,1,['Hash'],['Hash']
Security," constTObjectvirtual; Finish()TTreePerfStatsvirtual; fNameTTreePerfStatsprotected; fNleavesTTreePerfStatsprotected; fPaveTTreePerfStatsprotected; fReadaheadSizeTTreePerfStatsprotected; fReadCallsTTreePerfStatsprotected; fRealNormTTreePerfStatsprotected; fRealTimeTTreePerfStatsprotected; fRealTimeAxisTTreePerfStatsprotected; fTreeTTreePerfStatsprotected; fTreeCacheSizeTTreePerfStatsprotected; fUniqueIDTObjectprivate; fUnzipInputSizeTTreePerfStatsprotected; fUnzipObjSizeTTreePerfStatsprotected; fUnzipTimeTTreePerfStatsprotected; fWatchTTreePerfStatsprotected; GetBasketInfo(TBranch *b, size_t basketNumber)TTreePerfStatsprotected; GetBasketInfo(size_t bi, size_t basketNumber)TTreePerfStatsprotected; GetBytesRead() const overrideTTreePerfStatsinlinevirtual; GetBytesReadExtra() constTTreePerfStatsinlinevirtual; GetCpuTime() constTTreePerfStatsinlinevirtual; GetDiskTime() constTTreePerfStatsinlinevirtual; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetDuplicateBasketCache() constTTreePerfStats; GetGraphIO()TTreePerfStatsinline; GetGraphTime()TTreePerfStatsinline; GetHostInfo() constTTreePerfStatsinline; GetIconName() constTObjectvirtual; GetName() const overrideTTreePerfStatsinlinevirtual; GetNleaves() constTTreePerfStatsinlinevirtual; GetNumEvents() const overrideTTreePerfStatsinlinevirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetPave()TTreePerfStatsinline; GetReadaheadSize() constTTreePerfStatsinlinevirtual; GetReadCalls() constTTreePerfStatsinlinevirtual; GetRealTime() constTTreePerfStatsinlinevirtual; GetStopwatch() constTTreePerfStatsinline; GetTitle() constTObjectvirtual; GetTreeCacheSize() constTTreePerfStatsinlinevirtual; GetUniqueID() constTObjectvirtual; GetUnzipTime() constTTreePerfStatsinlinevirtual; HandleTimer(TTimer *timer)TObjectvirtual; Hash() constTObjectvirtual; HasInconsistentHash() constTObjectinline; Info(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePerfStats-members.html:4574,Hash,Hash,4574,doc/master/classTTreePerfStats-members.html,https://root.cern,https://root.cern/doc/master/classTTreePerfStats-members.html,1,['Hash'],['Hash']
Security," constTTreeinlinevirtual; GetMedianClusterSize()TTreeprivate; GetMinimum(const char *columname) overrideTChainvirtual; GetName() const overrideTNamedinlinevirtual; GetNbranches() overrideTChainvirtual; GetNewlineValue(std::istream &inputStream)TTreeprotected; GetNotify() constTTreeinline; GetNtrees() constTChaininline; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetPacketSize() constTTreeinlinevirtual; GetPerfStats() constTTreeinlinevirtual; GetPlayer()TTree; GetReadCache(TFile *file) constTTree; GetReadCache(TFile *file, bool create)TTree; GetReadEntry() const overrideTChainvirtual; GetReadEvent() constTTreeinlinevirtual; GetScanField() constTTreeinlinevirtual; GetSelect()TTreeinline; GetSelectedRows()TTreeinlinevirtual; GetStatus() constTChaininline; GetTargetMemoryRatio() constTTreeinline; GetTimerInterval() constTTreeinlinevirtual; GetTitle() const overrideTNamedinlinevirtual; GetTotBytes() constTTreeinlinevirtual; GetTransientBuffer(Int_t size)TTree; GetTree() const overrideTChaininlinevirtual; GetTreeIndex() constTTreeinlinevirtual; GetTreeNumber() const overrideTChaininlinevirtual; GetTreeOffset() constTChaininline; GetTreeOffsetLen() constTChaininline; GetUniqueID() constTObjectvirtual; GetUpdate() constTTreeinlinevirtual; GetUserInfo()TTreevirtual; GetV1()TTreeinlinevirtual; GetV2()TTreeinlinevirtual; GetV3()TTreeinlinevirtual; GetV4()TTreeinlinevirtual; GetVal(Int_t i)TTreeinlinevirtual; GetVar(Int_t i)TTreeinline; GetVar1()TTreeinline; GetVar2()TTreeinline; GetVar3()TTreeinline; GetVar4()TTreeinline; GetW()TTreeinlinevirtual; GetWeight() const overrideTChainvirtual; GetZipBytes() constTTreeinlinevirtual; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; ImportClusterRanges(TTree *fromtree)TTreeprotected; IncrementTotalBuffers(Int_t nbytes)TTreeinlinevirtual; Info(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain-members.html:14470,Hash,Hash,14470,doc/master/classTChain-members.html,https://root.cern,https://root.cern/doc/master/classTChain-members.html,1,['Hash'],['Hash']
Security," containing the const double * of the data An example could be the std::vector<const double *>::begin In case of weighted data, the external data must have a dim+1 lists of data The passed dim refers just to the coordinate size ;  ; virtual ~FitData ();  dummy virtual destructor ;  ; void Add (const double *x);  add multi-dim coordinate data with only value ;  ; void Add (double x);  add one dim data with only coordinate and values ;  ; void Append (unsigned int newPoints, unsigned int dim=1);  ; const double * Coords (unsigned int ipoint) const;  return a pointer to the coordinates data for the given fit point ;  ; const double * GetCoordComponent (unsigned int ipoint, unsigned int icoord) const;  returns a single coordinate component of a point. ;  ; const std::vector< const double * > & GetCoordDataPtrs () const;  direct access to coord data ptrs ;  ; unsigned int NDim () const;  return coordinate data dimension ;  ; unsigned int NPoints () const;  return number of fit points ;  ; FitData & operator= (const FitData &rhs);  ; DataOptions & Opt ();  ; const DataOptions & Opt () const;  access to options ;  ; const DataRange & Range () const;  access to range ;  ; unsigned int Size () const;  return number of fit points ;  . Private Attributes; bool fWeighted;  . Additional Inherited Members;  Protected Member Functions inherited from ROOT::Fit::FitData; void InitCoordsVector ();  initializer routines to set the corresponding pointers right The vectors must NOT be resized after this initialization without setting the corresponding pointers in the same moment ( has to be an atomic operation in case of multithreading ). ;  ; template<class Iterator > ; void InitFromRange (Iterator dataItr);  ; void UnWrap ();  ;  Static Protected Member Functions inherited from ROOT::Fit::FitData; static constexpr unsigned VectorPadding (const unsigned);  If VecCore is not defined, there is no vectorization available and the SIMD vector size will always be one. ;  ;  Protected Attribut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1UnBinData.html:8390,access,access,8390,doc/master/classROOT_1_1Fit_1_1UnBinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1UnBinData.html,3,['access'],['access']
Security," containing the const double * of the data An example could be the std::vector<const double *>::begin In case of weighted data, the external data must have a dim+1 lists of data The passed dim refers just to the coordinate size ;  ; virtual ~FitData ();  dummy virtual destructor ;  ; void Add (const double *x);  add multi-dim coordinate data with only value ;  ; void Add (double x);  add one dim data with only coordinate and values ;  ; void Append (unsigned int newPoints, unsigned int dim=1);  ; const double * Coords (unsigned int ipoint) const;  return a pointer to the coordinates data for the given fit point ;  ; const double * GetCoordComponent (unsigned int ipoint, unsigned int icoord) const;  returns a single coordinate component of a point. ;  ; const std::vector< const double * > & GetCoordDataPtrs () const;  direct access to coord data ptrs ;  ; unsigned int NDim () const;  return coordinate data dimension ;  ; unsigned int NPoints () const;  return number of fit points ;  ; FitData & operator= (const FitData &rhs);  ; DataOptions & Opt ();  ; const DataOptions & Opt () const;  access to options ;  ; const DataRange & Range () const;  access to range ;  ; unsigned int Size () const;  return number of fit points ;  . Private Attributes; std::unique_ptr< ProxyListBox > fList;  . Additional Inherited Members;  Protected Member Functions inherited from ROOT::Fit::FitData; void InitCoordsVector ();  initializer routines to set the corresponding pointers right The vectors must NOT be resized after this initialization without setting the corresponding pointers in the same moment ( has to be an atomic operation in case of multithreading ). ;  ; template<class Iterator > ; void InitFromRange (Iterator dataItr);  ; void UnWrap ();  ;  Static Protected Member Functions inherited from ROOT::Fit::FitData; static constexpr unsigned VectorPadding (const unsigned);  If VecCore is not defined, there is no vectorization available and the SIMD vector size will always be one. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1SparseData.html:5290,access,access,5290,doc/master/classROOT_1_1Fit_1_1SparseData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1SparseData.html,3,['access'],['access']
Security," containing the const double * of the data An example could be the std::vector<const double *>::begin In case of weighted data, the external data must have a dim+1 lists of data The passed dim refers just to the coordinate size ;  ; virtual ~FitData ();  dummy virtual destructor ;  ; void Add (const double *x);  add multi-dim coordinate data with only value ;  ; void Add (double x);  add one dim data with only coordinate and values ;  ; void Append (unsigned int newPoints, unsigned int dim=1);  ; const double * Coords (unsigned int ipoint) const;  return a pointer to the coordinates data for the given fit point ;  ; const double * GetCoordComponent (unsigned int ipoint, unsigned int icoord) const;  returns a single coordinate component of a point. ;  ; const std::vector< const double * > & GetCoordDataPtrs () const;  direct access to coord data ptrs ;  ; unsigned int NDim () const;  return coordinate data dimension ;  ; unsigned int NPoints () const;  return number of fit points ;  ; FitData & operator= (const FitData &rhs);  ; DataOptions & Opt ();  ; const DataOptions & Opt () const;  access to options ;  ; const DataRange & Range () const;  access to range ;  ; unsigned int Size () const;  return number of fit points ;  . Protected Member Functions; void ComputeSums ();  ; void InitBinEdge ();  ; void InitDataVector ();  ; void InitializeErrors ();  ; void UnWrap ();  ;  Protected Member Functions inherited from ROOT::Fit::FitData; void InitCoordsVector ();  initializer routines to set the corresponding pointers right The vectors must NOT be resized after this initialization without setting the corresponding pointers in the same moment ( has to be an atomic operation in case of multithreading ). ;  ; template<class Iterator > ; void InitFromRange (Iterator dataItr);  ; void UnWrap ();  . Private Attributes; std::vector< std::vector< double > > fBinEdge;  ; std::vector< std::vector< double > > fCoordErrors;  ; std::vector< const double * > fCoordErrorsPtr;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:11904,access,access,11904,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,3,['access'],['access']
Security," containing the const double * of the data An example could be the std::vector<const double *>::begin In case of weighted data, the external data must have a dim+1 lists of data The passed dim refers just to the coordinate size ;  ; virtual ~FitData ();  dummy virtual destructor ;  ; void Add (const double *x);  add multi-dim coordinate data with only value ;  ; void Add (double x);  add one dim data with only coordinate and values ;  ; void Append (unsigned int newPoints, unsigned int dim=1);  ; const double * Coords (unsigned int ipoint) const;  return a pointer to the coordinates data for the given fit point ;  ; const double * GetCoordComponent (unsigned int ipoint, unsigned int icoord) const;  returns a single coordinate component of a point. ;  ; const std::vector< const double * > & GetCoordDataPtrs () const;  direct access to coord data ptrs ;  ; unsigned int NDim () const;  return coordinate data dimension ;  ; unsigned int NPoints () const;  return number of fit points ;  ; FitData & operator= (const FitData &rhs);  ; DataOptions & Opt ();  ; const DataOptions & Opt () const;  access to options ;  ; const DataRange & Range () const;  access to range ;  ; unsigned int Size () const;  return number of fit points ;  . Protected Member Functions; void InitCoordsVector ();  initializer routines to set the corresponding pointers right The vectors must NOT be resized after this initialization without setting the corresponding pointers in the same moment ( has to be an atomic operation in case of multithreading ). ;  ; template<class Iterator > ; void InitFromRange (Iterator dataItr);  ; void UnWrap ();  . Static Protected Member Functions; static constexpr unsigned VectorPadding (const unsigned);  If VecCore is not defined, there is no vectorization available and the SIMD vector size will always be one. ;  . Protected Attributes; unsigned int fDim;  ; unsigned int fMaxPoints;  ; unsigned int fNPoints;  ; bool fWrapped;  . Private Attributes; std::vector< std::vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitData.html:4159,access,access,4159,doc/master/classROOT_1_1Fit_1_1FitData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitData.html,3,['access'],['access']
Security," contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a global/linearized gbin number. This global gbin is useful; 244 to access the bin content/error information independently of the dimension.; 245 Note that to access the information other than bin content and errors; 246 one should use the TAxis object directly with e.g.:; 247~~~ {.cpp}; 248 Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; 249~~~; 250 returns the center along z of bin number 27 (not the global bin); 251 in the 3-D histogram h3.; 252 ; 253\anchor alpha; 254### Alphanumeric Bin Labels; 255 ; 256 By default, a histogram axis is drawn with its numeric bin labels.; 257 One can specify alphanumeric labels instead with:; 258 ; 259 - call TAxis::SetBinLabel(bin, label);; 260 This can always be done before or after filling.; 261 When the histogram is drawn, bin labels will be automatically drawn.; 262 See examples labels1.C and labels2.C; 263 - call to a Fill function with one of the arguments being a string, e.g.; 264~~~ {.cpp}; 265 hist1->Fill(somename, weight);; 266 hist2->Fill(x, somename, weight);; 267 hist2->Fill(somename, y, weight);; 268 hist2->Fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:10901,access,access,10901,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['access'],['access']
Security," contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:32271,access,access,32271,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['access'],['access']
Security," contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jaco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:33924,access,access,33924,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,1,['access'],['access']
Security," contents to be printed. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Configure mapping of Print() arguments to RooPrintable print styles. void Streamer(TBuffer& ); Stream an object of class RooFitResult. TObject* Clone(const char* newname = 0) const. TObject* clone() const; { return new RooFitResult(*this); }. void Print(Option_t* options = 0) const; Printing interface. Int_t status() const; Accessors. UInt_t numStatusHistory() const; { return _statusHistory.size() ; }. Int_t covQual() const; Return MINUIT quality code of covariance matrix. Int_t numInvalidNLL() const; Return number of NLL evaluations with problems. Double_t edm() const; Return estimated distance to minimum. Double_t minNll() const; Return minimized -log(L) value. const RooArgList& constPars() const; Return list of constant parameters. const RooArgList& floatParsInit() const; Return list of floating parameters before fit. const RooArgList& floatParsFinal() const; Return list of floarting parameters after fit. Double_t correlation(const RooAbsArg& par1, const RooAbsArg& par2) const; Return correlation between par1 and par2. return correlation(par1.GetName(),par2.GetName()). Double_t globalCorr(const RooAbsArg& par); Global correlation accessors. { return globalCorr(par.GetName()) ; }. RooPlot * plotOn(RooPlot* frame, const RooAbsArg& par1, const RooAbsArg& par2, const char* options = ""ME"") const; Add objects to a 2D plot. void setMinNLL(Double_t val); { _minNLL = val ; }. void setEDM(Double_t val); { _edm = val ; }. void setStatus(Int_t val); { _status = val ; }. void setCovQual(Int_t val); { _covQual = val ; }. void setNumInvalidNLL(Int_t val); { _numBadNLL=val ; }. void setStatusHistory(vector<pair<string,int> >& hist); { _statusHistory = hist ; }. » Last changed: Tue Jun 30 14:32:59 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFitResult.html:18759,access,accessors,18759,root/html602/RooFitResult.html,https://root.cern,https://root.cern/root/html602/RooFitResult.html,1,['access'],['accessors']
Security," coordinates (Cartesian) in double precision; ROOT::Math::XYZTVectorF vector based on x, y, z, t coordinates (Cartesian) in float precision; ROOT::Math::PtEtaPhiEVector vector based on pt(rho), eta, phi and E(t) coordinates in double precision; ROOT::Math::PtEtaPhiMVector vector based on pt(rho), eta, phi and M(t) coordinates in double precision; ROOT::Math::PxPyPzMVector vector based on px, py, pz and M(mass) coordinates in double precision. The metric used for all the LorentzVector is (-,-,-,+) .; 13.12.4.1 Constructors and Assignment; The following declarations are available:; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; Note that each type of vector is constructed by passing its coordinate representation, so a XYZTVector(1,2,3,4) is different from a PtEtaPhiEVector(1,2,3,4). In addition, the Vector classes can be constructed by any vector, which implements the accessors x(), y(), z() and t().; This can be another ROOT::Math::LorentzVector based on a different coordinate system or any vector of a different package, like the CLHEP HepLorentzVector that implements the required signature.; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; 13.12.4.2 Coordinate Accessors; All the same coordinate accessors are available through the interface of ROOT::Math::LorentzVector. For example:; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); In addition, all 4 vector coordinates can be retrieved with the GetCoordinates method:; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:736978,access,accessors,736978,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessors']
Security," cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. ◆ MinimalErrorHandler(). void ROOT::Internal::MinimalErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). A very simple error handler that is usually replaced by the TROOT default error handler. ; The minimal error handler is not serialized across threads, so that output of multi-threaded programs can get scrambled Noteabort() is only called if abort_bool is true and level >= gErrorIgnoreLevel ; Definition at line 67 of file TError.cxx. ◆ NotifyDirected(). void ROOT::Internal::NotifyDirected ; (; Detail::TBranchProxy * ; x). Definition at line 36 of file TBranchProxyDirector.cxx. ◆ operator<<(). std::ostream & ROOT::Internal::operator<< ; (; std::ostream & ; os, . const RConcurrentHashColl::HashValue & ; h . ). Definition at line 24 of file RConcurrentHashColl.cxx. ◆ operator==(). bool ROOT::Internal::operator== ; (; const RConcurrentHashColl::HashValue & ; lhs, . const RConcurrentHashColl::HashValue & ; rhs . ). inline . Definition at line 69 of file RConcurrentHashColl.hxx. ◆ ParallelReduceHelper(). template<typename T > . static T ROOT::Internal::ParallelReduceHelper ; (; const std::vector< T > & ; objs, . const std::function< T(T a, T b)> & ; redfunc . ). static . A helper function to implement the TThreadExecutor::ParallelReduce methods. ; Definition at line 122 of file TThreadExecutor.cxx. ◆ R__AddPragmaForClass() [1/2]. static bool ROOT::Internal::R__AddPragmaForClass ; (; TTreeProxyGenerator * ; gen, . const char * ; classname . ). static . Add the ""pragma C++ class"" if needed and return true if it has been added or if it is known to not be needed. ; (I.e. return false if a container of this class can not have a ""pragma C++ class"" ; Definition at line 1588 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:38802,Hash,HashValue,38802,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,2,['Hash'],['HashValue']
Security," createChi2(RooDataSet& data, RooCmdArg arg1, RooCmdArg arg2, 				 RooCmdArg arg3, RooCmdArg arg4, RooCmdArg arg5, 				 RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. Double_t getVal(const RooArgSet* set=0); Return value and unit accessors. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:76337,access,accessors,76337,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['access'],['accessors']
Security," created, as it is shown in code below:. TImage *img = TImage::Create();; img->Bevel(0, 0, 400, 300, ""#dddddd"", ""#000000"", 3);. void Pad(const char* color = ""#00FFFFFF"", UInt_t left = 0, UInt_t right = 0, UInt_t top = 0, UInt_t bottom = 0); Enlarge image, padding it with specified color on each side in; accordance with requested geometry. void Crop(Int_t x = 0, Int_t y = 0, UInt_t width = 0, UInt_t height = 0); Crop an image. void Append(const TImage* im, const char* option = ""+"", const char* color = ""#00000000""); Append image. option:; ""+"" - appends to the right side; ""/"" - appends to the bottom. void BeginPaint(Bool_t fast = kTRUE); BeginPaint initializes internal array[width x height] of ARGB32 pixel; values.; That provides quick access to image during paint operations.; To RLE compress image one needs to call EndPaint method when paintinig; is over. void EndPaint(); EndPaint does internal RLE compression of image data. UInt_t * GetArgbArray(); Return a pointer to internal array[width x height] of ARGB32 values; This array is directly accessible. That allows to manipulate/change the; image. UInt_t * GetRgbaArray(); Return a pointer to an array[width x height] of RGBA32 values.; This array is created from internal ARGB32 array,; must be deleted after usage. UInt_t * GetScanline(UInt_t y); Return a pointer to scanline. void FillRectangleInternal(UInt_t col, Int_t x, Int_t y, UInt_t width, UInt_t height); Fill rectangle of size (width, height) at position (x,y); within the existing image with specified color. void FillRectangle(const char* col = 0, Int_t x = 0, Int_t y = 0, UInt_t width = 0, UInt_t height = 0); Fill rectangle of size (width, height) at position (x,y); within the existing image with specified color. To create new image with Fill method the following code can be used:. TImage *img = TImage::Create();; img->Fill(""#FF00FF"", 0, 0, 400, 300);. void DrawVLine(UInt_t x, UInt_t y1, UInt_t y2, UInt_t col, UInt_t thick); Draw a vertical line. void DrawHLine(UIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:36400,access,accessible,36400,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,7,['access'],['accessible']
Security," current attributes. ;  ; void SetNpx (Int_t n);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpline3.html:5068,Hash,Hash,5068,doc/master/classTSpline3.html,https://root.cern,https://root.cern/doc/master/classTSpline3.html,4,"['Hash', 'hash']","['Hash', 'hash']"
Security," currently active PROOF session. ;  ; Int_t Remove (TDSetElement *elem, Bool_t deleteElem=kTRUE);  Remove TDSetElement 'elem' from the list. ;  ; virtual void Reset ();  Reset or initialize access to the elements. ;  ; void SetDirectory (const char *dir);  Set/change directory. ;  ; virtual void SetEntryList (TObject *aList);  Set entry (or event) list for this data set. ;  ; void SetLookedUp ();  Flag all the elements as looked-up, so to avoid opening the files if the functionality is not supported. ;  ; void SetObjName (const char *objname);  Set/change object name. ;  ; void SetSrvMaps (TList *srvmaps=0);  Set (or unset) the list for mapping servers coordinate for files. ;  ; void SetWriteV3 (Bool_t on=kTRUE);  Set/Reset the 'OldStreamer' bit in this instance and its elements. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this TTree. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TDSet. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Validate ();  Validate the TDSet by opening files. ;  ; void Validate (TDSet *dset);  Validate the TDSet against another TDSet. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSet.html:6501,Validat,Validate,6501,doc/master/classTDSet.html,https://root.cern,https://root.cern/doc/master/classTDSet.html,2,['Validat'],['Validate']
Security," dCache server (for more on the dCache daemon see http://www-dcache.desy.de/ ;  CTDCacheSystem;  CTDecayChannel;  CTDecompBase;  CTDecompBK;  CTDecompChol;  CTDecompLU;  CTDecompQRH;  CTDecompSparse;  CTDecompSVD;  CTDialogCanvasA canvas specialized to set attributes ;  CTDiamondDraw a Diamond ;  CTDictAttributeMapThe ROOT object has a list of properties which are stored and retrieved using TDictAttributeMap ;  CTDictionaryThis class defines an abstract interface that must be implemented by all classes that contain dictionary information ;  ►CTDirectoryDescribe directory structure in memory ;  CTContext;  CTDirectoryFileA ROOT file is structured in Directories (like a file system) ;  CTDNDData;  CTDocDirective;  CTDocHtmlDirective;  CTDocLatexDirective;  CTDocMacroDirective;  CTDocMethodWrapper;  CTDocOutput;  CTDocParser;  CTDOMParser;  CTDrawFeedback;  CTDSet;  CTDSetElement;  CTDSetProxy;  CTDsKey;  CTEditQueryFrame;  CTEfficiencyClass to handle efficiency histograms ;  CTElementActionT;  CTElementPosActionT;  CTEllipseDraw Ellipses ;  CTELTUA cylinder with an elliptical section ;  CtemplateSmall helper to implement the function to create,access and destroy iterators ;  CtemplateSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CTEmulatedCollectionProxyStreamer around an arbitrary STL like container, which implements basic container functionality ;  CTEmulatedMapProxyStreamer around a map container ;  CTEntryListA List of entry numbers in a TTree or TChain ;  CTEntryListArrayA list of entries and subentries in a TTree or TChain ;  CTEntryListBlockUsed by TEntryList to store the entry numbers ;  CTEntryListFromFileManages entry lists from different files, when they are not loaded in memory at the same time ;  CTEnumImplements the enum type ;  CTEnumConstantImplements the constants of the enum type ;  CTEnvReads config files, by default named .rootrc ;  CTEnvRec;  CTestDialog;  CTestMainFrame;  CTestMsgBox;  CTestPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:97684,access,access,97684,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['access'],['access']
Security," database). But at the same time we will make sure that all data stored by the experiments remains readable (ideally even from 2001 :-).; This is mostly an issue of type names; CINT has some non-obvious (and non-standard compliant) naming conventions for types, and we must make sure that cling continues to understand them. Or we cannot read an edm::TaggedVector anymore (because CINT would have called it an edm::TaggedVector).; We plan to release a snapshot of ROOT using cling in the third quarter of 2012; we will really appreciate feedback on problems with reading old files - as you correctly pointed out this is one of the most crucial ingredients of this project.; Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Thank you for clarifying a . Thank you for clarifying a transition plan, it is quite a reasonable approach. I just want to add a personal request to your wish list. Would it be possible to improve IO speed for reading? Very often analysis code is constrained by CPU/disk access limits when reading ntuples. The speed varies from ~100kHz for a tree with few float branches to ~200 Hz for complex data structure. A factor of few improvement for complex data can be a difference between requiring just one machine or a small farm. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: I/O Performance . Hi ROOT User,; We have dramatically improved the I/O performance over the last two years. If you use the latest production release also for writing data you might be able to see a performance improvement of an order of magnitude compared to e.g. 5.26, both in real and CPU time! See e.g. this blog entry.; We have been comparing the performance of ROOT I/O with competitors like Google ProtoBuf; we know exactly where we spend extra time and why, e.g. for schema evolution, proper C++ type support, introspection, pointers.; On the other hand, are you sure you make use of all the performance features ROOT o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:14840,access,access,14840,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['access'],['access']
Security," delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ROOT::TSchemaRule&operator=(const ROOT::TSchemaRule& rhs); Bool_toperator==(const ROOT::TSchemaRule& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetAttributes(const TString& attributes); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Bool_tSetChecksum(const TString& checksum); voidSetCode(const TString& code); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEmbed(Bool_t embed); Bool_tSetFromRule(const char* rule); voidSetInclude(const TString& include); static voidTObject::SetObjectStat(Bool_t stat); voidSetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); voidSetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); voidSetRuleType(ROOT::TSchemaRule::RuleType_t type); voidSetSource(const TString& source); voidSetSourceClass(const TString& classname); voidSetTarget(const TString& target); voidSetTargetClass(const TString& classname); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetVersion(const TString& version); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaRule.html:4806,checksum,checksum,4806,root/html602/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaRule.html,2,['checksum'],['checksum']
Security," different compression parameters. To make the numbers more significant, the macro was modified to create 1000 histograms. We have included two more examples to show the impact of compression on Trees in the next chapter.; 11.6.1 Using the General Open Function of TFile; To make life simple we provide a general function to open any type of file (except shared memory files of class TMapFile). This functionality is provided by the static TFile::Open() function:; TFile *TFile::Open(const Text_t *name,Option_t *option="""",; const Text_t *title="""",Int_t compress,Int_t netopt); Depending on the name argument, the function returns a TFile or one of its derivations, for example a TNetXNGFile or a TDavixFile object. In case a URL specifies a local file, a TFile object will be returned (and of course no login information is needed). The arguments of the Open() function are the same as the ones for the TFile constructor.; Using ReOpen() method it is possible to reopen a file with a different access mode, like from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either “READ” or “UPDATE”. The method returns:. 0 in case the mode was successfully modified;; 1 in case the mode did not change (it was already as requested or there were wrong input arguments);; -1 in case of failure. In the last case the file cannot be used anymore. 11.7 Remotely Access to ROOT Files; ROOT files can be accessed remotely in many ways, on the base of the protocol URL. Among the most popular are XRootD (protocols ‘root://’ and ‘xrd://’) and a Web server (protocl ‘http://’ or ‘https://’).; The rootd daemon is deprecated and has been removed in version 6.16/00.; Please refer to the XRootD documentation for starting and ensuring that such a daemon is running.; Reading and writing ROOT files over the net can be done by creating a TFile object using the static method TFile::Open() object. This will instantiate the appropriate derivation of TFile to handle the request",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:515532,access,access,515532,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security," different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each Tree::Fill, the branch numbers containing the; referenced objects are saved to the TBranchRef basket.; When the Tree header is saved (via TTree::Write), the branch; is saved keeping the information with the pointers to the branches; having referenced objects. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the function TTree::Branch above.; This function is far more powerful than the Branch function.; It supports the full C++, including STL and has the same behaviour; in split or non-split mode. classname does not have to derive from TObject.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:51429,access,access,51429,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['access'],['access']
Security," different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each Tree::Fill, the branch numbers containing the; referenced objects are saved to the TBranchRef basket.; When the Tree header is saved (via TTree::Write), the branch; is saved keeping the information with the pointers to the branches; having referenced objects. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the internal; implementation of the old TTree::Branch (whose implementation; has been moved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:53514,access,access,53514,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['access'],['access']
Security," different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. void Browse(TBrowser* ); Browse content of the TTree. Int_t BuildIndex(const char* majorname, const char* minorname = ""0""); Build a Tree Index (default is TTreeIndex).; See a description of the parameters and functionality in; TTreeIndex::TTreeIndex(). The return value is the number of entries in the Index (< 0 indicates failure). A TTreeIndex object pointed by fTreeIndex is created.; This object will be automatically deleted by the TTree destructor.; See also comments in TT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:54068,access,access,54068,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['access'],['access']
Security," digest methods ;  httpcontrol.CThis program demonstrates simple application control via THttpServer Two histogram are filled within endless loop ;  httpserver.CThis program creates : ;  httptextlog.CThis macro demonstrates custom access and custom drawing for TMsgList class Main motivation for this example - demonstrate how traffic between server and client can be minimized and how one could build custom UI in the browser ;  httptextlog.js;  ws.C;  ► image;  galaxy_image.C Importing an image and manipulating it ;  hist2image.C Create an image from a 2-D histogram and manipulate it ;  hsumanim.C This script is a slightly modified version of hsum.C ;  image2hist.C Create a 2-D histogram from an image ;  img2pad.C Display image in canvas and pad ;  imgconv.C Open rose512.jpg and save it in the following formats: .png, .gif, .xpm and tiff ;  pad2png.C Create a canvas and save as png ;  rose_image.C Display image in a new canvas and pad ;  trans_graph.C Demonstrates how to access and manipulate ARGB pixel values of an image +.. ;  ► io;  copyFiles.C Example of script showing how to copy all objects (including directories) from a source file ;  dirs.C This macro illustrates how to create a hierarchy of directories in a Root file ;  double32.C Tutorial illustrating use and precision of the Double32_t data type You must run this tutorial with ACLIC: a dictionary will be automatically created ;  fildir.C This macro displays the ROOT Directory data structure ;  file.C This macro displays the physical ROOT file structure ;  hadd.C Macro to add histogram files This macro is kept for didactical purposes only: use instead the executable $ROOTSYS/bin/hadd ! ;  importCode.C Example of script showing how to create a ROOT file with subdirectories ;  loopdir.C Example of script to loop on all the objects of a ROOT file directory and print on Postscript all TH1 derived objects ;  loopdir11.C Example of script to loop on all the objects of a ROOT file directory and print on Postscript ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:127605,access,access,127605,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['access'],['access']
Security," dimensional array of fixed size.; 1969/// - In case of the truncated floating point types (Float16_t and Double32_t) you can; 1970/// furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; 1971/// the type character. See `TStreamerElement::GetRange()` for further information.; 1972///; 1973/// Any of other form is not supported.; 1974///; 1975/// Note that the TTree will assume that all the item are contiguous in memory.; 1976/// On some platform, this is not always true of the member of a struct or a class,; 1977/// due to padding and alignment. Sorting your data member in order of decreasing; 1978/// sizeof usually leads to their being contiguous in memory.; 1979///; 1980/// * bufsize is the buffer size in bytes for this branch; 1981/// The default value is 32000 bytes and should be ok for most cases.; 1982/// You can specify a larger value (e.g. 256000) if your Tree is not split; 1983/// and each entry is large (Megabytes); 1984/// A small value for bufsize is optimum if you intend to access; 1985/// the entries in the Tree randomly and your Tree is in split mode.; 1986 ; 1987TBranch* TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize /* = 32000 */); 1988{; 1989 TBranch* branch = new TBranch(this, name, address, leaflist, bufsize);; 1990 if (branch->IsZombie()) {; 1991 delete branch;; 1992 branch = nullptr;; 1993 return nullptr;; 1994 }; 1995 fBranches.Add(branch);; 1996 return branch;; 1997}; 1998 ; 1999////////////////////////////////////////////////////////////////////////////////; 2000/// Create a new branch with the object of class classname at address addobj.; 2001///; 2002/// WARNING:; 2003///; 2004/// Starting with Root version 3.01, the Branch function uses the new style; 2005/// branches (TBranchElement). To get the old behaviour, you can:; 2006/// - call BranchOld or; 2007/// - call TTree::SetBranchStyle(0); 2008///; 2009/// Note that with the new style, classname does not need to derive from ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:78660,access,access,78660,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security," directories, which could be accessed via serverDefinition THttpServer.h:48; THttpServer::SubmitHttpBool_t SubmitHttp(std::shared_ptr< THttpCallArg > arg, Bool_t can_run_immediately=kFALSE)Submit HTTP request.Definition THttpServer.cxx:681; THttpServer::fMainThrdIdLong_t fMainThrdId! id of the thread for processing requestsDefinition THttpServer.h:38; THttpServer::fJSROOTSYSTString fJSROOTSYS! location of local JSROOT filesDefinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(const char *subfolder, TObject *obj)Register object in subfolder.Definition THttpServer.cxx:1243; THttpServer::fEnginesTList fEngines! engines which runs http serverDefinition THttpServer.h:34; THttpServer::SetCorsvoid SetCors(const std::string &domain=""*"")Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-C...Definition THttpServer.h:109; THttpServer::IsCorsBool_t IsCors() constReturns kTRUE if CORS was configured.Definition THttpServer.h:112; THttpServer::GetCorsCredentialsconst char * GetCorsCredentials() constReturns specified CORS credentials value - if any.Definition THttpServer.h:124; THttpServer::fArgsstd::queue< std::shared_ptr< THttpCallArg > > fArgs! submitted argumentsDefinition THttpServer.h:58; THttpServer::SetDefaultPagevoid SetDefaultPage(const std::string &filename="""")Set default HTML page.Definition THttpServer.cxx:368; THttpServer::THttpServerTHttpServer(const THttpServer &)=delete; THttpServer::ReadFileContentstatic char * ReadFileContent(const char *filename, Int_t &len)Reads content of file from the disk.Definition THttpServer.cxx:1557; THttpServer::CreateServerThreadvoid CreateServerThread()Creates special thread to process all requests, directed to http server.Definition THttpServer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:62317,Access,Access-C,62317,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['Access'],['Access-C']
Security," directory, do eg: TH2D h3_1 = (TH2D)gDirectory->Get(""h3_1""); ; Definition at line 978 of file TH3.cxx. ◆ GetBin(). Int_t TH3::GetBin ; (; Int_t ; binx, . Int_t ; biny, . Int_t ; binz . ); const. overridevirtual . See comments in TH1::GetBin. ; Reimplemented from TH1.; Definition at line 1117 of file TH3.cxx. ◆ GetBinContent() [1/4]. Double_t TH1::GetBinContent ; (; Int_t ; bin); const. virtual . Return content of bin number bin. ; Implemented in TH1C,S,F,D; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined. For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; h#define h(i)Definition RSha256.hxx:106; int; returns a global/linearized bin number. This global bin is useful to access the bin information independently of the dimension. ; Reimplemented from TH1.; Reimplemented in TProfile3D.; Definition at line 265 of file TH1.cxx. ◆ GetBinContent() [2/4]. virtual Double_t TH1::GetBinContent ; (; Int_t ; bin, . Int_t ;  . ); const. inlinevirtual . Reimplemented from TH1.; Reimplemented in TProfile3D.; Definition at line 266 of file TH1.h. ◆ GetBinContent() [3/4]. virtual Double_t TH1::GetBinContent ; (; Int_t ; bin, . Int_t ; , . Int_t ;  . ); const. inlinevirtual . Reimplemented from TH1.; Reimplemented in TProfile3D.; Definition at line 267 of file TH1.h. ◆ GetBinContent() [4/4]. Double_t TH3::GetBinContent ; (; Int_t ; binx, . Int_t ; biny, . Int_t ; binz . ); const. inlineoverridevirtual . Reimplemented from TH1.; Reimplemented in TProfile3D.; Definition at line 101 of file TH3.h. ◆ GetBinErrorLow() [1/2]. Double_t TH1::GetBinErrorLow ; (; Int_t ; bin); const. virtual . Return lower error associated to bin number bin. ; The error will depend on the statistic option used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:79813,access,access,79813,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['access'],['access']
Security," documentation; RestrictPhi(). void SetCoordinates(const ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). Set internal data based on 4 Scalar numbers. GetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& mass) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:5969,access,accessors,5969,root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,5,['access'],['accessors']
Security," drawn; -; *. void PaintShape(Option_t* option = """"); Paint shape of the volume; To be called from the TObject::Paint method only. void DeletePosition(TVolumePosition* position); DeletePosition deletes the position of the TVolume *node from this TVolume; and removes that volume from the list of the nodes of this TVolume. void GetLocalRange(Float_t* min, Float_t* max); GetRange. Calculates the size of 3 box the volume occupies,; Return:; two floating point arrays with the bound of box; surroundind all shapes of this TVolumeView. void SetVisibility(TVolume::ENodeSEEN vis = TVolume::kBothVisible); Set visibility for this volume and its sons*-*-*-*-; *-* =========================================; ENodeSEEN Visibility flag 00 - everything visible,; 10 - this unvisible, but sons are visible; 01 - this visible but sons; 11 - neither this nor its sons are visible; -; *. void Sizeof3D() const; -*-*-*-*Return total size of this 3-D volume with its attributes; *-* ==========================================================. void Add(TDataSet* dataset); { TDataSet::Add(dataset);}. Bool_t IsMarked() const; { return TestBit(kMark); }. void SetPositionsList(TList* list = 0); {AddObject((TObject *)list);}. TVolume(). const Option_t * GetOption() const; { return fOption.Data();}. TShape * GetShape() const; {return fShape;}. TList * GetListOfShapes() const; {return fListOfShapes;}. ENodeSEEN GetVisibility() const; {return fVisibility;}. TList * GetListOfPositions(); { return (TList *)(GetObject());}. ULong_t Hash() const; { return TObject::Hash();}. Bool_t Is3D() const; {return kTRUE;}. TList * Nodes() const; { return GetList(); }. » Author: Valery Fine 10/12/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id: TVolume.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2010-09-30 11:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVolume.html:18116,Hash,Hash,18116,root/html528/TVolume.html,https://root.cern,https://root.cern/root/html528/TVolume.html,2,['Hash'],['Hash']
Security," drawn; -; *. void PaintShape(Option_t* option = """"); Paint shape of the volume; To be called from the TObject::Paint method only. void DeletePosition(TVolumePosition* position); DeletePosition deletes the position of the TVolume *node from this TVolume; and removes that volume from the list of the nodes of this TVolume. void GetLocalRange(Float_t* min, Float_t* max); GetRange. Calculates the size of 3 box the volume occupies,; Return:; two floating point arrays with the bound of box; surroundind all shapes of this TVolumeView. void SetVisibility(TVolume::ENodeSEEN vis = TVolume::kBothVisible); Set visibility for this volume and its sons*-*-*-*-; *-* =========================================; ENodeSEEN Visibility flag 00 - everything visible,; 10 - this unvisible, but sons are visible; 01 - this visible but sons; 11 - neither this nor its sons are visible; -; *. void Sizeof3D() const; -*-*-*-*Return total size of this 3-D volume with its attributes; *-* ==========================================================. void Add(TDataSet* dataset); { TDataSet::Add(dataset);}. Bool_t IsMarked() const; { return TestBit(kMark); }. void SetPositionsList(TList* list = 0); {AddObject((TObject *)list);}. TVolume(). const Option_t * GetOption() const; { return fOption.Data();}. TShape * GetShape() const; {return fShape;}. TList * GetListOfShapes() const; {return fListOfShapes;}. ENodeSEEN GetVisibility() const; {return fVisibility;}. TList * GetListOfPositions(); { return (TList *)(GetObject());}. ULong_t Hash() const; { return TObject::Hash();}. Bool_t Is3D() const; {return kTRUE;}. TList * Nodes() const; { return GetList(); }. » Author: Valery Fine 10/12/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id: TVolume.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVolume.html:18185,Hash,Hash,18185,root/html530/TVolume.html,https://root.cern,https://root.cern/root/html530/TVolume.html,2,['Hash'],['Hash']
Security," drawn; -; *. void PaintShape(Option_t* option = """"); Paint shape of the volume; To be called from the TObject::Paint method only. void DeletePosition(TVolumePosition* position); DeletePosition deletes the position of the TVolume *node from this TVolume; and removes that volume from the list of the nodes of this TVolume. void GetLocalRange(Float_t* min, Float_t* max); GetRange. Calculates the size of 3 box the volume occupies,; Return:; two floating point arrays with the bound of box; surroundind all shapes of this TVolumeView. void SetVisibility(TVolume::ENodeSEEN vis = TVolume::kBothVisible); Set visibility for this volume and its sons*-*-*-*-; *-* =========================================; ENodeSEEN Visibility flag 00 - everything visible,; 10 - this unvisible, but sons are visible; 01 - this visible but sons; 11 - neither this nor its sons are visible; -; *. void Sizeof3D() const; -*-*-*-*Return total size of this 3-D volume with its attributes; *-* ==========================================================. void Add(TDataSet* dataset); { TDataSet::Add(dataset);}. Bool_t IsMarked() const; { return TestBit(kMark); }. void SetPositionsList(TList* list = 0); {AddObject((TObject *)list);}. TVolume(). const Option_t * GetOption() const; { return fOption.Data();}. TShape * GetShape() const; {return fShape;}. TList * GetListOfShapes() const; {return fListOfShapes;}. ENodeSEEN GetVisibility() const; {return fVisibility;}. TList * GetListOfPositions(); { return (TList *)(GetObject());}. ULong_t Hash() const; { return TObject::Hash();}. Bool_t Is3D() const; {return kTRUE;}. TList * Nodes() const; { return GetList(); }. » Author: Valery Fine 10/12/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id: TVolume.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVolume.html:18185,Hash,Hash,18185,root/html532/TVolume.html,https://root.cern,https://root.cern/root/html532/TVolume.html,2,['Hash'],['Hash']
Security," el->GetCountName();; 1211 TBranchElement *bc2 = (TBranchElement*)fBranches.FindObject(name2);; 1212 bre->SetBranchCount2(bc2);; 1213 }; 1214 bre->SetReadLeavesPtr();; 1215 bre->SetFillLeavesPtr();; 1216 }; 1217}; 1218 ; 1219////////////////////////////////////////////////////////////////////////////////; 1220/// Loop on all leaves of this branch to fill the basket buffer.; 1221///; 1222/// The function returns the number of bytes committed to the; 1223/// individual branches. If a write error occurs, the number of; 1224/// bytes returned is -1. If no data are written, because, e.g.,; 1225/// the branch is disabled, the number of bytes returned is 0.; 1226///; 1227/// Note: We not not use any member functions from TLeafElement!; 1228 ; 1229Int_t TBranchElement::FillImpl(ROOT::Internal::TBranchIMTHelper *imtHelper); 1230{; 1231 Int_t nbytes = 0;; 1232 Int_t nwrite = 0;; 1233 Int_t nerror = 0;; 1234 Int_t nbranches = fBranches.GetEntriesFast();; 1235 ; 1236 ValidateAddress();; 1237 ; 1238 //; 1239 // If we are a top-level branch, update addresses.; 1240 //; 1241 ; 1242 if (fID < 0) {; 1243 if (!fObject) {; 1244 Error(""Fill"", ""attempt to fill branch %s while address is not set"", GetName());; 1245 return 0;; 1246 }; 1247 }; 1248 ; 1249 //; 1250 // If the tree has a TRefTable, set the current branch if; 1251 // branch is not a basic type.; 1252 //; 1253 ; 1254 // FIXME: This test probably needs to be extended past 10.; 1255 if ((fType >= -1) && (fType < 10)) {; 1256 TBranchRef* bref = fTree->GetBranchRef();; 1257 if (bref) {; 1258 fBranchID = bref->SetParent(this, fBranchID);; 1259 }; 1260 }; 1261 ; 1262 if (!nbranches) {; 1263 // No sub-branches.; 1264 if (!TestBit(kDoNotProcess)) {; 1265 nwrite = TBranch::FillImpl(imtHelper);; 1266 if (nwrite < 0) {; 1267 Error(""Fill"", ""Failed filling branch:%s, nbytes=%d"", GetName(), nwrite);; 1268 ++nerror;; 1269 } else {; 1270 nbytes += nwrite;; 1271 }; 1272 }; 1273 } else {; 1274 // We have sub-branches.; 1275 if (fType == 3 || fTy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:43332,Validat,ValidateAddress,43332,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['Validat'],['ValidateAddress']
Security," enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call. When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"", ""/rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.4 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigetst” file. When starting the server, the following arguments should be specified:; root [0] new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; root [6] serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; root [7] serv->Restrict(""/Folder"", ""visi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:4093,access,access,4093,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,2,['access'],['access']
Security," end of this page.; Fitting and Drawing the Histogram; Once the histogram is filled, fit it with a pol2 using TH1::Fit(""pol2""). Here ""pol2"" is ROOT's short name for ""polynomial of 2nd degree"", i.e. [0] + [1]x + [2]x*x, aka ""parabola"".; ""Fitting"" means using a function (in this case the pol2) with one or more free parameters ([0]..[2] in this case) and looking for those values of the parameters that result in the function passing as closely as possible through the data points, where ""close"" takes the points' uncertainties into account. You should first fit and then draw, to see the fit together with the histogram.; At the end, you should get something like this:. Figure 6: Distribution of ""fPosX"" leaf values, fitted with a pol2; If, for any reason, you don't manage to get it working, you can download the working macro file here: AnalyzeTree.C (or; wget http://root-mirror.github.io/training/intro/AnalyzeTree.C); . ‹ Using a Macro to Read a TTree; up; Fit Panel ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/histogramming.html:4691,Access,Accessing,4691,d/histogramming.html,https://root.cern,https://root.cern/d/histogramming.html,3,"['Access', 'access']","['Accessing', 'access']"
Security," enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TServerSocket (const char *service, Bool_t reuse=kFALSE, Int_t backlog=kDefaultBacklog, Int_t tcpwindowsize=-1);  Create a server socket object for a named service. ;  ;  TServerSocket (Int_t port, Bool_t reuse=kFALSE, Int_t backlog=kDefaultBacklog, Int_t tcpwindowsize=-1);  Create a server socket object on a specified port. ;  ; virtual ~TServerSocket ();  Destructor: cleanup authentication stuff (if any) and close. ;  ; virtual TSocket * Accept (UChar_t Opt=0);  Accept a connection on a server socket. ;  ; TInetAddress GetLocalInetAddress () override;  Return internet address of host to which the server socket is bound, i.e. ;  ; Int_t GetLocalPort () override;  Get port # to which server socket is bound. In case of error returns -1. ;  ; TClass * IsA () const override;  ; Int_t Recv (char *, Int_t) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (char *, Int_t, Int_t &) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (Int_t &, Int_t &) override;  Receives a status and a message type. ;  ; Int_t Recv (TMessage *&) override;  Receive a TMessage object. ;  ; Int_t RecvRaw (void *, Int_t, ESendRecvOptions=kDefault) override;  Receive a raw buffer of specified length bytes. ;  ; Int_t Send (const char *, Int_t=kMESS_STRING) override;  Send a character string buffer. ;  ; Int_t Sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:1726,authenticat,authentication,1726,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,1,['authenticat'],['authentication']
Security," error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; (TString) ""python3""[7]; Factory : Booking method: ␛[1mPyKeras_LSTM␛[0m; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Loadin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:10942,validat,validation,10942,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['validat'],['validation']
Security," error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Running with nthreads = 4; --- RNNClassification : Using input file: time_data_t10_d30.root; number of variables is 300; vars_time0[0]; vars_time0[1]; vars_time0[2]; vars_time0[3]; vars_time0[4]; vars_time0[5]; vars_time0[6]; vars_time0[7]; vars_time0[8]; vars_time0[9]; vars_time0[10]; vars_time0[11]; vars_time0[12]; vars_time0[13]; vars_time0[14]; vars_time0[15]; vars_time0[16]; vars_time0[17]; vars_time0[18]; vars_time0[19]; vars_time0[20]; vars_time0[21]; vars_time0[22]; vars_time0[23]; vars_time0[24]; vars_time0[25]; vars_time0[26]; vars_time0[27]; vars_time0[28]; vars_time0[29]; vars_time1[0]; vars_time1[1]; vars_time1[2]; vars_time1[3]; vars_time1[4]; vars_time1[5]; vars_time1[6]; vars_time1[7]; vars_time1[8]; vars_time1[9]; vars_time1[10]; vars_time1[11]; vars_time1[12]; vars_time1[13]; vars_time1[14]; vars_time1[15]; vars_time",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:6406,validat,validation,6406,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['validat'],['validation']
Security," error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDEDw(); Double_tGetDelta(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLearningRate(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWeight(); Double_tGetWeightedDelta(); Double_tGetWeightedValue(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; voidInitDelta(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::oper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__TSynapse.html:2403,Hash,Hash,2403,root/html528/TMVA__TSynapse.html,https://root.cern,https://root.cern/root/html528/TMVA__TSynapse.html,1,['Hash'],['Hash']
Security," error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDEDw(); Double_tGetDelta(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLearningRate(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWeight(); Double_tGetWeightedDelta(); Double_tGetWeightedValue(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; voidInitDelta(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__TSynapse.html:2403,Hash,Hash,2403,root/html530/TMVA__TSynapse.html,https://root.cern,https://root.cern/root/html530/TMVA__TSynapse.html,3,['Hash'],['Hash']
Security," error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDEDw(); Double_tGetDelta(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLearningRate(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWeight(); Double_tGetWeightedDelta(); Double_tGetWeightedValue(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; voidInitDelta(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__TSynapse.html:2549,Hash,Hash,2549,root/html602/TMVA__TSynapse.html,https://root.cern,https://root.cern/root/html602/TMVA__TSynapse.html,2,['Hash'],['Hash']
Security," error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::CreateApplication();; 2414 ; 2415 Longptr_t result = 0;; 2416 ; 2417 if (fInterpreter) {; 2418 TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;; 2419 result = gInterpreter->Calc(sline, code);; 2420 }; 2421 ; 2422 return result;; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Read Git commit information and branch name from the; 2427/// etc/gitinfo.txt file.; 2428 ; 2429void TROOT::ReadGitInfo(); 2430{; 2431 TString filename = ""gitinfo.txt"";; 2432 gSystem->PrependPathName(TROOT::GetEtcDir(), filename);; 2433 ; 2434 FILE *fp = fopen(filename, ""r"");; 2435 if (fp) {; 2436 TString s;; 2437 // read branch name; 2438 s.Gets(fp);; 2439 fGitBranch = s;; 2440 // read commit hash; 2441 s.Gets(fp);; 2442 fGitCommit = s;; 2443 // read date/time make was run; 2444 s.Gets(fp);; 2445 fGitDate = s;; 2446 fclose(fp);; 2447 } else {; 2448 Error(""ReadGitInfo()"", ""Cannot determine git info: etc/gitinfo.txt not found!"");; 2449 }; 2450}; 2451 ; 2452Bool_t &GetReadingObject() {; 2453 TTHREAD_TLS(Bool_t) fgReadingObject = false;; 2454 return fgReadingObject;; 2455}; 2456 ; 2457////////////////////////////////////////////////////////////////////////////////; 2458/// Deprecated (will be removed in next release).; 2459 ; 2460Bool_t TROOT::ReadingObject() const; 2461{; 2462 return GetReadingObject();; 2463}; 2464 ; 2465void TROOT::SetReadingObject(Bool_t flag); 2466{; 2467 GetReadingObject() = flag;; 2468}; 2469 ; 2470 ; 2471////////////////////////////////////////////////////////////////////////////////; 2472/// Return date/time make was run.; 2473 ; 2474const char *TROOT::GetGitDate(); 2475{; 2476 if (fGitDate == """") {; 2477 Int_t iday,imonth,iyear, ih",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:92730,hash,hash,92730,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['hash'],['hash']
Security," error message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3], TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in order to be fully accessible from external code. The manager class is the owner of all geometry objects defined in a session; therefore, users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. A special case is the one of geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use TGeoMatrix::RegisterYourself() method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.; Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:63967,access,accessible,63967,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['access'],['accessible']
Security," error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLegendEntry.html:5065,Hash,Hash,5065,doc/master/classTLegendEntry.html,https://root.cern,https://root.cern/doc/master/classTLegendEntry.html,27,['Hash'],['Hash']
Security," error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHelix.html:10353,Hash,Hash,10353,doc/master/classTHelix.html,https://root.cern,https://root.cern/doc/master/classTHelix.html,7,['Hash'],['Hash']
Security," error, fill in histogram, and also fill significance; if (Use[""PDEFoam""]) {; histPDEFoam = new TH1F( ""MVA_PDEFoam"", ""MVA_PDEFoam"", nbin, 0, 1 );; histPDEFoamErr = new TH1F( ""MVA_PDEFoamErr"", ""MVA_PDEFoam error"", nbin, 0, 1 );; histPDEFoamSig = new TH1F( ""MVA_PDEFoamSig"", ""MVA_PDEFoam significance"", nbin, 0, 10 );; }; ; // Book example histogram for probability (the other methods are done similarly); TH1F *probHistFi(0), *rarityHistFi(0);; if (Use[""Fisher""]) {; probHistFi = new TH1F( ""MVA_Fisher_Proba"", ""MVA_Fisher_Proba"", nbin, 0, 1 );; rarityHistFi = new TH1F( ""MVA_Fisher_Rarity"", ""MVA_Fisher_Rarity"", nbin, 0, 1 );; }; ; // Prepare input tree (this must be replaced by your data source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; ; // Event loop; ; // Prepare the event tree; // - Here the variable names have to corresponds to your tree; // - You can use the same variables as above which is slightly faster,; // but of course you can use different ones and copy the values inside the event loop; //; std::cout << ""--- Select signal sample"" << std::endl;; TTree* theTree = (TTree*)input->Get(""TreeS"");; Float_t userVar1, userVar2;; theTree->SetBranchAddress( ""var1"", &userVar1 );; theTree->SetBranchAddress( ""var2"", &userVar2 );; theTree->SetBranchAddress( ""var3"", &var3 );; theTree->SetBranchAddress( ""var4"", &var4 );; ; // Efficie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C.html:14781,Access,AccessPathName,14781,doc/master/TMVAClassificationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html,1,['Access'],['AccessPathName']
Security," event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIntersection.html:4019,Hash,Hash,4019,root/html528/TGeoIntersection.html,https://root.cern,https://root.cern/root/html528/TGeoIntersection.html,3,['Hash'],['Hash']
Security," event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoIntersection.html:4019,Hash,Hash,4019,root/html530/TGeoIntersection.html,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html,3,['Hash'],['Hash']
Security," event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:11671,Hash,Hash,11671,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,12,"['Hash', 'hash']","['Hash', 'hash']"
Security," exec number (in the ROOT list of Execs) into the fBits of this TRef. ;  ; virtual void SetAction (TObject *parent);  Find the action to be executed in the dictionary of the parent class and store the corresponding exec number into fBits. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TRef. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:12495,Hash,Hash,12495,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,2,['Hash'],['Hash']
Security," exits the canvas is empty and the histogram has disappeared. To avoid the histogram from disappearing you can create it on the heap (by using new). This will leave the histogram object intact, but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; In addition, histograms and trees are automatically deleted when the current directory is closed. This will automatically take care of the clean up. See “Input/Output”.; 7.2.1 Executing a Script From a Script; You may want to execute a script conditionally inside another script. To do it you need to call the interpreter and you can do that with TROOT::ProcessLine(). The example $ROOTSYS/tutorials/tree/cernstaff.C calls a script to build the root file if it does not exist:; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ProcessLine takes a parameter, which is a pointer to an int or to a TInterpreter::EErrorCode to let you access the interpreter error code after an attempt to interpret. This will contain the error as defined in enum TInterpreter::EErrorCode with TInterpreter::kSuccess being the value for a successful execution.; 7.2.2 Executing a Script From the Invocation; Instead if starting ROOT and running a script on the prompt you can also pass it to ROOT in its invocation:; $ root -l -b 'myCode.C(""some String"", 12)'; The exact kind of quoting depends on your shell; the one shown here works for bash-like shells.; ROOT can evaluate any expression as part of the invocation; another version of the previous example can be spelled like this:; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; 7.3 C++ Extensions To Ease Scripting; In the next example, we demonstrate ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:264983,Access,AccessPathName,264983,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Access'],['AccessPathName']
Security," expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, e.g. for a button, is by providing the execution string. See for example tutorials/pyroot/demo.py that comes with the ROOT installation:; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddBu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058209,access,access,1058209,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security," fBaseDir = fMethodBaseDir = methodDir; }. void SetBaseDir(TDirectory* methodDir); { fBaseDir = methodDir; }. void SetMethodBaseDir(TDirectory* methodDir); { fMethodBaseDir = methodDir; }. UInt_t GetTrainingTMVAVersionCode() const; the TMVA version can be obtained and checked using; if (GetTrainingTMVAVersionCode()>TMVA_VERSION(3,7,2)) {...}; or; if (GetTrainingROOTVersionCode()>ROOT_VERSION(5,15,5)) {...}. { return fTMVATrainingVersion; }. UInt_t GetTrainingROOTVersionCode() const; { return fROOTTrainingVersion; }. TransformationHandler& GetTransformationHandler(Bool_t takeReroutedIfAvailable = true). const TransformationHandler& GetTransformationHandler(Bool_t takeReroutedIfAvailable = true) const. void RerouteTransformationHandler(TMVA::TransformationHandler* fTargetTransformation); { fTransformationPointer=fTargetTransformation; }. DataSetInfo& DataInfo() const; { return fDataSetInfo; }. UInt_t GetNEvents() const; event reference and update; NOTE: these Event accessors make sure that you get the events transformed according to the; particular clasifiers transformation chosen. { return Data()->GetNEvents(); }. Bool_t HasMVAPdfs() const; { return fHasMVAPdfs; }. void SetAnalysisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of standalone classes. { fDisableWriting = setter; }. const TString& GetWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBase.html:35615,access,accessors,35615,root/html534/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBase.html,3,['access'],['accessors']
Security," fBitsTObjectprivate; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; FillBuffer(char *&buffer)TNamedvirtual; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fNameTNamedprotected; fTextAlignTAttTextprotected; fTextAngleTAttTextprotected; fTextColorTAttTextprotected; fTextFontTAttTextprotected; fTextSizeTAttTextprotected; fTitleTNamedprotected; fUniqueIDTObjectprivate; fWcsTitleTTextprotected; fXTTextprotected; fYTTextprotected; GetBBox() overrideTTextvirtual; GetBBoxCenter() overrideTTextvirtual; GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle=kFALSE)TTextvirtual; GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t cBoxX[4], Int_t cBoxY[4])TTextvirtual; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetIconName() constTObjectvirtual; GetName() const overrideTNamedinlinevirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetTextAdvance(UInt_t &a, const char *text, const Bool_t kern=kTRUE) constTTextvirtual; GetTextAlign() constTAttTextinlinevirtual; GetTextAngle() constTAttTextinlinevirtual; GetTextAscentDescent(UInt_t &a, UInt_t &d, const char *text) constTTextvirtual; GetTextAscentDescent(UInt_t &a, UInt_t &d, const wchar_t *text) constTTextvirtual; GetTextColor() constTAttTextinlinevirtual; GetTextExtent(UInt_t &w, UInt_t &h, const char *text) constTTextvirtual; GetTextExtent(UInt_t &w, UInt_t &h, const wchar_t *text) constTTextvirtual; GetTextFont() constTAttTextinlinevirtual; GetTextSize() constTAttTextinlinevirtual; GetTextSizePercent(Float_t size)TAttTextvirtual; GetTitle() const overrideTNamedinlinevirtual; GetUniqueID() constTObjectvirtual; GetWcsTitle(void) constTText; GetX() constTTextinline; GetY() constTTextinline; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; Info(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTText-members.html:3762,Hash,Hash,3762,doc/master/classTText-members.html,https://root.cern,https://root.cern/doc/master/classTText-members.html,1,['Hash'],['Hash']
Security," fNModLabsTGaxisprotected; fTextAlignTAttTextprotected; fTextAngleTAttTextprotected; fTextColorTAttTextprotected; fTextFontTAttTextprotected; fTextSizeTAttTextprotected; fTickSizeTGaxisprotected; fTimeFormatTGaxisprotected; fTitleTGaxisprotected; fTitleOffsetTGaxisprotected; fTitleSizeTGaxisprotected; fUniqueIDTObjectprivate; fWmaxTGaxisprotected; fWminTGaxisprotected; fX1TLineprotected; fX2TLineprotected; fY1TLineprotected; fY2TLineprotected; GetBBox() overrideTLinevirtual; GetBBoxCenter() overrideTLinevirtual; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFunction() constTGaxisinline; GetGridLength() constTGaxisinline; GetIconName() constTObjectvirtual; GetLabelColor() constTGaxisinline; GetLabelFont() constTGaxisinline; GetLabelOffset() constTGaxisinline; GetLabelSize() constTGaxisinline; GetLineColor() constTAttLineinlinevirtual; GetLineStyle() constTAttLineinlinevirtual; GetLineWidth() constTAttLineinlinevirtual; GetMaxDigits()TGaxisstatic; GetName() const overrideTGaxisinlinevirtual; GetNdiv() constTGaxisinline; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() const overrideTGaxisinlinevirtual; GetTextAlign() constTAttTextinlinevirtual; GetTextAngle() constTAttTextinlinevirtual; GetTextColor() constTAttTextinlinevirtual; GetTextFont() constTAttTextinlinevirtual; GetTextSize() constTAttTextinlinevirtual; GetTextSizePercent(Float_t size)TAttTextvirtual; GetTickSize() constTGaxisinline; GetTitle() const overrideTGaxisinlinevirtual; GetTitleOffset() constTGaxisinline; GetTitleSize() constTGaxisinline; GetUniqueID() constTObjectvirtual; GetWmax() constTGaxisinline; GetWmin() constTGaxisinline; GetX1() constTLineinline; GetX2() constTLineinline; GetY1() constTLineinline; GetY2() constTLineinline; HandleTimer(TTimer *timer)TObjectvirtual; Hash() constTObjectvirtual; HasInconsistentHash() constTObjectinline; ImportAxisAttributes(TAxis *axis)TGaxisvirtual; Info(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis-members.html:5321,Hash,Hash,5321,doc/master/classTGaxis-members.html,https://root.cern,https://root.cern/doc/master/classTGaxis-members.html,1,['Hash'],['Hash']
Security," fNbytesName);; 2636 tobuf(buffer, fUnits);; 2637 tobuf(buffer, fCompress);; 2638 tobuf(buffer, (Int_t)fSeekInfo);; 2639 tobuf(buffer, fNbytesInfo);; 2640 } else {; 2641 tobuf(buffer, fEND);; 2642 tobuf(buffer, fSeekFree);; 2643 tobuf(buffer, fNbytesFree);; 2644 tobuf(buffer, nfree);; 2645 tobuf(buffer, fNbytesName);; 2646 tobuf(buffer, fUnits);; 2647 tobuf(buffer, fCompress);; 2648 tobuf(buffer, fSeekInfo);; 2649 tobuf(buffer, fNbytesInfo);; 2650 }; 2651 if (TestBit(kReproducible)); 2652 TUUID(""00000000-0000-0000-0000-000000000000"").FillBuffer(buffer);; 2653 else; 2654 fUUID.FillBuffer(buffer);; 2655 Int_t nbytes = buffer - psave;; 2656 Seek(0); // NOLINT: silence clang-tidy warnings; 2657 WriteBuffer(psave, nbytes); // NOLINT: silence clang-tidy warnings; 2658 Flush(); // NOLINT: silence clang-tidy warnings, Intentionally not conditional on fMustFlush, this is the 'obligatory' flush.; 2659 delete [] psave;; 2660}; 2661 ; 2662////////////////////////////////////////////////////////////////////////////////; 2663/// Generate source code necessary to access the objects stored in the file.; 2664///; 2665/// Generate code in directory dirname for all classes specified in; 2666/// argument classes If classes = ""*"" (default and currently the; 2667/// only supported value), the function generates an include file; 2668/// for each class in the StreamerInfo list for which a TClass; 2669/// object does not exist.; 2670///; 2671/// The code generated includes:; 2672/// - <em>dirnameProjectHeaders.h</em>, which contains one `#include` statement per generated header file; 2673/// - <em>dirnameProjectSource.cxx</em>,which contains all the constructors and destructors implementation.; 2674/// and one header per class that is not nested inside another class.; 2675/// The header file name is the fully qualified name of the class after all the special characters; 2676/// ""<>,:"" are replaced by underscored. For example for std::pair<edm::Vertex,int> the file name is; 2677/// pair_edm__",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:94217,access,access,94217,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['access']
Security," factor of 'factor' (default =2) uses previous zoom factor by default Keep center defined by 'offset' fixed ie. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classAxis2.html:8661,Hash,Hash,8661,doc/master/classAxis2.html,https://root.cern,https://root.cern/doc/master/classAxis2.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," factor of 'factor' (default =2) uses previous zoom factor by default Keep center defined by 'offset' fixed ie. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAxis.html:9859,Hash,Hash,9859,doc/master/classTAxis.html,https://root.cern,https://root.cern/doc/master/classTAxis.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," factory method to create different http engines; At the moment two engine kinds are supported:; civetweb (default) and fastcgi; Examples:; ""civetweb:8080"" or ""http:8080"" or "":8080"" - creates civetweb web server with http port 8080; ""fastcgi:9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC server with port 1237 (only available with DABC installed); ""dabc:master_host:port"" - attach to DABC master, running on master_host:port (only available with DABC installed). void SetTimer(Long_t milliSec = 100, Bool_t mode = kTRUE); create timer which will invoke ProcessRequests() function periodically; Timer is required to perform all actions in main ROOT thread; Method arguments are the same as for TTimer constructor; By default, sync timer with 100 ms period is created. If milliSec == 0, no timer will be created.; In this case application should regularly call ProcessRequests() method. Bool_t VerifyFilePath(const char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains prefix like ""jsrootsys/""; If true, method returns real name of the file,; which should be delivered to the client; Method is thread safe and can be called from any thread. Bool_t ExecuteHttp(THttpCallArg* arg); Executes http request, specified in THttpCallArg structure; Method can be called from any thread; Actual execution will be done in main ROOT thread, where analysis code is running. void ProcessRequests(); Process requests, submitted for execution; Regularly invoked by THttpTimer, when somewhere in the code; gSystem->ProcessEvents() is called.; User can call serv->ProcessRequests() directly, but only from main analysis thread. void ProcessRequest(THttpCallArg* arg); Process single http request; Depending from requested path and filename different actions will be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpServer.html:11818,access,access,11818,root/html534/THttpServer.html,https://root.cern,https://root.cern/root/html534/THttpServer.html,3,['access'],['access']
Security," file TASPluginGS.h. ◆ DeclFileName(). static const char * TASPluginGS::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 38 of file TASPluginGS.h. ◆ File2ASImage(). ASImage * TASPluginGS::File2ASImage ; (; const char * ; filename). overridevirtual . read PS/EPS/PDF file and convert it to ASImage ; Reimplemented from TASImagePlugin.; Definition at line 76 of file TASPluginGS.cxx. ◆ Hash(). ULong_t TASPluginGS::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TASPluginGS::HashULong_t Hash() const overrideReturn hash value for this object.Definition TASPluginGS.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TASImagePlugin.; Definition at line 34 of file TASPluginGS.h. ◆ IsA(). TClass * TASPluginGS::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASPluginGS.html:13303,Hash,Hash,13303,doc/master/classTASPluginGS.html,https://root.cern,https://root.cern/doc/master/classTASPluginGS.html,1,['Hash'],['Hash']
Security, file TDSet.cxx. ◆ SetWriteV3(). void TDSet::SetWriteV3 ; (; Bool_t ; on = kTRUE). Set/Reset the 'OldStreamer' bit in this instance and its elements. ; Needed for backward compatibility in talking to old client / masters. ; Definition at line 1874 of file TDSet.cxx. ◆ SplitEntryList(). void TDSet::SplitEntryList ; (; ). private . for browsing purposes ; Splits the main entry (or event) list into sub-lists for the elements of thet data set. ; Definition at line 1941 of file TDSet.cxx. ◆ StartViewer(). void TDSet::StartViewer ; (; ). virtual . Start the TTreeViewer on this TTree. ; Definition at line 1520 of file TDSet.cxx. ◆ Streamer(). void TDSet::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TDSet. ; Reimplemented from TObject.; Reimplemented in TDSetProxy.; Definition at line 1813 of file TDSet.cxx. ◆ StreamerNVirtual(). void TDSet::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 262 of file TDSet.h. ◆ Validate() [1/2]. void TDSet::Validate ; (; ). Validate the TDSet by opening files. ; Definition at line 1589 of file TDSet.cxx. ◆ Validate() [2/2]. void TDSet::Validate ; (; TDSet * ; dset). Validate the TDSet against another TDSet. ; Only validates elements in common from input TDSet. ; Definition at line 1668 of file TDSet.cxx. Member Data Documentation. ◆ fCurrent. TDSetElement* TDSet::fCurrent. protected . iterator on fElements ; Definition at line 182 of file TDSet.h. ◆ fDir. TString TDSet::fDir. protected . Definition at line 177 of file TDSet.h. ◆ fElements. THashList* TDSet::fElements. protected . Definition at line 180 of file TDSet.h. ◆ fEntryList. TObject* TDSet::fEntryList. private . Definition at line 168 of file TDSet.h. ◆ fIsTree. Bool_t TDSet::fIsTree. private . Definition at line 167 of file TDSet.h. ◆ fIterator. TIter* TDSet::fIterator. protected . Definition at line 181 of file TDSet.h. ◆ fObjName. TString TDSet::fObjName. protected . Definition at line 179 of file TDSet.h,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSet.html:29706,Validat,Validate,29706,doc/master/classTDSet.html,https://root.cern,https://root.cern/doc/master/classTDSet.html,1,['Validat'],['Validate']
Security," file TGHtml.h. Public Member Functions;  TGHtmlElement (int etype=0);  HTML element constructor. ;  ; virtual int GetAlignment (int dflt);  ; virtual int GetOrderedListType (int dflt);  ; virtual int GetUnorderedListType (int dflt);  ; virtual int GetVerticalAlignment (int dflt);  ; virtual int IsMarkup () const;  ; virtual const char * MarkupArg (const char *, const char *);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtmlElement.html:1270,Hash,Hash,1270,doc/master/classTGHtmlElement.html,https://root.cern,https://root.cern/doc/master/classTGHtmlElement.html,2,['Hash'],['Hash']
Security, file TGeoManager.h. ◆ fgNumThreads. Int_t TGeoManager::fgNumThreads = 0. staticprivate . Thread id's map. ; Definition at line 121 of file TGeoManager.h. ◆ fGShapes. TObjArray* TGeoManager::fGShapes. private . Definition at line 97 of file TGeoManager.h. ◆ fgThreadId. TGeoManager::ThreadsMap_t * TGeoManager::fgThreadId = nullptr. staticprivate . Map between thread id's and navigator arrays. ; Definition at line 120 of file TGeoManager.h. ◆ fgVerboseLevel. Int_t TGeoManager::fgVerboseLevel = 1. staticprotected . Lock preventing a second geometry to be loaded. ; Definition at line 51 of file TGeoManager.h. ◆ fGVolumes. TObjArray* TGeoManager::fGVolumes. private . list of runtime shapes ; Definition at line 98 of file TGeoManager.h. ◆ fHashGVolumes. THashList* TGeoManager::fHashGVolumes. private . hash list of volumes providing fast search ; Definition at line 137 of file TGeoManager.h. ◆ fHashPNE. THashList* TGeoManager::fHashPNE. private . hash list of group volumes providing fast search ; Definition at line 138 of file TGeoManager.h. ◆ fHashVolumes. THashList* TGeoManager::fHashVolumes. private . Definition at line 136 of file TGeoManager.h. ◆ fIsGeomCleaning. Bool_t TGeoManager::fIsGeomCleaning. private . flag set when reading geometry ; Definition at line 83 of file TGeoManager.h. ◆ fIsGeomReading. Bool_t TGeoManager::fIsGeomReading. private . Definition at line 82 of file TGeoManager.h. ◆ fIsNodeSelectable. Bool_t TGeoManager::fIsNodeSelectable. private . switch ON/OFF volume activity (default OFF - all volumes active)) ; Definition at line 90 of file TGeoManager.h. ◆ fKeyPNEId. Int_t* TGeoManager::fKeyPNEId. private . Definition at line 142 of file TGeoManager.h. ◆ fLoopVolumes. Bool_t TGeoManager::fLoopVolumes. private . flag that geometry is closed ; Definition at line 80 of file TGeoManager.h. ◆ fMasterVolume. TGeoVolume* TGeoManager::fMasterVolume. private . top physical node ; Definition at line 127 of file TGeoManager.h. ◆ fMaterials. TList* TGeoManager::f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:148852,hash,hash,148852,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['hash'],['hash']
Security," file THtml.h. ◆ GetName(). const char * THtml::TFileSysEntry::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 115 of file THtml.h. ◆ GetParent(). TFileSysDir * THtml::TFileSysEntry::GetParent ; (; ); const. inline . Definition at line 127 of file THtml.h. ◆ Hash(). ULong_t THtml::TFileSysEntry::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; THtml::TFileSysEntry::HashULong_t Hash() const overrideReturn hash value for this object.Definition THtml.h:116; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 116 of file THtml.h. ◆ IsA(). TClass * THtml::TFileSysEntry::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml_1_1TFileSysEntry.html:12584,Hash,Hash,12584,doc/master/classTHtml_1_1TFileSysEntry.html,https://root.cern,https://root.cern/doc/master/classTHtml_1_1TFileSysEntry.html,1,['Hash'],['Hash']
Security," file TWebCanvas.h. ◆ fAllPads. std::vector<TPad *> TWebCanvas::fAllPads. protected . ! list of all pads recognized during streaming ; Definition at line 93 of file TWebCanvas.h. ◆ fAsyncMode. Bool_t TWebCanvas::fAsyncMode {kFALSE}. protected . ! when true, methods like TCanvas::Update will never block ; Definition at line 102 of file TWebCanvas.h. ◆ fCanCreateObjects. Bool_t TWebCanvas::fCanCreateObjects {kTRUE}. protected . ! indicates if canvas allowed to create extra objects for interactive painting ; Definition at line 99 of file TWebCanvas.h. ◆ fCanvVersion. Long64_t TWebCanvas::fCanvVersion {1}. protected . ! actual canvas version, changed with every new Modified() call ; Definition at line 91 of file TWebCanvas.h. ◆ fClientBits. UInt_t TWebCanvas::fClientBits {0}. protected . ! latest status bits from client like editor visible or not ; Definition at line 92 of file TWebCanvas.h. ◆ fColorsHash. UInt_t TWebCanvas::fColorsHash {0}. protected . ! last hash of colors/palette ; Definition at line 106 of file TWebCanvas.h. ◆ fColorsVersion. Long64_t TWebCanvas::fColorsVersion {0}. protected . ! current colors/palette version, checked every time when new snapshot created ; Definition at line 105 of file TWebCanvas.h. ◆ fFixedSize. Bool_t TWebCanvas::fFixedSize {kFALSE}. protected . ! is canvas size fixed ; Definition at line 109 of file TWebCanvas.h. ◆ fHelpHandles. std::vector<std::unique_ptr<ROOT::RWebDisplayHandle> > TWebCanvas::fHelpHandles. protected . ! array of handles for help widgets ; Definition at line 117 of file TWebCanvas.h. ◆ fJsonComp. Int_t TWebCanvas::fJsonComp {0}. protected . ! compression factor for messages send to the client ; Definition at line 98 of file TWebCanvas.h. ◆ fLongerPolling. Bool_t TWebCanvas::fLongerPolling {kFALSE}. protected . ! when true, make longer polling in blocking operations ; Definition at line 100 of file TWebCanvas.h. ◆ fObjSelectSignal. ObjectSelectSignal_t TWebCanvas::fObjSelectSignal. protected . ! signal emitted w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:41170,hash,hash,41170,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['hash'],['hash']
Security," file TXMLFile.h. ◆ IsOpen(). Bool_t TXMLFile::IsOpen ; (; ); const. finalvirtual . return kTRUE if file is opened and can be accessed ; Reimplemented from TFile.; Definition at line 363 of file TXMLFile.cxx. ◆ MakeFree(). void TXMLFile::MakeFree ; (; Long64_t ; first, . Long64_t ; last . ). inlinefinalvirtual . Mark unused bytes on the file. ; The list of free segments is in the fFree linked list. When an object is deleted from the file, the freed space is added into the FREE linked list (fFree). The FREE list consists of a chain of consecutive free segments on the file. At the same time, the first 4 bytes of the freed record on the file are overwritten by GAPSIZE where GAPSIZE = -(Number of bytes occupied by the record). ; Reimplemented from TFile.; Definition at line 77 of file TXMLFile.h. ◆ MakeProject(). void TXMLFile::MakeProject ; (; const char * ; dirname, . const char * ; classes = ""*"", . Option_t * ; option = ""new"" . ). inlinefinalvirtual . Generate source code necessary to access the objects stored in the file. ; Generate code in directory dirname for all classes specified in argument classes If classes = ""*"" (default and currently the only supported value), the function generates an include file for each class in the StreamerInfo list for which a TClass object does not exist.; The code generated includes:; dirnameProjectHeaders.h, which contains one #include statement per generated header file; dirnameProjectSource.cxx,which contains all the constructors and destructors implementation. and one header per class that is not nested inside another class. The header file name is the fully qualified name of the class after all the special characters ""<>,:"" are replaced by underscored. For example for std::pair<edm::Vertex,int> the file name is pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class are replaced by a vector of pair. set and multiset when the tempalte parameter is a class are replaced by a vec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:57400,access,access,57400,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['access'],['access']
Security," file in bytes; md5:<md5_ascii> MD5 sum of the file in ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'first' and 'last'; define the entry range. obj:<name>,<class>,<entries>; meta-information about a generic object in the file;; the should be in the form <subdir>/obj-name; 'class'; is the object class; 'entries' is the number of occurences; for this object.; Multiple occurences of 'tree:' or 'obj:' can be specified.; The initializations done via the input string are superseeded by the ones by other; parameters in the constructor, if any.; If no key is given, the token is interpreted as URL(s). void SetUUID(const char* uuid); Set the UUID to the value associated to the string 'uuid'. This is; useful to set the UUID to the one of the ROOT file during verification.; NB: we do not change the name in here, because this would screw up lists; of these objects hashed on the name. Those lists need to be rebuild.; TFileCollection does that in RemoveDuplicates. TUrl * GetCurrentUrl() const; Return the current url. TUrl * NextUrl(); Iterator function, start iteration by calling ResetUrl().; The first call to NextUrl() will return the 1st element,; the seconde the 2nd element etc. Returns 0 in case no more urls. TUrl * FindByUrl(const char* url, Bool_t withDeflt = kFALSE); Find an element from a URL. Returns 0 if not found. Bool_t AddUrl(const char* url, Bool_t infront = kFALSE); Add a new URL. If 'infront' is TRUE the new url is pushed at the beginning; of the list; otherwise is pushed back.; Returns kTRUE if successful, kFALSE otherwise. Bool_t RemoveUrl(const char* url); Remove an URL. Returns kTRUE if successful, kFALSE otherwise. Bool_t SetCurrentUrl(const char* url); Set 'url' as current URL, if in the list; Return kFALSE if not in the list. Bool_t SetCurrentUrl(TUrl* url); Set 'url' as current URL, if i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileInfo.html:8052,hash,hashed,8052,root/html528/TFileInfo.html,https://root.cern,https://root.cern/root/html528/TFileInfo.html,3,['hash'],['hashed']
Security," file specified in the URL does not exist or is not accessible the kZombie bit will be set in the TWebFile object. Use IsZombie() to see if the file is accessible. The preferred interface to this constructor is via TFile::Open(). ; Definition at line 146 of file TWebFile.cxx. ◆ TWebFile() [3/3]. TWebFile::TWebFile ; (; TUrl ; url, . Option_t * ; opt = """" . ). Create a Web file object. ; A web file is the same as a read-only TFile except that it is being read via a HTTP server. Make sure url is a valid TUrl object. The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell variable. The proxy can be specified as (in sh, or equivalent csh): export http_proxy=http://pcsalo.cern.ch:3128 The proxy can also be specified via the static method TWebFile::SetProxy(). Basic authentication (AuthType Basic) is supported. The user name and passwd can be specified in the url like this: http://username:mypasswd@pcsalo.cern.ch/files/aap.root If the file specified in the URL does not exist or is not accessible the kZombie bit will be set in the TWebFile object. Use IsZombie() to see if the file is accessible. ; Definition at line 181 of file TWebFile.cxx. ◆ ~TWebFile(). TWebFile::~TWebFile ; (; ). virtual . Cleanup. ; Definition at line 199 of file TWebFile.cxx. Member Function Documentation. ◆ BasicAuthentication(). TString TWebFile::BasicAuthentication ; (; ). protectedvirtual . Return basic authentication scheme, to be added to the request. ; Definition at line 1385 of file TWebFile.cxx. ◆ CheckProxy(). void TWebFile::CheckProxy ; (; ). protectedvirtual . Check if shell var ""http_proxy"" has been set and should be used. ; Definition at line 353 of file TWebFile.cxx. ◆ Class(). static TClass * TWebFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TWebFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TWebFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:45388,access,accessible,45388,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['access'],['accessible']
Security," file using this cache and reset the current blocks (if any). ;  ; virtual void SetSkipZip (Bool_t=kTRUE);  ; virtual void Sort ();  Sort buffers to be prefetched in increasing order of positions. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void WaitFinishPrefetch ();  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:4329,Hash,Hash,4329,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,2,['Hash'],['Hash']
Security," first object. 16.4 A Collectable Class; By default, all objects of TObject derived classes can be stored in ROOT containers. However, the TObject class provides some member functions that allow you to tune the behavior of objects in containers. For example, by default two objects are considered equal if their pointers point to the same address. This might be too strict for some classes where equality is already achieved if some or all of the data members are equal. By overriding the following TObject member functions, you can change the behavior of objects in collections:. IsEqual()is used by the FindObject()collection method. By default, IsEqual() compares the two object pointers.; Compare()returns -1, 0 or 1 depending if the object is smaller, equal or larger than the other object. By default, a TObject has not a valid Compare() method.; IsSortable()returns true if the class is sort able (i.e. if it has a valid Compare() method). By default, a TObject is not sort able.; Hash()returns a hash value. It needs to be implemented if an object has to be stored in a collection using a hashing technique, like THashTable, THashList and TMap. By default, Hash() returns the address of the object. It is essential to choose a good hash function. The example below shows how to use and override these member functions.; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; 16.5 The TIter Generic Iterator; As stated above, the TIt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:847767,Hash,Hash,847767,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," float number with negative exponent; [ROOT-8331] - Error in the member function Multiply(const Double_t *vin, Double_t* vout, Double_t w) in TEveTrans of Eve package; [ROOT-8489] - Toy generation using RooCBShape with conditional PDF; [ROOT-8497] - Wrong likelihood is computed for RooProdPdf containing a RooFFTConvPdf; [ROOT-8535] - Non unique UUID; [ROOT-8885] - Cannot create a branch of long, unsigned long, std::size_t types; [ROOT-9062] - $HOME is not automatically extended in TCling; [ROOT-9240] - Compiled program with libNew.so crash; [ROOT-9324] - [cling] segfault when calling cout both from jitted and compiled code; [ROOT-9483] - TMVAGui::mvaeffs crashes when compiled stand-alone; [ROOT-9497] - TCling::Calc() must not abort; [ROOT-9563] - [TreeProcMT] Trees in subdirectories are not supported (and their usage lead to a crash); [ROOT-9583] - TF1::Random; [ROOT-9674] - [DF] Wrong branch type inference in some cases; [ROOT-9731] - [DF] Cannot read columns holding TVector3 pointers; [ROOT-9975] - [DF] Cannot access certain sub-branches; [ROOT-9977] - [DF] SaveGraph produces an empty graph; [ROOT-10023] - [TTreeReader] Unable to read TBranchObject; [ROOT-10152] - [DF] Cannot analyze friend trees in subdirectories with MT; [ROOT-10215] - RDataFrame can’t Snapshot an std::array; [ROOT-10464] - TBB Deprecation Warning; [ROOT-10468] - Crash when users rootlogon contains std::cout in embedded python; [ROOT-10499] - TROOT::ProcessLine(""cout ..."") crashes when called from compiled code; [ROOT-10623] - Functions TF2::Moment2, TF2::CentralMoment2, and similar for TF3 work only for Formula based object; [ROOT-10639] - [DF] Handle errors in opening Snapshot output files; [ROOT-10663] - ROOT dictionary for ATLAS persistent class can’t load correctly; [ROOT-10692] - CMake should use system default C++ standard; [ROOT-10702] - [TTree] Wrong data could be silently written if data-member of object has same name as another branch; [ROOT-10703] - TCling fails to catch compiled exc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:32918,access,access,32918,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['access'],['access']
Security," following requests can be performed:. root.bin - binary data produced by object streaming with TBufferFile; root.json - ROOT JSON representation for object and objects members; root.xml - ROOT XML representation; root.png - PNG image (if object drawing implemented); root.gif - GIF image; root.jpeg - JPEG image; exe.json - method execution in the object; exe.bin - method execution, return result in binary form; cmd.json - command execution; item.json - item (object) properties, specified on the server; multi.json - perform several requests at once; multi.bin - perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.7.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: “title”.; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all).; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH1 object shown in the table:. Request; Size. root.bin; 1658 bytes. root.bin.gz; 782 bytes. root.json; 7555 bytes. root.json?compact=3; 5381 bytes. root.json.gz?com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:10940,password,password,10940,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['password'],['password']
Security," for ""dataMemberName"" defined in ""scopeName"".; 818/// It returns a TString with the URL used in the online reference guide,; 819/// generated with Doxygen. For data members the URL consist of 2 parts -; 820/// URL for ""scopeName"" and a part for ""dataMemberName"".; 821/// For enumerator, the URL could be separated into 3 parts - URL for; 822/// ""scopeName"", part for the enumeration and a part for the enumerator.; 823///; 824/// \param[in] scopeName the name of the class/namespace/struct; 825/// \param[in] dataMemberName the name of the data member/enumerator; 826/// \param[in] dataMember pointer to the data member/enumerator; 827/// \param[in] scopeType enumerator to the scope type; 828 ; 829static TString; 830GetUrlForDataMember(const TString &scopeName, const TString &dataMemberName, TDataMember *dataMember, EUrl scopeType); 831{; 832 // We first check if the data member is not enumerator.; 833 if (!dataMember->IsEnum()) {; 834 // If we work with data members, we have to append a hashed with MD5 text, consisting of:; 835 // ""Type ClassName::DataMemberNameDataMemberName(arguments)"".; 836 // We first get the type of the data member.; 837 TString md5DataMember(dataMember->GetFullTypeName());; 838 md5DataMember.Append("" "");; 839 // We append the scopeName and ""::"".; 840 md5DataMember.Append(scopeName);; 841 md5DataMember.Append(""::"");; 842 // We append the dataMemberName twice.; 843 md5DataMember.Append(dataMemberName);; 844 md5DataMember.Append(dataMemberName);; 845 // We call UrlGenerator for the scopeName.; 846 TString urlForDataMember = UrlGenerator(scopeName, scopeType);; 847 // Then we append ""#a"" and the hashed text.; 848 urlForDataMember.Append(""#a"");; 849 urlForDataMember.Append(md5DataMember.MD5());; 850 return urlForDataMember;; 851 }; 852 // If the data member is enumerator, then we first have to check if the enumeration is anonymous.; 853 // Doxygen requires different syntax for anonymous enumeration (""scopeName::@1@1"").; 854 // We create a TString with the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:30746,hash,hashed,30746,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['hash'],['hashed']
Security," for RNTupleReader::PrintInfo() and RPrintSchemaVisitor::VisitField() More...;  ; class  RNTupleGlobalRange;  Used to loop over indexes (entries or collections) between start and end. More...;  ; class  RNTupleImporter;  Converts a TTree into an RNTuple. More...;  ; class  RNTupleInspector;  Inspect on-disk and storage-related information of an RNTuple. More...;  ; struct  RNTupleLocator;  Generic information about the physical location of data. More...;  ; struct  RNTupleLocatorObject64;  RNTupleLocator payload that is common for object stores using 64bit location information. More...;  ; class  RNTupleModel;  The RNTupleModel encapulates the schema of an ntuple. More...;  ; class  RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  RNTupleView;  An RNTupleView provides read-only access to a single field of the ntuple. More...;  ; class  RNTupleView< void, UserProvidedAddress >;  ; class  RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  RNullableField;  The field for values that may or may not be present in an entry. More...;  ; class  ROnFrameDrawable;  Base class for drawable which can be drawn on frame or on pad. More...;  ; class  RPad;  Graphic container for RDrawable-s. More...;  ; class  RPadBase;  Base class for graphic containers for RDrawable-s. More...;  ; class  RPadBaseDisplayItem;  class RPadBaseDisplayItem More...;  ; class  RPadDisplayItem;  class RPadDisplayItem More...;  ; class  RPadExtent;  An extent / size (horizontal and vertical) in a RPad. More...;  ; class  RPadLength;  A leng",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:18920,access,access,18920,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['access'],['access']
Security," for additional arguments; 5494 */; 5495 interp_arg =; 5496 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5497 } else {; 5498 /* Otherwise, the interpreter must be stated in the first line of the; 5499 * CGI script file, after a #! (shebang) mark. */; 5500 buf[0] = buf[1] = '\0';; 5501 ; 5502 /* Get the full script path */; 5503 mg_snprintf(; 5504 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5505 ; 5506 if (truncated) {; 5507 pi.hProcess = (pid_t)-1;; 5508 goto spawn_cleanup;; 5509 }; 5510 ; 5511 /* Open the script file, to read the first line */; 5512 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5513 ; 5514 /* Read the first line of the script into the buffer */; 5515 mg_fgets(buf, sizeof(buf), &file);; 5516 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5517 buf[sizeof(buf) - 1] = '\0';; 5518 }; 5519 ; 5520 if ((buf[0] == '#') && (buf[1] == '!')) {; 5521 trim_trailing_whitespaces(buf + 2);; 5522 } else {; 5523 buf[2] = '\0';; 5524 }; 5525 interp = buf + 2;; 5526 }; 5527 ; 5528 GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);; 5529 ; 5530 if (interp[0] != '\0') {; 5531 /* This is an interpreted script file. We must call the interpreter. */; 5532 if ((interp_arg != 0) && (interp_arg[0] != 0)) {; 5533 mg_snprintf(conn,; 5534 &truncated,; 5535 cmdline,; 5536 sizeof(cmdline),; 5537 ""\""%s\"" %s \""%s\\%s\"""",; 5538 interp,; 5539 interp_arg,; 5540 full_dir,; 5541 prog);; 5542 } else {; 5543 mg_snprintf(conn,; 5544 &truncated,; 5545 cmdline,; 5546 sizeof(cmdline),; 5547 ""\""%s\"" \""%s\\%s\"""",; 5548 interp,; 5549 full_dir,; 5550 prog);; 5551 }; 5552 } else {; 5553 /* This is (probably) a compiled program. We call it directly. */; 5554 mg_snprintf(conn,; 5555 &truncated,; 5556 cmdline,; 5557 sizeof(cmdline),; 5558 ""\""%s\\%s\"""",; 5559 full_dir,; 5560 prog);; 5561 }; 5562 ; 5563 if (truncated) {; 5564 pi.hProcess = (pid_t)-1;; 5565 goto spawn_cleanup;; 5566 }; 5567 ; 5568 DEBUG_TRACE(""Running [%s]"", ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:162987,access,access,162987,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security," for additional arguments; 5495 */; 5496 interp_arg =; 5497 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5498 } else {; 5499 /* Otherwise, the interpreter must be stated in the first line of the; 5500 * CGI script file, after a #! (shebang) mark. */; 5501 buf[0] = buf[1] = '\0';; 5502 ; 5503 /* Get the full script path */; 5504 mg_snprintf(; 5505 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5506 ; 5507 if (truncated) {; 5508 pi.hProcess = (pid_t)-1;; 5509 goto spawn_cleanup;; 5510 }; 5511 ; 5512 /* Open the script file, to read the first line */; 5513 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5514 ; 5515 /* Read the first line of the script into the buffer */; 5516 mg_fgets(buf, sizeof(buf), &file);; 5517 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5518 buf[sizeof(buf) - 1] = '\0';; 5519 }; 5520 ; 5521 if ((buf[0] == '#') && (buf[1] == '!')) {; 5522 trim_trailing_whitespaces(buf + 2);; 5523 } else {; 5524 buf[2] = '\0';; 5525 }; 5526 interp = buf + 2;; 5527 }; 5528 ; 5529 GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);; 5530 ; 5531 if (interp[0] != '\0') {; 5532 /* This is an interpreted script file. We must call the interpreter. */; 5533 if ((interp_arg != 0) && (interp_arg[0] != 0)) {; 5534 mg_snprintf(conn,; 5535 &truncated,; 5536 cmdline,; 5537 sizeof(cmdline),; 5538 ""\""%s\"" %s \""%s\\%s\"""",; 5539 interp,; 5540 interp_arg,; 5541 full_dir,; 5542 prog);; 5543 } else {; 5544 mg_snprintf(conn,; 5545 &truncated,; 5546 cmdline,; 5547 sizeof(cmdline),; 5548 ""\""%s\"" \""%s\\%s\"""",; 5549 interp,; 5550 full_dir,; 5551 prog);; 5552 }; 5553 } else {; 5554 /* This is (probably) a compiled program. We call it directly. */; 5555 mg_snprintf(conn,; 5556 &truncated,; 5557 cmdline,; 5558 sizeof(cmdline),; 5559 ""\""%s\\%s\"""",; 5560 full_dir,; 5561 prog);; 5562 }; 5563 ; 5564 if (truncated) {; 5565 pi.hProcess = (pid_t)-1;; 5566 goto spawn_cleanup;; 5567 }; 5568 ; 5569 DEBUG_TRACE(""Running [%s]"", ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:163019,access,access,163019,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security," for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooDataHist::ErrorType_etypeError type store in associated RooDataHist; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooChi2Var::FuncMode_funcModeFunction, P.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:39960,access,access,39960,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,2,['access'],['access']
Security," for directives. Bool_t CheckProofAuth(Int_t cSec, TString& det); Check if the authentication method can be attempted for the client. void MergeHostAuthList(TList* Std, TList* New, Option_t* Opt = """"); Tool for updating fgAuthInfo or fgProofAuthInfo; 'nin' contains list of last input information through (re)reading; of a rootauthrc-alike file. 'nin' info has priority.; 'std' is cleaned from inactive members.; 'nin' members used to update existing members in 'std' are; removed from 'nin', do that they do not leak; opt = ""P"" for proofauthinfo. void RemoveSecContext(TRootSecContext* ctx); Tool for removing SecContext ctx from THostAuth listed in; fgAuthInfo or fgProofAuthInfo. Int_t ProofAuthSetup(); Authentication related stuff setup in TProofServ.; This is the place where the buffer send by the client / master is; decoded. It contains also password information, if the case requires.; Return 0 on success, -1 on failure. Int_t ProofAuthSetup(TSocket* sock, Bool_t client); Setup of authetication related stuff in PROOF run after a; successful authentication.; Return 0 on success, -1 on failure. Int_t GetClientProtocol(); Static method returning supported client protocol. Bool_t GetPwHash() const; { return fPwHash; }. Int_t GetRSAKey() const; { return fRSAKey; }. ESecurity GetSecurity() const; { return fSecurity; }. Bool_t GetSRPPwd() const; { return fSRPPwd; }. Int_t GetVersion() const; { return fVersion; }. TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """"); { }. THostAuth * GetHostAuth() const; { return fHostAuth; }. const char * GetProtocol() const; { return fProtocol; }. const char * GetRemoteHost() const; { return fRemote; }. Int_t GetRSAKeyType() const; { return fRSAKey; }. TRootSecContext * GetSecContext() const; { return fSecContext; }. TSocket * GetSocket() const; { return fSocket; }. const char * GetUser() const; { return fUser; }. Int_t HasTimedOut() const; { return fTimeOut; }. void SetRSAKeyType(Int_t key); { fRSAKey =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:22178,authenticat,authentication,22178,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security," for given set of input variablesDefinition Reader.cxx:630; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; AuthorAndreas Hoecker ; Definition in file TMVAMulticlassApplication.C. tutorialstmvaTMVAMulticlassApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlassApplication_8C.html:12068,Access,AccessPathNamevirtual,12068,doc/master/TMVAMulticlassApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlassApplication_8C.html,4,"['Access', 'access']","['AccessPathName', 'AccessPathNamevirtual', 'access']"
Security," for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; ///<! list of local directories, which could be accessed via server; 49 ; 50 std::string fDefaultPage; ///<! file name for default page name; 51 std::string fDefaultPageCont; ///<! content of default html page; 52 std::string fDrawPage; ///<! file name for drawing of single element; 53 std::string fDrawPageCont; ///<! content of draw html page; 54 std::string fCors; ///<! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responses; 55 std::string fCorsCredentials; ///<! CORS: add Access-Control-Allow-Credentials: true response header; 56 ; 57 std::mutex fMutex; ///<! mutex to protect list with arguments; 58 std::queue<std::shared_ptr<THttpCallArg>> fArgs; ///<! submitted arguments; 59 ; 60 std::mutex fWSMutex; ///<! mutex to protect WS handler lists; 61 std::vector<std::shared_ptr<THttpWSHandler>> fWSHandlers; ///<! list of WS handlers; 62 ; 63 virtual void MissedRequest(THttpCallArg *arg);; 64 ; 65 virtual void ProcessRequest(std::shared_ptr<THttpCallArg> arg);; 66 ; 67 virtual void ProcessBatchHolder(std::shared_ptr<THttpCallArg> &arg);; 68 ; 69 void StopServerThread();; 70 ; 71 std::string BuildWSEntryPage();; 72 ; 73 void ReplaceJSROOTLinks(std::shared_ptr<THttpCallArg> &arg, const std::string &version = """");; 74 ; 75 static Bool_t VerifyFilePath(const char *fname);; 76 ; 77 THttpServer(const THttpServer &) = delete;; 78 THttpServer &operator=(const THttpServ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8h_source.html:2385,Access,Access-Control-Allow-Origin,2385,doc/master/THttpServer_8h_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html,1,['Access'],['Access-Control-Allow-Origin']
Security," for this host. ;  ; const char * GetDetailsByIdx (Int_t idx) const;  ; Int_t GetFailure (Int_t idx) const;  ; const char * GetHost () const;  ; Int_t GetMethod (Int_t idx) const;  ; Int_t GetServer () const;  ; Int_t GetSuccess (Int_t idx) const;  ; const char * GetUser () const;  ; Bool_t HasMethod (Int_t level, Int_t *pos=nullptr);  Return kTRUE if method 'level' is in the list. ;  ; TClass * IsA () const override;  ; Bool_t IsActive () const;  ; Int_t NumMethods () const;  ; void Print (Option_t *option="""") const override;  Print object content. ;  ; void PrintEstablished () const;  Print info about established authentication vis-a-vis of this Host. ;  ; void RemoveMethod (Int_t level);  Remove method 'meth' from the list, if there ... ;  ; void ReOrder (Int_t nmet, Int_t *fmet);  Reorder nmet methods according fmet[nmet]. ;  ; void Reset ();  Remove all methods, leaving Active status and list of associted TSceContexts unchanged. ;  ; void SetDetails (Int_t level, const char *details);  Set authentication details for specified level. ;  ; void SetEstablished (TList *nl);  ; void SetFirst (Int_t level);  Set 'method' to be the first used (if in the list ...). ;  ; void SetHost (const char *host);  ; void SetLast (Int_t level);  Set 'method' to be the last used (if in the list ...). ;  ; void SetServer (Int_t server);  ; void SetUser (const char *user);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Update (THostAuth *ha);  Update info with the one in ha Remaining methods, if any, get lower priority. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void Append",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHostAuth.html:3255,authenticat,authentication,3255,doc/master/classTHostAuth.html,https://root.cern,https://root.cern/doc/master/classTHostAuth.html,1,['authenticat'],['authentication']
Security," for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNode.html:10263,Hash,Hash,10263,doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNode.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNode.html,2,['Hash'],['Hash']
Security," from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.4 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigetst” file. When starting the server, the following arguments should be specified:; root [0] new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; root [6] serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; root [7] serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; root [8] serv->Restrict(""/Folder/histo1"", ""allow=all"");; root [9] serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; root [10] serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:4712,password,password,4712,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,3,"['access', 'authoriz', 'password']","['access', 'authorized', 'password']"
Security," from /dev/urandom (or current time if /dev/urandom not available). ; Definition at line 2473 of file TAuthenticate.cxx. ◆ IsA(). TClass * TAuthenticate::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 207 of file TAuthenticate.h. ◆ MergeHostAuthList(). void TAuthenticate::MergeHostAuthList ; (; TList * ; std, . TList * ; nin, . Option_t * ; opt = """" . ). static . Tool for updating fgAuthInfo or fgProofAuthInfo 'nin' contains list of last input information through (re)reading of a rootauthrc-alike file. ; 'nin' info has priority. 'std' is cleaned from inactive members. 'nin' members used to update existing members in 'std' are removed from 'nin', do that they do not leak opt = ""P"" for proofauthinfo. ; Definition at line 3611 of file TAuthenticate.cxx. ◆ PromptPasswd(). char * TAuthenticate::PromptPasswd ; (; const char * ; prompt = ""Password: ""). static . Static method to prompt for the user's passwd to be used for authentication to rootd or proofd. ; Uses non-echoing command line to get passwd. Returns passwd (which must de deleted by caller) or 0. If non-interactive run (eg ProofServ) returns -1 ; Definition at line 1142 of file TAuthenticate.cxx. ◆ PromptUser(). char * TAuthenticate::PromptUser ; (; const char * ; remote). static . Static method to prompt for the user name to be used for authentication to rootd or proofd. ; User is asked to type user name. Returns user name (which must be deleted by caller) or 0. If non-interactive run (eg ProofServ) returns default user. ; Definition at line 1102 of file TAuthenticate.cxx. ◆ ProofAuthSetup() [1/2]. Int_t TAuthenticate::ProofAuthSetup ; (; ). private . Authentication related stuff setup in TProofServ. ; This is the place where the buffer send by the client / master is decoded. It contains also password information, if the case requires. Return 0 on success, -1 on failure. ; Definition at line 3699 of file TAuthenticate.cxx. ◆ Pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:34041,authenticat,authentication,34041,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security," from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal inspection tools (such as e.g. ‘dir()’). This feature prevents the inspection tools from being swamped by an enormous amount of classes, but they can no longer be used to explore unknown parts of the system (e.g. to find out which classes are available). Furthermore, because of this approach, <tab>-completion will usually not be available until after the first use (and hence creation) of a class.; Access to class static functions, public data members, enums, etc. is as expected. Many more example uses of ROOT classes from Python can be found in the tutorials directory in the ROOT distribution. The recipes section contains a description on working with your own classes (see “Using Your Own Classes”).; 19.1.5.2 Access to STL Classes; The STL classes live in the ROOT.std namespace (or, if you prefer to get them from there, in the ROOT module directly, but doing so makes the code less clear, of course). Be careful in their use, because Python already has types called “string” and “list.”; In order to understand how to get access to a templated class, think of the general template as a meta class. By instantiating the meta class with the proper parameters, you get an actual class, which can then be used to create object instances. An example usage:; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1052014,Access,Access,1052014,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Access'],['Access']
Security," from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t[16] seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t[16] uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }. » Author: Fons Rademakers 30/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUUID.html:6438,Hash,Hash,6438,root/html604/TUUID.html,https://root.cern,https://root.cern/root/html604/TUUID.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t[16] seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t[16] uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }. » Author: Fons Rademakers 30/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUUID.html:6438,Hash,Hash,6438,root/html602/TUUID.html,https://root.cern,https://root.cern/root/html602/TUUID.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," from the columns px and py. The system builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches from the names of the variables specified by the user.; Custom columns as function of slot and entry number; It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can be invoked are:; DefineSlot(name, f, columnList). In this case the callable f has this signature R(unsigned int, T1, T2, ...): the first parameter is the slot number which ranges from 0 to ROOT::GetThreadPoolSize() - 1.; DefineSlotEntry(name, f, columnList). In this case the callable f has this signature R(unsigned int, ULong64_t,; T1, T2, ...): the first parameter is the slot number while the second one the number of the entry being processed. Actions: getting results. Instant and lazy actions; Actions can be instant or lazy. Instant actions are executed as soon as they are called, while lazy actions are executed whenever the object they return is accessed for the first time. As a rule of thumb, actions with a return value are lazy, the others are instant. Return type of a lazy action; When a lazy action is called, it returns a ROOT::RDF::RResultPtr<T>, where T is the type of the result of the action. The final result will be stored in the RResultPtr and can be retrieved by dereferencing it or via its GetValue method. Actions that return collections; If the type of the return value of an action is a collection, e.g. std::vector<int>, you can iterate its elements directly through the wrapping RResultPtr:; ROOT::RDataFrame df{5};; auto df1 = df.Define(""x"", []{ return 42; });; for (const auto &el: df1.Take<int>(""x"")){; std::cout << ""Element: "" << el << ""\n"";; }; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::TakeRResultPtr< COLL > Take(std::string_view column="""")Return a collection of values of a column (lazy action, returns a std::vector by default).Definition RInterface.hxx:1592;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:32769,access,accessed,32769,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['access'],['accessed']
Security," from the columns px and py. The system builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches from the names of the variables specified by the user.; Custom columns as function of slot and entry number; It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can be invoked are:; DefineSlot(name, f, columnList). In this case the callable f has this signature R(unsigned int, T1, T2, ...): the first parameter is the slot number which ranges from 0 to ROOT::GetThreadPoolSize() - 1.; DefineSlotEntry(name, f, columnList). In this case the callable f has this signature R(unsigned int, ULong64_t,; T1, T2, ...): the first parameter is the slot number while the second one the number of the entry being processed. Actions: getting results. Instant and lazy actions; Actions can be instant or lazy. Instant actions are executed as soon as they are called, while lazy actions are executed whenever the object they return is accessed for the first time. As a rule of thumb, actions with a return value are lazy, the others are instant. Return type of a lazy action; When a lazy action is called, it returns a ROOT::RDF::RResultPtr<T>, where T is the type of the result of the action. The final result will be stored in the RResultPtr and can be retrieved by dereferencing it or via its GetValue method. Actions that return collections; If the type of the return value of an action is a collection, e.g. std::vector<int>, you can iterate its elements directly through the wrapping RResultPtr:; ROOT::RDataFrame df{5};; auto df1 = df.Define(""x"", []{ return 42; });; for (const auto &el: df1.Take<int>(""x"")){; std::cout << ""Element: "" << el << ""\n"";; }; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::TakeRResultPtr< COLL > Take(std::string_view column="""")Return a collection of values of a column (lazy action, returns a std::vector by default).Definition RInterface.hxx:1761;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:34191,access,accessed,34191,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['access'],['accessed']
Security," from the tree. ; Its position (up to a maximal tree depth of 64) is coded as a sequence of left-right moves starting from the root, coded as 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right ; Definition at line 1231 of file DecisionTree.cxx. ◆ GetNodePurityLimit(). Double_t TMVA::DecisionTree::GetNodePurityLimit ; (; ); const. inline . Definition at line 162 of file DecisionTree.h. ◆ GetPruneStrength(). Double_t TMVA::DecisionTree::GetPruneStrength ; (; ); const. inline . Definition at line 147 of file DecisionTree.h. ◆ GetRandomisedVariables(). void TMVA::DecisionTree::GetRandomisedVariables ; (; Bool_t * ; useVariable, . UInt_t * ; variableMap, . UInt_t & ; nVars . ). Definition at line 1247 of file DecisionTree.cxx. ◆ GetRoot(). virtual DecisionTreeNode * TMVA::DecisionTree::GetRoot ; (; ); const. inlinevirtual . Reimplemented from TMVA::BinaryTree.; Definition at line 94 of file DecisionTree.h. ◆ GetSumWeights(). Double_t TMVA::DecisionTree::GetSumWeights ; (; const EventConstList * ; validationSample); const. calculate the normalization factor for a pruning validation sample ; Definition at line 1118 of file DecisionTree.cxx. ◆ GetTreeID(). Int_t TMVA::DecisionTree::GetTreeID ; (; ). inline . Definition at line 186 of file DecisionTree.h. ◆ GetVariableImportance() [1/2]. vector< Double_t > TMVA::DecisionTree::GetVariableImportance ; (; ). Return the relative variable importance, normalized to all variables together having the importance 1. ; The importance in evaluated as the total separation-gain that this variable had in the decision trees (weighted by the number of events) ; Definition at line 2745 of file DecisionTree.cxx. ◆ GetVariableImportance() [2/2]. Double_t TMVA::DecisionTree::GetVariableImportance ; (; UInt_t ; ivar). returns the relative importance of variable ivar ; Definition at line 2766 of file DecisionTree.cxx. ◆ IsA(). virtual TClass * TMVA::DecisionTree::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:21729,validat,validationSample,21729,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['validat'],['validationSample']
Security," from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooSetProxy_compSetDSet proxy for denominator components; RooSetProxy_compSetNSet proxy for numerator components; RooArgSet*_compSetOwnedDOwner of denominator components; RooArgSet*_compSetOwnedNOwner of numerator components; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenProdProj.html:35458,access,access,35458,root/html602/RooGenProdProj.html,https://root.cern,https://root.cern/root/html602/RooGenProdProj.html,2,['access'],['access']
Security," function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; ROOT::Fit::Fitter*fFitterpointer to the real fitter; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBinomialEfficiencyFitter.html:9804,access,access,9804,root/html602/TBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/root/html602/TBinomialEfficiencyFitter.html,2,['access'],['access']
Security," function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries. Int_t WriteClassBuffer(const TClass* cl, void* pointer); Function called by the Streamer functions to serialize object at p; to buffer b. The optional argument info may be specified to give an; alternative StreamerInfo instead of using the default StreamerInfo; automatically built from the class definition.; For more information, see class TStreamerInfo. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:44488,hash,hashtable,44488,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['hash'],['hashtable']
Security," gVirtualPS->SetName(psname);; 5140 gVirtualPS->Open(psname);; 5141 gVirtualPS->SetBit(kPrintingPS);; 5142 gVirtualPS->NewPage();; 5143 }; 5144 Paint();; 5145 if (noScreen); 5146 GetCanvas()->SetBatch(kFALSE);; 5147 ; 5148 if (!gSystem->AccessPathName(psname)); 5149 Info(""Print"", ""SVG file %s has been created"", psname.Data());; 5150 ; 5151 delete gVirtualPS;; 5152 gVirtualPS = nullptr;; 5153 ; 5154 return;; 5155 }; 5156 ; 5157 //==============Save pad/canvas as a TeX file================================; 5158 if (strstr(opt,""tex"") || strstr(opt,""Standalone"")) {; 5159 gVirtualPS = (TVirtualPS*)gROOT->GetListOfSpecials()->FindObject(psname);; 5160 ; 5161 Bool_t noScreen = kFALSE;; 5162 if (!GetCanvas()->IsBatch() && GetCanvas()->GetCanvasID() == -1) {; 5163 noScreen = kTRUE;; 5164 GetCanvas()->SetBatch(kTRUE);; 5165 }; 5166 ; 5167 TContext ctxt(this, kTRUE);; 5168 ; 5169 if (!gVirtualPS) {; 5170 // Plugin Postscript/SVG driver; 5171 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPS"", ""tex"")) {; 5172 if (h->LoadPlugin() == -1); 5173 return;; 5174 h->ExecPlugin(0);; 5175 }; 5176 }; 5177 ; 5178 Bool_t standalone = kFALSE;; 5179 if (strstr(opt,""Standalone"")) standalone = kTRUE;; 5180 ; 5181 // Create a new TeX file; 5182 if (gVirtualPS) {; 5183 gVirtualPS->SetName(psname);; 5184 if (standalone) gVirtualPS->SetTitle(""Standalone"");; 5185 gVirtualPS->Open(psname);; 5186 gVirtualPS->SetBit(kPrintingPS);; 5187 gVirtualPS->NewPage();; 5188 }; 5189 Paint();; 5190 if (noScreen) GetCanvas()->SetBatch(kFALSE);; 5191 ; 5192 if (!gSystem->AccessPathName(psname)) {; 5193 if (standalone) {; 5194 Info(""Print"", ""Standalone TeX file %s has been created"", psname.Data());; 5195 } else{; 5196 Info(""Print"", ""TeX file %s has been created"", psname.Data());; 5197 }; 5198 }; 5199 ; 5200 delete gVirtualPS;; 5201 gVirtualPS = nullptr;; 5202 ; 5203 return;; 5204 }; 5205 ; 5206 //==============Save pad/canvas as a Postscript file=========================; 5207 ; 5208 // in case we read d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:167243,Access,AccessPathName,167243,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['Access'],['AccessPathName']
Security," gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:36686,access,access,36686,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,5,['access'],['access']
Security," gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionLevel(Int_t level = 1); Set level of compression for this file:; level = 0 objects written to this file will not be compressed.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35960,access,access,35960,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['access'],['access']
Security," general two vector class, which can be used for the description of different vectors in 2D ;  CTVector3TVector3 is a general three vector class, which can be used for the description of different vectors in 3D ;  CTVectorTTVectorT ;  CTVersionCheck;  CTViewSee TView3D ;  CTView3DThe 3D view class ;  CTViewer3DPadProvides 3D viewer interface (TVirtualViewer3D) support on a pad ;  CTViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data members in a class and all its base classes without caching any of the TDictionary pointers ;  CTViewPubDataMembersIterIterator of over the view's content ;  CTViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods in a class and all its base classes without caching any of the TFunction pointers ;  CTViewPubFunctionsIterIterator of over the view's content ;  CTViewTimer;  CTVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary ;  CTVirtualAuth;  CTVirtualBranchBrowsableTVirtualBranchBrowsable is a base class (not really abstract, but useless by itself) for helper objects that extend TBranch's browsing support ;  CTVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators ;  ►CTVirtualCollectionProxy;  CTPushPop;  ►CTVirtualCollectionPtrIterators;  CTInternalIterator;  CTVirtualDragManager;  CTVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms ;  CTVirtualFitterAbstract Base Class for Fitting ;  CTVirtualGeoConverterAbstract class for geometry converters ;  CTVirtualGeoPainterAbstract class for geometry painters ;  CTVirtualGeoTrackBase class for user-defined tracks attached to a geometry ;  CTVirtualGLManip;  CTVirtualGLPainter;  CTVirtualGraphPainterAbstract interface to a histogram painter ;  CTVirtualHistPainterAbstract interface to a histogram painter ;  CTVirtualIndex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:195298,access,access,195298,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,5,['access'],['access']
Security," given names . SplitParam(var, cat) Split given parameter(s) in given category(s) . SplitParamConstrained(vname, cname, remainder) Make constrained split in parameter(s) with given name(s) in category(s) with given names putting remainder fraction formula in state with name ""remainder"" . SplitParamConstrained(var,cat,remainder) Make constrained split in parameter(s) with given name(s) in category(s) with given names putting remainder fraction formula in state with name ""remainder"" . Restrict(catName,stateNameList) Restrict build by only considered listed state names of category with given name. PyROOT; The RooSimWSTool::build() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 173 of file RooSimWSTool.cxx. ◆ executeBuild(). RooSimultaneous * RooSimWSTool::executeBuild ; (; const char * ; simPdfName, . ObjBuildConfig & ; obc, . bool ; verbose = true . ). protected . Internal build driver from validation ObjBuildConfig. ; Definition at line 378 of file RooSimWSTool.cxx. ◆ makeSplitName(). std::string RooSimWSTool::makeSplitName ; (; const RooArgSet & ; splitCatSet). protected . Construct name of composite split. ; Definition at line 612 of file RooSimWSTool.cxx. ◆ validateConfig(). std::unique_ptr< RooSimWSTool::ObjBuildConfig > RooSimWSTool::validateConfig ; (; BuildConfig & ; bc). protected . Validate build configuration. ; If not syntax errors or missing objects are found, return an ObjBuildConfig in which all names are replaced with object pointers. ; Definition at line 206 of file RooSimWSTool.cxx. Member Data Documentation. ◆ _ws. RooWorkspace* RooSimWSTool::_ws. protected . Definition at line 69 of file RooSimWSTool.h. Libraries for RooSimWSTool:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooSimWSTool.h; roofit/roofitcore/src/RooSimWSTool.cxx; /home/sftnight/build/workspace/root-makedoc-master/rootspi/rd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimWSTool.html:8298,validat,validation,8298,doc/master/classRooSimWSTool.html,https://root.cern,https://root.cern/doc/master/classRooSimWSTool.html,1,['validat'],['validation']
Security," h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; The method SetTitle() has the same syntax: h->SetTitle(""Histogram title;Another X title Axis"");; Alternatively, the title of each axis can be set directly: h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");; For bin labels see binning. Binning. Fix or variable bin size; All histogram types support either fix or variable bin sizes. 2-D histograms may have fix size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw or access histograms are identical in both cases.; Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis. To access the axis parameters, use: TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; See class TAxis for a description of all the access functions. The axis range is always stored internally in double precision. Convention for numbering bins; For all histogram types: nbins, xlow, xup bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; In case of 2-D or 3-D histograms, a ""global bin"" number is defined. For example, assuming a 3-D histogram with (binx, biny, binz), the function Int_t gbin = h->GetBin(binx, biny, binz);; int; returns a global/linearized gbin number. This global gbin is useful to access the bin content/error information independently of the dimension. Note that to access the information other than bin content and errors one should use the TAxis object directly with e.g.: Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; double; returns the center along z of bin number 27 (not the global bin) in the 3-D histogram h3. Alphanumeric Bin Labels; By default, a histogram axis is drawn w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:7198,access,access,7198,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['access'],['access']
Security," has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGClient.html:17862,expose,expose,17862,root/html528/TGClient.html,https://root.cern,https://root.cern/root/html528/TGClient.html,6,['expose'],['expose']
Security," hash value. ;  ; TExMap & operator= (const TExMap &);  Assignment operator. ;  ; void Remove (Long64_t key);  ; void Remove (ULong64_t hash, Long64_t key);  Remove entry with specified key from the TExMap. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:2735,Hash,Hash,2735,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,2,['Hash'],['Hash']
Security," have the feeling he has been sitting in the room next door since 1995.; Andrei and Mihaela Gheata (Alice collaboration) are co-authors of the ROOT geometry classes and Virtual Monte-Carlo. They have been working with the ROOT team since 2000.; Olivier Couet, who after a successful development and maintenance of PAW, has joined the ROOT team in 2000 and has been working on the graphics sub-system.; Ilka Antcheva has been working on the Graphical User Interface classes. She is also responsible for this latest edition of the Users Guide with a better style, improved index and several new chapters (since 2002).; Bertrand Bellenot has been developing and maintaining the Win32GDK version of ROOT. Bertrand has also many other contributions like the nice RootShower example (since 2001).; Valeriy Onoutchin has been working on several ROOT packages, in particular the graphics sub-system for Windows and the GUI Builder (since 2000).; Gerri Ganis has been working on the authentication procedures to be used by the root daemons and the PROOF system (since 2002).; Maarten Ballintijn (MIT) is one of the main developers of the PROOF sub-system (since 1995).; Valeri Fine (now at BNL) ported ROOT to Windows and contributed largely to the 3-D graphics. He is currently working on the Qt layer of ROOT (since 1995).; Victor Perevoztchikov (BNL) worked on key elements of the I/O system, in particular the improved support for STL collections (1997-2001).; Nenad Buncic developed the HTML documentation generation system and integrated the X3D viewer inside ROOT (1995-1997).; Suzanne Panacek was the author of the first version of this User’s Guide and very active in preparing tutorials and giving lectures about ROOT (1999-2002).; Axel Naumann has been developing further the HTML Reference Guide and helps in porting ROOT under Windows (cygwin/gcc implementation) (since 2000).; Anna Kreshuk has developed the Linear Fitter and Robust Fitter classes as well as many functions in TMath, TF1, TGraph ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:4037,authenticat,authentication,4037,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['authenticat'],['authentication']
Security," header files. It is better; to use these keywords in user code instead of hardcoded color numbers, e.g.:. myObject.SetFillColor(kRed);; myObject.SetFillColor(kYellow-10);; myLine.SetLineColor(kMagenta+2);. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; return w->GetCanvas();; }; Bright and dark colors; The dark and bright color are used to give 3-D effects when drawing various; boxes (see TWbox, TPave, TPaveText, TPaveLabel, etc). The Dark colors have an index = color_index+100; The Bright colors have an index = color_index+150; Pointers to the dark and bright colors can be retrieved via the TColor static functions:; ; TColor *dark = TColor::GetColorDark(color_index);; TColor *bright = TColor::GetColorBright(color_index);; . Gray scale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using; TCanvas::SetGrayscale(). Note that in grayscale mode, access via RGB; will return grayscale values according to ITU standards (and close to b&w; printer grayscales), while access via HLS returns de-saturated grayscales. The; image below shows the ROOT color wheel in grayscale mode. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; w->GetCanvas()->SetGrayscale();; w->GetCanvas()->Modified();; w->GetCanvas()->Update();; return w->GetCanvas();; }; Color palettes; It is often very useful to represent a variable with a color map. The concept; of ""color palette"" allows to do that. One color palette is active at any time.; This ""current palette"" is set using:. gStyle->SetPalette(...);. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the pallette. The following small; example demonstrates how to define and use the color palette: . Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TColor.html:3207,access,access,3207,root/html526/TColor.html,https://root.cern,https://root.cern/root/html526/TColor.html,2,['access'],['access']
Security," histogram is filled using the Delaunay triangles to interpolate the data set. The 2D histogram has equidistant bins along the X and Y directions. The number of bins along each direction can be change using SetNpx() and SetNpy(). Each bin is filled with the Z value found via a linear interpolation on the plane defined by the triangle above the (X,Y) coordinates of the bin center.; The existing (X,Y,Z) points can be randomly scattered. The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then used to define flat planes in (X,Y,Z) over which the interpolation is done to fill the 2D histogram. The 3D triangles int takes build a 3D surface in the form of tessellating triangles at various angles. The triangles found can be drawn in 3D with one of the TGraph2D specific drawing options.; The histogram generated by the Delaunay interpolation can be accessed using the GetHistogram() method.; The axis settings (title, ranges etc ...) can be changed accessing the axis via the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created at drawing time only. Therefore they should called after the TGraph2D is drawn:; auto g = new TGraph2D();; ; [...]; ; g->Draw(""tri1"");; gPad->Update();; g->GetXaxis()->SetTitle(""X axis title"");; gPad#define gPadDefinition TVirtualPad.h:308. Examples. SURF1 Example; {; auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; Double_t x, y, z, P = 6.;; Int_t np = 200;; auto dt = new TGraph2D();; dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; auto r = new TRandom();; for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(1);; dt->Draw(""surf1"");; }; c#define c(i)Definition RSha256.hxx:101; N#define N; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2D.html:4141,access,accessing,4141,doc/master/classTGraph2D.html,https://root.cern,https://root.cern/doc/master/classTGraph2D.html,1,['access'],['accessing']
Security," httpRequest(filename, 'object');; draw(""drawing"", obj, ""lego"");; In very seldom cases one need to access painter object, created in draw() function. This can be done via handling Promise results like:; let painter = await draw(""drawing"", obj, ""colz"");; console.log('Object type in painter', painter.getClassName());; One is also able to update the drawing with a new version of the object:; // after some interval request object again; redraw(""drawing"", obj2, ""colz"");; The redraw function will call draw if the drawing was not performed before.; In the case when changing of HTML layout leads to resize of element with JSROOT drawing, one should call resize() to let JSROOT adjust drawing size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look like:; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; Here is running example and source code; 1.11.5 TTree API; Simple TTree::Draw operation can be performed with following code:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:27936,access,access,27936,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['access'],['access']
Security," iEl++) {; 1367 for (iEl2 = Narr-1; iEl2 > iEl; --iEl2) {; 1368 if (localArr1[iEl2-1] > localArr1[iEl2]) {; 1369 double tmp = localArr1[iEl2-1];; 1370 localArr1[iEl2-1] = localArr1[iEl2];; 1371 localArr1[iEl2] = tmp;; 1372 ; 1373 int tmp2 = localArr2[iEl2-1];; 1374 localArr2[iEl2-1] = localArr2[iEl2];; 1375 localArr2[iEl2] = tmp2;; 1376 }; 1377 }; 1378 }; 1379 ; 1380 for (iEl = 0; iEl < Narr; iEl++) {; 1381 arr2[iEl] = localArr2[iEl];; 1382 }; 1383 delete [] localArr2;; 1384 delete [] localArr1;; 1385}; 1386 ; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389/// Calculates hash index from any char string.; 1390/// Based on pre-calculated table of 256 specially selected numbers.; 1391/// These numbers are selected in such a way, that for string; 1392/// length == 4 (integer number) the hash is unambiguous, i.e.; 1393/// from hash value we can recalculate input (no degeneration).; 1394///; 1395/// The quality of hash method is good enough, that; 1396/// ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); 1397/// tested by `<R>`, `<R*R>`, `<Ri*Ri+1>` gives the same result; 1398/// as for libc rand().; 1399///; 1400/// - For string: i = TMath::Hash(string,nstring);; 1401/// - For int: i = TMath::Hash(&intword,sizeof(int));; 1402/// - For pointer: i = TMath::Hash(&pointer,sizeof(void*));; 1403///; 1404/// V.Perev; 1405/// This function is kept for back compatibility. The code previously in this function; 1406/// has been moved to the static function TString::Hash; 1407 ; 1408ULong_t TMath::Hash(const void *txt, Int_t ntxt); 1409{; 1410 return TString::Hash(txt,ntxt);; 1411}; 1412 ; 1413 ; 1414////////////////////////////////////////////////////////////////////////////////; 1415 ; 1416ULong_t TMath::Hash(const char *txt); 1417{; 1418 return Hash(txt, Int_t(strlen(txt)));; 1419}; 1420 ; 1421////////////////////////////////////////////////////////////////////////////////; 1422/// Computes the modified Bessel function I_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:46259,hash,hash,46259,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,3,"['Hash', 'hash']","['Hash', 'hash']"
Security," id2 << "" "" << name1 << "" "" << name2 << std::endl;; }; }. 4. Working with date/time parameters. The current implementation supports date, time, date&time and timestamp; data (all time intervals are not supported yet). To set or get date/time values,; the following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware that TDatime supports only dates after 1995-01-01.; There are also methods to get year, month, day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typicall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLStatement.html:8768,access,access,8768,root/html602/TSQLStatement.html,https://root.cern,https://root.cern/root/html602/TSQLStatement.html,2,['access'],['access']
Security," idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; StreamerNVirtualvoid StreamerNVirtual(TBuffer &ClassDef_StreamerNVirtual_b)Definition TStringLong.h:20; Class_Versionstatic constexpr Version_t Class_Version()Definition TStringLong.h:20; IsATClass * IsA() const overrideDefinition TStringLong.h:20; DeclFileNamestatic const char * DeclFileName()Definition TStringLong.h:20; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; ROOT::Internal::THashConsistencyHolderDefinition Rtypes.h:255. Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ; NoteDeclFileLine() is not part of it, since Cling uses that as trigger for associating as class title the comment string found right after the macro. ; Definition at line 271 of file Rtypes.h. ◆ _ClassDefInline_. #define _ClassDefInline_; (;  ; name, .  ; id, .  ; virtual_keyword, .  ; overrd . ). Value: _ClassDefBase_(name, id, virtual_keyword, overrd) public : \; /** \cond HIDDEN_SYMBOLS \deprecated */ static int ImplFileLine() { return -1; } /** \endcond */ \; /** \cond HIDDEN_SYMBOLS \deprecated */ static const char *ImplFileName() { return nullptr; } /** \endcond */\; /** \return Name of this class */ static const char *Class_Name() \; { \; return ::ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector<name>::Name(); \; } \; /** \cond HIDDEN_SYMBOLS */ static TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/Rtypes_8h.html:9361,access,accessing,9361,doc/v632/Rtypes_8h.html,https://root.cern,https://root.cern/doc/v632/Rtypes_8h.html,1,['access'],['accessing']
Security," idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; StreamerNVirtualvoid StreamerNVirtual(TBuffer &ClassDef_StreamerNVirtual_b)Definition TStringLong.h:20; Class_Versionstatic constexpr Version_t Class_Version()Definition TStringLong.h:20; IsATClass * IsA() const overrideDefinition TStringLong.h:20; DeclFileNamestatic const char * DeclFileName()Definition TStringLong.h:20; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; ROOT::Internal::THashConsistencyHolderDefinition Rtypes.h:260. Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ; NoteDeclFileLine() is not part of it, since Cling uses that as trigger for associating as class title the comment string found right after the macro. ; Definition at line 276 of file Rtypes.h. ◆ _ClassDefInline_. #define _ClassDefInline_; (;  ; name, .  ; id, .  ; virtual_keyword, .  ; overrd . ). Value: _ClassDefBase_(name, id, virtual_keyword, overrd) public : \; /** \cond HIDDEN_SYMBOLS \deprecated */ static int ImplFileLine() { return -1; } /** \endcond */ \; /** \cond HIDDEN_SYMBOLS \deprecated */ static const char *ImplFileName() { return nullptr; } /** \endcond */\; /** \return Name of this class */ static const char *Class_Name() \; { \; return ::ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector<name>::Name(); \; } \; /** \cond HIDDEN_SYMBOLS */ static TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h.html:9840,access,accessing,9840,doc/master/Rtypes_8h.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html,1,['access'],['accessing']
Security," idx, Double_t v=1.);  ; Int_t GetEntries () const;  ; TClass * IsA () const override;  ; Bool_t Matches (Int_t idx, const Char_t *idxbuf) const;  Check whether bin at idx batches idxbuf. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Sumw2 ();  Turn on support of errors. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparseArrayChunk.html:2088,Hash,Hash,2088,doc/master/classTHnSparseArrayChunk.html,https://root.cern,https://root.cern/doc/master/classTHnSparseArrayChunk.html,2,['Hash'],['Hash']
Security," if (fCxxModulesEnabled) {; 1490 if (!fromRootCling) {; 1491 // We only set this flag, rest is done by the CIFactory.; 1492 interpArgs.push_back(""-fmodules"");; 1493 interpArgs.push_back(""-fno-implicit-module-maps"");; 1494 // We should never build modules during runtime, so let's enable the; 1495 // module build remarks from clang to make it easier to spot when we do; 1496 // this by accident.; 1497 interpArgs.push_back(""-Rmodule-build"");; 1498 }; 1499 // ROOT implements its AutoLoading upon module's link directives. We; 1500 // generate module A { header ""A.h"" link ""A.so"" export * } where ROOT's; 1501 // facilities use the link directive to dynamically load the relevant; 1502 // library. So, we need to suppress clang's default autolink behavior.; 1503 interpArgs.push_back(""-fno-autolink"");; 1504 }; 1505 ; 1506#ifdef R__FAST_MATH; 1507 // Same setting as in rootcling_impl.cxx.; 1508 interpArgs.push_back(""-ffast-math"");; 1509#endif; 1510 ; 1511 TString llvmResourceDir = TROOT::GetEtcDir() + ""/cling"";; 1512 // Add statically injected extra arguments, usually coming from rootcling.; 1513 for (const char** extraArgs = TROOT::GetExtraInterpreterArgs();; 1514 extraArgs && *extraArgs; ++extraArgs) {; 1515 if (!strcmp(*extraArgs, ""-resource-dir"")) {; 1516 // Take the next arg as the llvm resource directory.; 1517 llvmResourceDir = *(++extraArgs);; 1518 } else {; 1519 interpArgs.push_back(*extraArgs);; 1520 }; 1521 }; 1522 ; 1523 std::vector<std::string> _empty;; 1524 auto args = TROOT::AddExtraInterpreterArgs(_empty);; 1525 for (const auto &arg: args); 1526 interpArgs.emplace_back(arg.c_str());; 1527 ; 1528 // Add the Rdict module file extension.; 1529 cling::Interpreter::ModuleFileExtensions extensions;; 1530 EnvOpt = llvm::sys::Process::GetEnv(""ROOTDEBUG_RDICT"");; 1531 if (!EnvOpt.has_value()); 1532 extensions.push_back(std::make_shared<TClingRdictModuleFileExtension>());; 1533 ; 1534 fInterpreter = std::make_unique<cling::Interpreter>(interpArgs.size(),; 1535 &(interpArgs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:55870,inject,injected,55870,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['inject'],['injected']
Security," if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:102068,access,accessible,102068,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,6,['access'],['accessible']
Security," if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23015,access,access,23015,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security," if loopback mode used by THttpServer for web widgets. ;  ; static bool IsMainThrd ();  Returns true when called from main process Main process recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to use AssignMainThrd() method to let RWebWindowsManager correctly recognize such situation. ;  ; static void SetLoopbackMode (bool on=true);  Set loopback mode for THttpServer used for web widgets By default is on. ;  ; static void SetUseConnectionKey (bool on=true);  Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  ; static void SetUseSessionKey (bool on=true);  Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  . Private Member Functions; bool CreateServer (bool with_http=false);  Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP port, which should be used for the server, provide following entry in rootrc file: ;  ; float GetLaunchTmout () const;  Returns timeout for launching new browser process. ;  ; std::string GetUrl (RWebWindow &win, bool remote=false, std::string *produced_key=nullptr);  Provide URL address to access specified window from inside or from remote. ;  ; bool InformListener (const std::string &msg);  If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket. ;  ; bool IsUseHttpThread () const;  Returns true if http server use special thread for requests processing (default off) ;  ; bool IsUseSenderThreads () const;  Returns true if extra threads to send data via ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:3074,hash,hash,3074,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,2,['hash'],['hash']
Security," if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0, Int_t signalClass = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: BinarySearchTree.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__BinarySearchTree.html:8044,access,access,8044,root/html532/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html532/TMVA__BinarySearchTree.html,4,['access'],['access']
Security," if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0, Int_t signalClass = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: BinarySearchTree.h 40012 2011-06-27 16:03:11Z stelzer $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__BinarySearchTree.html:8044,access,access,8044,root/html530/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html530/TMVA__BinarySearchTree.html,4,['access'],['access']
Security," if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~VariableTransformBase(). void CalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); update min and max of a given variable (target) and a given transformation method. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ). const Event* Transform(const TMVA::Event *const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event *const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void SetUseSignalTransform(Bool_t e = kTRUE); { fUseSignalTransform = e; }. Bool_t UseSignalTransform() const; { return fUseSignalTransform; }. const char* GetName() const; { return fTransformName.Data(); }. TString GetShortName() const; { TString a(fTransformName); a.ReplaceAll(""Transform"",""""); return a; }. void WriteTransformationToStream(ostream& o) const. void ReadTransformationFromStream(istream& istr, const TString& classname = """"). void AttachXMLTo(void* parent). void ReadFromXML(void* trfnode). Types::EVariableTransform GetVariableTransform() const; { return fVariableTransform; }. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); writer of function code. void PrintTransformation(ostream& ); provi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__VariableTransformBase.html:8261,access,accessors,8261,root/html528/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html528/TMVA__VariableTransformBase.html,1,['access'],['accessors']
Security," in TBufferSQL.; Definition at line 393 of file TBufferFile.h. ◆ ReadVersion(). Version_t TBufferFile::ReadVersion ; (; UInt_t * ; start = nullptr, . UInt_t * ; bcnt = nullptr, . const TClass * ; cl = nullptr . ). overridevirtual . Read class version from I/O buffer. ; Implements TBuffer.; Definition at line 2930 of file TBufferFile.cxx. ◆ ReadVersionForMemberWise(). Version_t TBufferFile::ReadVersionForMemberWise ; (; const TClass * ; cl = nullptr). overridevirtual . Read class version from I/O buffer. ; To be used when streaming out member-wise streamed collection where we do not care (not save) about the byte count and can safely ignore missing streamerInfo (since they usually indicate empty collections). ; Implements TBuffer.; Definition at line 3079 of file TBufferFile.cxx. ◆ ReadVersionNoCheckSum(). Version_t TBufferFile::ReadVersionNoCheckSum ; (; UInt_t * ; start = nullptr, . UInt_t * ; bcnt = nullptr . ). overridevirtual . Read class version from I/O buffer, when the caller knows for sure that there is no checksum written/involved. ; Implements TBuffer.; Definition at line 3036 of file TBufferFile.cxx. ◆ ReadWithFactor() [1/2]. void TBufferFile::ReadWithFactor ; (; Double_t * ; ptr, . Double_t ; factor, . Double_t ; minvalue . ). overridevirtual . Read a Double32_t from the buffer when the factor and minimum value have been specified see comments about Double32_t encoding at TBufferFile::WriteDouble32(). ; Implements TBuffer.; Definition at line 524 of file TBufferFile.cxx. ◆ ReadWithFactor() [2/2]. void TBufferFile::ReadWithFactor ; (; Float_t * ; ptr, . Double_t ; factor, . Double_t ; minvalue . ). overridevirtual . Read a Float16_t from the buffer when the factor and minimum value have been specified see comments about Double32_t encoding at TBufferFile::WriteDouble32(). ; Implements TBuffer.; Definition at line 489 of file TBufferFile.cxx. ◆ ReadWithNbits() [1/2]. void TBufferFile::ReadWithNbits ; (; Double_t * ; ptr, . Int_t ; nbits . ). overridevirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:69808,checksum,checksum,69808,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['checksum'],['checksum']
Security," in THashList, TList, TObjArray, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TViewPubDataMembers, TViewPubFunctions, and TRootBrowserHistory.; Definition at line 574 of file TCollection.cxx. ◆ Remove(). virtual TObject * TCollection::Remove ; (; TObject * ; obj). pure virtual . Implemented in TMap, TBtree, TClonesArray, THashList, THashTable, TList, TObjArray, TOrdCollection, TRefArray, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TViewPubDataMembers, and TViewPubFunctions. ◆ RemoveAll() [1/2]. void TCollection::RemoveAll ; (; ). inline . Definition at line 204 of file TCollection.h. ◆ RemoveAll() [2/2]. void TCollection::RemoveAll ; (; TCollection * ; col). virtual . Remove all objects in collection col from this collection. ; Definition at line 594 of file TCollection.cxx. ◆ SetCurrentCollection(). void TCollection::SetCurrentCollection ; (; ). Set this collection to be the globally accessible collection. ; Definition at line 688 of file TCollection.cxx. ◆ SetName(). void TCollection::SetName ; (; const char * ; name). inline . Definition at line 206 of file TCollection.h. ◆ SetOwner(). void TCollection::SetOwner ; (; Bool_t ; enable = kTRUE). virtual . Set whether this collection is the owner (enable==true) of its content. ; If it is the owner of its contents, these objects will be deleted whenever the collection itself is deleted. The objects might also be deleted or destructed when Clear is called (depending on the collection). ; Reimplemented in TClonesArray.; Definition at line 746 of file TCollection.cxx. ◆ StartGarbageCollection(). void TCollection::StartGarbageCollection ; (; ). static . Set up for garbage collection. ; Definition at line 696 of file TCollection.cxx. ◆ Streamer(). void TCollection::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TObject.; Reimplem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:32775,access,accessible,32775,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,2,['access'],['accessible']
Security," in Terminate(). void Print(Option_t* option = """") const; Print the class table. Before printing the table is sorted; alphabetically. Only classes specified in option are listed.; The default is to list all classes.; Standard wilcarding notation supported. char * At(int index); Returns class at index from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc.; Returns 0 if index points beyond last class name. int Classes(). { return fgTally; }. void Init(); { fgCursor = 0; SortTable(); }. void Add(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. VoidFuncPtr_t GetDict(const char *cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). VoidFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Termi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassTable.html:7354,hash,hash,7354,root/html526/TClassTable.html,https://root.cern,https://root.cern/root/html526/TClassTable.html,1,['hash'],['hash']
Security," in a sub-array. ;  ; Double_t GetValue (char *pointer, Int_t i, Int_t j, Int_t len) const;  ; Double_t GetValueClones (TClonesArray *clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  ; Double_t GetValueSTL (TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  ; Double_t GetValueSTLP (TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  ; TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions (Bool_t forCollection);  ; TStreamerInfoActions::TActionSequence * GetWriteObjectWiseActions ();  ; TStreamerInfoActions::TActionSequence * GetWriteTextActions ();  ; TClass * IsA () const override;  ; void ls (Option_t *option="""") const override;  List the TStreamerElement list and also the precomputed tables if option contains the string ""incOrig"", also prints the original (non-optimized elements in the list of compiled elements. ;  ; Bool_t MatchLegacyCheckSum (UInt_t checksum) const;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void * New (void *obj=nullptr) override;  An emulated object is created at address obj, if obj is null we allocate memory for the object. ;  ; void * NewArray (Long_t nElements, void *ary=nullptr) override;  An array of emulated objects is created at address ary, if ary is null, we allocate memory for the array. ;  ; TVirtualStreamerInfo * NewInfo (TClass *cl) override;  ; void PrintValue (const char *name, char *pointer, Int_t i, Int_t len, Int_t lenmax=1000) const;  print value of element i in object at pointer The function may be called in two ways: -method1 len < 0 i is assumed to be the TStreamerElement number i in StreamerInfo -method2 len >= 0 i is the type address of variable is directly pointer. ;  ; void PrintValueClones (const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;  Print value of element i in a TClonesArray. ;  ; void PrintValueSTL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:10730,checksum,checksum,10730,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,4,['checksum'],['checksum']
Security," in case of error. ; enc = 1 for private encoding, enc = 2 for public encoding ; Definition at line 2803 of file TAuthenticate.cxx. ◆ SendRSAPublicKey(). Int_t TAuthenticate::SendRSAPublicKey ; (; TSocket * ; Socket, . Int_t ; key = 0 . ). static . Receives server RSA Public key Sends local RSA public key encoded. ; Definition at line 3117 of file TAuthenticate.cxx. ◆ SetAuthReUse(). void TAuthenticate::SetAuthReUse ; (; Bool_t ; authreuse). static . Set global AuthReUse flag. ; Definition at line 1377 of file TAuthenticate.cxx. ◆ SetDefaultRSAKeyType(). void TAuthenticate::SetDefaultRSAKeyType ; (; Int_t ; key). static . Static method setting the default type of RSA key. ; Definition at line 1219 of file TAuthenticate.cxx. ◆ SetDefaultUser(). void TAuthenticate::SetDefaultUser ; (; const char * ; defaultuser). static . Set default user name. ; Definition at line 1357 of file TAuthenticate.cxx. ◆ SetEnvironment(). void TAuthenticate::SetEnvironment ; (; ). private . Set default authentication environment. ; The values are inferred from fSecurity and fDetails. ; Definition at line 681 of file TAuthenticate.cxx. ◆ SetGlobalExpDate(). void TAuthenticate::SetGlobalExpDate ; (; TDatime ; expdate). static . Set default expiring date for new validity contexts. ; Definition at line 1349 of file TAuthenticate.cxx. ◆ SetGlobalPasswd(). void TAuthenticate::SetGlobalPasswd ; (; const char * ; passwd). static . Set global passwd to be used for authentication to rootd or proofd. ; Definition at line 1309 of file TAuthenticate.cxx. ◆ SetGlobalPwHash(). void TAuthenticate::SetGlobalPwHash ; (; Bool_t ; pwhash). static . Set global passwd hash flag to be used for authentication to rootd or proofd. ; Definition at line 1323 of file TAuthenticate.cxx. ◆ SetGlobalSRPPwd(). void TAuthenticate::SetGlobalSRPPwd ; (; Bool_t ; srppwd). static . Set global SRP passwd flag to be used for authentication to rootd or proofd. ; Definition at line 1331 of file TAuthenticate.cxx. ◆ SetGlobalUser().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:37981,authenticat,authentication,37981,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security," in containers. For example, by default two objects are considered equal if their pointers point to the same address. This might be too strict for some classes where equality is already achieved if some or all of the data members are equal. By overriding the following TObject member functions, you can change the behavior of objects in collections:. IsEqual()is used by the FindObject()collection method. By default, IsEqual() compares the two object pointers.; Compare()returns -1, 0 or 1 depending if the object is smaller, equal or larger than the other object. By default, a TObject has not a valid Compare() method.; IsSortable()returns true if the class is sort able (i.e. if it has a valid Compare() method). By default, a TObject is not sort able.; Hash()returns a hash value. It needs to be implemented if an object has to be stored in a collection using a hashing technique, like THashTable, THashList and TMap. By default, Hash() returns the address of the object. It is essential to choose a good hash function. The example below shows how to use and override these member functions.; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; 16.5 The TIter Generic Iterator; As stated above, the TIterator class is abstract; it is not possible to create TIterator objects. However, it should be possible to write generic code to process all members of a collection so there is a need for a generic iterator object. A TIter objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:848019,hash,hash,848019,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['hash'],['hash']
Security," in target. ; If dsName is defined, only the information about the specified dataset is processed.; The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet. Available options (to be .or.ed): kPrint print the dataset content kQuotaUpdate update quotas kExport use export naming kList get a list of dataset names; NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. ; Definition at line 577 of file TDataSetManagerFile.cxx. ◆ CheckLocalCache(). Int_t TDataSetManagerFile::CheckLocalCache ; (; const char * ; group, . const char * ; user, . const char * ; dsName = ""ls"", . UInt_t ; option = 0 . ). private . Check if the local cache information for group, user, dsName is up-to-date If not, make the relevant updates Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. ; Definition at line 1085 of file TDataSetManagerFile.cxx. ◆ ChecksumDataSet(). Int_t TDataSetManagerFile::ChecksumDataSet ; (; const char * ; path, . const char * ; md5path, . TString & ; checksum . ). protected . Calculate the checksum of the indicated dataset at 'path' and save it to the appropriate file 'md5path'. ; The MD5 string is returned in 'md5sum'. Return 0 on success, -1 on error. ; Definition at line 1512 of file TDataSetManagerFile.cxx. ◆ Class(). static TClass * TDataSetManagerFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDataSetManagerFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDataSetManagerFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TDataSetManagerFile.h. ◆ ClearCache(). Int_t TDataSetManagerFile::ClearCache ; (; const char * ; uri = 0). overridevirtual . Clear cached information matching uri. ; Reimplemented from TDataSetManager.; Definition at line 1253 of file TDataSetManagerFile.cxx. ◆ C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:22585,Checksum,ChecksumDataSet,22585,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['Checksum'],['ChecksumDataSet']
Security," in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgList.html:18204,Hash,Hash,18204,doc/master/classRooArgList.html,https://root.cern,https://root.cern/doc/master/classRooArgList.html,4,['Hash'],['Hash']
Security," in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'.; If the fileprefix contains a period, the right side of the period; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreePlayer.html:18009,access,access,18009,root/html530/TTreePlayer.html,https://root.cern,https://root.cern/root/html530/TTreePlayer.html,5,['access'],['access']
Security," in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](int j); { return (*fMat)(fRow,j); }. const T & operator[](int j); { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6600,access,access,6600,root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['access'],['access']
Security," index 0:; Int_t ci = TColor::GetFreeColorIndex();; TColor *color = new TColor(ci, 1., 1., 1.);. Bright and dark colors; Dark and bright colors are used to add 3D effects to graphical objects like TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; Two static functions are available that return the bright or dark color number corresponding to a given color index. If these variants don't already exist, they are created as needed: Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; TColor::GetColorBrightstatic Int_t GetColorBright(Int_t color)Static function: Returns the bright color number corresponding to n If the TColor object does not exi...Definition TColor.cxx:2087; TColor::GetColorDarkstatic Int_t GetColorDark(Int_t color)Static function: Returns the dark color number corresponding to n If the TColor object does not exist...Definition TColor.cxx:2130. Accessible Color Schemes; Choosing an appropriate color scheme is essential for making results easy to understand and interpret. Factors like colorblindness and converting colors to grayscale for publications can impact accessibility. Furthermore, results should be aesthetically pleasing. The following three color schemes, recommended by M. Petroff in arXiv:2107.02270v2 and available on GitHub under the MIT License, meet these criteria.; These three color schemes are available as color sets with 6, 8, and 10 colors, named kP[6, 8, 10]ColorName. For example, kP6Red represents the red color within the P6 color scheme (P for Petroff or Preferred). The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings. It also demonstrates that they are effective in grayscale. Grayscale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using TCanvas::SetGrayscale(). Note that in grayscale mode, access via RGB will return grayscale values according to ITU standards (and close ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:6109,Access,Accessible,6109,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['Access'],['Accessible']
Security," info object ;  ; DataSet * CreateDataSet (const TString &dsiName);  Creates the singleton dataset. ;  ; DataSetInfo * GetDataSetInfo (const TString &dsiName);  returns datasetinfo object for given name ;  ; virtual TClass * IsA () const;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSetManager.html:1796,Hash,Hash,1796,doc/master/classTMVA_1_1DataSetManager.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSetManager.html,2,['Hash'],['Hash']
Security," information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:9416,access,accessors,9416,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,6,['access'],['accessors']
Security," ingredients needed to setup the connection to a Dask cluster (e.g. a LocalCluster for a single machine). After this initial setup, an RDataFrame with distributed capabilities is created and connected to a Dask Client instance. Finally, a couple of histograms are drawn from the created columns in the dataset. Relevant documentation can be found at http://distributed.dask.org/en/stable .; from dask.distributed import LocalCluster, Client; import ROOT; ; # Point RDataFrame calls to Dask RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; ; ; def create_connection():; """"""; Setup connection to a Dask cluster. Two ingredients are needed:; 1. Creating a cluster object that represents computing resources. This can be; done in various ways depending on the type of resources at disposal. To use; only the local machine (e.g. your laptop), a `LocalCluster` object can be; used. This step can be skipped if you have access to an existing Dask; cluster; in that case, the cluster administrator should provide you with a; URL to connect to the cluster in step 2. More options for cluster creation; can be found in the Dask docs at; http://distributed.dask.org/en/stable/api.html#cluster .; 2. Creating a Dask client object that connects to the cluster. This accepts; directly the object previously created. In case the cluster was setup; externally, you need to provide an endpoint URL to the client, e.g.; 'https://myscheduler.domain:8786'.; ; Through Dask, you can connect to various types of cluster resources. For; example, you can connect together a set of machines through SSH and use them; to run your computations. This is done through the `SSHCluster` class. For; example:; ; ```python; from dask.distributed import SSHCluster; cluster = SSHCluster(; # A list with machine host names, the first name will be used as; # scheduler, following names will become workers.; hosts=[""machine1"",""machine2"",""machine3""],; # A dictionary of options for each worker node, her",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/distrdf002__dask__connection_8py.html:1306,access,access,1306,doc/master/distrdf002__dask__connection_8py.html,https://root.cern,https://root.cern/doc/master/distrdf002__dask__connection_8py.html,1,['access'],['access']
Security," inlineoverride . Definition at line 40 of file TGDMLParse.h. ◆ TGDMLRefl() [2/2]. TGDMLRefl::TGDMLRefl ; (; const char * ; name, . const char * ; solid, . TGeoMatrix * ; matrix . ). This constructor method stores the values brought in as params. ; Definition at line 4615 of file TGDMLParse.cxx. Member Function Documentation. ◆ Class(). static TClass * TGDMLRefl::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGDMLRefl::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGDMLRefl::Class_Version ; (; ). inlinestaticconstexpr . matrix of reflected solid ; ReturnsVersion of this class ; Definition at line 50 of file TGDMLParse.h. ◆ DeclFileName(). static const char * TGDMLRefl::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 50 of file TGDMLParse.h. ◆ GetMatrix(). TGeoMatrix * TGDMLRefl::GetMatrix ; (; ). This accessor method returns the matrix. ; Definition at line 4625 of file TGDMLParse.cxx. ◆ IsA(). TClass * TGDMLRefl::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 50 of file TGDMLParse.h. ◆ Streamer(). void TGDMLRefl::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGDMLRefl::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 50 of file TGDMLParse.h. Member Data Documentation. ◆ fMatrix. TGeoMatrix* TGDMLRefl::fMatrix. private . solid name being reflected ; Definition at line 48 of file TGDMLParse.h. ◆ fNameS. const char* TGDMLRefl::fNameS. private . Definition at line 46 of file TGDMLParse.h. ◆ fSolid. const char* TGDMLRefl::fSolid. private . reflected solid name ; Definition at line 47 of file TGDMLParse.h. Libraries for TGDMLRefl:. [legend]; The documentation for this class was ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDMLRefl.html:11947,access,accessor,11947,doc/master/classTGDMLRefl.html,https://root.cern,https://root.cern/doc/master/classTGDMLRefl.html,1,['access'],['accessor']
Security," instance using regular expressions.; @pythonization('pair<', ns='std', is_prefix=True); def pair_pythonizor(klass, name):; print('Pythonizing class ' + name); ; # The pythonizor above will be applied to any instantiation of `std::pair` - we; # can see this with the print we did inside the pythonizor.; # Note that we could use the `name` parameter to e.g. further filter which; # particular instantiations we would like to pythonize.; p1 = ROOT.std.pair['int','int'](1,2) # prints 'Pythonizing class std::pair<int,int>'; p2 = ROOT.std.pair['int','double'](1,2.) # prints 'Pythonizing class std::pair<int,double>'; ; # Note that, to pythonize multiple classes in different namespaces, we can; # stack multiple @pythonization decorators. For example, if we define these; # classes:; ROOT.gInterpreter.Declare('''; class FirstClass {};; namespace NS {; class SecondClass {};; }; '''); ; # We can pythonize both of them with a single pythonizor function like so:; @pythonization('FirstClass'); @pythonization('SecondClass', ns='NS'); def pythonizor_for_first_and_second(klass, name):; print('Executed for class ' + name); ; # If we now access both classes, we should see that the pythonizor runs twice.; f = ROOT.FirstClass(); s = ROOT.NS.SecondClass(); ; # So far we have seen how pythonizations can be registered for classes that; # have not been used yet. We have discussed how, in that case, the pythonizor; # functions are executed lazily when their target class/es are used for the; # first time in the application.; # However, it can also happen that our target class/es have already been; # accessed by the time we register a pythonization. In such a scenario, the; # pythonizor is applied immediately (at registration time) to the target; # class/es.; ; # Let's see an example of what was just explained. We will define a new class; # and immediately create an object of that class. We can check how the object; # still does not have a new attribute `pythonized` that we are going to inject; # ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html:7758,access,access,7758,doc/master/pyroot002__pythonizationDecorator_8py.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html,1,['access'],['access']
Security," instead of hardcoded color numbers, e.g.:. myObject.SetFillColor(kRed);; myObject.SetFillColor(kYellow-10);; myLine.SetLineColor(kMagenta+2);. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; return w->GetCanvas();; }; Bright and dark colors; The dark and bright color are used to give 3-D effects when drawing various; boxes (see TWbox, TPave, TPaveText, TPaveLabel, etc). The dark colors have an index = color_index+100; The bright colors have an index = color_index+150; Two static functions return the bright and dark color number; corresponding to a color index. If the bright or dark color does not; exist, they are created:; ; Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; . Grayscale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using; TCanvas::SetGrayscale(). Note that in grayscale mode, access via RGB; will return grayscale values according to ITU standards (and close to b&w; printer grayscales), while access via HLS returns de-saturated grayscales. The; image below shows the ROOT color wheel in grayscale mode. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; w->GetCanvas()->SetGrayscale();; w->GetCanvas()->Modified();; w->GetCanvas()->Update();; return w->GetCanvas();; }; Color palettes; It is often very useful to represent a variable with a color map. The concept; of ""color palette"" allows to do that. One color palette is active at any time.; This ""current palette"" is set using:. gStyle->SetPalette(...);. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the palette. The following small; example demonstrates how to define and use the color palette:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TColor.html:3260,access,access,3260,root/html532/TColor.html,https://root.cern,https://root.cern/root/html532/TColor.html,8,['access'],['access']
Security," integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t). ==> Case B. TBranch *branch = tree->Branch(branchname,className,object, bufsize, splitlevel); object is the address of a pointer to an existing object (derived from TObject).; if splitlevel=1 (default), this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; if splitlevel=0, the object is serialized in the branch buffer. ==> Case C. TBranch *branch = tree->Branch(branchname,clonesarray, bufsize, splitlevel); clonesarray is the address of a pointer to a TClonesArray.; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with only one branch). /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:3796,access,access,3796,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['access'],['access']
Security," interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7462,access,access,7462,root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,32,['access'],['access']
Security," into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; w.Import(model); ; ; # Create and fill workspace; # ------------------------------------------------; ; ; # Create a workspace named 'w'; # With CINT w could exports its contents to; # a same-name C++ namespace in CINT 'namespace w'.; # but self does not work anymore in CLING.; # so self tutorial is an example on how to; # change the code; w = ROOT.RooWorkspace(""w"", True); ; # Fill workspace with pdf and data in a separate function; fillWorkspace(w); ; # Print workspace contents; w.Print(); ; # self does not work anymore with CLING; # use normal workspace functionality; ; # Use workspace contents; # ----------------------------------------------; ; # Old syntax to use the name space prefix operator to access the workspace contents; #; # d = w.model.generate(w.x,1000); # r = w.model.fitTo(*d); ; # use normal workspace methods; model = w[""model""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8py.html:2302,access,access,2302,doc/master/rf509__wsinteractive_8py.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html,1,['access'],['access']
Security," is explicitly added to the collection (and thus visible via ls or Print) only if it is requested explicitly. ; Definition at line 30 of file TListOfTypes.h. Public Member Functions;  TListOfTypes ();  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; TDataType * FindType (const char *name) const;  ;  Public Member Functions inherited from THashTable;  THashTable (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashTable object. ;  ; virtual ~THashTable ();  Delete a hashtable. ;  ; void Add (TObject *obj) override;  Add object to the hash table. ;  ; void AddAll (const TCollection *col) override;  Add all objects from collection col to this collection. ;  ; void AddBefore (const TObject *before, TObject *obj);  Add object to the hash table. ;  ; Float_t AverageCollisions () const;  ; void Clear (Option_t *option="""") override;  Remove all objects from the table. ;  ; Int_t Collisions (const char *name) const;  Returns the number of collisions for an object with a certain name (i.e. ;  ; Int_t Collisions (TObject *obj) const;  Returns the number of collisions for an object (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the table AND delete all heap based objects. ;  ; Bool_t Empty () const;  ; const TList * GetListForObject (const char *name) const;  Return the TList corresponding to object's name based hash value. ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the TList corresponding to object's hash value. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Int_t GetRehashLevel () const;  ; Int_t GetSize () const override;  Return the capacity of the collection, i.e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfTypes.html:1484,hash,hash,1484,doc/master/classTListOfTypes.html,https://root.cern,https://root.cern/doc/master/classTListOfTypes.html,1,['hash'],['hash']
Security," is going to be converted in an histogram and the corresponding; histogram is painted.; The painted histogram can be retrieved calling afterwards the method TF1::GetHistogram(). TH1 * DoCreateHistogram(Double_t xmin, Double_t xmax, Bool_t recreate = kFALSE); create histogram with bin content equal to function value; computed at the bin center; This histogram will be used to paint the function; A re-creation is forced and a new histogram is done if recreate=true. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.; the current function may be accessed in static C-like functions; when fitting or painting a function. void SetFitResult(const ROOT::Fit::FitResult& result, const Int_t* indpar = 0); Set the result from the fit; parameter values, errors, chi2, etc...; Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed; This is useful in the case of a combined fit with different functions, and the FitResult contains the global result; By default it is assume that indpar = {0,1,2,....,fNpar-1}. void SetMaximum(Double_t maximum = -1111); Set the maximum value along Y for this function; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1.html:55236,access,accessed,55236,root/html604/TF1.html,https://root.cern,https://root.cern/root/html604/TF1.html,1,['access'],['accessed']
Security," is named ""TVectorT"" by default and no title. void TVectorT<Element> Print(Option_t* option = """") const; Print the vector as a list of elements. void TVectorT<Element> Streamer(TBuffer& ); Stream an object of class TVectorT. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVectorT_float_.html:17443,Access,Access,17443,root/html534/TVectorT_float_.html,https://root.cern,https://root.cern/root/html534/TVectorT_float_.html,1,['Access'],['Access']
Security," is not associated to gDirectory; 1801 /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; 1802 /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).; 1803 template <typename V = RDFDetail::RInferredType>; 1804 RResultPtr<::TH1D> Histo1D(const TH1DModel &model = {"""", """", 128u, 0., 0.}, std::string_view vName = """"); 1805 {; 1806 const auto userColumns = vName.empty() ? ColumnNames_t() : ColumnNames_t({std::string(vName)});; 1807 ; 1808 const auto validatedColumns = GetValidatedColumnNames(1, userColumns);; 1809 ; 1810 std::shared_ptr<::TH1D> h(nullptr);; 1811 {; 1812 ROOT::Internal::RDF::RIgnoreErrorLevelRAII iel(kError);; 1813 h = model.GetHistogram();; 1814 h->SetDirectory(nullptr);; 1815 }; 1816 ; 1817 if (h->GetXaxis()->GetXmax() == h->GetXaxis()->GetXmin()); 1818 RDFInternal::HistoUtils<::TH1D>::SetCanExtendAllAxes(*h);; 1819 return CreateAction<RDFInternal::ActionTags::Histo1D, V>(validatedColumns, h, h, fProxiedPtr);; 1820 }; 1821 ; 1822 ////////////////////////////////////////////////////////////////////////////; 1823 /// \brief Fill and return a one-dimensional histogram with the values of a column (*lazy action*).; 1824 /// \tparam V The type of the column used to fill the histogram.; 1825 /// \param[in] vName The name of the column that will fill the histogram.; 1826 /// \return the monodimensional histogram wrapped in a RResultPtr.; 1827 ///; 1828 /// This overload uses a default model histogram TH1D(name, title, 128u, 0., 0.).; 1829 /// The ""name"" and ""title"" strings are built starting from the input column name.; 1830 /// See the description of the first Histo1D() overload for more details.; 1831 ///; 1832 /// ### Example usage:; 1833 /// ~~~{.cpp}; 1834 /// // Deduce column type (this invocation needs jitting internally); 1835 /// auto myHist1 = myDf.Histo1D(""myColumn"");; 1836 /// // Explicit column type; 1837 /// auto myHist2 = myDf.Histo1D<float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:101784,validat,validatedColumns,101784,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['validat'],['validatedColumns']
Security," is not being deleted! ;  ; void RemoveRules (TObjArray *rules);  remove given array of rules from the set - the rules are not being deleted! ;  ; void SetClass (TClass *cls);  Set the TClass associated with this rule set. ;  ; void Streamer (TBuffer &) override;  Stream an object of class ROOT::TSchemaRuleSet. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html:4130,Hash,Hash,4130,doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html,2,['Hash'],['Hash']
Security," is overridden by a more efficient version in concrete collection classes (e.g. THashTable). ; Reimplemented from TObject.; Reimplemented in TMap, TListOfTypes, THashList, THashTable, TList, TObjArray, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TViewPubDataMembers, and TViewPubFunctions.; Definition at line 337 of file TCollection.cxx. ◆ GarbageCollect(). void TCollection::GarbageCollect ; (; TObject * ; obj). static . Add to the list of things to be cleaned up. ; Definition at line 725 of file TCollection.cxx. ◆ GetCollectionEntryName(). const char * TCollection::GetCollectionEntryName ; (; TObject * ; entry); const. protectedvirtual . For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ; Definition at line 437 of file TCollection.cxx. ◆ GetCurrentCollection(). TCollection * TCollection::GetCurrentCollection ; (; ). static . Return the globally accessible collection. ; Definition at line 680 of file TCollection.cxx. ◆ GetEntries(). virtual Int_t TCollection::GetEntries ; (; ); const. inlinevirtual . Reimplemented in TObjArray, and TRefArray.; Definition at line 179 of file TCollection.h. ◆ GetName(). const char * TCollection::GetName ; (; ); const. overridevirtual . Return name of this collection. ; if no name, return the collection class name. ; Reimplemented from TObject.; Reimplemented in TQCommand, and TQConnection.; Definition at line 351 of file TCollection.cxx. ◆ GetObjectRef(). virtual TObject ** TCollection::GetObjectRef ; (; const TObject * ; obj); const. pure virtual . Implemented in TBtree, THashTable, TList, TMap, TObjArray, TOrdCollection, TRefArray, TListOfEnumsWithLock, TListOfFunctions, TViewPubDataMembers, and TViewPubFunctions. ◆ GetSize(). virtual Int_t TCollection::GetSize ; (; ); const. inlinevirtual . Return the capacity of the collection, i.e. ; the current total amount of space that has been allocated ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:21798,access,accessible,21798,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,2,['access'],['accessible']
Security," is used to isolate sequential tokens in a TString. ;  ; Bool_t Tokenize (TString &tok, Ssiz_t &from, const char *delim="" "") const;  Search for tokens delimited by regular expression 'delim' (default "" "") in this string; search starts at 'from' and the token is returned in 'tok'. ;  ; void ToLower ();  Change string to lower-case. ;  ; void ToUpper ();  Change string to upper case. ;  ; std::string_view View () const;  . Static Public Member Functions; static TString BaseConvert (const TString &s_in, Int_t base_in, Int_t base_out);  Converts string from base base_in to base base_out. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TString Format (const char *fmt,...);  Static method which formats a string using a printf style format descriptor and return a TString. ;  ; static Ssiz_t GetInitialCapacity ();  ; static Ssiz_t GetMaxWaste ();  ; static Ssiz_t GetResizeIncrement ();  ; static UInt_t Hash (const void *txt, Int_t ntxt);  Calculates hash index from any char string. ;  ; static Ssiz_t InitialCapacity (Ssiz_t ic=15);  Set default initial capacity for all TStrings. Default is 15. ;  ; static TString Itoa (Int_t value, Int_t base);  Converts an Int_t to a TString with respect to the base specified (2-36). ;  ; static TString LLtoa (Long64_t value, Int_t base);  Converts a Long64_t to a TString with respect to the base specified (2-36). ;  ; static Ssiz_t MaxWaste (Ssiz_t mw=15);  Set maximum space that may be wasted in a string before doing a resize. ;  ; static TString * ReadString (TBuffer &b, const TClass *clReq);  Read TString object from buffer. ;  ; static Ssiz_t ResizeIncrement (Ssiz_t ri=16);  Set default resize increment for all TStrings. Default is 16. ;  ; static TString UItoa (UInt_t value, Int_t base);  Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ;  ; static TString ULLtoa ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTString.html:13282,Hash,Hash,13282,doc/master/classTString.html,https://root.cern,https://root.cern/doc/master/classTString.html,4,"['Hash', 'hash']","['Hash', 'hash']"
Security," is useful to access the bin information independently of the dimension. ; Reimplemented in TH3, and TH2.; Definition at line 4961 of file TH1.cxx. ◆ GetBinCenter(). Double_t TH1::GetBinCenter ; (; Int_t ; bin); const. virtual . Return bin center for 1D histogram. ; Better to use h1.GetXaxis()->GetBinCenter(bin) ; Definition at line 9141 of file TH1.cxx. ◆ GetBinContent() [1/3]. Double_t TH1::GetBinContent ; (; Int_t ; bin); const. virtual . Return content of bin number bin. ; Implemented in TH1C,S,F,D; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined. For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; returns a global/linearized bin number. This global bin is useful to access the bin information independently of the dimension. ; Reimplemented in TH2, TH3, TH1K, TH2Poly, TProfile, TProfile2D, TProfile2Poly, TProfile2Poly, and TProfile3D.; Definition at line 5061 of file TH1.cxx. ◆ GetBinContent() [2/3]. virtual Double_t TH1::GetBinContent ; (; Int_t ; bin, . Int_t ;  . ); const. inlinevirtual . Reimplemented in TH2, TH3, TH1K, TProfile, TH2, TProfile2D, TH2Poly, TProfile2Poly, and TProfile3D.; Definition at line 266 of file TH1.h. ◆ GetBinContent() [3/3]. virtual Double_t TH1::GetBinContent ; (; Int_t ; bin, . Int_t ; , . Int_t ;  . ); const. inlinevirtual . Reimplemented in TH2, TH3, TH1K, TProfile, TH3, TProfile3D, TH2, TProfile2D, TH2Poly, and TProfile2Poly.; Definition at line 267 of file TH1.h. ◆ GetBinError() [1/3]. Double_t TH1::GetBinError ; (; Int_t ; bin); const. virtual . Return value of error associated to bin number bin. ; if the sum of squares of weights has been defined (via Sumw2), this function returns the sqrt(sum of w2). otherwise it returns the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:148546,access,access,148546,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['access'],['access']
Security," is: kNoCheck: no check is done, register the rule as is kCheckConflict: check only for conflicting rules kCheckAll: check for conflict and check for rule about members that are not in the current class layout. ;  ; Bool_t AddRules (TSchemaRuleSet *rules, EConsistencyCheck checkConsistency=kCheckAll, TString *errmsg=nullptr);  ; void AsString (TString &out) const;  Fill the string 'out' with the string representation of the rule. ;  ; const TMatches FindRules (const TString &source) const;  Return all the rules that are about the given 'source' class. ;  ; const TMatches FindRules (const TString &source, Int_t version) const;  Return all the rules that applies to the specified version of the given 'source' class. ;  ; const TMatches FindRules (const TString &source, Int_t version, UInt_t checksum) const;  Return all the rules that applies to the specified version OR checksum of the given 'source' class. ;  ; const TMatches FindRules (const TString &source, UInt_t checksum) const;  Return all the rules that applies to the specified checksum of the given 'source' class. ;  ; TClass * GetClass ();  ; UInt_t GetClassCheckSum () const;  ; TString GetClassName () const;  ; Int_t GetClassVersion () const;  ; const TObjArray * GetPersistentRules () const;  ; const TObjArray * GetRules () const;  ; Bool_t HasRuleWithSourceClass (const TString &source) const;  Return True if we have any rule whose source class is 'source'. ;  ; TClass * IsA () const override;  ; void ls (Option_t *option="""") const override;  The ls function lists the contents of a class on stdout. ;  ; void RemoveRule (TSchemaRule *rule);  Remove given rule from the set - the rule is not being deleted! ;  ; void RemoveRules (TObjArray *rules);  remove given array of rules from the set - the rules are not being deleted! ;  ; void SetClass (TClass *cls);  Set the TClass associated with this rule set. ;  ; void Streamer (TBuffer &) override;  Stream an object of class ROOT::TSchemaRuleSet. ;  ; void StreamerNVir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html:2444,checksum,checksum,2444,doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html,2,['checksum'],['checksum']
Security," it is not representing an STL collection. ; Definition at line 2886 of file TClass.cxx. ◆ GetContextMenuTitle(). const char * TClass::GetContextMenuTitle ; (; ); const. inline . Definition at line 438 of file TClass.h. ◆ GetConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::GetConversionStreamerInfo ; (; const char * ; onfile_classname, . Int_t ; version . ); const. Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. ; Definition at line 7086 of file TClass.cxx. ◆ GetConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::GetConversionStreamerInfo ; (; const TClass * ; onfile_cl, . Int_t ; version . ); const. Return a Conversion StreamerInfo from the class represented by cl for version number 'version' to this class, if any. ; Definition at line 7097 of file TClass.cxx. ◆ GetConvStreamerFunc(). ClassConvStreamerFunc_t TClass::GetConvStreamerFunc ; (; ); const. Get a wrapper/accessor function around this class custom conversion streamer (member function). ; Definition at line 2947 of file TClass.cxx. ◆ GetCurrentStreamerInfo(). TVirtualStreamerInfo * TClass::GetCurrentStreamerInfo ; (; ). inline . Definition at line 439 of file TClass.h. ◆ GetDataMember(). TDataMember * TClass::GetDataMember ; (; const char * ; datamember); const. Return pointer to datamember object with name ""datamember"". ; Definition at line 3439 of file TClass.cxx. ◆ GetDataMemberOffset(). Longptr_t TClass::GetDataMemberOffset ; (; const char * ; name); const. return offset for member name. ; name can be a data member in the class itself, one of its base classes, or one member in one of the aggregated classes.; In case of an emulated class, the list of emulated TRealData is built ; Definition at line 3477 of file TClass.cxx. ◆ GetDeclFileLine(). Short_t TClass::GetDeclFileLine ; (; ); const. inline . Definition at line 429 of file TClass.h. ◆ GetDeclFileName(). const char * TClass::GetDeclFileName ; (; ); const. Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:77523,access,accessor,77523,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['accessor']
Security," it is not representing an STL collection. ; Definition at line 2953 of file TClass.cxx. ◆ GetContextMenuTitle(). const char * TClass::GetContextMenuTitle ; (; ); const. inline . Definition at line 438 of file TClass.h. ◆ GetConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::GetConversionStreamerInfo ; (; const char * ; onfile_classname, . Int_t ; version . ); const. Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. ; Definition at line 7153 of file TClass.cxx. ◆ GetConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::GetConversionStreamerInfo ; (; const TClass * ; onfile_cl, . Int_t ; version . ); const. Return a Conversion StreamerInfo from the class represented by cl for version number 'version' to this class, if any. ; Definition at line 7164 of file TClass.cxx. ◆ GetConvStreamerFunc(). ClassConvStreamerFunc_t TClass::GetConvStreamerFunc ; (; ); const. Get a wrapper/accessor function around this class custom conversion streamer (member function). ; Definition at line 3014 of file TClass.cxx. ◆ GetCurrentStreamerInfo(). TVirtualStreamerInfo * TClass::GetCurrentStreamerInfo ; (; ). inline . Definition at line 439 of file TClass.h. ◆ GetDataMember(). TDataMember * TClass::GetDataMember ; (; const char * ; datamember); const. Return pointer to datamember object with name ""datamember"". ; Definition at line 3506 of file TClass.cxx. ◆ GetDataMemberOffset(). Longptr_t TClass::GetDataMemberOffset ; (; const char * ; name); const. return offset for member name. ; name can be a data member in the class itself, one of its base classes, or one member in one of the aggregated classes.; In case of an emulated class, the list of emulated TRealData is built ; Definition at line 3544 of file TClass.cxx. ◆ GetDeclFileLine(). Short_t TClass::GetDeclFileLine ; (; ); const. inline . Definition at line 429 of file TClass.h. ◆ GetDeclFileName(). const char * TClass::GetDeclFileName ; (; ); const. Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:77524,access,accessor,77524,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['accessor']
Security," it1->second );; 308 std::string warning = ""IO rule for class "" + className;; 309 ; 310 //-----------------------------------------------------------------------; 311 // Check if we have the source tag; 312 //////////////////////////////////////////////////////////////////////////; 313 ; 314 it1 = rule.find( ""sourceClass"" );; 315 if( it1 == rule.end()); 316 {; 317 error_string = warning + "" - sourceClass parameter is missing"";; 318 return false;; 319 }; 320 ; 321 //-----------------------------------------------------------------------; 322 // Check if we have either version or checksum specified; 323 //////////////////////////////////////////////////////////////////////////; 324 ; 325 it1 = rule.find( ""version"" );; 326 it2 = rule.find( ""checksum"" );; 327 if( it1 == rule.end() && it2 == rule.end() ) {; 328 error_string = warning + "" - you need to specify either version or "";; 329 error_string += ""checksum"";; 330 return false;; 331 }; 332 ; 333 //-----------------------------------------------------------------------; 334 // Check if the checksum has been set to right value; 335 //////////////////////////////////////////////////////////////////////////; 336 ; 337 if( it2 != rule.end() ) {; 338 if( it2->second.size() < 2 || it2->second[0] != '[' ||; 339 it2->second[it2->second.size()-1] != ']' ) {; 340 error_string = warning + "" - a comma separated list of ints"";; 341 error_string += "" enclosed in square brackets expected"";; 342 error_string += "" as a value of checksum parameter"";; 343 return false;; 344 }; 345 ; 346 TSchemaRuleProcessor::SplitList( it2->second.substr( 1, it2->second.size()-2 ),; 347 lst );; 348 if( lst.empty() ) {; 349 error_string += warning + "" - the list of checksums is empty\n"";; 350 }; 351 ; 352 for( const auto& chk : lst ) {; 353 if( !TSchemaRuleProcessor::IsANumber(chk, true) ) {; 354 error_string = warning + "" - "" + chk + "" is not a valid value"";; 355 error_string += "" of checksum parameter - an integer (decimal/hex) expected"";; 356 return fa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html:12239,checksum,checksum,12239,doc/master/RConversionRuleParser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html,4,['checksum'],['checksum']
Security," it;; 871 for( it = versions.begin(); it != versions.end(); ++it ) {; 872 std::pair<Int_t, Int_t> verpair;; 873 if( !Internal::TSchemaRuleProcessor::ProcessVersion( *it, verpair ) ); 874 {; 875 delete fVersionVect;; 876 fVersionVect = nullptr;; 877 return kFALSE;; 878 }; 879 fVersionVect->push_back( verpair );; 880 }; 881 return kTRUE;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Check if specified checksum string is correct and build checksum vector.; 886 ; 887Bool_t TSchemaRule::ProcessChecksum( const TString& checksum ) const; 888{; 889 //---------------------------------------------------------------------------; 890 // Check if we have valid list; 891 /////////////////////////////////////////////////////////////////////////////; 892 ; 893 if (!checksum[0]); 894 return kFALSE;; 895 std::string chk = (const char*)checksum;; 896 if( chk[0] != '[' || chk[chk.size()-1] != ']' ); 897 return kFALSE;; 898 ; 899 std::list<std::string> checksums;; 900 Internal::TSchemaRuleProcessor::SplitList( chk.substr( 1, chk.size()-2), checksums );; 901 ; 902 if( checksums.empty() ) {; 903 delete fChecksumVect;; 904 fChecksumVect = nullptr;; 905 return kFALSE;; 906 }; 907 ; 908 if( !fChecksumVect ); 909 fChecksumVect = new std::vector<UInt_t>;; 910 fChecksumVect->clear();; 911 ; 912 //---------------------------------------------------------------------------; 913 // Check the validity of each list element; 914 /////////////////////////////////////////////////////////////////////////////; 915 ; 916 for( const auto& checksumStr : checksums ) {; 917 auto chksum = ParseChecksum( checksumStr.c_str() );; 918 if (chksum == 0u) {; 919 delete fChecksumVect;; 920 fChecksumVect = nullptr;; 921 return kFALSE;; 922 }; 923 ; 924 fChecksumVect->push_back( chksum );; 925 }; 926 return kTRUE;; 927}; 928 ; 929////////////////////////////////////////////////////////////////////////////////; 930/// Parse the checksum in the given string. Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:29332,checksum,checksums,29332,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,1,['checksum'],['checksums']
Security," its base classes. ;  ; const TList * GetListOfAllPublicMethods (Bool_t load=kTRUE);  Returns a list of all public methods of this class and its base classes. ;  ; TList * GetListOfBases ();  Return list containing the TBaseClass(es) of a class. ;  ; TList * GetListOfDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of a class. ;  ; TList * GetListOfEnums (Bool_t load=kTRUE);  Return a list containing the TEnums of a class. ;  ; TList * GetListOfFunctionTemplates (Bool_t load=kTRUE);  Return TListOfFunctionTemplates for a class. ;  ; TCollection * GetListOfMethodOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TList * GetListOfMethods (Bool_t load=kTRUE);  Return list containing the TMethods of a class. ;  ; TList * GetListOfRealData () const;  ; TList * GetListOfUsingDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of using declarations of a class. ;  ; void GetMenuItems (TList *listitems);  Returns list of methods accessible by context menu. ;  ; TList * GetMenuList () const;  Return the list of menu items associated with the class. ;  ; ROOT::MergeFunc_t GetMerge () const;  Return the wrapper around Merge. ;  ; TMethod * GetMethod (const char *method, const char *params, Bool_t objectIsConst=kFALSE);  Find the best method (if there is one) matching the parameters. ;  ; TMethod * GetMethodAllAny (const char *method);  Return pointer to method without looking at parameters. ;  ; TMethod * GetMethodAny (const char *method);  Return pointer to method without looking at parameters. ;  ; TMethod * GetMethodWithPrototype (const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch);  Find the method with a given prototype. ;  ; void GetMissingDictionaries (THashTable &result, bool recurse=false);  Get the classes that have a missing dictionary starting from this one. ;  ; Int_t GetNdata ();  Return the number of data mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:12276,access,accessible,12276,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,3,['access'],['accessible']
Security," kBigNumber); Add all files referenced in the list to the chain. The object type in the; list must be either TFileInfo or TObjString or TUrl .; The function return 1 if successful, 0 otherwise. TFriendElement* AddFriend(const char* chainname, const char* dummy = """"); -- Add a TFriendElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:31668,access,access,31668,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,6,['access'],['access']
Security, kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; TStringTWebFile::fBasicUrlbasic url without authentication and options; TStringTWebFile::fBasicUrlOrgsave original url in case of temp redirection; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tTWebFile::fHTTP11true if server support HTTP/1.1; Bool_tTWebFile::fHasModRoottrue if server has mod_root installed; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initial,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:21171,authenticat,authentication,21171,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,1,['authenticat'],['authentication']
Security," kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. string_addCoefRangeNameName of reference to be used for RooAddPdf components; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:32554,validat,validate,32554,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,2,"['access', 'validat']","['access', 'validate']"
Security," kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooCatType*_defCat; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVar; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooThresholdCategory.html:21404,access,access,21404,root/html534/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html,1,['access'],['access']
Security," kTRUE, Bool_t allowOptimize = kFALSE); voidsetClearOnRedirect(Bool_t flag); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidRooCacheManager<RooAbsCacheElement>::wireCache(). Data Members; protected:. Bool_t_allowOptimize; static Bool_t_clearObsListClear obslist on sterilize?; Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndex! Last slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSize! Maximum size; vector<RooNormSetCache>RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen!; RooArgSet*_optCacheObservables! current optCacheObservables; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooObjCacheManager.html:3364,access,accessed,3364,root/html602/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html602/RooObjCacheManager.html,2,['access'],['accessed']
Security," kURLforMethod) {; 935 // In the case of method, we append the return type too.; 936 // ""FormatReturnTypeForDoxygen"" modifies the return type with respect to Doxygen's requirement.; 937 md5Text.Append((FormatReturnTypeForDoxygen(scopeName, func)));; 938 if (scopeType == kURLforNameSpace) {; 939 // We need to append ""constexpr"" if we work with constexpr functions in namespaces.; 940 if (func->Property() & kIsConstexpr) {; 941 md5Text.Prepend(""constexpr "");; 942 }; 943 }; 944 md5Text.Append("" "");; 945 }; 946 // We append ScopeName::MethodNameMethodName.; 947 md5Text.Append(scopeName);; 948 md5Text.Append(""::"");; 949 md5Text.Append(methodName);; 950 md5Text.Append(methodName);; 951 // We use ""FormatMethodArgsForDoxygen"" to modify the arguments of Method with respect of Doxygen.; 952 md5Text.Append(FormatMethodArgsForDoxygen(scopeName, func));; 953 // We generate the URL for the class/namespace/struct.; 954 TString url = UrlGenerator(scopeName, scopeType);; 955 url.Append(""#a"");; 956 // We append the hashed text.; 957 url.Append(md5Text.MD5());; 958 return url;; 959}; 960} // namespace; 961 ; 962////////////////////////////////////////////////////////////////////////////////; 963/// It gets the ROOT installation setup as TString; 964///; 965/// \return a string with several lines; 966///; 967TString TApplication::GetSetup(); 968{; 969 std::vector<TString> lines;; 970 lines.emplace_back(""```"");; 971 lines.emplace_back(TString::Format(""ROOT v%s"",; 972 gROOT->GetVersion()));; 973 lines.emplace_back(TString::Format(""Built for %s on %s"", gSystem->GetBuildArch(), gROOT->GetGitDate()));; 974 if (!strcmp(gROOT->GetGitBranch(), gROOT->GetGitCommit())) {; 975 static const char *months[] = {""January"",""February"",""March"",""April"",""May"",; 976 ""June"",""July"",""August"",""September"",""October"",; 977 ""November"",""December""};; 978 Int_t idatqq = gROOT->GetVersionDate();; 979 Int_t iday = idatqq%100;; 980 Int_t imonth = (idatqq/100)%100;; 981 Int_t iyear = (idatqq/10000);; 982 ; 983 lines.emplac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:36432,hash,hashed,36432,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['hash'],['hashed']
Security," keep as is; 24#include ""RConfigure.h""; 25 ; 26#include ""cuda.h""; 27#include ""cuda_runtime.h""; 28#include ""cublas_v2.h""; 29#include ""curand_kernel.h""; 30 ; 31#include ""TMatrixT.h""; 32#include ""CudaBuffers.h""; 33 ; 34#define CUDACHECK(ans) {cudaError((ans), __FILE__, __LINE__); }; 35 ; 36namespace TMVA {; 37namespace DNN {; 38 ; 39/** Function to check cuda return code. Taken from; 40 * http://stackoverflow.com/questions/14038589/; 41 */; 42inline void cudaError(cudaError_t code, const char *file, int line, bool abort=true);; 43 ; 44//____________________________________________________________________________; 45//; 46// Cuda Device Reference; 47//____________________________________________________________________________; 48 ; 49/** TCudaDeviceReference; 50 *; 51 * Helper class emulating lvalue references for AFloat values that are; 52 * physically on the device. Allows for example to assign to matrix elements.; 53 * Note that device access through CudaDeviceReferences enforces synchronization; 54 * with all streams and thus qualifies as performance killer. Only used for; 55 * testing.; 56 */; 57template<typename AFloat>; 58class TCudaDeviceReference; 59{; 60private:; 61 ; 62 AFloat * fDevicePointer;; 63 ; 64public:; 65 ; 66 TCudaDeviceReference(AFloat * devicePointer);; 67 ; 68 operator AFloat();; 69 ; 70 void operator=(const TCudaDeviceReference &other);; 71 void operator=(AFloat value);; 72 void operator+=(AFloat value);; 73 void operator-=(AFloat value);; 74};; 75 ; 76//____________________________________________________________________________; 77//; 78// Cuda Matrix; 79//____________________________________________________________________________; 80 ; 81/** TCudaMatrix Class; 82 *; 83 * The TCudaMatrix class represents matrices on a CUDA device. The elements; 84 * of the matrix are stored in a TCudaDeviceBuffer object which takes care of; 85 * the allocation and freeing of the device memory. TCudaMatrices are lightweight; 86 * object, that means on assignme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaMatrix_8h_source.html:2229,access,access,2229,doc/master/CudaMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaMatrix_8h_source.html,1,['access'],['access']
Security," key used. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootSecContext.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-11-02 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootSecContext.html:7702,secur,security,7702,root/html528/TRootSecContext.html,https://root.cern,https://root.cern/root/html528/TRootSecContext.html,1,['secur'],['security']
Security," key used. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootSecContext.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRootSecContext.html:7771,secur,security,7771,root/html530/TRootSecContext.html,https://root.cern,https://root.cern/root/html530/TRootSecContext.html,1,['secur'],['security']
Security," key used. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootSecContext.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootSecContext.html:7771,secur,security,7771,root/html532/TRootSecContext.html,https://root.cern,https://root.cern/root/html532/TRootSecContext.html,1,['secur'],['security']
Security," known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) std::cout << it->first << "" "";; std::cout << std::endl;; return;; }; Use[regMethod] = 1;; }; }; ; // Create a new root output file.; TString outfileName = ""TMVAMulticlass.root"";; TFile* outputFile = TFile::Open( outfileName, ""RECREATE"" );; ; TMVA::Factory *factory = new TMVA::Factory( ""TMVAMulticlass"", outputFile,; ""!V:!Silent:Color:DrawProgressBar:Transformations=I;D;P;G,D:AnalysisType=multiclass"" );; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""dataset"");; ; dataloader->AddVariable( ""var1"", 'F' );; dataloader->AddVariable( ""var2"", ""Variable 2"", """", 'F' );; dataloader->AddVariable( ""var3"", ""Variable 3"", ""units"", 'F' );; dataloader->AddVariable( ""var4"", ""Variable 4"", ""units"", 'F' );; ; TFile *input(0);; TString fname = ""./tmva_example_multiclass.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_multiclass_example.root"", ""CACHEREAD"");; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAMulticlass: Using input file: "" << input->GetName() << std::endl;; ; TTree *signalTree = (TTree*)input->Get(""TreeS"");; TTree *background0 = (TTree*)input->Get(""TreeB0"");; TTree *background1 = (TTree*)input->Get(""TreeB1"");; TTree *background2 = (TTree*)input->Get(""TreeB2"");; ; gROOT->cd( outfileName+TString("":/"") );; dataloader->AddTree (signalTree,""Signal"");; dataloader->AddTree (background0,""bg0"");; dataloader->AddTree (background1,""bg1"");; dataloader->AddTree (background2,""bg2"");; ; dataloader->PrepareTrainingAndTestTree( """", ""SplitMode=Random:NormMode=NumEvents:!V"" );; ; if (Use[""BDTG""]) // gradient boosted decision trees; factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDTG"", ""!H:!V:NTrees=10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:33964,Access,AccessPathName,33964,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['Access'],['AccessPathName']
Security," labels, title, min/max, log, reverse, ... More...;  ; class  RAttrAxisLabels;  Axis labels drawing attributes. More...;  ; class  RAttrAxisTicks;  Axis ticks attributes. More...;  ; class  RAttrAxisTitle;  Axis title and its drawing attributes. More...;  ; class  RAttrBase;  Base class for all attributes, used with RDrawable. More...;  ; class  RAttrBorder;  Drawing line attributes for different objects. More...;  ; class  RAttrFill;  Drawing fill attributes for different objects. More...;  ; class  RAttrFont;  A font attributes, used together with text attributes. More...;  ; class  RAttrLine;  Drawing line attributes for different objects. More...;  ; class  RAttrLineEnding;  Attributes for line ending. More...;  ; class  RAttrMap;  ; class  RAttrMargins;  A margins attributes. Only relative and pixel coordinates are allowed. More...;  ; class  RAttrMarker;  A marker attributes. More...;  ; class  RAttrText;  A text attributes. More...;  ; class  RAttrValue;  Template class to access single value from drawable or other attributes. More...;  ; class  RAxisBase;  Histogram axis base class. More...;  ; class  RAxisConfig;  Objects used to configure the different axis types. More...;  ; class  RAxisDrawable;  Axis drawing. More...;  ; class  RAxisEquidistant;  Axis with equidistant bin borders. More...;  ; class  RAxisGrow;  An axis that can extend its range, keeping the number of its bins unchanged. More...;  ; class  RAxisIrregular;  An axis with non-equidistant bins (also known as ""variable binning""). More...;  ; class  RAxisLabels;  A RAxisGrow that has a label assigned to each bin and a bin width of 1. More...;  ; class  RBitsetField;  Template specializations for C++ std::bitset. More...;  ; class  RCanvas;  A window's topmost RPad. More...;  ; class  RCanvasDisplayItem;  class RCanvasDisplayItem More...;  ; class  RCanvasPainter;  Implementation of painter for ROOT::Experimental::RCanvas, using RWebWindow. More...;  ; class  RCardinalityField;  An artificial fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html:2259,access,access,2259,doc/master/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html,1,['access'],['access']
Security," labels, title, min/max, log, reverse, ... More...;  ; class  RAttrAxisLabels;  Axis labels drawing attributes. More...;  ; class  RAttrAxisTicks;  Axis ticks attributes. More...;  ; class  RAttrAxisTitle;  Axis title and its drawing attributes. More...;  ; class  RAttrBase;  Base class for all attributes, used with RDrawable. More...;  ; class  RAttrBorder;  Drawing line attributes for different objects. More...;  ; class  RAttrFill;  Drawing fill attributes for different objects. More...;  ; class  RAttrFont;  A font attributes, used together with text attributes. More...;  ; class  RAttrLine;  Drawing line attributes for different objects. More...;  ; class  RAttrLineEnding;  Attributes for line ending. More...;  ; class  RAttrMap;  ; class  RAttrMargins;  A margins attributes. Only relative and pixel coordinates are allowed. More...;  ; class  RAttrMarker;  A marker attributes. More...;  ; class  RAttrText;  A text attributes. More...;  ; class  RAttrValue;  Template class to access single value from drawable or other attributes. More...;  ; class  RAxisBase;  Histogram axis base class. More...;  ; class  RAxisConfig;  Objects used to configure the different axis types. More...;  ; class  RAxisDrawable;  Axis drawing. More...;  ; class  RAxisEquidistant;  Axis with equidistant bin borders. More...;  ; class  RAxisGrow;  An axis that can extend its range, keeping the number of its bins unchanged. More...;  ; class  RAxisIrregular;  An axis with non-equidistant bins (also known as ""variable binning""). More...;  ; class  RAxisLabels;  A RAxisGrow that has a label assigned to each bin and a bin width of 1. More...;  ; class  RBitsetField;  The generic field an std::bitset<N>. More...;  ; class  RCanvas;  A window's topmost RPad. More...;  ; class  RCanvasDisplayItem;  class RCanvasDisplayItem More...;  ; class  RCanvasPainter;  ; class  RCardinalityField;  An artificial field that transforms an RNTuple column that contains the offset of collections into collection si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:2163,access,access,2163,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['access'],['access']
Security," layout is accepted, in which case we take ownership of; the rule object.; return kFALSE if the rule failed one of the test, the rule now needs to be deleted by the caller. void AsString(TString& out) const; Fill the string 'out' with the string representation of the rule. Bool_t HasRuleWithSourceClass(const TString& source) const; Return True if we have any rule whose source class is 'source'. const TObjArray* FindRules(const TString& source) const; Return all the rules that are about the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version) const; Return all the rules that applies to the specified version of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const; Return all the rules that applies to the specified checksum of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const; Return all the rules that applies to the specified version OR checksum of the given 'source' class.; User has to delete the returned array. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName() const. Int_t GetClassVersion() const. const TObjArray* GetRules() const. const TObjArray* GetPersistentRules() const. void RemoveRule(ROOT::TSchemaRule* rule); Remove given rule from the set - the rule is not being deleted!. void RemoveRules(TObjArray* rules); remove given array of rules from the set - the rules are not being deleted!. void SetClass(TClass* cls); Set the TClass associated with this rule set. void Streamer(TBuffer& ); Stream an object of class ROOT::TSchemaRuleSet. TSchemaRuleSet(). » Last changed: root/core:$Id$ » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__TSchemaRuleSet.html:8561,checksum,checksum,8561,root/html534/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html534/ROOT__TSchemaRuleSet.html,2,['checksum'],['checksum']
Security," layout is accepted, in which case we take ownership of; the rule object.; return kFALSE if the rule failed one of the test, the rule now needs to be deleted by the caller. void AsString(TString& out) const; Fill the string 'out' with the string representation of the rule. Bool_t HasRuleWithSourceClass(const TString& source) const; Return True if we have any rule whose source class is 'source'. const TObjArray* FindRules(const TString& source) const; Return all the rules that are about the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version) const; Return all the rules that applies to the specified version of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const; Return all the rules that applies to the specified checksum of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const; Return all the rules that applies to the specified version OR checksum of the given 'source' class.; User has to delete the returned array. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName() const. Int_t GetClassVersion() const. const TObjArray* GetRules() const. const TObjArray* GetPersistentRules() const. void RemoveRule(ROOT::TSchemaRule* rule); Remove given rule from the set - the rule is not being deleted!. void RemoveRules(TObjArray* rules); remove given array of rules from the set - the rules are not being deleted!. void SetClass(TClass* cls); Set the TClass associated with this rule set. void Streamer(TBuffer& ); Stream an object of class ROOT::TSchemaRuleSet. TSchemaRuleSet(). » Last changed: root/core:$Id$ » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaRuleSet.html:9131,checksum,checksum,9131,root/html602/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaRuleSet.html,2,['checksum'],['checksum']
Security," layout is accepted, in which case we take ownership of; the rule object.; return kFALSE if the rule failed one of the test, the rule now needs to be deleted by the caller. void AsString(TString& out) const; Fill the string 'out' with the string representation of the rule. Bool_t HasRuleWithSourceClass(const TString& source) const; Return True if we have any rule whose source class is 'source'. const TObjArray* FindRules(const TString& source) const; Return all the rules that are about the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version) const; Return all the rules that applies to the specified version of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const; Return all the rules that applies to the specified checksum of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const; Return all the rules that applies to the specified version OR checksum of the given 'source' class.; User has to delete the returned array. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName() const. Int_t GetClassVersion() const. const TObjArray* GetRules() const. const TObjArray* GetPersistentRules() const. void RemoveRule(ROOT::TSchemaRule* rule); Remove given rule from the set - the rule is not being deleted!. void RemoveRules(TObjArray* rules); remove given array of rules from the set - the rules are not being deleted!. void SetClass(TClass* cls); Set the TClass associated with this rule set. void Streamer(TBuffer& ); Stream an object of class ROOT::TSchemaRuleSet. TSchemaRuleSet(). » Last changed: root/core:$Id$ » Last generated: 2015-09-08 17:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__TSchemaRuleSet.html:9131,checksum,checksum,9131,root/html604/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html604/ROOT__TSchemaRuleSet.html,2,['checksum'],['checksum']
Security," len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMD5.html:4255,checksum,checksum,4255,root/html602/TMD5.html,https://root.cern,https://root.cern/root/html602/TMD5.html,2,['checksum'],['checksum']
Security," length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTable.html:10874,hash,hashtable,10874,root/html528/THashTable.html,https://root.cern,https://root.cern/root/html528/THashTable.html,6,['hash'],['hashtable']
Security," level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringfNameIdentfier for this object; TProof*fProofhandle to PROOF session; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TStatsFeedback. Function documentation; TStatsFeedback(TProof* proof = 0); Constructor. ~TStatsFeedback(); Destructor. void Feedback(TList* objs); Display feedback. TStatsFeedback(TProof* proof = 0). const char * GetName() const; { return fName.Data(); }. ULong_t Hash() const; { return fName.Hash(); }. » Author: G. Ganis May 2012 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-02 16:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStatsFeedback.html:9692,Hash,Hash,9692,root/html604/TStatsFeedback.html,https://root.cern,https://root.cern/root/html604/TStatsFeedback.html,2,['Hash'],['Hash']
Security," level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringfNameIdentfier for this object; TProof*fProofhandle to PROOF session; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TStatsFeedback. Function documentation; TStatsFeedback(TProof* proof = 0); Constructor. ~TStatsFeedback(); Destructor. void Feedback(TList* objs); Display feedback. TStatsFeedback(TProof* proof = 0). const char * GetName() const; { return fName.Data(); }. ULong_t Hash() const; { return fName.Hash(); }. » Author: G. Ganis May 2012 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStatsFeedback.html:9692,Hash,Hash,9692,root/html602/TStatsFeedback.html,https://root.cern,https://root.cern/root/html602/TStatsFeedback.html,2,['Hash'],['Hash']
Security," line 1123 of file TMath.h. ◆ GhbarC(). constexpr Double_t TMath::GhbarC ; (; ). constexpr . \( \frac{G}{\hbar C} \) in \( (GeV/c^{2})^{-2} \) ; Definition at line 158 of file TMath.h. ◆ GhbarCUncertainty(). constexpr Double_t TMath::GhbarCUncertainty ; (; ). constexpr . \( \frac{G}{\hbar C} \) uncertainty. ; Definition at line 166 of file TMath.h. ◆ Gn(). constexpr Double_t TMath::Gn ; (; ). constexpr . Standard acceleration of gravity in \( m s^{-2} \). ; Definition at line 174 of file TMath.h. ◆ GnUncertainty(). constexpr Double_t TMath::GnUncertainty ; (; ). constexpr . Standard acceleration of gravity uncertainty. ; Definition at line 181 of file TMath.h. ◆ GUncertainty(). constexpr Double_t TMath::GUncertainty ; (; ). constexpr . Gravitational constant uncertainty. ; Definition at line 150 of file TMath.h. ◆ H(). constexpr Double_t TMath::H ; (; ). constexpr . Planck's constant in \( J s \): \( h \). ; Definition at line 188 of file TMath.h. ◆ Hash() [1/2]. ULong_t TMath::Hash ; (; const char * ; str). Definition at line 1416 of file TMath.cxx. ◆ Hash() [2/2]. ULong_t TMath::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). Calculates hash index from any char string. ; Based on pre-calculated table of 256 specially selected numbers. These numbers are selected in such a way, that for string length == 4 (integer number) the hash is unambiguous, i.e. from hash value we can recalculate input (no degeneration).; The quality of hash method is good enough, that ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N) tested by <R>, <R*R>, <Ri*Ri+1> gives the same result as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*)); V.Perev; This function is kept for back compatibility. The code previously in this function has been moved to the static function TString::Hash . Definition at line 1408 of file TMath.cxx. ◆ Hbar(). constexpr Double_t TMath::Hbar ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:46579,Hash,Hash,46579,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['Hash'],['Hash']
Security," line 195 of file MethodDL.h. ◆ fInputLayoutString. TString TMVA::MethodDL::fInputLayoutString. private . The string defining the layout of the input. ; Definition at line 192 of file MethodDL.h. ◆ fInputShape. std::vector<size_t> TMVA::MethodDL::fInputShape. private . Contains the batch size (no. ; of images in the batch), input depth (no. channels) and further input dimensions of the data (image height, width ...) ; Definition at line 178 of file MethodDL.h. ◆ fLayoutString. TString TMVA::MethodDL::fLayoutString. private . The string defining the layout of the deep net. ; Definition at line 194 of file MethodDL.h. ◆ fLossFunction. DNN::ELossFunction TMVA::MethodDL::fLossFunction. private . The loss function. ; Definition at line 190 of file MethodDL.h. ◆ fNet. std::unique_ptr<DeepNetImpl_t> TMVA::MethodDL::fNet. private . Definition at line 209 of file MethodDL.h. ◆ fNumValidationString. TString TMVA::MethodDL::fNumValidationString. private . The string defining the number (or percentage) of training data used for validation. ; Definition at line 199 of file MethodDL.h. ◆ fOutputFunction. DNN::EOutputFunction TMVA::MethodDL::fOutputFunction. private . The output function for making the predictions. ; Definition at line 189 of file MethodDL.h. ◆ fRandomSeed. size_t TMVA::MethodDL::fRandomSeed. private . The random seed used to initialize the weights and shuffling batches (default is zero) ; Definition at line 186 of file MethodDL.h. ◆ fResume. bool TMVA::MethodDL::fResume. private . Definition at line 200 of file MethodDL.h. ◆ fSettings. KeyValueVector_t TMVA::MethodDL::fSettings. private . Map for the training strategy. ; Definition at line 203 of file MethodDL.h. ◆ fTrainingSettings. std::vector<TTrainingSettings> TMVA::MethodDL::fTrainingSettings. private . The vector defining each training strategy. ; Definition at line 204 of file MethodDL.h. ◆ fTrainingStrategyString. TString TMVA::MethodDL::fTrainingStrategyString. private . The string defining the training s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:54084,validat,validation,54084,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['validat'],['validation']
Security," line 209 of file MethodBDT.h. ◆ fTrainWithNegWeights. Bool_t TMVA::MethodBDT::fTrainWithNegWeights. private . yes there are negative event weights and we don't ignore them ; Definition at line 259 of file MethodBDT.h. ◆ fUseExclusiveVars. Bool_t TMVA::MethodBDT::fUseExclusiveVars. private . individual variables already used in fisher criterium are not anymore analysed individually for node splitting ; Definition at line 238 of file MethodBDT.h. ◆ fUseFisherCuts. Bool_t TMVA::MethodBDT::fUseFisherCuts. private . use multivariate splits using the Fisher criterium ; Definition at line 236 of file MethodBDT.h. ◆ fUseNTrainEvents. UInt_t TMVA::MethodBDT::fUseNTrainEvents. private . number of randomly picked training events used in randomised (and bagged) trees ; Definition at line 252 of file MethodBDT.h. ◆ fUseNvars. UInt_t TMVA::MethodBDT::fUseNvars. private . the number of variables used in the randomised tree splitting ; Definition at line 250 of file MethodBDT.h. ◆ fUsePoissonNvars. Bool_t TMVA::MethodBDT::fUsePoissonNvars. private . use ""fUseNvars"" not as fixed number but as mean of a poisson distr. in each split ; Definition at line 251 of file MethodBDT.h. ◆ fUseYesNoLeaf. Bool_t TMVA::MethodBDT::fUseYesNoLeaf. private . use sig or bkg classification in leave nodes or sig/bkg ; Definition at line 239 of file MethodBDT.h. ◆ fValidationSample. std::vector<const TMVA::Event*> TMVA::MethodBDT::fValidationSample. private . the Validation events ; Definition at line 207 of file MethodBDT.h. ◆ fVariableImportance. std::vector<Double_t> TMVA::MethodBDT::fVariableImportance. private . the relative importance of the different variables ; Definition at line 278 of file MethodBDT.h. Libraries for TMVA::MethodBDT:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/MethodBDT.h; tmva/tmva/src/MethodBDT.cxx. TMVAMethodBDT. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:71126,Validat,Validation,71126,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['Validat'],['Validation']
Security," line 269 of file TSystem.h. ◆ EAclicProperties. enum TSystem::EAclicProperties. EnumeratorkFlatBuildDir . Definition at line 270 of file TSystem.h. Constructor & Destructor Documentation. ◆ TSystem() [1/2]. TSystem::TSystem ; (; const TSystem & ; ). privatedelete . ◆ TSystem() [2/2]. TSystem::TSystem ; (; const char * ; name = ""Generic"", . const char * ; title = ""Generic System"" . ). Create a new OS interface. ; Definition at line 125 of file TSystem.cxx. ◆ ~TSystem(). TSystem::~TSystem ; (; ). virtual . Delete the OS interface. ; Definition at line 139 of file TSystem.cxx. Member Function Documentation. ◆ Abort(). void TSystem::Abort ; (; int ; code = 0). virtual . Abort the application. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 725 of file TSystem.cxx. ◆ AcceptConnection(). int TSystem::AcceptConnection ; (; int ; sock). virtual . Accept a connection. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2381 of file TSystem.cxx. ◆ AccessPathName(). Bool_t TSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode = kFileExists . ). virtual . Returns FALSE if one can access a file using the specified access mode. ; The file name must not contain any special shell characters line ~ or $, in those cases first call ExpandPathName(). Attention, bizarre convention of return value!! ; Reimplemented in TDCacheSystem, TNetSystem, TWebSystem, TUnixSystem, and TWinNTSystem.; Definition at line 1296 of file TSystem.cxx. ◆ AddDynamicPath(). void TSystem::AddDynamicPath ; (; const char * ; pathname). virtual . Add a new directory to the dynamic path. ; Reimplemented in TWinNTSystem, and TUnixSystem.; Definition at line 1787 of file TSystem.cxx. ◆ AddFileHandler(). void TSystem::AddFileHandler ; (; TFileHandler * ; h). virtual . Add a file handler to the list of system file handlers. ; Only adds the handler if it is not already in the list of file handlers. ; Reimplemented in TMacOSXSystem, TUnixSystem, and TWinNTSystem.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:34678,Access,AccessPathName,34678,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['Access'],['AccessPathName']
Security," line 57 of file TArchiveFile.h. ◆ GetMemberName(). const char * TArchiveFile::GetMemberName ; (; ); const. inline . Definition at line 56 of file TArchiveFile.h. ◆ GetMembers(). TObjArray * TArchiveFile::GetMembers ; (; ); const. inline . Definition at line 52 of file TArchiveFile.h. ◆ GetNumberOfMembers(). Int_t TArchiveFile::GetNumberOfMembers ; (; ); const. Returns number of members in archive. ; Definition at line 79 of file TArchiveFile.cxx. ◆ IsA(). TClass * TArchiveFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TZIPFile.; Definition at line 61 of file TArchiveFile.h. ◆ Open(). TArchiveFile * TArchiveFile::Open ; (; const char * ; url, . TFile * ; file . ). static . Return proper archive file handler depending on passed url. ; The handler is loaded via the plugin manager and is triggered by the extension of the archive file. In case no handler is found 0 is returned. The file argument is used to access the archive. The archive should be specified as url with the member name as the anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"", where tpc.root is the file in the archive to be opened. Alternatively the sub-file can be specified via its index number, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"". This function is normally only called via TFile::Open(). ; Definition at line 121 of file TArchiveFile.cxx. ◆ OpenArchive(). virtual Int_t TArchiveFile::OpenArchive ; (; ). pure virtual . Implemented in TZIPFile. ◆ operator=(). TArchiveFile & TArchiveFile::operator= ; (; const TArchiveFile & ; ). privatedelete . Not implemented because TArchiveFile can not be copied. . ◆ ParseUrl(). Bool_t TArchiveFile::ParseUrl ; (; const char * ; url, . TString & ; archive, . TString & ; member, . TString & ; type . ). staticprotected . Try to determine if url contains an anchor specifying an archive member. ; Returns kFALSE in case of an error. ; Definition at line 149 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTArchiveFile.html:14970,access,access,14970,doc/master/classTArchiveFile.html,https://root.cern,https://root.cern/doc/master/classTArchiveFile.html,1,['access'],['access']
Security," line 61 of file TWinNTSystem.h. Constructor & Destructor Documentation. ◆ TWinNTSystem(). TWinNTSystem::TWinNTSystem ; (; ). ctor ; Definition at line 985 of file TWinNTSystem.cxx. ◆ ~TWinNTSystem(). TWinNTSystem::~TWinNTSystem ; (; ). virtual . dtor ; Definition at line 1048 of file TWinNTSystem.cxx. Member Function Documentation. ◆ Abort(). void TWinNTSystem::Abort ; (; int ; code = 0). overridevirtual . Abort the application. ; Reimplemented from TSystem.; Definition at line 3949 of file TWinNTSystem.cxx. ◆ AcceptConnection(). int TWinNTSystem::AcceptConnection ; (; int ; socket). overridevirtual . Accept a connection. ; In case of an error return -1. In case non-blocking I/O is enabled and no connections are available return -2. ; Reimplemented from TSystem.; Definition at line 5525 of file TWinNTSystem.cxx. ◆ AccessPathName(). Bool_t TWinNTSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode = kFileExists . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the same as for the WinNT access(2) function. Attention, bizarre convention of return value!! ; Reimplemented from TSystem.; Definition at line 2557 of file TWinNTSystem.cxx. ◆ AddDynamicPath(). void TWinNTSystem::AddDynamicPath ; (; const char * ; dir). overridevirtual . Add a new directory to the dynamic path. ; Reimplemented from TSystem.; Definition at line 4077 of file TWinNTSystem.cxx. ◆ AddFileHandler(). void TWinNTSystem::AddFileHandler ; (; TFileHandler * ; h). overridevirtual . Add a file handler to the list of system file handlers. ; Only adds the handler if it is not already in the list of file handlers. ; Reimplemented from TSystem.; Definition at line 1335 of file TWinNTSystem.cxx. ◆ AddSignalHandler(). void TWinNTSystem::AddSignalHandler ; (; TSignalHandler * ; h). overridevirtual . Add a signal handler to list of system signal handlers. ; Only adds the handler if it is not already in the list of signal handlers. ; Reimpleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:37820,access,access,37820,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,2,['access'],['access']
Security, list. Returns 0 when list is empty. ; Reimplemented from TList.; Definition at line 276 of file TListOfEnumsWithLock.cxx. ◆ LastLink(). TObjLink * TListOfEnumsWithLock::LastLink ; (; ); const. overridevirtual . Reimplemented from TList.; Definition at line 284 of file TListOfEnumsWithLock.cxx. ◆ MakeIterator(). TIterator * TListOfEnumsWithLock::MakeIterator ; (; Bool_t ; dir = kIterForward); const. overridevirtual . Return a list iterator. ; Reimplemented from TList.; Definition at line 220 of file TListOfEnumsWithLock.cxx. ◆ operator=(). TListOfEnumsWithLock & TListOfEnumsWithLock::operator= ; (; const TListOfEnumsWithLock & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfEnumsWithLock::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from TListOfEnums.; Definition at line 190 of file TListOfEnumsWithLock.cxx. ◆ Remove() [1/2]. TObject * TListOfEnumsWithLock::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Reimplemented from TListOfEnums.; Definition at line 201 of file TListOfEnumsWithLock.cxx. ◆ Remove() [2/2]. TObject * TListOfEnumsWithLock::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from TListOfEnums.; Definition at line 210 of file TListOfEnumsWithLock.cxx. ◆ Streamer(). void TListOfEnumsWithLock::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TListOfEnums. ◆ StreamerNVirtual(). void TListOfEnumsWithLock::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inlin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:31868,hash,hash,31868,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,2,['hash'],['hash']
Security," loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to call this method to let RWebWindowsManager correctly recognize such situation. ; Definition at line 116 of file RWebWindowsManager.cxx. ◆ CreateServer(). bool RWebWindowsManager::CreateServer ; (; bool ; with_http = false). private . Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP port, which should be used for the server, provide following entry in rootrc file: ; WebGui.HttpPort: 8088; or specify range of http ports, which can be used: WebGui.HttpPortMin: 8800; WebGui.HttpPortMax: 9800; By default range [8800..9800] is used; One also can bind HTTP server socket to loopback address, In that case only connection from localhost will be available: WebGui.HttpLoopback: yes; Or one could specify hostname which should be used for binding of server socket WebGui.HttpBind: hostname | ipaddress; To use secured protocol, following parameter should be specified WebGui.UseHttps: yes; WebGui.ServerCert: sertificate_filename.pem; Alternatively, one can specify unix socket to handle requests: WebGui.UnixSocket: /path/to/unix/socket; WebGui.UnixSocketMode: 0700; Typically one used unix sockets together with server mode like root --web=server:/tmp/root.socket and then redirect it via ssh tunnel (e.g. using rootssh) to client node; All incoming requests processed in THttpServer in timer handler with 10 ms timeout. One may decrease value to improve latency or increase value to minimize CPU load WebGui.HttpTimer: 10; To processing incoming http requests and websockets, THttpServer allocate 10 threads One have to increase this number if more simultaneous connections are expected: WebGui.HttpThrds: 10; One also can configure usage of special thread of processing of http server requests WebGui.HttpThrd: no; Extra threads can be used to send data to different clients via websocket (default no) WebGui.SenderThrd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:7927,secur,secured,7927,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['secur'],['secured']
Security," locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRFIOFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a RFIO file object. A RFIO file is the same as a TFile; except that it is being accessed via a rfiod server. The url; argument must be of the form: rfio:/path/file.root (where file.root; is a symlink of type /shift/aaa/bbb/ccc) or rfio:server:/path/file.root.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TRFIOFile; object. Use IsZombie() to see if the file is accessable.; For a description of the option and other arguments see the TFile ctor.; The preferred interface to this constructor is via TFile::Open(). ~TRFIOFile(); RFIO file dtor. Close and flush directory structure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it; in a single buffer. Returns kTRUE in case of error. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRFIOFile.html:23041,access,accessed,23041,root/html530/TRFIOFile.html,https://root.cern,https://root.cern/root/html530/TRFIOFile.html,2,['access'],['accessed']
Security," logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. ◆ MinimalErrorHandler(). void ROOT::Internal::MinimalErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). A very simple error handler that is usually replaced by the TROOT default error handler. ; The minimal error handler is not serialized across threads, so that output of multi-threaded programs can get scrambled Noteabort() is only called if abort_bool is true and level >= gErrorIgnoreLevel ; Definition at line 67 of file TError.cxx. ◆ NotifyDirected(). void ROOT::Internal::NotifyDirected ; (; Detail::TBranchProxy * ; x). Definition at line 36 of file TBranchProxyDirector.cxx. ◆ operator<<(). std::ostream & ROOT::Internal::operator<< ; (; std::ostream & ; os, . const RConcurrentHashColl::HashValue & ; h . ). Definition at line 24 of file RConcurrentHashColl.cxx. ◆ operator==(). bool ROOT::Internal::operator== ; (; const RConcurrentHashColl::HashValue & ; lhs, . const RConcurrentHashColl::HashValue & ; rhs . ). inline . Definition at line 69 of file RConcurrentHashColl.hxx. ◆ ParallelReduceHelper(). template<typename T > . static T ROOT::Internal::ParallelReduceHelper ; (; const std::vector< T > & ; objs, . const std::function< T(T a, T b)> & ; redfunc . ). static . A helper function to implement the TThreadExecutor::ParallelReduce methods. ; Definition at line 122 of file TThreadExecutor.cxx. ◆ R__AddPragmaForClass() [1/2]. static bool ROOT::Internal::R__AddPragmaForClass ; (; TTreeProxyGenerator * ; gen, . const char * ; classname . ). static . Add the ""pragma C++ class"" if needed and return true if it has been added or if it is known to not be needed. ; (I.e. return false if a container of this class can not have a ""pragma C++ class"" ; Definition at line 1588 of file TTreeProxyGenerator.cxx. ◆ R__AddPragmaForClass() [2/2]. static bool ROOT::Internal::R__AddPragmaForClass ; (; TTreeProxyGenerator * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:38958,Hash,HashValue,38958,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,2,['Hash'],['HashValue']
Security," long */; 11732 mg_send_http_error(conn,; 11733 414,; 11734 ""Error: Path too long\nput_dir(%s): %s"",; 11735 path,; 11736 strerror(ERRNO));; 11737 return;; 11738 }; 11739 ; 11740 if (rc == -2) {; 11741 /* put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path,; 11746 strerror(ERRNO));; 11747 return;; 11748 }; 11749 ; 11750 /* A file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->status_code = 507;; 11783 }; 11784 ; 11785 /* Create response (status_code has been set before) */; 11786 mg_response_header_start(conn, conn->status_code);; 11787 send_no_cache_header(conn);; 11788 send_additional_header(conn);; 11789 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11790 ; 11791 /* Send all headers - there is no body */; 11792 mg_response",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:340254,access,access,340254,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security," long */; 11733 mg_send_http_error(conn,; 11734 414,; 11735 ""Error: Path too long\nput_dir(%s): %s"",; 11736 path,; 11737 strerror(ERRNO));; 11738 return;; 11739 }; 11740 ; 11741 if (rc == -2) {; 11742 /* put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path,; 11747 strerror(ERRNO));; 11748 return;; 11749 }; 11750 ; 11751 /* A file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->status_code = 507;; 11784 }; 11785 ; 11786 /* Create response (status_code has been set before) */; 11787 mg_response_header_start(conn, conn->status_code);; 11788 send_no_cache_header(conn);; 11789 send_additional_header(conn);; 11790 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11791 ; 11792 /* Send all headers - there is no body */; 11793 mg_response",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:340287,access,access,340287,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security," lower limit of param in the shortest confidence interval Note that this works better for some distributions (ones with exactly one maximum) than others, and sometimes has little value. ;  ; virtual double LowerLimitTailFraction (RooRealVar &param);  determine lower limit of the lower confidence interval ;  ; virtual void SetAxes (RooArgList &axes);  Set which parameters go on which axis. ;  ; virtual void SetChain (MarkovChain &chain);  Set the MarkovChain that this interval is based on. ;  ; void SetConfidenceLevel (double cl) override;  set the desired confidence level (see GetActualConfidenceLevel()) Note: calling this function triggers the algorithm that determines the interval, so call this after initializing all other aspects of this IntervalCalculator Also, calling this function again with a different confidence level re-triggers the calculation of the interval ;  ; virtual void SetDelta (double delta);  kbelasco: The inner-workings of the class really should not be exposed like this in a comment, but it seems to be the only way to give the user any control over this process, if they desire it ;  ; virtual void SetEpsilon (double epsilon);  set the acceptable level or error for Keys interval determination ;  ; virtual void SetHistStrict (bool isHistStrict);  whether the specified confidence level is a floor for the actual confidence level (strict), or a ceiling (not strict) ;  ; virtual void SetIntervalType (enum IntervalType intervalType);  Set the type of interval to find. ;  ; virtual void SetLeftSideTailFraction (double a);  set the left-side tail fraction for a tail-fraction interval ;  ; virtual void SetNumBurnInSteps (Int_t numBurnInSteps);  set the number of steps in the chain to discard as burn-in, starting from the first ;  ; virtual void SetParameters (const RooArgSet &parameters);  Set the parameters of interest for this interval and change other internal data members accordingly. ;  ; virtual void SetShortestInterval ();  ; virtual void SetUseKe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MCMCInterval.html:8086,expose,exposed,8086,doc/master/classRooStats_1_1MCMCInterval.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MCMCInterval.html,1,['expose'],['exposed']
Security," machine, one have to use xvfb-run utility, see also here:; [shell] xvfb-run -s ""-ac -screen 0 1280x1024x24"" node geomsvg.js; 1.11.9 Use with OpenUI5; OpenUI5 is a web toolkit for developers to ease and speed up the development of full-blown HTML5 web applications. JSROOT provides loadOpenui5 function to load supported OpenUI5:; <script type=""module"">; import { loadOpenui5 } from 'path_to_jsroot/modules/main.mjs';; let sap = await loadOpenui5();; sap.registerModulePath(""NavExample"", ""./"");; new sap.m.App ({; pages: [; new sap.m.Page({; title: ""Nav Container"",; enableScrolling : true,; content: [ new sap.ui.core.ComponentContainer({ name : ""NavExample"" })]; }); ]; }).placeAt(""content"");; </script>; JSROOT uses https://openui5.hana.ondemand.com/1.128.0/ when no other source is specified.; There are small details when using OpenUI5 with THttpServer. First of all, location of JSROOT modules should be specified as /jsrootsys/modules/main.mjs. And then trying to access files from local disk, one should specify /currentdir/ folder:; jQuery.sap.registerModulePath(""NavExample"", ""/currentdir/"");; JSROOT provides example showing usage of JSROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, createHistogram, redraw } from 'https://root.cern/js/7.0.0/modules/main.mjs';. It is still possible to use JSRoot.core.js script, which provides very similar (but not identical!) functionality as with v6 via global JSROOT object; JSROOT.define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:34206,access,access,34206,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['access'],['access']
Security," macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMacro.html:8516,Checksum,Checksum,8516,root/html534/TMacro.html,https://root.cern,https://root.cern/root/html534/TMacro.html,2,"['Checksum', 'checksum']","['Checksum', 'checksum']"
Security," manager. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool Sync ();  Synchronize all the formulae. ;  ; virtual void UpdateFormulaLeaves ();  This function could be called TTreePlayer::UpdateFormulaLeaves, itself called by TChain::LoadTree when a new Tree is loaded. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormulaManager.html:2313,Hash,Hash,2313,doc/master/classTTreeFormulaManager.html,https://root.cern,https://root.cern/doc/master/classTTreeFormulaManager.html,2,['Hash'],['Hash']
Security," masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fDirpdirectory handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRFIOSystem(); Create helper class that allows directory access via rfiod.; The name must start with '-' to bypass the TSystem singleton check. Int_t MakeDirectory(const char* name); Make a directory via rfiod. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp); Free directory via rfiod. const char * GetDirEntry(void* dirp); Get directory entry via rfiod. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Int_t Unlink(const char* path); Unlink, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRFIOSystem.html:19976,access,access,19976,root/html530/TRFIOSystem.html,https://root.cern,https://root.cern/root/html530/TRFIOSystem.html,2,['access'],['access']
Security," masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fDirpdirectory handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TWebSystem(); Create helper class that allows directory access via httpd.; The name must start with '-' to bypass the TSystem singleton check. Int_t MakeDirectory(const char* name); Make a directory via httpd. Not supported. void * OpenDirectory(const char* name); Open a directory via httpd. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp); Free directory via httpd. const char * GetDirEntry(void* dirp); Get directory entry via httpd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Int_t Unlink(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TWebSystem.html:19761,access,access,19761,root/html604/TWebSystem.html,https://root.cern,https://root.cern/root/html604/TWebSystem.html,1,['access'],['access']
Security," matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](int j); { return (*fMat)(fRow,j); }. const T & operator[](int j); { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6714,access,access,6714,root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['access'],['access']
Security," maxfcn); voidSetMaxIterations(unsigned int maxiter); voidSetPrecision(double prec); voidSetPrintLevel(int level); voidSetStrategy(int strategyLevel); voidSetTolerance(double tol); virtual boolSetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); voidSetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int, double); virtual boolSetVariableValues(const double* x); intStatus() const; intStrategy() const; doubleTolerance() const; virtual intVariableIndex(const string&) const; virtual stringVariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::Minimizer&operator=(const ROOT::Math::Minimizer& rhs). Data Members; protected:. intfDebugprint level; unsigned intfMaxCallsmax number of function calls ; unsigned intfMaxItermax number or iterations used to find the minimum; doublefPrecprecision; intfStatusstatus of minimizer ; intfStrategyminimizer strategy; doublefToltolerance (absolute); doublefUperror scale ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction & func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction & func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Minimizer.html:4186,validat,validated,4186,root/html526/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Minimizer.html,1,['validat'],['validated']
Security," may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted.; Fix or variable bin size; All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:. Double_t xcenter = h3->GetZaxis()->GetBi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:4093,access,access,4093,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['access'],['access']
Security," member string; TStringfSourceClassSource clss; TObjArray*fSourceVect! Source data member vector (for searching purposes); TStringfTargetTarget data mamber string; TObjArray*fTargetVect! Target data member vector (for searching purposes); TStringfVersionSource version string; vector<std::pair<Int_t,Int_t> >*fVersionVect! Source version vector (for searching purposes). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRule(); Default Constructor. ~TSchemaRule(); Destructor. TSchemaRule(const ROOT::TSchemaRule& rhs); Copy Constructor. void ls(Option_t* option = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump(). Bool_t SetVersion(const TString& version); Set the version string - returns kFALSE if the format is incorrect. Bool_t TestVersion(Int_t version) const; Check if given version number is defined in this rule. Bool_t SetChecksum(const TString& checksum); Set the checksum string - returns kFALSE if the format is incorrect. Bool_t TestChecksum(UInt_t checksum) const; Check if given checksum is defined in this rule. void SetSourceClass(const TString& classname); Set the source class of this rule (i.e. the onfile class). TString GetSourceClass() const; Set the source class of this rule (i.e. the onfile class). void SetTarget(const TString& target); Set the target class of this rule (i.e. the in memory class). const TObjArray* GetTarget() const; Get the target class of this rule (i.e. the in memory class). void SetSource(const TString& source); Set the list of source members. This should be in the form of a declaration:; Int_t fOldMember; TNamed fName;. const TObjArray* GetSource() const; Get the list of source members as a TObjArray of TNamed object,; with the name being the member name and the title being its type. void SetInclude(const TString& include); Set the comma separated list of header files to include to be able; to compile this rule. const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__TSchemaRule.html:8107,checksum,checksum,8107,root/html526/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html526/ROOT__TSchemaRule.html,2,['checksum'],['checksum']
Security," message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3],TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. 18.4.4 Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in order to be fully accessible from external code. The manager class is the owner of all geometry objects defined in a session; therefore, users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. A special case is the one of geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use TGeoMatrix::RegisterYourself() method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.; Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:969033,access,accessible,969033,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessible']
Security," method (remember: method = member function of a class) in the child class (TArrow) as in the parent (TLine) does not give any problem. This is called overriding a method. Draw in TArrow overrides Draw in TLine. There is no possible ambiguity since, when one calls the Draw() method; this applies to an object whose type is known. Suppose we have an object l of type TLine and an object a of type TArrow. When you want to draw the line, you do:; l.Draw();; Draw() from TLine is called. If you do:; a.Draw();; Draw() from TArrow is called and the arrow a is drawn.; 6.2.2 Data Encapsulation; We have seen previously the keyword “public”. This keyword means that every name declared public is seen by the outside world. This is opposed to “private” that means only the class where the name was declared private could see this name. For example, suppose we declare in TArrow the variable ArrowHeadSize private.; private:; int ArrowHeadSize;; Then, only the methods (i.e. member functions) of TArrow will be able to access this variable. Nobody else will see it. Even the classes that we could derive from TArrow will not see it. On the other hand, if we declare the method Draw() as public, everybody will be able to see it and use it. You see that the character public or private does not depend of the type of argument. It can be a data member, a member function, or even a class. For example, in the case of TArrow, the base class TLine is declared as public:; class TArrow : public TLine { ...; This means that all methods of TArrow will be able to access all methods of TLine, but this will be also true for anybody in the outside world. Of course, this is true if TLine accepts the outside world to see its methods/data members. If something is declared private in TLine, nobody will see it, not even TArrow members, even if TLine is declared as a public base class.; What if TLine is declared “private” instead of “public” ? Well, it will behave as any other name declared private in TArrow: only",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:245581,access,access,245581,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security," method SumOfSquareResiduals), and display the histogram. ;  ; virtual void X2P (const Double_t *x, Double_t *p);  Calculate the principal components from the original data vector x, and return it in p. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPrincipal.html:11179,Hash,Hash,11179,doc/master/classTPrincipal.html,https://root.cern,https://root.cern/doc/master/classTPrincipal.html,2,"['Hash', 'hash']","['Hash', 'hash']"
Security," method must be overridden if an object has to react to timers. ; Reimplemented in TGWindow, TGuiBldDragManager, TSessionViewer, TGLEventHandler, TGCommandPlugin, TGDNDManager, TGFileContainer, TGPopupMenu, TGScrollBar, TGShutter, TGTextEdit, TGTextEditor, TGTextEntry, TGTextView, TGToolTip, TGHtml, TVirtualPacketizer, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, TProofPlayerLite, and TTreeViewer.; Definition at line 493 of file TObject.cxx. ◆ Hash(). ULong_t TObject::Hash ; (; ); const. virtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:515; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:42734,Hash,Hash,42734,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['Hash'],['Hash']
Security," method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPerfStats.html:2696,Hash,Hash,2696,root/html528/TPerfStats.html,https://root.cern,https://root.cern/root/html528/TPerfStats.html,2,['Hash'],['Hash']
Security," method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPerfStats.html:2840,Hash,Hash,2840,root/html534/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html534/TVirtualPerfStats.html,1,['Hash'],['Hash']
