quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"ics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value appl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:7436,optimiz,optimize,7436,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['optimiz'],['optimize']
Performance,"ics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the state of the environment does not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:9187,perform,perform,9187,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,5,['perform'],['perform']
Performance,"ics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (5) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (5) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the state of the environment does not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html:9280,perform,perform,9280,docs/4.5/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html,1,['perform'],['perform']
Performance,"idden in the subclass. dump_summary; (bool) If True a summary is recorded each time a new item is added to the the dump. Default is True. summary_sep; (str) delimiter for the summary file. default is a space. data_sep; (str) delimiter for the data files (arrays saved to file). default is a space. summary_file; (str) File path for summary file. Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. level¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation.; Attributes. dump_summary; (bool) When True summary items are appended to the iter_summary. iter_summary; (list of optimizer.OptimIterSummary) Summary at each iteration. dump_fid_err; (bool) When True values are appended to the fid_err_log. fid_err_log; (list of float) Fidelity error at each call of the fid_err_func. dump_grad_norm; (bool) When True values are appended to the fid_err_log. grad_norm_log; (list of float) Gradient norm at each call of the grad_norm_log. dump_grad; (bool) When True values are appended to the grad_log. grad_log; (list of ndarray) Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to fil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:112115,optimiz,optimizer,112115,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimizer']
Performance,"ide these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:232921,optimiz,optimize,232921,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"ide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.filei",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-saving.html:1485,load,loading,1485,docs/3.0.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html,2,['load'],['loading']
Performance,"idelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:211723,perform,performane,211723,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['perform'],['performane']
Performance,"idelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:223810,perform,performane,223810,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['perform'],['performane']
Performance,ient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (DispersivecQED method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/genindex.html:12364,optimiz,optimizer,12364,docs/4.4/genindex.html,https://qutip.org,https://qutip.org/docs/4.4/genindex.html,1,['optimiz'],['optimizer']
Performance,ient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (DispersivecQED method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). p,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/genindex.html:12414,optimiz,optimizer,12414,docs/4.4/genindex.html,https://qutip.org,https://qutip.org/docs/4.4/genindex.html,1,['optimiz'],['optimizer']
Performance,"iew, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:212126,load,load-balanced,212126,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['load'],['load-balanced']
Performance,"if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENS",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:89032,optimiz,optimizerOptimizerInstance,89032,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,4,['optimiz'],['optimizerOptimizerInstance']
Performance,"ify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:96268,cache,cached,96268,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['cache'],['cached']
Performance,"ilds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a pe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:7132,load,load,7132,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['load'],['load']
Performance,"im_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:149936,optimiz,optimize,149936,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"im_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:158768,optimiz,optimize,158768,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"ime correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-parfor.html:1359,perform,performed,1359,docs/4.6/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html,1,['perform'],['performed']
Performance,"imization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:198797,optimiz,optimize,198797,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"imizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4586,optimiz,optimize,4586,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['optimiz'],['optimize']
Performance,"ing the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported. There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised. TerminationConditions; This is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:16272,perform,performed,16272,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['perform'],['performed']
Performance,"ing the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:254081,load,load-balanced,254081,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['load'],['load-balanced']
Performance,"ing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulseoptim. Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:1204,optimiz,optimize,1204,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes:¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012):¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes:¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:6955,perform,performance,6955,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,2,['perform'],['performance']
Performance,"ion 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). In [13]: print(a); [0 1 2 3 4]. In [14]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], typ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-parfor.html:2047,perform,performed,2047,docs/3.0.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html,1,['perform'],['performed']
Performance,"ion2int(_cython_requirement):; print(""QuTiP warning: old version of cython detected "" +; (""(%s), requiring %s."" %; (Cython.__version__, _cython_requirement))). import pyximport; os.environ['CFLAGS'] = '-O3 -w -ffast-math -march=native -mfpmath=sse'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}). except Exception as e:; print(""QuTiP warning: Cython setup failed: "" + str(e)); else:; del Cython, pyximport. # -----------------------------------------------------------------------------; # Load user configuration if present: override defaults.; #; try:; if os.name == ""nt"":; qutip_rc_file = os.path.join(; os.getenv('APPDATA'), 'qutip', ""qutiprc""; ); else:; qutip_rc_file = os.path.join(; # This should possibly be changed to ~/.config/qutiprc,; # to follow XDG specs. Also, OS X uses a different naming; # convention as well.; os.environ['HOME'], "".qutiprc""; ); qutip.settings.load_rc_file(qutip_rc_file). except Exception as e:; try:; qutip.settings._logger.warning(""Error loading RC file."", exc_info=1); except:; pass. # -----------------------------------------------------------------------------; # cpu/process configuration; #; import multiprocessing. # Check if environ flag for qutip processes is set; if 'QUTIP_NUM_PROCESSES' in os.environ:; qutip.settings.num_cpus = int(os.environ['QUTIP_NUM_PROCESSES']); else:; os.environ['QUTIP_NUM_PROCESSES'] = str(qutip.settings.num_cpus). if qutip.settings.num_cpus == 0:; # if num_cpu is 0 set it to the available number of cores; from qutip.hardware_info import hardware_info; info = hardware_info(); if 'cpus' in info:; qutip.settings.num_cpus = info['cpus']; else:; qutip.settings.num_cpus = multiprocessing.cpu_count(). # -----------------------------------------------------------------------------; # Load configuration from environment variables: override defaults and; # configuration file.; #. # check for fortran mcsolver files; try:; from qutip.fortran import mcsolve_f90; except:; qutip.settings.fortran = False",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:6774,load,loading,6774,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['load'],['loading']
Performance,"ionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:54574,optimiz,optimize,54574,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance,ip.operators). num_ctrls (Dynamics attribute). (DynamicsUnitary attribute). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (CircularSpinChain method). (DispersivecQED method). (LinearSpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application (Dynamics attribute). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot_qubism() (in module qutip.visualization). plot_schmidt() (in,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/genindex.html:12173,optimiz,optimizer,12173,docs/4.3/genindex.html,https://qutip.org,https://qutip.org/docs/4.3/genindex.html,1,['optimiz'],['optimizer']
Performance,"iprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-settings.html:2526,load,loaded,2526,docs/4.5/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-settings.html,1,['load'],['loaded']
Performance,"irst things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-basics.html:1193,load,load,1193,docs/4.2/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-basics.html,5,['load'],['load']
Performance,"is case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [27]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [28]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,4.6345969256,2.2937984593,-0.0834019751; 1.0101010101,3.6929064190,0.9743342177,-1.6588904559; 2.0202020202,3.0435621859,-0.7571772825,-1.4733799069; 3.0303030303,2.5588500376,-1.4298597237,-0.1269254187. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [29]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [30]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,4.6345969256e+00,2.2937984593e+00,-8.3401975147e-02; 1.0101010101e+00,3.6929064190e+00,9.7433421768e-01,-1.6588904559e+00; 2.0202020202e+00,3.0435621859e+00,-7.5717728249e-01,-1.4733799069e+00; 3.0303030303e+00,2.5588500376e+00,-1.4298597237e+00,-1.2692541867e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [31]: input_data = file_data_read('expect.dat'). In [32]: shape(input_data); Out[32]: (100, 4). In [33]: from pylab import *. In [34]: plot(input_data[:,0], input_data[:,1]); # plot the data; Out[34]: [<matplotlib.lines.Line2D at 0x2ac6d0b3cfd0>]. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-saving.html:8993,load,loaded,8993,docs/3.0.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html,1,['load'],['loaded']
Performance,"is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-control.html:14741,load,loadparams,14741,docs/4.4/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-control.html,3,['load'],['loadparams']
Performance,"is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-control.html:17285,perform,performance,17285,docs/4.4/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-control.html,4,['perform'],['performance']
Performance,"isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:8681,load,load,8681,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,1,['load'],['load']
Performance,"isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:8498,load,load,8498,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,2,['load'],['load']
Performance,"it (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to store data. Returns:; data : array_like; Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename : str; Name of data file to be stored, including extension. data: array_like; Data to be written to file. numtype : str {‘complex, ‘real’}; Type of numerical data. numformat : str {‘decimal’,’exp’}; Format for written data. sep : str; Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:; name : str; Name of data file to be loaded. Returns:; qobject : instance / array_like; Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data : instance/array_like; Input Python object to be stored. filename : str; Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func : function_type; A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the funct",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:209095,load,loaded,209095,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['load'],['loaded']
Performance,"it gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_fact",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:4781,optimiz,optimizer,4781,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,"it gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:4785,optimiz,optimizer,4785,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,8,['optimiz'],['optimizer']
Performance,"ithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:44522,optimiz,optimize,44522,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance,"ithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:33886,optimiz,optimize,33886,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance,"itten data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name : str. Name of data file to be loaded. Returns:qobject : instance / array_like. Object retrieved from requested file. qsave(data, name='qutip_data')¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:data : instance/array_like. Input Python object to be stored. filename : str. Name of output data file. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. The list or array of values for which the task function is to be; evaluated. args: list / dictionary :. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; clus",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:107850,load,load-balanced,107850,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['load'],['load-balanced']
Performance,"ity matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns; -------; q : Qobj; A new instance of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:43228,cache,cached,43228,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['cache'],['cached']
Performance,"ity matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns; -------; q : Qobj; A new instance of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental.; ; """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another operator. Parameters; ----------; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B.; ; """"""; return mts.dnorm(self, B); ; ; @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:43027,cache,cached,43027,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['cache'],['cached']
Performance,"ity; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and it",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:3232,optimiz,optimize,3232,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['optimiz'],['optimize']
Performance,ix_histogram_complex() (in module qutip.visualization). maximally_mixed_dm() (in module qutip.states). maximum_bipartite_matching() (in module qutip.graph). mcsolve() (in module qutip.mcsolve). MemoryCascade (class in qutip.nonmarkov.memorycascade). mesolve() (in module qutip.mesolve). momentum() (in module qutip.operators). N. n_thermal() (in module qutip.utilities). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls (Dynamics attribute). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). plot_e,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/genindex.html:10652,optimiz,optimizer,10652,docs/4.1/genindex.html,https://qutip.org,https://qutip.org/docs/4.1/genindex.html,2,['optimiz'],['optimizer']
Performance,ize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls (Dynamics attribute). (DynamicsUnitary attribute). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (CircularSpinChain method). (DispersivecQED method). (LinearSpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application (Dynamics attribute). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot_qubism,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/genindex.html:12119,optimiz,optimizer,12119,docs/4.3/genindex.html,https://qutip.org,https://qutip.org/docs/4.3/genindex.html,1,['optimiz'],['optimizer']
Performance,"j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); Out[13]: array([-1.000000e+00, -6.123234e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [14]: psi0 = basis(2,1). In [15]: H = sigmaz(). In [16]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [17]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [18]: es; Out[18]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-eseries.html:5755,perform,performed,5755,docs/4.5/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-eseries.html,1,['perform'],['performed']
Performance,"jOperator in new basis. Notes; This function is still in development. trunc_neg(self, method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(self, inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :. +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number. and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[“w1”]). def f2_t(t, args):return np.cos(t * args[“w2”]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={“w1”:1., “w2”:2.}). For string based coeffien",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:16642,perform,performed,16642,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['perform'],['performed']
Performance,"jOperator in new basis. Notes; This function is still in development. trunc_neg(self, method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(self, inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, tlist=None, copy=True)[source]¶; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :. +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number. and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[“w1”]). def f2_t(t, args):return np.cos(t * args[“w2”]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={“w1”:1., “w2”:2.}). For string based coeffients, the string must be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:16135,perform,performed,16135,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['perform'],['performed']
Performance,"ject.; cosm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; permute(order); Returns composite qobj with indices reordered.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. """"""; __array_priority__ = 100 # sets Qobj priority above numpy arrays. def __init__(self, inpt=None, dims=[[], []], shape=[],; type=None, isherm=None, copy=True,; fast=False, superrep=None):; """"""; Qobj constructor.; """"""; self._isherm = isherm; self._type = type; self.superrep = superrep. if fast == 'mc':; # fast Qobj construction for use in mcsolve with ket output; self._data = inpt; self.dims = dims; self._isherm = False; return. if fa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qobj.html:6902,perform,performing,6902,docs/4.1/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qobj.html,1,['perform'],['performing']
Performance,"ject.; cosm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; permute(order); Returns composite qobj with indices reordered.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object.; ; """"""; __array_priority__ = 100 # sets Qobj priority above numpy arrays. def __init__(self, inpt=None, dims=[[], []], shape=[],; type=None, isherm=None, copy=True,; fast=False, superrep=None):; """"""; Qobj constructor.; """"""; self._isherm = isherm; self._type = type; self.superrep = superrep. if fast == 'mc':; # fast Qobj construction for use in mcsolve with ket output; self._data = inpt; self.dims = dims; self._isherm = False; return. if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:6858,perform,performing,6858,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['perform'],['performing']
Performance,"jects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:1583,load,loading,1583,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,6,['load'],"['load', 'loading']"
Performance,"jects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calcula",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-saving.html:1583,load,loading,1583,docs/4.0.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html,4,['load'],"['load', 'loading']"
Performance,"jugate of quantum object. cosm(); Cosine of quantum object. dag(); Adjoint (dagger) of quantum object. dnorm(); Diamond norm of quantum operator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=’clip’); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm()[source]¶; Check if the quantum object is hermitian. Returns:isherm : bool. Returns the new value of isherm property. conj()[source]¶; Conjugate operator of quantum object. copy()[source]¶; Create identical copy. cosm()[source]¶; Cosine of a quantum operator.; Operator must be square. Returns:oper : qobj. Matrix cosine of operator. Raises:TypeError. Quantum object is not square. Notes; Uses the Q.expm() method. dag()[source]¶; Adjoint o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/classes.html:3902,perform,performing,3902,docs/4.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/classes.html,1,['perform'],['performing']
Performance,"k. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers.; Attributes. solver; (str) Which solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, ...]. times; (list/array) Times at which simulation data was collected. expect; (list/array) Expectation values (if requested) for simulation. states; (array) State of the simulation (density matrix or ket) evaluated at times. num_expect; (int) Number of expectation value operators in simulation. num_collapse; (int) Number of collapse operators in simualation. ntraj; (int/list) Number of trajectories (for stochastic solvers). A list indicates that averaging of expectation values was done over a subset of total number of trajectories. col_times; (list) Times at which state collpase occurred. Only for Monte Carlo solver. col_which; (list) Which collapse operator was responsible for each collapse in col_times. Only for Monte Carlo solver. class Stats(section_names=None)[source]¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters:section_names : list. list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. Attributes. sections; (OrderedDict of _StatsSection) These are the sections that are created automatically on instantiation or added using add_section. header; (string) Some text that will be used as the heading in the report By default there is None. total_time; (float) Time in seconds for the solver to complete processing Can be None, meaning that total timing percentages will be reported. Methods. add_section. add_count. add_timing. add_message. report:; Output the statistics report to console or file. add_count(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:36028,perform,performance,36028,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performance']
Performance,"kron(; h_identity_mat, liouvillian(H_list[idx][0]); ); solver_params.append([temp_mat, H_list[idx][1]]). solver = scipy.integrate.ode(self._dsuper_list_td); solver.set_f_params(solver_params); else:; solver = scipy.integrate.ode(cy_ode_rhs); solver.set_f_params(RHSmat.data, RHSmat.indices, RHSmat.indptr). solver.set_integrator(; ""zvode"",; method=self.options.method,; order=self.options.order,; atol=self.options.atol,; rtol=self.options.rtol,; nsteps=self.options.nsteps,; first_step=self.options.first_step,; min_step=self.options.min_step,; max_step=self.options.max_step,; ). self._ode = solver; self.RHSmat = RHSmat. [docs] def steady_state(; self,; use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False; ):; """"""; Compute the steady state of the system. Parameters; ----------; use_mkl : bool, default=False; Whether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refine : int; Specifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs. For a complete description, see iparm(8) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. mkl_weighted_matching : bool; MKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods. For a complete description, see iparm(13) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. Returns; -------; steady_state : Qobj; The steady state density matrix of the system. steady_ados : :class:`HierarchyADOsState`; The steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling :meth:`.extract`.; """"""; n = self._sys_shape. b_mat = np.zeros(n ** 2 * self._n_ados, dtype=complex); b_mat[0] = 1.0. L = deepcopy(self.RHSmat); L = L.tolil(); L[0, 0: n ** 2 * self._n_ados] = 0.0; L = L.to",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:20742,perform,performs,20742,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,1,['perform'],['performs']
Performance,"l Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:1409,perform,performed,1409,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,3,['perform'],['performed']
Performance,"l Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steady",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-saving.html:1409,perform,performed,1409,docs/4.0.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html,2,['perform'],['performed']
Performance,"l be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Instance of an Optimizer, through which the. Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer. The optimisation can be run through the optimizer.run_optimization. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; These are the periodic o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:147990,optimiz,optimizer,147990,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['optimiz'],['optimizer']
Performance,"l computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steady",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:1469,perform,performed,1469,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,1,['perform'],['performed']
Performance,"l=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:6052,perform,performed,6052,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['perform'],['performed']
Performance,lass in qutip.nonmarkov.memorycascade). mesolve() (in module qutip.mesolve). momentum() (in module qutip.operators). N. n_thermal() (in module qutip.utilities). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls (Dynamics attribute). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/genindex.html:10862,optimiz,optimizer,10862,docs/4.1/genindex.html,https://qutip.org,https://qutip.org/docs/4.1/genindex.html,2,['optimiz'],['optimizer']
Performance,"lation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsula",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-basics.html:1088,load,load,1088,docs/4.2/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-basics.html,5,['load'],['load']
Performance,"lculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/biblio.html:3043,optimiz,optimization,3043,docs/4.2/biblio.html,https://qutip.org,https://qutip.org/docs/4.2/biblio.html,2,['optimiz'],['optimization']
Performance,"ld be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. .. note:: :. Experimental. full(squeeze=False)¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000)¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError :. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:9282,perform,performed,9282,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['perform'],['performed']
Performance,"le below:. Gate name; Description. “RX”; Rotation around x axis. “RY”; Rotation around y axis. “RZ”; Rotation around z axis. “SQRTNOT”; Square root of NOT gate. “SNOT”; Hardmard gate. “PHASEGATE”; Add a phase one the state 1. “CRX”; Controlled rotation around x axis. “CRY”; Controlled rotation around y axis. “CRZ”; Controlled rotation around z axis. “CPHASE”; Controlled phase gate. “CNOT”; Controlled NOT gate. “CSIGN”; Same as CPHASE. “BERKELEY”; Berkeley gate. “SWAPalpha”; SWAPalpha gate. “SWAP”; Swap the states of two qubits. “ISWAP”; Swap gate with additional phase for 01 and 10 states. “SQRTSWAP”; Square root of the SWAP gate. “SQRTISWAP”; Square root of the ISWAP gate. “FREDKIN”; Fredkin gate. “TOFFOLI”; Toffoli gate. “GLOBALPHASE”; Global phase. For some of the gates listed above, qutip.qip.QubitCircuit also has a primitive qutip.qip.QubitCircuit.resolve_gates method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates. However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. Apart from it, there is also a function drawing the circuit with LaTeX code using the Q-qircuit package from http://physics.unm.edu/CQuIC/Qcircuit.; In addition to these pre-defined gates, QuTiP also allows the user to define their own gate. The following example shows how to define a customized gate. Note; Available from QuTiP 4.4. >>> from qutip.qip.circuit import Gate; >>> from qutip.qip.operations import rx; >>> from qutip import Qobj; >>> import numpy as np; >>> def user_gate1(arg_value):; ... # controlled rotation X; ... mat = np.zeros((4, 4), dtype=np.complex); ... mat[0, 0] = mat[1, 1] = 1.; ... mat[2:4, 2:4] = rx(arg_value); ... return Qobj(mat, dims=[[2, 2], [2, 2]]); ...; >>> def user_gate2():; ... # S gate; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); ...; >>>; >>> qc = QubitCircuit(2); >>> qc.user_gates = {""CTRLRX""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-qip.html:3811,optimiz,optimized,3811,docs/4.5/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-qip.html,1,['optimiz'],['optimized']
Performance,"leaky cavity with three different relaxation rates.; from qutip import *; from scipy import *. times = linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_ss(H, times, [sqrt(0.5) * a], x, x); corr2 = correlation_ss(H, times, [sqrt(1.0) * a], x, x); corr3 = correlation_ss(H, times, [sqrt(2.0) * a], x, x). from pylab import *; plot(times, real(corr1), times, real(corr2), times, real(corr3)); xlabel(r'Time $t$'); ylabel(r'Correlation $\left<x(t)x(0)\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to mak",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-correlation.html:5583,perform,performs,5583,docs/3.0.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html,2,['perform'],['performs']
Performance,"left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:12299,perform,perform,12299,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['perform'],['perform']
Performance,"left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:7551,perform,perform,7551,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,1,['perform'],['perform']
Performance,"lement the GRAPE algorithm for; calculating pulse sequences for quantum systems. plot_grape_control_fields(times, u, labels, uniform_axes=False)[source]¶; Plot a series of plots showing the GRAPE control fields given in the; given control pulse matrix u. Parameters:times : array. Time coordinate array. u : array. Control pulse matrix. labels : list. List of labels for each control pulse sequence in the control pulse; matrix. uniform_axes : bool. Whether or not to plot all pulse sequences using the same y-axis scale. grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None, u_limits=None, interp_kind='linear', use_interp=False, alpha=None, beta=None, phase_sensitive=True, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x107b6fd90>)[source]¶; Calculate control pulses for the Hamiltonian operators in H_ops so that the; unitary U is realized.; Experimental: Work in progress. Parameters:U : Qobj. Target unitary evolution operator. H0 : Qobj. Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj. A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int. Number of GRAPE iterations. time : array / list. Array of time coordinates for control pulse evalutation. u_start : array. Optional array with initial control pulse values. Returns:Instance of GRAPEResult, which contains the control pulses calculated. with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator. grape_unitary_adaptive(U, H0, H_ops, R, times, eps=None, u_start=None, u_limits=None, interp_kind='linear', use_interp=False, alpha=None, beta=None, phase_sensitive=False, overlap_terminate=1.0, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x107be58d0>)[source]¶; Calculate control pulses for the Hamiltonian operators in H_ops so that; the unitary U is realized.; Experimental: Work in progress. Parameters:U : Qobj. Target unitary evolution operator. H0 : Qobj. Stati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:128058,tune,tuned,128058,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['tune'],['tuned']
Performance,"lementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:4724,perform,performs,4724,docs/4.6/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html,1,['perform'],['performs']
Performance,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:20132,cache,cached,20132,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,8,['cache'],['cached']
Performance,"lf, value):; if not _is_string(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = N",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:7464,optimiz,optimizer,7464,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,7,['optimiz'],['optimizer']
Performance,"lf.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:12813,optimiz,optimizer,12813,docs/4.3/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html,5,['optimiz'],['optimizer']
Performance,"lf.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:11430,queue,queue,11430,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['queue'],['queue']
Performance,"lgorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:174748,optimiz,optimize,174748,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"lgorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:183318,optimiz,optimize,183318,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/fileio.html:7184,load,load,7184,docs/4.4/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/fileio.html,2,['load'],['load']
Performance,"litude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any config",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:104643,cache,cached,104643,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,3,['cache'],['cached']
Performance,"litudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm; Attributes. max_metric_corr; (integer) The maximum number of variable metric corrections used to define the limited memory matrix. That is the number of previous gradient values that are used to approximate the Hessian see the scipy.optimize.fmin_l_bfgs_b documentation for description of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:65617,optimiz,optimize,65617,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"ll eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Note; Ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:6847,perform,performed,6847,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['perform'],['performed']
Performance,"loat; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:34278,optimiz,optimize,34278,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,loch3d method). add_states() (Bloch method). (Bloch3d method). add_vectors() (Bloch method). (Bloch3d method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). B. basis() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). C. checkherm() (Qobj method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). concurrence() (in module qutip.entropy). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). csign() (in module qutip.qip.gates). D. dag() (Qobj method). destroy() (in module qutip.operators). diag() (Qobj method). dispersive_gate_correction() (DispersivecQED method). DispersivecQED (class in qutip.qip.models.cqed).,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/genindex.html:2716,concurren,concurrence,2716,docs/3.0.0/genindex.html,https://qutip.org,https://qutip.org/docs/3.0.0/genindex.html,2,['concurren'],['concurrence']
Performance,"lphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:181694,optimiz,optimized,181694,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['optimiz'],['optimized']
Performance,"lse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:170661,optimiz,optimizer,170661,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimizer']
Performance,"lse; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default=’COLAMD’; ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:103919,perform,perform,103919,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['perform'],['perform']
Performance,"lse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:68865,optimiz,optimizer,68865,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"lt of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstates = eigenstates_or_projectors; state = eigenstates[i]; else:; projectors = eigenstates_or_projectors; state = (projectors[i] * state * projectors[i]) / probabilities[i]; return eigenvalues[i], state. [docs]def measure_povm(state, ops, targets=None):; r""""""; Perform a measurement specified by list of POVMs. This function simulates a POVM measurement. The measurement collapses the; state ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/measurement.html:8296,perform,perform,8296,docs/4.7/modules/qutip/measurement.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/measurement.html,1,['perform'],['perform']
Performance,"lt of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstates = eigenstates_or_projectors; state = eigenstates[i]; else:; projectors = eigenstates_or_projectors; state = (projectors[i] * state * projectors[i]) / probabilities[i]; return eigenvalues[i], state. def measure_povm(state, ops, targets=None):; r""""""; Perform a measurement specified by list of POVMs. This function simulates a POVM measurement. The measurement collapses the; state to one",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/measurement.html:9970,perform,perform,9970,docs/4.6/modules/qutip/measurement.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/measurement.html,1,['perform'],['perform']
Performance,"ltiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool(processes=kw['num_cpus']); args = [list(arg) for arg in args]; var = [[args[j][i] for j in range(len(args))]; for i in range(len(list(args[0])))]; try:; map_args = ((func, v, os.getpid()) for v in var); par_return = list(pool.map(task_func, map_args)). pool.terminate(); pool.join(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; if isinstance(par_return[0], tuple):; par_return = [elem for elem in par_return]; num_elems = len(par_return[0]); dt = [type(ii) for ii in par_return[0]]; return [array([elem[ii] for elem in par_return], dtype=dt[ii]); for ii in range(num_elems)]; else:; return list(par_return). except KeyboardInterrupt:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(). [docs]def serial_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. resu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/parallel.html:4350,perform,performance,4350,docs/4.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html,5,['perform'],['performance']
Performance,"ltiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool(processes=kw['num_cpus']); args = [list(arg) for arg in args]; var = [[args[j][i] for j in range(len(args))]; for i in range(len(list(args[0])))]; try:; map_args = ((func, v, os.getpid()) for v in var); par_return = list(pool.map(task_func, map_args)). pool.terminate(); pool.join(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; if isinstance(par_return[0], tuple):; par_return = [elem for elem in par_return]; num_elems = len(par_return[0]); dt = [type(ii) for ii in par_return[0]]; return [array([elem[ii] for elem in par_return], dtype=dt[ii]); for ii in range(num_elems)]; else:; return par_return. except KeyboardInterrupt:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(). [docs]def serial_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/parallel.html:4484,perform,performance,4484,docs/4.6/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html,2,['perform'],['performance']
Performance,"ltiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-settings.html:2481,load,loaded,2481,docs/4.4/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-settings.html,1,['load'],['loaded']
Performance,"ltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g. propagators[t2][t1] returns U[t2,t1].; """"""; def __init__(self, H, tlist, options=None):; self.H = H; self.tlist = tlist; if options is None:; self.options = Options(nsteps=10000, normalize_output=False); else:; self.options = options; # Make a blank nested dictionary to store propagators; self.propagators = dict.fromkeys(tlist); for t in tlist:; self.propagators[t] = dict.fromkeys(tlist). def prop(self, tf, ti):; """"""Compute U[t2,t1] where t2 > t1 or return the cached operator. Parameters; ----------; tf : float; Final time to compute the propagator U[tf, ti].; ti : float; Initial time to compute the propagator U[tf,ti]. Returns; -------; propagator : :class: qutip.Qobj; The propagation operator.; """"""; left, right = np.searchsorted(self.tlist, [ti, tf], side='left'); t1, t2 = self.tlist[left], self.tlist[right]; if self.propagators[t2][t1] is None:; self.propagators[t2][t1] = propagator(self.H, [t1, t2],; options=self.options,; unitary_mode='single'); # Something is still broken about batch unitary mode (see #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Retu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/scattering.html:4173,cache,cached,4173,docs/4.3/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/scattering.html,5,['cache'],['cached']
Performance,"lue > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-settings.html:2485,load,loaded,2485,docs/4.2/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-settings.html,1,['load'],['loaded']
Performance,"lue > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-settings.html:2485,load,loaded,2485,docs/4.1/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-settings.html,1,['load'],['loaded']
Performance,"lue, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the obj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:22731,optimiz,optimize,22731,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance,"lue, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; :class:`~qutip.control.optimizer.Optimizer` object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:53587,optimiz,optimize,53587,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"lue, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:54489,optimiz,optimize,54489,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"lues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:7179,perform,performed,7179,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['perform'],['performed']
Performance,"lus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-measurement.html:6812,perform,perform,6812,docs/4.7/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html,1,['perform'],['perform']
Performance,"lus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:6752,perform,perform,6752,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,1,['perform'],['perform']
Performance,"lying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}; Use umfpack solver instead of SuperLU. For SciPy 0.14+, this option; requires installing scikits.umfpack. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-9; ITERATIVE ONLY. Tolerance used for terminating solver. permc_spec : str, optional, default='COLAMD'; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:7136,perform,perform,7136,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['perform'],['perform']
Performance,"l¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method¶; string – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params¶; Dictionary – Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad¶; bool – If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:60611,optimiz,optimize,60611,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"m States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-basics.html:1951,load,load,1951,docs/3.0.1/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html,1,['load'],['load']
Performance,"m the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result – The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. Return type:list. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the va",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:201586,load,load-balanced,201586,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['load'],['load-balanced']
Performance,"m). # check extra inputs; e_ops, e_ops_dict = _check_e_ops(e_ops); pbar = _check_progress_bar(progress_bar). # transform inputs type from Qobj to np.ndarray/csr_matrix; if sparse:; _H = H.get_data() # (fast_) csr_matrix; else:; _H = H.full().copy() # np.ndarray; _psi = psi0.full().copy(); _psi = _psi / np.linalg.norm(_psi). # create internal variable and output containers; if options is None:; options = Options(nsteps=10000); krylov_results = Result(); krylov_results.solver = ""krylovsolve"". # handle particular cases of an empty tlist or single element; n_tlist_steps = len(tlist); if n_tlist_steps < 1:; return krylov_results. if n_tlist_steps == 1: # if tlist has only one element, return it; krylov_results = particular_tlist_or_happy_breakdown(; tlist, n_tlist_steps, options, psi0, e_ops, krylov_results, pbar; ) # this will also raise a warning; return krylov_results. tf = tlist[-1]; t0 = tlist[0]. # optimization step using Lanczos, then reuse it for the first partition; dim_m = krylov_dim; krylov_basis, T_m = lanczos_algorithm(; _H, _psi, krylov_dim=dim_m, sparse=sparse; ). # check if a happy breakdown occurred; if T_m.shape[0] < krylov_dim + 1:; if T_m.shape[0] == 1:; # this means that the state does not evolve in time, it lies in a; # symmetry of H subspace. Thus, theres no work to be done.; krylov_results = particular_tlist_or_happy_breakdown(; tlist,; n_tlist_steps,; options,; psi0,; e_ops,; krylov_results,; pbar,; happy_breakdown=True,; ); return krylov_results; else:; # no optimization is required, convergence is guaranteed.; delta_t = tf - t0; n_timesteps = 1; else:. # calculate optimal number of internal timesteps.; delta_t = _optimize_lanczos_timestep_size(; T_m, krylov_basis=krylov_basis, tlist=tlist, options=options; ); n_timesteps = int(ceil((tf - t0) / delta_t)). if n_timesteps >= options.nsteps:; raise Exception(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:4054,optimiz,optimization,4054,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['optimiz'],['optimization']
Performance,"m_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn,; pulse_params=ramping_pulse_params)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:65784,perform,performance,65784,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,3,['perform'],['performance']
Performance,"malize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True). Check for degenerate ground state. Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/classes.html:10258,perform,performed,10258,docs/4.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/classes.html,1,['perform'],['performed']
Performance,"mall elements removed. tr()¶; Trace of a quantum object. Returns:trace: float. Returns real if operator is Hermitian, returns complex; otherwise. trans()¶; Transposed operator. Returns:oper : qobj. Transpose of input operator. transform(inpt, inverse=False)¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:inpt : array_like. A matrix or list of kets defining the transformation. inverse : bool. Whether to return inverse transformation. Returns:oper : qobj. Operator in new basis. Notes; This function is still in development. unit(norm=None, sparse=False, tol=0, maxiter=100000)¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:norm : str. Requested norm for states / operators. sparse : bool. Use sparse eigensolver for trace norm. Does not affect other norms. tol : float. Tolerance used by sparse eigensolver. maxiter: int. Number of maximum iterations performed by sparse eigensolver. Returns:oper : qobj. Normalized quantum object. eseries¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))¶; Class representation of an exponential-series expansion of; time-dependent quantum objects.; Attributes. ampl; (ndarray) Array of amplitudes for exponential series. rates; (ndarray) Array of rates for exponential series. dims; (list) Dimensions of exponential series components. shape; (list) Shape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:wlist : array_like. Array/list of frequenies. Returns:val_list : ndarray. Values of exponential series at frequencies in wlist. tidyup(*args)¶; Returns a tidier ve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:14595,perform,performed,14595,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['perform'],['performed']
Performance,"mation Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:; As an example, we can add a single data point:; In [3]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [4]: b.add_points(pnt). In [5]: b.show(); <Figure size 500x500 with 1 Axes>. and then a single vector:; In [6]: vec = [0,1,0]. In [7]: b.add_vectors(vec). In [8]: b.show(); <Figure size 500x500 with 1 Axes>. and then add another vector corresponding to the \(\left|\rm up \right>\) state:; In [9]: up = basis(2,0). In [10]: b.add_states(up). In [11]: b.show(); <Figure size 500x500 with 1 Axes>. Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the code for constructing our Bloch sphere with one vector, one state, and a sin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-bloch.html:1885,load,loads,1885,docs/4.5/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-bloch.html,1,['load'],['loads']
Performance,"maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gradient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:15828,optimiz,optimize,15828,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['optimiz'],['optimize']
Performance,"me and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the; ``termination_conditions`` matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics genera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:23776,optimiz,optimize,23776,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"me-dependent Hamiltonian) The time-dependent Hamiltonian that realize the GRAPE pulse sequence. U_f; (Qobj) The final unitary transformation that is realized by the evolution of the system with the GRAPE generated pulse sequences. class Dynamics(optimconfig)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before any of the methods; can be used.; Attributes. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN Note value should be set using set_log_level. stats; (Stats) Attributes of which give performance stats for the optimisation set to None to reduce overhead of calculating stats. Note it is (usually) shared with the Optimizer object. tslot_computer; (TimeslotComputer (subclass instance)) Used to manage when the timeslot dynamics generators, propagators, gradients etc are updated. prop_computer; (PropagatorComputer (subclass instance)) Used to compute the propagators and their gradients. fid_computer; (FidelityComputer (subclass instance)) Used to computer the fidelity error and the fidelity error gradient. num_tslots; (integer) Number of timeslots, aka timeslices. num_ctrls; (integer) Number of controls. Note this is set when get_num_ctrls is called based on the length of ctrl_dyn_gen. evo_time; (float) Total time for the evolution. tau; (array[num_tslots] of float) Duration of each timeslot Note that if this is set before initialize_controls is called then num_tslots and evo_time are calculated from tau, otherwise tau is generated from num_tslots and evo_time, that is equal size time slices. ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:45951,perform,performance,45951,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['perform'],['performance']
Performance,"mes \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:155901,optimiz,optimize,155901,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,3,['optimiz'],['optimize']
Performance,method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stocha,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:19780,optimiz,optimizer,19780,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,2,['optimiz'],['optimizer']
Performance,"mics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the state of the environment does not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:10452,perform,perform,10452,docs/3.0.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html,3,['perform'],['perform']
Performance,micsUnitary attribute). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (CircularSpinChain method). (DispersivecQED method). (LinearSpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application (Dynamics attribute). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot_qubism() (in module qutip.visualization). plot_schmidt() (in module qutip.visualization). plot_spin_distribution,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/genindex.html:12225,optimiz,optimizer,12225,docs/4.3/genindex.html,https://qutip.org,https://qutip.org/docs/4.3/genindex.html,1,['optimiz'],['optimizer']
Performance,"min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.options.average_states):; states = np.array([Qobj()] * nstep); if (self.sparse_dms):; # averaged sparse density matrices; for i in range(nstep):; qtf90.qutraj_run",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13374,queue,queue,13374,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['queue'],['queue']
Performance,"misation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:44183,perform,performane,44183,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['perform'],['performane']
Performance,"misation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:33547,perform,performane,33547,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['perform'],['performane']
Performance,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:1825,perform,performance,1825,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['perform'],['performance']
Performance,"more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the nea",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:12974,optimiz,optimization,12974,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['optimiz'],['optimization']
Performance,"mp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:64976,optimiz,optimize,64976,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"mping that will occur; SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary(self)[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(self, fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(self, grad)[source]¶; add an entry to the grad log. update_grad_norm_log(self, grad_norm)[source]¶; add an entry to the grad_norm log. writeout(self, f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:131670,optimiz,optimizer,131670,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimizer']
Performance,"mplemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:12460,optimiz,optimize,12460,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['optimiz'],['optimize']
Performance,"mplex); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape=_tmp.shape); if not np.any(dims):; self.dims = [[1], [1]]; else:; self.dims = dims. else:; warnings.warn(""Initializing Qobj from unsupported type: %s"" %; builtins.type(inpt)); inpt = np.array([[0]]); _tmp = sp.csr_matrix(inpt, dtype=complex, copy=copy); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape = _tmp.shape); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]. if type == 'super':; # Type is not super, i.e. dims not explicitly passed, but oper shape; if dims== [[], []] and self.shape[0] == self.shape[1]:; sub_shape = np.sqrt(self.shape[0]); # check if root of shape is int; if (sub_shape % 1) != 0:; raise Exception('Invalid shape for a super operator.'); else:; sub_shape = int(sub_shape); self.dims = [[[sub_shape], [sub_shape]]]*2. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data; #Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; self._isunitary = None. if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; if isinstance(other, (int, float, complex, np.integer, np.floating,; np.complexfloating, np.ndarray, list, tuple)) \; or sp.issparse(other):; other = Qobj(other); else:; return NotImplemented. if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:11382,cache,cache,11382,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['cache'],['cache']
Performance,"mplex); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape=_tmp.shape); if not np.any(dims):; self.dims = [[1], [1]]; else:; self.dims = dims. else:; warnings.warn(""Initializing Qobj from unsupported type: %s"" %; builtins.type(inpt)); inpt = np.array([[0]]); _tmp = sp.csr_matrix(inpt, dtype=complex, copy=copy); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape = _tmp.shape); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]. if type == 'super':; # Type is not super, i.e. dims not explicitly passed, but oper shape; if dims== [[], []] and self.shape[0] == self.shape[1]:; sub_shape = np.sqrt(self.shape[0]); # check if root of shape is int; if (sub_shape % 1) != 0:; raise Exception('Invalid shape for a super operator.'); else:; sub_shape = int(sub_shape); self.dims = [[[sub_shape], [sub_shape]]]*2. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data; #Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; self._isunitary = None. if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; other = Qobj(other). if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.data = self.data + dat * fast_identity(; self.shape[0]); else:; out.data = self.data; out.data.data = out.data.data + dat. out.dims = self.dims. if settings.auto_tidyup: out",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:11386,cache,cache,11386,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['cache'],['cache']
Performance,"mplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:82407,optimiz,optimize,82407,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"mplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and detail",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:196262,optimiz,optimize,196262,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"mputerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:205607,perform,perform,205607,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['perform'],['perform']
Performance,"ms (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:166534,optimiz,optimize,166534,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"ms : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:23245,optimiz,optimize,23245,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance,"ms). # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:65128,optimiz,optimizer,65128,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/biblio.html:2669,optimiz,optimization,2669,docs/4.7/biblio.html,https://qutip.org,https://qutip.org/docs/4.7/biblio.html,1,['optimiz'],['optimization']
Performance,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/biblio.html:3024,optimiz,optimization,3024,docs/4.5/biblio.html,https://qutip.org,https://qutip.org/docs/4.5/biblio.html,2,['optimiz'],['optimization']
Performance,mul_mat() (QobjEvo method). mul_vec() (QobjEvo method). N. n_thermal() (in module qutip.utilities). Noise (class in qutip.qip.noise). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:19493,optimiz,optimizer,19493,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,1,['optimiz'],['optimizer']
Performance,"multiplication. Default; None means auto check. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers. Attributes. solverstrWhich solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, …]. timeslist/arrayTimes at which simulation data was collected. expectlist/arrayExpectation values (if requested) for simulation. statesarrayState of the simulation (density matrix or ket) evaluated at times. num_expectintNumber of expectation value operators in simulation. num_collapseintNumber of collapse operators in simualation. ntrajint/listNumber of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_timeslistTimes at which state collpase occurred. Only for Monte Carlo solver. col_whichlistWhich collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class Stats(section_names=None)[source]¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters. section_nameslistlist of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(self, name); Add another section with the given name. add_count(self, key, value[, section]); Add value to count. add_tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:42235,perform,performance,42235,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['perform'],['performance']
Performance,"n a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future appli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2350,perform,perform,2350,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,1,['perform'],['perform']
Performance,"n delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, method=""brentq"", xtol=options.atol); if sol.converged:; delta_t = sol.root; return delta_t; else:; raise Exception(; ""Method did not converge, try increasing 'krylov_dim', ""; ""taking a lesser final time 'tlist[-1]' or decreasing the ""; ""tolerance via Options().atol. ""; ""If nothing works, this problem might not be suitable for ""; ""Krylov or a deeper analysis might be required.""; ). def _lanczos_error_equation_to_optimize_delta_t(; T, krylov_basis, t0, tf, target_tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteractions.; """"""; eigenvalues1, eigenvectors1 = eigh(T[0:, 0:]); U1 = np.matmul(krylov_basis[0:, 0:].T, eigenvectors1); e01 = eigenvectors1.conj().T[:, 0]. eigenvalues2, eigenvectors2 = eigh(T[0:-1, 0: T.shape[1] - 1]); U2 = np.matmul(krylov_basis[0:-1, :].T, eigenvectors2); e02 = eigenvectors2.conj().T[:, 0]. def f(t):; delta_t = -1j * (t - t0). aux1 = np.multiply(np.exp(delta_t * eigenvalues1), e01); psi1 = np.matmul(U1, aux1). aux2 = np.multiply(np.exp(delta_t * eigenvalues2), e02); psi2 = np.matmul(U2, aux2). error = np.linalg.norm(psi1 - psi2). steps = max(1, (tf - t0) // (t - t0)); return np.log10(error) + np.log10(steps) - np.log10(target_tolerance). return f. def _make_partitions(tlist, n_timesteps):; """"""Generates an internal 'partitions' list of np.arrays to iterate Lanczos; algorithms on each of them, based on 'tlist' and the optimized number of; iterations ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:15686,optimiz,optimize,15686,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['optimiz'],['optimize']
Performance,"n qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.29179401, 3.37589742, 2.75659972, 2.30562634, 1.97257341,; 1.72505191, 1.54045945, 1.40251047, 1.2992826 , 1.22196967]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understoo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-saving.html:2993,load,load,2993,docs/4.0.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html,1,['load'],['load']
Performance,"n qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.21111367, 3.243081 , 2.64337648, 2.2162089 , 1.90369673,; 1.67257851, 1.50071221, 1.37250326, 1.27667537, 1.20496022]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-saving.html:2993,load,load,2993,docs/4.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-saving.html,1,['load'],['load']
Performance,"n qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 5.47236604, 4.25321934, 3.40221147, 2.78459863, 2.32939541,; 1.99152365, 1.739766 , 1.55173281, 1.41108289, 1.30577149]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:3793,load,load,3793,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,1,['load'],['load']
Performance,"n qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 3.87543797, 3.11893669, 2.5717301 , 2.17012827, 1.87240607,; 1.65062668, 1.48498272, 1.36107052, 1.26828395, 1.19875921]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-saving.html:3691,load,load,3691,docs/3.0.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html,1,['load'],['load']
Performance,"n qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 5.05864971, 3.933244 , 3.16570274, 2.60846057, 2.19781898,; 1.8930801 , 1.66604188, 1.49648702, 1.36966702, 1.27471483]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understoo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-saving.html:3753,load,load,3753,docs/3.0.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html,1,['load'],['load']
Performance,"n the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:42216,perform,performed,42216,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['perform'],['performed']
Performance,"n the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:39017,perform,performed,39017,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,4,['perform'],['performed']
Performance,"n will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Paramet",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:44447,perform,performance,44447,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['perform'],['performance']
Performance,"n will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:43377,perform,performance,43377,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['perform'],['performance']
Performance,"n, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular.; This function looks at both the structure and ABS values of the; underlying matrix. Parameters:; A (csc_matrix) – Input matrix; perm_type (str {'row', 'column'}) – Type of permutation to generate. Returns:perm – Array of row or column permutations. Return type:array. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; I. S. Duff and J. Koster, “The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices”, SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters:; w (float or array) – Frequency of the oscillator.; w_th (float) – The temperature in units of frequency (or the same units as w). Returns:n_avg – Return the number of average photons in thermal equilibrium for a; an osci",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:192391,perform,performing,192391,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['perform'],['performing']
Performance,"n. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propaga",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:89813,perform,performance,89813,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,4,['perform'],['performance']
Performance,"n; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html:3921,optimiz,optimizer,3921,docs/4.0.2/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html,2,['optimiz'],['optimizer']
Performance,"n; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html:3921,optimiz,optimizer,3921,docs/4.2/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html,2,['optimiz'],['optimizer']
Performance,"n; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimresult.html:3921,optimiz,optimizer,3921,docs/4.1/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimresult.html,2,['optimiz'],['optimizer']
Performance,"n; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:3872,perform,performance,3872,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,8,['perform'],['performance']
Performance,"n_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes:; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num :",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:79036,optimiz,optimize,79036,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"n_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation; Attributes. iter_num; (int) Iteration number of the pulse optimisation. fid_func_call_num; (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:68146,optimiz,optimize,68146,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"nal Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[sour",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:43775,concurren,concurrence,43775,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['concurren'],['concurrence']
Performance,"ncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions by providing the following advantages:. QuTiP relies on completely open-source software. You are free to modify and use it as you wish with no licensing fees.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created usi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/frontmatter.html:5536,perform,performance,5536,docs/3.0.1/frontmatter.html,https://qutip.org,https://qutip.org/docs/3.0.1/frontmatter.html,1,['perform'],['performance']
Performance,"ncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions by providing the following advantages:. QuTiP relies on completely open-source software. You are free to modify and use it as you wish with no licensing fees.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created usi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/frontmatter.html:5474,perform,performance,5474,docs/3.0.0/frontmatter.html,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html,1,['perform'],['performance']
Performance,"nce measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; Attributes. scale_factor; (float) The fidelity error calculated is of some arbitary scale. This factor can be used to scale the fidelity error such that it may represent some physical measure If None is given then it is caculated as 1/2N, where N is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients; Attributes. epsilon; (float) control amplitude offset to use when approximating the gradient wrt a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on; Att",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:94325,cache,cached,94325,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['cache'],['cached']
Performance,"nces = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.lin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:12168,cache,cache,12168,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,1,['cache'],['cache']
Performance,"nces = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:13844,cache,cache,13844,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,1,['cache'],['cache']
Performance,"nd how it was obtained. sparse : bool, optional, default = True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. x0 : ndarray, optional. ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000. ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12. ITERATIVE ONLY. Tolerance used for terminating solver. permc_spec : str, optional, default=’COLAMD’. ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precond : bool optional, default = False. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factor : float, option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:102431,perform,perform,102431,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['perform'],['perform']
Performance,"nd(e_0). e_m_0 = []; for m in range(n_expt_op):; op = e_ops[m]. if not isinstance(op, Qobj) and callable(op):; e_m_0.append(op(0, psi0)); res.expect[m][0] = e_m_0[m]; continue. e_m_0.append(expect(op, psi0)); res.expect[m][0] = e_m_0[m]. if happy_breakdown:; res = _happy_breakdown(; tlist,; options,; res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, me",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:14201,optimiz,optimize,14201,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,2,"['optimiz', 'perform']","['optimize', 'performed']"
Performance,"ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen¶; bool – If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad¶; bool – If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj¶; bool – If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp¶; bool – If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots¶; integer – Number of timeslots (aka timeslices). num_ctrls¶; integer – Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time¶; float – Total time for the evolution. tau¶; array[num_tslots] of float – Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time¶; array[num_tslots+1] of float – Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen¶; Qobj or list of Qobj – Drift or system dynamic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:79000,cache,cached,79000,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['cache'],['cached']
Performance,"ndarrayArray of coeffcients defining cubic spline. Non-Markovian Solvers¶. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:29977,perform,performance,29977,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,3,['perform'],['performance']
Performance,"ndblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:2554,perform,perform,2554,docs/3.0.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html,3,['perform'],['perform']
Performance,"nderlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. For SciPy 0.14+, this option; requires installing scikits.umfpack. x0 : ndarray, optional. ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000. ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-9. ITERATIVE ONLY. Tolerance used for terminating solver. permc_spec : str, optional, default=’COLAMD’. ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precond : bool optional, default = False. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factor : float, optiona",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:90873,perform,perform,90873,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['perform'],['perform']
Performance,"ne[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/fileio.html:7197,load,load,7197,docs/4.5/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/fileio.html,2,['load'],['load']
Performance,"near operators.; Superoperators can be represented; using the isomorphism; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\) [Hav03], [Wat13].; To represent superoperators acting on \(\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)\) thus takes some tensor rearrangement to get the desired ordering; \(\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2\).; In particular, this means that qutip.tensor does not act as; one might expect on the results of qutip.to_super:; >>> A = qeye([2]). >>> B = qeye([3]). >>> to_super(tensor(A, B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-tensor.html:11495,perform,performs,11495,docs/4.6/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html,1,['perform'],['performs']
Performance,"need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [6,7] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of mag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:10375,perform,performing,10375,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['perform'],['performing']
Performance,"nenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value.; ; if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2); ; # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; ; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices, J_dat.indptr), ; shape=J_dat.shape); ; Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices, J_dat.indptr),; shape=J_dat.shape); # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose); ; return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchfor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/metrics.html:12010,cache,cache,12010,docs/4.3/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/metrics.html,2,['cache'],['cache']
Performance,"nerating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-measurement.html:1573,perform,perform,1573,docs/4.7/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html,1,['perform'],['perform']
Performance,"nerators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more informati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:5860,perform,performance,5860,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,4,['perform'],['performance']
Performance,"nerators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more informatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:7037,perform,performance,7037,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,4,['perform'],['performance']
Performance,"new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:25881,load,loading,25881,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,1,['load'],['loading']
Performance,"ng (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:175054,optimiz,optimize,175054,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"ng (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; U",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:183624,optimiz,optimize,183624,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"ng Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear(). Removes all data from Bloch sphere.; Keeps customi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-bloch.html:1840,load,loads,1840,docs/4.4/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-bloch.html,1,['load'],['loads']
Performance,"ng Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps cust",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-bloch.html:1844,load,loads,1844,docs/4.2/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-bloch.html,4,['load'],['loads']
Performance,"ng Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. « Visualization of... Saving QuTiP Obj... ». Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-parfor.html:2022,perform,performing,2022,docs/3.1.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html,1,['perform'],['performing']
Performance,"ng Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:206150,cache,cache,206150,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['cache'],['cache']
Performance,"ng factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:8776,perform,perform,8776,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,8,['perform'],['perform']
Performance,"ng maybe made with memory_optimization > 1. The options are processed in _set_memory_optimizations, see this for more information. Individual memory saving options can be switched by settting them directly (see below). oper_dtype; (type) Data type for internal dynamics generators, propagators and time evolution operators. This can be ndarray or Qobj, or (in theory) any other representaion that supports typical matrix methods (e.g. dot) ndarray performs best for smaller quantum systems. Qobj may perform better for larger systems, and will also perform better when (custom) fidelity measures use Qobj methods such as partial trace. See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen; (bool) If True then the dynamics generators will be saved with and without the propagation prefactor (if there is one) Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad; (bool) If the True then the propagator gradients (for exact gradients) will be computed when the propagator are computed and cache until the are used by the fidelity computer. If False then the fidelity computer will calculate them as needed. Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of the Hamiltion eignvector matrix Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue decomposition. Defaults to True when memory_optimization<=1, otherwise False. num_tslots; (integer) Number of timeslots (aka timeslices). evo_time; (float) Total time for the evolution. tau; (array[num_tslots] of float) Duration of each timeslot Note that if this is set before initialize_controls is called then num_tslots and evo_time are calculated from tau, otherwise tau is generated from num_tslots and evo_time, that is equal size time slices. time; (array[num_tslots+1] of float) Cumulative ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:75784,cache,cache,75784,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['cache'],['cache']
Performance,"ng on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox counterpart by a substantial margin as the system size increases. To test the Monte Carlo solvers, here we simulate a trilinear Hamiltonian over a range of Hilbert space sizes. Since QuTiP uses multiprocessing, we can measure the performance gain when using several CPU’s. In contrast, the qotoolbox is limited to a single processor only. In the legend, we show the speed-up factor in the parenthesis, which should ideally be equal to the number of processors. Finally, we have included the results using hyperthreading, written here as 4+(x) where x is the number of hyperthreads, found in some newer Intel processors. We see however that the performance benefits from hyperthreading are marginal at best. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-performance.html:1912,perform,performs,1912,docs/3.0.0/guide/dynamics/dynamics-performance.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-performance.html,3,['perform'],"['performance', 'performs']"
Performance,"ng operators; Quantum process tomography; Implementation in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-visualization.html:1641,perform,perform,1641,docs/4.5/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-visualization.html,1,['perform'],['perform']
Performance,"ng pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:182051,optimiz,optimizer,182051,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,3,['optimiz'],['optimizer']
Performance,"ng statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:26166,perform,performance,26166,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performance']
Performance,"ng that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of qutip.control.optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.Evo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:277238,optimiz,optimizer,277238,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['optimiz'],['optimizer']
Performance,"ng the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Ins",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:10447,perform,performance,10447,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['perform'],['performance']
Performance,nic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; Quantum Information Processing. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/index.html:2826,load,loading,2826,docs/4.7/index.html,https://qutip.org,https://qutip.org/docs/4.7/index.html,2,['load'],['loading']
Performance,"normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns; -------; q : :class:`qutip.Qobj`; A new instance of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except TypeError:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except TypeError:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:49345,cache,cached,49345,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['cache'],['cached']
Performance,"ns – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:8662,perform,performance,8662,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,1,['perform'],['performance']
Performance,"ns""); M += 1. #; # read data and store in a matrix; #; f.seek(0). if numtype == ""complex"":; data = np.zeros((M, N), dtype=""complex""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; out = pickle.load(fileObject) # return the object from the file; if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fileio.html:8220,load,loaded,8220,docs/3.1.0/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fileio.html,2,['load'],"['load', 'loaded']"
Performance,"ns; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State Solutions for Arbitrary Systems; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; Optimal control; Utilitiy Functions. Change Log; Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/index.html:4002,load,loading,4002,docs/3.1.0/index.html,https://qutip.org,https://qutip.org/docs/3.1.0/index.html,2,['load'],['loading']
Performance,"nse; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherw",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:6365,perform,performance,6365,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['perform'],['performance']
Performance,"nspose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html:4695,perform,performs,4695,docs/4.3/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html,1,['perform'],['performs']
Performance,"nstance)) Used to computer the fidelity error and the fidelity error gradient. memory_optimization; (int) Level of memory optimisation. Setting to 0 (default) means that execution speed is prioritized over memory. Setting to 1 means that some memory prioritisation steps will be taken, for instance using Qobj (and hence sparse arrays) as the the internal operator data type, and not caching some operators Potentially further memory saving maybe made with memory_optimization > 1. The options are processed in _set_memory_optimizations, see this for more information. Individual memory saving options can be switched by settting them directly (see below). oper_dtype; (type) Data type for internal dynamics generators, propagators and time evolution operators. This can be ndarray or Qobj, or (in theory) any other representaion that supports typical matrix methods (e.g. dot) ndarray performs best for smaller quantum systems. Qobj may perform better for larger systems, and will also perform better when (custom) fidelity measures use Qobj methods such as partial trace. See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen; (bool) If True then the dynamics generators will be saved with and without the propagation prefactor (if there is one) Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad; (bool) If the True then the propagator gradients (for exact gradients) will be computed when the propagator are computed and cache until the are used by the fidelity computer. If False then the fidelity computer will calculate them as needed. Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of the Hamiltion eignvector matrix Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue decomposition. Defaults to True when memory_optimization<=1, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:75237,perform,perform,75237,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,4,['perform'],['perform']
Performance,"nstances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:41275,perform,performance,41275,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['perform'],['performance']
Performance,"nt Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; :class:`~qutip.control.optimizer.Optimizer` object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; P",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:53958,optimiz,optimizer,53958,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"ntrol amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics¶; Dynamics (subclass instance) – describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config¶; OptimConfig instance – various configuration options; (see OptimConfig for details). termination_conditions¶; TerminationCondition instance – attributes determine when the optimisation will end. pulse_generator¶; PulseGen (subclass instance) – (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats¶; Stats – attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump¶; dump.OptimDump – Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir¶; string – Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary¶; OptimIterSummary – Summary of the most recent iteration.; Note this is on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:62485,perform,performance,62485,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performance']
Performance,"num_tslots (Dynamics attribute). (PulseGen attribute). num_waves (PulseGenPeriodic attribute). O. ode2es() (in module qutip.essolve). offset (PulseGen attribute). omega (DynamicsSymplectic attribute). onto_evo (Dynamics attribute), [1]. onwd_evo (Dynamics attribute), [1]. oper_dtype (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). optim_method (Optimizer attribute). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). optimizer (OptimResult attribute). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). options (HEOMSolver attribute). (MemoryCascade attribute). (StochasticSolverOptions attribute). (TTMSolverOptions attribute). orbital() (in module qutip.orbital). order (Options attribute). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel (MemoryCascade attribute). parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). params (Dynamics attribute). (Optimizer attribute). parent (Dump attribute). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). periodic (PulseGen attribute). permute() (Qobj method), [1]. phase() (in module qutip.operators). phase_basis() (in module qutip.states). phase_option (FidCompUnitary attribute). phasegate() (in module qutip.qip.gates). planck (HEOMSolver attribut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:19014,optimiz,optimizer,19014,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['optimiz'],['optimizer']
Performance,"o be called for each value in task_vec. values: array / list. The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary. The optional additional argument to the task function. task_kwargs: list / dictionary. The optional additional keyword argument to the task function. progress_bar: ProgressBar. Progress bar class instance for showing progress. Returns:result : list. The result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. task_vec: array / list. The list or array of values for which the task function is to be; evaluated. args: list / dictionary. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:160619,load,load-balanced,160619,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['load'],['load-balanced']
Performance,"o computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:7264,perform,perform,7264,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,8,['perform'],['perform']
Performance,"o store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:10335,perform,performing,10335,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,5,['perform'],['performing']
Performance,"o tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:59207,load,loading,59207,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['load'],['loading']
Performance,"o the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:11990,load,loading,11990,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['load'],['loading']
Performance,"oattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:44437,perform,performed,44437,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['perform'],['performed']
Performance,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for exampl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-saving.html:2043,load,loads,2043,docs/4.3/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html,2,['load'],['loads']
Performance,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345063. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for exampl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-saving.html:2039,load,loads,2039,docs/4.4/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-saving.html,1,['load'],['loads']
Performance,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for exampl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:2043,load,loads,2043,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,1,['load'],['loads']
Performance,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example stor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-saving.html:2043,load,loads,2043,docs/4.0.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html,1,['load'],['loads']
Performance,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example stor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-saving.html:2043,load,loads,2043,docs/4.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-saving.html,1,['load'],['loads']
Performance,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example stor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:2843,load,loads,2843,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,1,['load'],['loads']
Performance,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example stor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-saving.html:2741,load,loads,2741,docs/3.0.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html,1,['load'],['loads']
Performance,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example stor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-saving.html:2803,load,loads,2803,docs/3.0.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html,1,['load'],['loads']
Performance,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:2103,load,loads,2103,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,2,['load'],['loads']
Performance,"ocesses; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; print(Qobj()). Output:; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-basics.html:1674,load,loaded,1674,docs/4.7/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html,1,['load'],['loaded']
Performance,"och3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-bloch.html:2631,load,load,2631,docs/3.1.0/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-bloch.html,1,['load'],['load']
Performance,"od). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeffs (PulseGenCrab attribute). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). col_times (Result attribute). col_which (Result attribute). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). config (Optimizer attribute). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method), [1]. controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method), [1]. coup_op (HEOMSolver attribute). coup_strength (HEOMSolver attribute). covariance_matrix() (in module qutip.continuous_variables). cphase() (i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:3558,concurren,concurrence,3558,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['concurren'],['concurrence']
Performance,"od_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn, ; pulse_params=ramping_pulse_params",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:65891,perform,performance,65891,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['perform'],['performance']
Performance,"odel, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:4804,perform,performance,4804,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,8,['perform'],['performance']
Performance,"of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; permute(order); Returns composite qobj with indices reordered.; proj(); Computes the projector for a ket or bra vector.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. """"""; __array_priority__ = 100 # sets Qobj priority above numpy arrays. def __init__(self, inpt=None, dims=[[], []], shape=[],; type=None, isherm=None, copy=True,; fast=False, superrep=None, isunitary=None):; """"""; Qobj constructor.; """"""; self._isherm = isherm; self._type = type; self.superrep = superrep; self._isunitary = isunitary. if fast == 'mc':; # fast Qobj construction for use in mcsolve with ket output; self._data = inpt; self.dim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:7319,perform,performing,7319,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,2,['perform'],['performing']
Performance,"of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html:4014,optimiz,optimizer,4014,docs/4.3/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html,2,['optimiz'],['optimizer']
Performance,"og_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:6547,optimiz,optimize,6547,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['optimiz'],['optimize']
Performance,"og_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:68284,optimiz,optimize,68284,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"ol optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:74209,optimiz,optimize,74209,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"olvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:137053,perform,perform,137053,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['perform'],['perform']
Performance,"om this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/entropy.html:2138,concurren,concurrence,2138,docs/4.5/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/entropy.html,1,['concurren'],['concurrence']
Performance,"om this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:2129,concurren,concurrence,2129,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,5,['concurren'],['concurrence']
Performance,"om; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/termcond.html:3452,optimiz,optimize,3452,docs/4.4/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/termcond.html,1,['optimiz'],['optimize']
Performance,"omp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65548,optimiz,optimize,65548,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimize']
Performance,"omplex); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape=_tmp.shape); if not np.any(dims):; self.dims = [[1], [1]]; else:; self.dims = dims. else:; warnings.warn(""Initializing Qobj from unsupported type: %s"" %; builtins.type(inpt)); inpt = np.array([[0]]); _tmp = sp.csr_matrix(inpt, dtype=complex, copy=copy); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape=_tmp.shape); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]. if type == 'super':; # Type is not super, i.e. dims not explicitly passed, but oper shape; if dims == [[], []] and self.shape[0] == self.shape[1]:; sub_shape = np.sqrt(self.shape[0]); # check if root of shape is int; if (sub_shape % 1) != 0:; raise Exception('Invalid shape for a super operator.'); else:; sub_shape = int(sub_shape); self.dims = [[[sub_shape], [sub_shape]]]*2. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data; # Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; self._isunitary = None. if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; if isinstance(other, (int, float, complex, np.integer, np.floating,; np.complexfloating, np.ndarray, list, tuple)) \; or sp.issparse(other):; other = Qobj(other); else:; return NotImplemented. if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:11473,cache,cache,11473,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['cache'],['cache']
Performance,"ompute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: boo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:7211,perform,performs,7211,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,4,['perform'],['performs']
Performance,"omputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:8414,perform,perform,8414,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,4,['perform'],['perform']
Performance,"on 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [3]: Qobj(); Out[3]: ; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]. where we see the blank `Qobj` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. H",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-basics.html:2254,load,loaded,2254,docs/3.0.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html,2,['load'],['loaded']
Performance,"on 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). In [13]: print(a); [0 1 2 3 4]. In [14]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], typ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-parfor.html:2109,perform,performed,2109,docs/3.0.1/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-parfor.html,1,['perform'],['performed']
Performance,"on in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-visualization.html:1660,perform,perform,1660,docs/4.6/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-visualization.html,1,['perform'],['perform']
Performance,"on is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:4470,optimiz,optimize,4470,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,5,['optimiz'],['optimize']
Performance,"on of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:35336,load,loaded,35336,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['load'],['loaded']
Performance,"oncatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_tlist. [docs] def print_info(self):; """"""; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise.; """"""; print(""-----------------------------------""; ""-----------------------------------""); if self.label is not None:; print(""Pulse label:"", self.label); print(""The pulse contains: {} coherent noise elements and {} ""; ""Lindblad noise elements."".format(; len(self.coherent_noise), len(self.lindblad_noise))); print(); print(""Ideal pulse:""); print(self.ideal_pulse); if self.coherent_noise:; print(); print(""Coherent noise:""); for ele in self.coherent_noise:; print(ele); if self.lindblad_noise:; print(); print(""Lindblad noise:""); for ele in self.lindblad_noise:; print(ele); print(""-----------------------------------""; ""-----------------------------------""). class Drift():; """"""; The time independent drift Hamiltonian. Usually its the intrinsic; evolution of the quantum system that can not be tuned. Parameters; ----------; qobj: :class:`qutip.Qobj` or list of :class:`qutip.Qobj`, optional; The drift Hamiltonians. Attributes; ----------; qobj: list of :class:`qutip.Qobj`; A list of the the drift Hamiltonians.; """"""; def __init__(self, qobj=None):; if qobj is None:; self.drift_hamiltonians = []; elif isinstance(qobj, list):; self.drift_hamiltonians = qobj; else:; self.drift_hamiltonians = [qobj]. def add_drift(self, qobj, targets):; """"""; Add a Hamiltonian to the drift. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; """"""; self.drift_hamiltonians.append(_EvoElement(qobj, targets)). def get_ideal_qobjevo(self, dims):; """"""; Get the QobjEvo representation of the drift Hamiltonian. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:13428,tune,tuned,13428,docs/4.6/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html,2,['tune'],['tuned']
Performance,"onds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:84465,optimiz,optimize,84465,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"ons. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps cust",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-bloch.html:2711,load,loads,2711,docs/3.1.0/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-bloch.html,1,['load'],['loads']
Performance,"ons. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [3]: b=Bloch(). which will load an instance of the qutip.Bloch class, or using:; In [4]: b3d=Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [5]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps cust",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-bloch.html:2609,load,loads,2609,docs/3.0.0/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html,2,['load'],['loads']
Performance,"ontain N photons"", ; Science 348, 776 (2015). 101. Leggio et al., ""Thermally activated nonlocal amplification in quantum energy transport"", ; Euro. Phys. Lett 110, 40002 (2015). 100. Patrzyk et al., ""Towards a novel environment for simulation of quantum computing"", ; Computer Science 16, 103 (2015). 99. Plankensteiner et al., ""Selective protected state preparation of coupled dissipative quantum emitters"", ; Sci Rep. 5, 16231 (2015). 98. Goryachev et al., ""Single-photon level study of microwave properties of lithium niobate at millikelvin temperatures"", ; Phys. Rev. B 92, 060406(R) 2015). 97. Nation, ""Steady-state solution methods for open quantum optical systems"", ; arXiv:1504.06768. 96. Higgins et al., ""Quantum-Enhanced Capture of Photons Using Optical Ratchet States"", ; J. Phys. Chem. C 121, 20714 (2017). 95. Bassereh et al., ""Perfect energy transport via single edge deletion in a complete network"", ; arXiv:1504.04398. 94. Wiśniewska et al., ""High performance computing and quantum trajectory method in CPU and GPU systems"", ; J. Phys.: Conf. Ser. 574, 012127 (2015). 93. Holland et al., ""Single-Photon-Resolved Cross-Kerr Interaction for Autonomous Stabilization of Photon-Number States"", ; Phys. Rev. Lett. 115, 180501 (2015). 92. Ardelt et al., ""Controlled tunneling-induced dephasing of Rabi rotations for high-fidelity hole spin initialization"", ; Phys. Rev. B 92, 115306 (2015). 91. Wallman et al., ""Estimating the coherence of noise"", ; New J. Phys. 17, 113020 (2015). 90. Černotík et al., ""Adiabatic elimination of Gaussian subsystems from quantum dynamics under continuous measurement"", ; Phys. Rev. A 92, 012124 (2015). 89. Müller et al., ""Ultrafast Polariton-Phonon Dynamics of Strongly Coupled Quantum Dot-Nanocavity Systems"", ; Phys. Rev. X 5, 031006 (2015). 88. Osipovs et al., ""Markov Chains in the Task of Author's Writing Style Profile Construction"", ; Information Technology and Management Science 17, 119 (2014). 87. Armour et al., ""Josephson photonics with a two-mo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:36760,perform,performance,36760,users.html,https://qutip.org,https://qutip.org/users.html,1,['perform'],['performance']
Performance,"ontrol fields. R : int. Number of GRAPE iterations. time : array / list. Array of time coordinates for control pulse evalutation. u_start : array. Optional array with initial control pulse values. Returns:Instance of GRAPEResult, which contains the control pulses calculated. with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator. grape_unitary_adaptive(U, H0, H_ops, R, times, eps=None, u_start=None, u_limits=None, interp_kind='linear', use_interp=False, alpha=None, beta=None, phase_sensitive=False, overlap_terminate=1.0, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x107be58d0>)[source]¶; Calculate control pulses for the Hamiltonian operators in H_ops so that; the unitary U is realized.; Experimental: Work in progress. Parameters:U : Qobj. Target unitary evolution operator. H0 : Qobj. Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj. A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int. Number of GRAPE iterations. time : array / list. Array of time coordinates for control pulse evalutation. u_start : array. Optional array with initial control pulse values. Returns:Instance of GRAPEResult, which contains the control pulses calculated. with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator. Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:129168,tune,tuned,129168,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['tune'],['tuned']
Performance,"onvenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:17610,perform,performance,17610,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['perform'],['performance']
Performance,"onvenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:17322,perform,performance,17322,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,2,['perform'],['performance']
Performance,"oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense method; self.oper_dtype = np.ndarray. return self.oper_dtype. def _init_evo(self):; """"""; Create the container lists / arrays for the:; dynamics generations, propagators, and evolutions etc; Set the time slices and cumulative time; """"""; # check evolution operators; if not self._drift_dyn_gen_checked:; _check_drift_dyn_gen(self.drift_dyn_gen); if not self._ctrl_dyn_gen_checked:; self.ctrl_dyn_gen = _check_ctrls_container(self.ctrl_dyn_gen). if not isinstance(self.initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(self.target, Qobj):; raise TypeError(""target must be a Qobj""). self.refresh_drift_attribs(); self.sys_dims = self.initial.dims; self.sys_shape = self.initial.shape; # Set the phase application method; self._init_phase(). self._set_memory_optimizations(); if self.sparse_eigen_decomp and self.sys_shape[0] <= 2:; raise ValueError(; ""Single qubit pulse optimization dynamics cannot use sparse""; "" eigenvector decomposition because of limitations in""; "" scipy.linalg.eigsh. Pleae set sparse_eigen_decomp to False""; "" or increase the size of the system.""). n_ts = self.num_tslots; n_ctrls = self.num_ctrls; if self.oper_dtype == Qobj:; self._initial = self.initial; self._target = self.target; self._drift_dyn_gen = self.drift_dyn_gen; self._ctrl_dyn_gen = self.ctrl_dyn_gen; elif self.oper_dtype == np.ndarray:; self._initial = self.initial.full(); self._target = self.target.full(); if self.time_depend_drift:; self._drift_dyn_gen = [d.full() for d in self.drift_dyn_gen]; else:; self._drift_dyn_gen = self.drift_dyn_gen.full(); if self.time_depend_ctrl_dyn_gen:; self._ctrl_dyn_gen = np.empty([n_ts, n_ctrls], dtype=object); for k in range(n_ts):; for j in range(n_ctrls):; self._ctrl_dyn_gen[k, j] = \; self.ctrl_dyn_gen[k, j].full(); else:; self._ctrl_dyn_gen = [ctrl.full(); for ctrl in self.ctrl_dyn_gen]; else:; raise ValueError(; ""Unknown oper_dtype {!r}. The oper_dtype",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:23930,optimiz,optimization,23930,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,2,['optimiz'],['optimization']
Performance,"operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:26413,load,loading,26413,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['load'],['loading']
Performance,"optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string. Fidelity",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:148174,optimiz,optimize,148174,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict. Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string. Method for computing the dynamics generators, propagators and; evolution in the timeslots.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:157058,optimiz,optimize,157058,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:162963,optimiz,optimize,162963,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:171851,optimiz,optimize,171851,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"optimisation will; terminate when the fidelity error falls below this value. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float. Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:172802,perform,performane,172802,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['perform'],['performane']
Performance,"optimisation will; terminate when the fidelity error falls below this value. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float. Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict. Parameters for the Dynamics object; The ke",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:181433,perform,performane,181433,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['perform'],['performane']
Performance,"optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:187603,perform,performane,187603,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['perform'],['performane']
Performance,"optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The ke",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:196238,perform,performane,196238,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['perform'],['performane']
Performance,"option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:65573,optimiz,optimizer,65573,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,"option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:65179,optimiz,optimizer,65179,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['optimiz'],['optimizer']
Performance,"optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; can set its tlist and coeff. Param",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:129813,optimiz,optimized,129813,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['optimiz'],['optimized']
Performance,"or each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:227933,optimiz,optimize,227933,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"or each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL; (see Dyn",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:240048,optimiz,optimize,240048,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"or each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:236623,optimiz,optimize,236623,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"or each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:248741,optimiz,optimize,248741,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"or m in range(n_expt_op):; op = e_ops[m]; if not isinstance(op, Qobj) and callable(op):; res.expect[m][t] = op(t, state); continue. res.expect[m][t] = expect(op, state). if (; idx == len(partitions) - 1; and options.store_final_state; and not options.store_states; ):; res.states = [evolved_states[-1]]. return res. def lanczos_algorithm(; H,; psi: np.ndarray,; krylov_dim: int,; sparse: bool = False,; ):; """"""; Computes a basis of the Krylov subspace for Hamiltonian 'H', a system; state 'psi' and Krylov dimension 'krylov_dim'. The space is spanned; by {psi, H psi, H^2 psi, ..., H^(krylov_dim) psi}.; Parameters; ------------; H : np.ndarray or csr_matrix; System Hamiltonian. If the Hamiltonian is dense, a np.ndarray is; preferred, whereas if it is sparse, a scipy csr_matrix is optimal.; psi: np.ndarray; State used to calculate Krylov subspace.; krylov_dim: int; Dimension (krylov_dim + 1) of the spanned Krylov subspace.; sparse: bool (optional, default False); Wether to perform scipy sparse matrix multiplication operations or; numpy dense matrix multiplications.; Returns; ---------; v: np.ndarray; Lanczos eigenvector.; T: np.ndarray; Tridiagonal decomposition.; """""". v = np.zeros((krylov_dim + 1, psi.shape[0]), dtype=complex); T_m = np.zeros((krylov_dim + 1, krylov_dim + 1), dtype=complex). v[0, :] = psi.squeeze(). w_prime = H.dot(v[0, :]). alpha = np.vdot(w_prime, v[0, :]). w = w_prime - alpha * v[0, :]. T_m[0, 0] = alpha. for j in range(1, krylov_dim + 1):. beta = np.linalg.norm(w). if beta < 1e-7:. # Happy breakdown; v_happy = v[0:j, :]; T_m_happy = T_m[0:j, 0:j]. return v_happy, T_m_happy. v[j, :] = w / beta; w_prime = H.dot(v[j, :]); alpha = np.vdot(w_prime, v[j, :]). w = w_prime - alpha * v[j, :] - beta * v[j - 1, :]. T_m[j, j] = alpha; T_m[j, j - 1] = beta; T_m[j - 1, j] = beta. return v, T_m. def _evolve(t0: float, krylov_basis: np.ndarray, T_m: np.ndarray):; """"""; Computes the time evolution operator 'U(t - t0) psi0_k', where 'psi0_k'; is the first basis element of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:7793,perform,perform,7793,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['perform'],['perform']
Performance,"or object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:183785,optimiz,optimizer,183785,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimizer']
Performance,"or the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :class:`~qutip.control.optimizer.Optimizer` object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the :class:`qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~qutip.control.propcomp.PropagatorComputer` classes for; details). prop_params : dict; Parameters for the :obj:`~qutip.control.propcomp.PropagatorComputer`; object. The key value pairs are assumed to be attribute name value; pairs. They app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:33036,optimiz,optimize,33036,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"ord arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(self, file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(self, tlist)[source]¶; Set tlist for all the pulses. It can be used to set tlist if; all pulses are controlled by the same time sequence. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See qutip.qip.Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class qutip.qip.device.Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. add_control(self, qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; qutip.qip.Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:82300,optimiz,optimized,82300,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['optimiz'],['optimized']
Performance,"ori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. Earlier development of QuTiP was partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/frontmatter.html:2060,perform,performed,2060,docs/4.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html,1,['perform'],['performed']
Performance,"orithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.; There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised. TerminationConditionsThis is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-control.html:15963,perform,performed,15963,docs/4.4/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-control.html,4,['perform'],['performed']
Performance,"ors and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide.html:2773,load,loading,2773,docs/4.4/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide.html,2,['load'],['loading']
Performance,"ors and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; print(a * vac). Output:; Quantum object: dims = [[5]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:1356,perform,performing,1356,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,1,['perform'],['performing']
Performance,"os partitions can also be determined using the qutip.solver.options.nsteps parameter, which defaults to ‘10000’.; Let’s solve a simple example using the algorithm in QuTiP to get familiar with the method.; >>> from qutip import jmat, rand_ket, krylovsolve; >>> import numpy as np; >>> import matplotlib.pyplot as plt; >>> dim = 100; >>> e_ops = [jmat((dim - 1) / 2.0, ""x""), jmat((dim - 1) / 2.0, ""y""), jmat((dim - 1) / 2.0, ""z"")]; >>> H = .5*jmat((dim - 1) / 2.0, ""z"") + .5*jmat((dim - 1) / 2.0, ""x""); >>> psi0 = rand_ket(dim); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results = krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). Sparse and Dense Hamiltonians¶; If the Hamiltonian of interest is known to be sparse, qutip.krylovsolve also comes equipped with the possibility to store its internal data in a sparse optimized format using scipy. This allows for significant speed-ups, let’s showcase it:; >>> from qutip import krylovsolve, rand_herm, rand_ket; >>> import numpy as np; >>> from time import time; >>> def time_krylov(psi0, H, tlist, sparse):; >>> start = time(); >>> krylovsolve(H, psi0, tlist, krylov_dim=30, sparse=sparse); >>> end = time(); >>> return end - start; >>> dim = 2000; >>> tlist = np.linspace(0, 1, 10); >>> psi0 = rand_ket(dim, seed=0); >>> H_sparse = rand_herm(dim, density=0.1, seed=0); >>> H_dense = rand_herm(dim, density=0.9, seed=0); >>> # first index for type of H and second index for sparse = True or False (dense); >>> t_ss = time_krylov(psi0, H_sparse, tlist, sparse=True); >>> t_sd = time_krylov(psi0, H_sparse, tlist, sparse=False); >>> t_ds = time_krylov(psi0, H_dense, tlist, sparse=True); >>> t_dd = time_krylov(psi0, H_dense, tlist, sparse=False); >>> print(f""Average time of solution for a sparse H is {round((t_sd)/t_ss, 2)} faster for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:5411,optimiz,optimized,5411,docs/4.7/guide/dynamics/dynamics-krylov.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html,1,['optimiz'],['optimized']
Performance,"oth the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.8999160647,-0.3698450405,-0.0386004040; 1.0101010101,3.1665288000,-0.1086153265,0.2308584366; 2.0202020202,2.6416361771,0.1101685451,0.1748708584; 3.0303030303,2.2509491702,0.1735585411,0.0018155507. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,3.8999160647e+00,-3.6984504055e-01,-3.8600403996e-02; 1.0101010101e+00,3.1665288000e+00,-1.0861532645e-01,2.3085843662e-01; 2.0202020202e+00,2.6416361771e+00,1.1016854507e-01,1.7487085839e-01; 3.0303030303e+00,2.2509491702e+00,1.7355854113e-01,1.8155506866e-03. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-saving.html:8330,load,loaded,8330,docs/4.4/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-saving.html,1,['load'],['loaded']
Performance,"ou will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:6702,perform,perform,6702,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['perform'],['perform']
Performance,"output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/changelog.html:24255,load,loading,24255,docs/4.3/changelog.html,https://qutip.org,https://qutip.org/docs/4.3/changelog.html,1,['load'],['loading']
Performance,"ov_results = Result(); krylov_results.solver = ""krylovsolve"". # handle particular cases of an empty tlist or single element; n_tlist_steps = len(tlist); if n_tlist_steps < 1:; return krylov_results. if n_tlist_steps == 1: # if tlist has only one element, return it; krylov_results = particular_tlist_or_happy_breakdown(; tlist, n_tlist_steps, options, psi0, e_ops, krylov_results, pbar; ) # this will also raise a warning; return krylov_results. tf = tlist[-1]; t0 = tlist[0]. # optimization step using Lanczos, then reuse it for the first partition; dim_m = krylov_dim; krylov_basis, T_m = lanczos_algorithm(; _H, _psi, krylov_dim=dim_m, sparse=sparse; ). # check if a happy breakdown occurred; if T_m.shape[0] < krylov_dim + 1:; if T_m.shape[0] == 1:; # this means that the state does not evolve in time, it lies in a; # symmetry of H subspace. Thus, theres no work to be done.; krylov_results = particular_tlist_or_happy_breakdown(; tlist,; n_tlist_steps,; options,; psi0,; e_ops,; krylov_results,; pbar,; happy_breakdown=True,; ); return krylov_results; else:; # no optimization is required, convergence is guaranteed.; delta_t = tf - t0; n_timesteps = 1; else:. # calculate optimal number of internal timesteps.; delta_t = _optimize_lanczos_timestep_size(; T_m, krylov_basis=krylov_basis, tlist=tlist, options=options; ); n_timesteps = int(ceil((tf - t0) / delta_t)). if n_timesteps >= options.nsteps:; raise Exception(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This can ""; ""be increased via the 'Options.nsteps' property.""; ). partitions = _make_partitions(tlist=tlist, n_timesteps=n_timesteps). if progress_bar:; pbar.start(len(partitions)). # update parameters regarding e_ops; krylov_results, expt_callback, options, n_expt_op = _e_ops_outputs(; krylov_results, e_ops, n_tlist_steps, options; ). # parameters for the lazy iteration evolve tlist; psi_norm = np.linalg.norm(_psi); last_t = t0. for idx",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:4645,optimiz,optimization,4645,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['optimiz'],['optimization']
Performance,"overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormb",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:38898,perform,performance,38898,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['perform'],['performance']
Performance,"overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are cou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:72580,perform,performance,72580,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['perform'],['performance']
Performance,"ow it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. permc_spec : str, optional, default='COLAMD'; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:6624,perform,perform,6624,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['perform'],['perform']
Performance,"ow. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/installation.html:5622,load,load,5622,docs/4.4/installation.html,https://qutip.org,https://qutip.org/docs/4.4/installation.html,2,['load'],['load']
Performance,"ow. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:5526,load,load,5526,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,3,['load'],['load']
Performance,"p.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.40942767, 3.44132235, 2.80622054, 2.3433275 , 2.00107858,; 1.74653819, 1.55662702, 1.41466358, 1.30841238, 1.22882551]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only unde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-saving.html:2999,load,load,2999,docs/4.3/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html,1,['load'],['load']
Performance,"p.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only unde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-saving.html:3040,load,load,3040,docs/4.5/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-saving.html,1,['load'],['load']
Performance,"p.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345063. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.04416292, 3.22336973, 2.64206514, 2.2194952 , 1.90787059,; 1.67647333, 1.50399675, 1.37514572, 1.27874735, 1.20656019]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only unde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-saving.html:2995,load,load,2995,docs/4.4/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-saving.html,1,['load'],['load']
Performance,"p.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 3.40657352, 2.74980446, 2.29441406, 1.96186716, 1.71601185,; 1.5332011 , 1.39683111, 1.29490432, 1.21862519, 1.16149242]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only und",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:2999,load,load,2999,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,1,['load'],['load']
Performance,"p.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:; output : qutip.solver.Result; An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H : qutip.Qobj; System Hamiltonian. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times : list / array; List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary; Option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:76636,optimiz,optimizing,76636,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,2,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"parse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:7822,cache,cache,7822,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,4,['cache'],['cache']
Performance,"perators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [2]: vac = basis(5, 0). In [3]: print(vac); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [4]: a = destroy(5). In [5]: print(a); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [6]: a * vac; Out[6]: ; Q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-states.html:1974,perform,performing,1974,docs/3.0.1/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html,1,['perform'],['performing']
Performance,"perqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:16841,perform,performed,16841,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['perform'],['performed']
Performance,"perqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj; instances, each of which may have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:16865,perform,performed,16865,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['perform'],['performed']
Performance,ph). mcsolve() (in module qutip.mcsolve). MemoryCascade (class in qutip.nonmarkov.memorycascade). mesolve() (in module qutip.mesolve). momentum() (in module qutip.operators). N. n_thermal() (in module qutip.utilities). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (DispersivecQED method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). p,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/genindex.html:12109,optimiz,optimizer,12109,docs/4.4/genindex.html,https://qutip.org,https://qutip.org/docs/4.4/genindex.html,1,['optimiz'],['optimizer']
Performance,"phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]¶; clear any temporarily held status data. compute_fid_grad(self)[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]¶; Check configuration and initialise the normalisation. init_normalization(self)[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:109920,cache,cached,109920,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['cache'],['cached']
Performance,"photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestr or pathlib.PathName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestr or pathlib.PathName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters. namestr or pathlib.PathName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestr or pathlib.PathName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:260788,load,loaded,260788,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['load'],['loaded']
Performance,"phy; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mcsolve. Source code for qutip.mcsolve; __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:1240,load,loaded,1240,docs/4.7/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html,1,['load'],['loaded']
Performance,"play the Bloch sphere and corresponding data sets. non-Markovian Solvers¶. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. H_sys¶; Qobj – System Hamiltonian. coup_op¶; Qobj – Operator describing the coupling between system and bath. coup_strength¶; float – Coupling strength. temperature¶; float – Bath temperature, in units corresponding to planck. N_cut¶; int – Cutoff parameter for the bath. N_exp¶; int – Number of exponential terms used to approximate the bath correlation; functions. planck¶; float – reduced Planck constant. boltzmann¶; float – Boltzmann’s constant. options¶; qutip.solver.Options – Generic solver options.; If set to None the default options will be used. progress_bar¶; BaseProgressBar – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:26618,perform,performance,26618,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performance']
Performance,"plicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_facto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:4806,optimiz,optimizer,4806,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['optimiz'],['optimizer']
Performance,"ptimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html:4718,optimiz,optimizer,4718,docs/4.6/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html,1,['optimiz'],['optimizer']
Performance,"pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:220070,optimiz,optimizer,220070,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimizer']
Performance,"putation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-visualization.html:1718,perform,perform,1718,docs/4.7/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html,1,['perform'],['perform']
Performance,"pute the propagators and their gradients. fid_computer¶; FidelityComputer (subclass instance) – Used to computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen¶; bool – If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad¶; bool – If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj¶; bool – If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp¶; bool – If",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:78135,perform,performs,78135,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performs']
Performance,"putes the product of the unitaries (in between the measurements):; sim = CircuitSimulator(qc, precompute_unitary=True). print(sim.ops). [Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = False; Qobj data =; [[ 0. 0.57734961 0. -0.57734961 0. 0.40824922; 0. -0.40824922]; [ 0.57734961 0. -0.57734961 0. 0.40824922 0.; -0.40824922 0. ]; [ 0.57734961 0. 0.57734961 0. 0.40824922 0.; 0.40824922 0. ]; [ 0. 0.57734961 0. 0.57734961 0. 0.40824922; 0. 0.40824922]; [ 0.57735159 0. 0. 0. -0.81649565 0.; 0. 0. ]; [ 0. 0.57735159 0. 0. 0. -0.81649565; 0. 0. ]; [ 0. 0. 0.57735159 0. 0. 0.; -0.81649565 0. ]; [ 0. 0. 0. 0.57735159 0. 0.; 0. -0.81649565]],; Measurement(M0, target=[0], classical_store=0),; Measurement(M1, target=[1], classical_store=1),; Measurement(M2, target=[2], classical_store=2)]. Here, sim.ops stores all the circuit operations that are going to be applied during; state evolution. As observed above, all the unitaries of the circuit are compressed into; a single unitary product with the precompute optimization enabled.; This is more efficient if one runs the same circuit one multiple initial states.; However, as the number of qubits increases, this will consume more and more memory; and become unfeasible. Density Matrix Simulation¶; By default, the state evolution is carried out in the “state_vector_simulator” mode; (specified by the mode argument) as described before.; In the “density_matrix_simulator” mode, the input state can be either a ket or a density; matrix. If it is a ket, it is converted into a density matrix before the evolution is; carried out. Unlike the “state_vector_simulator” mode, upon measurement, the state; does not collapse to one of the post-measurement states. Rather, the new state is now; the density matrix representing the ensemble of post-measurement states.; In this sense, we measure the qubits and forget all the results.; To demonstrate this consider the original W-state preparation circuit which is foll",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html:7263,optimiz,optimization,7263,docs/4.6/guide/qip/qip-simulator.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html,2,['optimiz'],['optimization']
Performance,"py: http://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Cho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:10093,optimiz,optimization,10093,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,7,['optimiz'],['optimization']
Performance,"qobjevocy_qobj (CQobjCte or CQobjEvoTd)Cython version of the QobjEvo. dummy_cteboolis self.cte a dummy Qobj. constboolIndicates if quantum object is Constant. typeint; information about the type of coefficient“string”, “func”, “array”,; “spline”, “mixed_callable”, “mixed_compilable”. num_objintnumber of Qobj in the QobjEvo : len(ops) + (1 if not dummy_cte). Methods. copy() :; Create copy of Qobj. arguments(new_args):; Update the args of the object. Math:; +/- QobjEvo, Qobj, scalar: Addition is possible between QobjEvo and with Qobj or scalar -: Negation operator * Qobj, scalar: Product is possible with Qobj or scalar / scalar: It is possible to divide by scalar only. conj(); Return the conjugate of quantum object. dag(); Return the adjoint (dagger) of quantum object. trans(); Return the transpose of quantum object. norm(); Return self.dag() * self. Only possible if num_obj == 1. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. apply(f, *args, **kw_args); Apply the function f to every Qobj. f(Qobj) -> Qobj Return a modified QobjEvo and let the original one untouched. apply_decorator(decorator, *args, str_mod=None,; inplace_np=False, **kw_args): Apply the decorator to each function of the ops. The *args and **kw_args are passed to the decorator. new_coeff_function = decorator(coeff_function, *args, **kw_args) str_mod : list of 2 elements replace the string : str_mod[0] + original_string + str_mod[1] *exemple: str_mod = [“exp(“,”)”] inplace_np: Change the numpy array instead of applying the decorator to the function reading the array. Some decorators create incorrect array. Transformations f’(t) = f(g(t)) create a missmatch between the array and the associated time list. tidyup(atol=1e-12); Removes small elements from quantum object. compress():; Merge ops which are based on the same quantum object and coeff type. compile(code=False, matched=False, dense=False, omp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:20436,perform,performing,20436,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['perform'],['performing']
Performance,"quation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Introduction; Quantum Circuit; Processor for QIP simulation; Noise Simulation; Workflow of the Processor. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide.html:2798,load,loading,2798,docs/4.5/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide.html,2,['load'],['loading']
Performance,"qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-saving.html:2582,load,loaded,2582,docs/4.3/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html,2,['load'],['loaded']
Performance,"qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345063. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-saving.html:2578,load,loaded,2578,docs/4.4/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-saving.html,1,['load'],['loaded']
Performance,"qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:2582,load,loaded,2582,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,1,['load'],['loaded']
Performance,"r Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide.html:2704,load,loading,2704,docs/4.3/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide.html,2,['load'],['loading']
Performance,"r counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014):¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:3438,perform,performance,3438,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,7,['perform'],['performance']
Performance,"r counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:35198,perform,performance,35198,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['perform'],['performance']
Performance,"r each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:203295,optimiz,optimize,203295,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"r each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:215375,optimiz,optimize,215375,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"r each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:161063,optimiz,optimize,161063,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"r each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringdetermines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - globa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:169739,optimiz,optimize,169739,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"r each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:177363,optimiz,optimize,177363,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"r given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return type:float. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho (qobj) – Density matrix of composite object; selB (int/list) – Selected components for density matrix B; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_cond – Value of conditional entropy. Return type:float. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho (qobj) – sensity matrix or ket/bra vector. Returns:entropy – Linear entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, sel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:45326,concurren,concurrence,45326,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,['concurren'],['concurrence']
Performance,"r).tr(); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:40909,perform,performed,40909,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['perform'],['performed']
Performance,"rad_func_calls (Stats attribute). num_iter (OptimResult attribute). (Stats attribute). num_timeslot_changes (Stats attribute). num_tslot_recompute (Stats attribute). num_tslots (Dynamics attribute). (PulseGen attribute). num_waves (PulseGenPeriodic attribute). O. ode2es() (in module qutip.essolve). offset (PulseGen attribute). omega (DynamicsSymplectic attribute). onto_evo (Dynamics attribute), [1]. onwd_evo (Dynamics attribute), [1]. oper_dtype (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). optim_method (Optimizer attribute). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). optimizer (OptimResult attribute). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). options (HEOMSolver attribute). (MemoryCascade attribute). (StochasticSolverOptions attribute). (TTMSolverOptions attribute). orbital() (in module qutip.orbital). order (Options attribute). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel (MemoryCascade attribute). parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). params (Dynamics attribute). (Optimizer attribute). parent (Dump attribute). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). periodic (PulseGen attribute). permute() (Qobj method), [1]. phase() (in module q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:18837,optimiz,optimizer,18837,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['optimiz'],['optimizer']
Performance,"rad_norm_min_reached; (float) True if the optimisation terminated due to the minimum value of the gradient being reached. num_iter; (integer) Number of iterations of the optimisation algorithm completed. max_iter_exceeded; (boolean) True if the iteration limit was reached. max_fid_func_exceeded; (boolean) True if the fidelity function call limit was reached. wall_time; (float) time elapsed during the optimisation. wall_time_limit_exceeded; (boolean) True if the wall time limit was reached. time; (array[num_tslots+1] of float) Time are the start of each timeslot with the final value being the total evolution time. initial_amps; (array[num_tslots, n_ctrls]) The amplitudes at the start of the optimisation. final_amps; (array[num_tslots, n_ctrls]) The amplitudes at the end of the optimisation. evo_full_final; (Qobj) The evolution operator from t=0 to t=T based on the final amps. stats; (Stats) Object contaning the stats for the run (if any collected). optimizer; (Optimizer) Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However; Attributes. num_ctrls. dyn_gen. prop. prop_grad. fwd_evo. onwd_evo. onto_evo. dumping. log_level; (integer) level of messaging output from the logger. Options are attribu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:72269,optimiz,optimizer,72269,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimizer']
Performance,"rams : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:9834,optimiz,optimize,9834,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance,raph). mcsolve() (in module qutip.mcsolve). MemoryCascade (class in qutip.nonmarkov.memorycascade). mesolve() (in module qutip.mesolve). momentum() (in module qutip.operators). N. n_thermal() (in module qutip.utilities). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls (Dynamics attribute). (DynamicsUnitary attribute). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (CircularSpinChain method). (DispersivecQED method). (LinearSpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_ap,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/genindex.html:11730,optimiz,optimizer,11730,docs/4.3/genindex.html,https://qutip.org,https://qutip.org/docs/4.3/genindex.html,1,['optimiz'],['optimizer']
Performance,"rating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-saving.html:1624,load,loading,1624,docs/4.5/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-saving.html,2,['load'],"['load', 'loading']"
Performance,"rator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=’C’); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. inv(); Return a Qobj corresponding to the matrix inverse of the operator. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. proj(); Computes the projector for a ket or bra vector. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=’clip’); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm()[source]¶; Check if the quantum object is hermitian. Returns. ishermboolReturns the new value of isherm property. check_isunitary()[source]¶; Checks whether qobj is a unitary matrix. conj()[source]¶; Conjugate operator of quantum object. copy()[source]¶; Create identical copy. cosm()[source]¶; Cosine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix cosine of operator. Raises. TypeErrorQuantum object is not ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:4133,perform,performing,4133,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['perform'],['performing']
Performance,"rator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=’C’); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. inv(); Return a Qobj corresponding to the matrix inverse of the operator. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. proj(); Computes the projector for a ket or bra vector. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=’clip’); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm(self)[source]¶; Check if the quantum object is hermitian. Returns. ishermboolReturns the new value of isherm property. check_isunitary(self)[source]¶; Checks whether qobj is a unitary matrix. conj(self)[source]¶; Conjugate operator of quantum object. copy(self)[source]¶; Create identical copy. cosm(self)[source]¶; Cosine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix cosine of operator. Raises. TypeErrorQu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:4100,perform,performing,4100,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['perform'],['performing']
Performance,"rd gate. “PHASEGATE”; Add a phase one the state 1. “CRX”; Controlled rotation around x axis. “CRY”; Controlled rotation around y axis. “CRZ”; Controlled rotation around z axis. “CX”; Controlled X gate. “CY”; Controlled Y gate. “CZ”; Controlled Z gate. “CS”; Controlled S gate. “CT”; Controlled T gate. “CPHASE”; Controlled phase gate. “CNOT”; Controlled NOT gate. “CSIGN”; Same as CPHASE. “QASMU”; U rotation gate used as a primitive in the QASM standard. “BERKELEY”; Berkeley gate. “SWAPalpha”; SWAPalpha gate. “SWAP”; Swap the states of two qubits. “ISWAP”; Swap gate with additional phase for 01 and 10 states. “SQRTSWAP”; Square root of the SWAP gate. “SQRTISWAP”; Square root of the ISWAP gate. “FREDKIN”; Fredkin gate. “TOFFOLI”; Toffoli gate. “GLOBALPHASE”; Global phase. For some of the gates listed above, QubitCircuit also has a primitive resolve_gates method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates (RX, RY and RZ). However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. It is required that the gate resolution be carried out before the measurements to the circuit are added.; Custom Gates; In addition to these pre-defined gates, QuTiP also allows the user to define their own gate.; The following example shows how to define a customized gate.; The key step is to define a; gate function returning a qutip.Qobj and save it in the attribute user_gates.; from qutip.qip.circuit import Gate; from qutip.qip.operations import rx. def user_gate1(arg_value):; # controlled rotation X; mat = np.zeros((4, 4), dtype=np.complex); mat[0, 0] = mat[1, 1] = 1.; mat[2:4, 2:4] = rx(arg_value); return Qobj(mat, dims=[[2, 2], [2, 2]]). def user_gate2():; # S gate; mat = np.array([[1., 0],; [0., 1.j]]); return Qobj(mat, dims=[[2], [2]]). qc = QubitCircuit(2); qc.user_gates = {""CTRLRX"": user_gate1,; ""S"" : user_gate2}. # qubit 0 controls qubit 1; qc.add_gate(""CTR",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-basics.html:6692,optimiz,optimized,6692,docs/4.6/guide/qip/qip-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html,2,['optimiz'],['optimized']
Performance,"rd; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/termcond.html:1766,optimiz,optimize,1766,docs/4.7/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/termcond.html,1,['optimiz'],['optimize']
Performance,"re currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.14+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:3238,perform,performance,3238,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['perform'],['performance']
Performance,"re for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotCompute",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:112934,cache,cached,112934,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['cache'],['cached']
Performance,"re specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the Fideli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:220510,optimiz,optimize,220510,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"re specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the Fideli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:232623,optimiz,optimize,232623,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisation algorithm completed. max_iter_exceeded¶; boolean – True if the iteration limit was reached. max_fid_func_exceeded¶; boolean – True if the fidelity function call limit was reached. wall_time¶; float – time elapsed during the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the optimisation. final_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the end of the optimisation. evo_full_final¶; Qobj – The evolution operator from t=0 to t=T based on the final amps. stats¶; Stats – Object contaning the stats for the run (if any collected). optimizer¶; Optimizer – Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:75271,optimiz,optimizer,75271,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimizer']
Performance,"reation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); qo = destroy(N, offset=offset) # create operator using destroy function; return qo.dag(). def _implicit_tensor_dimensions(dimensions):; """"""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise ValueError(""All dimensions must be integers >= 0""); return np.prod(flat), [dimensions, dimensions]. [docs]def qzero(dimensions):; """"""; Zero operator. Parameters; ----------; dimensions : (int",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:10188,perform,perform,10188,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,2,['perform'],['perform']
Performance,"represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:10698,perform,performed,10698,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['perform'],['performed']
Performance,"result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:26135,optimiz,optimize,26135,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['optimiz'],['optimize']
Performance,"ride these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for; details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:224438,optimiz,optimize,224438,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"ride these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:220807,optimiz,optimize,220807,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"rix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparse : bool. Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float. Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:norm : float. The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(state)¶; Overlap between two state vectors.; Gives the overlap (scalar product) for the quantum object and state; state vector. Parameters:state : qobj. Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:overlap : complex. Complex valued overlap. Raises:TypeError. Can only calculate overlap between a bra and ket quantum objects. permute(order)¶; Permutes a composite quantum object. Parameters:order : list/array. List specifying new tensor order. Returns:P : qobj. Permuted quantum object. ptrace(sel)¶; Partial trace of the quantum object. Parameters:sel : int/list. An int or list of components to keep after partial trace. Returns:oper: qobj. Quantum object representing partial trace with selected components; remaining. Notes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:11752,perform,performed,11752,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['perform'],['performed']
Performance,"rix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = ket2dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:23324,perform,performance,23324,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['perform'],['performance']
Performance,"rm_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:198304,optimiz,optimize,198304,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"rnal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). I",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-parfor.html:2031,perform,performing,2031,docs/3.0.1/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-parfor.html,1,['perform'],['performing']
Performance,"rocessor.load_circuit(qc); fig, axis = processor.plot_pulses(); fig.show(). (png, hires.png, pdf). DispersiveCavityQED; Same as above, DispersiveCavityQED is a simulator based on Cavity Quantum Electrodynamics. The workflow is similar to the one for the spin chain, except that the component systems are a multi-level cavity and a qubits system. The control Hamiltonians are the single-qubit rotation together with the qubits-cavity interaction \(a^{\dagger} \sigma^{-} + a \sigma^{+}\). The device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. Note; The run_state method of DispersiveCavityQED; returns the full simulation result of the solver,; hence including the cavity.; To obtain the circuit result, one needs to first trace out the cavity state. OptPulseProcessor; The OptPulseProcessor uses the function in optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for optimize_pulse_unitary as keyword arguments to load_circuit. Usually, the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; from qutip.qip.device import OptPulseProcessor; from qutip.operators import sigmaz, sigmax, sigmay; from qutip.tensor import tensor. # Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keywor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:8128,optimiz,optimized,8128,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,1,['optimiz'],['optimized']
Performance,"rol amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:203480,optimiz,optimize,203480,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"rol amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:215560,optimiz,optimize,215560,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"rol amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:161248,optimiz,optimize,161248,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"rol amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringdetermines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_paramsdictParameters fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:169924,optimiz,optimize,169924,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"rol amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:177548,optimiz,optimize,177548,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"rol modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. num_tslots : integer; Number of timeslots, aka timeslices. num_ctrls : integer; Number of controls.; Note this is set when get_num_ctrls is called based on the; length of ctrl_dyn_gen. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:5439,perform,performance,5439,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['perform'],['performance']
Performance,"ror target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:9299,optimiz,optimize,9299,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"ror target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:7580,optimiz,optimize,7580,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"ror target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the; ``termination_conditions`` matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:23024,optimiz,optimize,23024,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"ror target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the ``termination_conditions`` matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:21565,optimiz,optimize,21565,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"rray(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:7288,load,load-balanced,7288,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,9,['load'],['load-balanced']
Performance,"rray[num_tslots, n_ctrls]) The amplitudes at the end of the optimisation. evo_full_final; (Qobj) The evolution operator from t=0 to t=T based on the final amps. stats; (Stats) Object contaning the stats for the run (if any collected). optimizer; (Optimizer) Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However; Attributes. num_ctrls. dyn_gen. prop. prop_grad. fwd_evo. onwd_evo. onto_evo. dumping. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value Note: attributes are created if they do not exist already, and are overwritten if they do. stats; (Stats) Attributes of which give performance stats for the optimisation set to None to reduce overhead of calculating stats. Note it is (usually) shared with the Optimizer object. tslot_computer; (TimeslotComputer (s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:73055,perform,performance,73055,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performance']
Performance,"rride these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:212350,optimiz,optimize,212350,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"rs. This can be ndarray or Qobj, or (in theory) any other representaion that supports typical matrix methods (e.g. dot) ndarray performs best for smaller quantum systems. Qobj may perform better for larger systems, and will also perform better when (custom) fidelity measures use Qobj methods such as partial trace. See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen; (bool) If True then the dynamics generators will be saved with and without the propagation prefactor (if there is one) Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad; (bool) If the True then the propagator gradients (for exact gradients) will be computed when the propagator are computed and cache until the are used by the fidelity computer. If False then the fidelity computer will calculate them as needed. Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of the Hamiltion eignvector matrix Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue decomposition. Defaults to True when memory_optimization<=1, otherwise False. num_tslots; (integer) Number of timeslots (aka timeslices). evo_time; (float) Total time for the evolution. tau; (array[num_tslots] of float) Duration of each timeslot Note that if this is set before initialize_controls is called then num_tslots and evo_time are calculated from tau, otherwise tau is generated from num_tslots and evo_time, that is equal size time slices. time; (array[num_tslots+1] of float) Cumulative time for the evolution, that is the time at the start of each time slice. drift_dyn_gen; (Qobj or list of Qobj) Drift or system dynamics generator (Hamiltonian) Matrix defining the underlying dynamics of the system Can also be a list of Qobj (length num_tslots) for time varying drift dynamics. ctrl_dyn_gen; (List of Q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:76036,cache,cached,76036,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['cache'],['cached']
Performance,"rue. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. For SciPy 0.14+, this option; requires installing scikits.umfpack. maxiter : int, optional, default=10000. Maximum number of iterations to perform if using an iterative method. tol : float, optional, default=1e-9. Tolerance used for terminating solver solution when using iterative; solvers. permc_spec : str, optional, default=’COLAMD’. Column ordering used internally by superLU for the ‘direct’ LU; decomposition method. Options include ‘COLAMD’ and ‘NATURAL’.; If using RCM then this is set to ‘NATURAL’ automatically unless; explicitly specified. use_precond : bool optional, default = True. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. Preconditioner for A. The preconditioner should approximate the inverse; of A. Effective preconditioning dramatically improves the rate of; convergence, for iterative methods only . If no preconditioner is; given and use_precond=True, then one is generated automatically. fill_factor : float, o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:71130,perform,perform,71130,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['perform'],['perform']
Performance,"rue. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. For SciPy 0.14+, this option; requires installing scikits.umfpack. maxiter : int, optional, default=10000. Maximum number of iterations to perform if using an iterative method. tol : float, optional, default=1e-9. Tolerance used for terminating solver solution when using iterative; solvers. permc_spec : str, optional, default=’NATURAL’. Column ordering used internally by superLU for the ‘direct’ LU; decomposition method. Options include ‘NATURAL and ‘COLAMD’.; If not using RCM then this is set to ‘COLAMD’ automatically unless; explicitly specified. use_precond : bool optional, default = True. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. Preconditioner for A. The preconditioner should approximate the inverse; of A. Effective preconditioning dramatically improves the rate of; convergence, for iterative methods only . If no preconditioner is; given and use_precond=True, then one is generated automatically. fill_factor : float",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:71067,perform,perform,71067,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['perform'],['perform']
Performance,ry method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (DispersivecQED method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot_qubism() (in module qutip.visualization). plot_schmidt() (i,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/genindex.html:12518,optimiz,optimizer,12518,docs/4.4/genindex.html,https://qutip.org,https://qutip.org/docs/4.4/genindex.html,1,['optimiz'],['optimizer']
Performance,rycascade). mesolve() (in module qutip.mesolve). ModelProcessor (class in qutip.qip.device). momentum() (in module qutip.operators). N. n_thermal() (in module qutip.utilities). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.opera,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:15743,optimiz,optimizer,15743,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['optimiz'],['optimizer']
Performance,"s : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:55006,optimiz,optimize,55006,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"s and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.pa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-parfor.html:1281,perform,performing,1281,docs/4.6/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html,1,['perform'],['performing']
Performance,"s are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; :class:`~qutip.control.optimizer.Optimizer` object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:54138,optimiz,optimize,54138,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"s as argument, and returns a list of corresponding propagators. Bug Fixes:¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012):¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum obje",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:8680,perform,performance,8680,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,9,['perform'],['performance']
Performance,"s here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are cal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:3203,optimiz,optimize,3203,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['optimiz'],['optimize']
Performance,"s in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-basics.html:1846,load,load,1846,docs/3.0.1/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html,1,['load'],['load']
Performance,"s obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner.; weight (float, optional) – Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; x0 (ndarray, optional) – ITERATIVE ONLY. Initial guess for solution vector.; maxiter (int, optional, default=1000) – ITERATIVE ONLY. Maximum number of iterations to perform.; tol (float, optional, default=1e-12) – ITERATIVE ONLY. Tolerance used for terminating solver.; permc_spec (str, optional, default='COLAMD') – ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified.; use_precond (bool optional, default = False) – ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases.; M ({sparse matrix, dense matrix, LinearOperator}, optional) – ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically.; fill_factor (float",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:103206,perform,perform,103206,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['perform'],['perform']
Performance,"s of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value appl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:68218,optimiz,optimize,68218,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"s trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; !",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:13556,optimiz,optimize,13556,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"s). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. [docs]def weighted_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular. This function looks at both the structure and ABS values of the; underlying matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; .. [1] I. S. Duff and J. Koster, ""The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices"", SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). """"""; nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'). if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(). perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. B",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/graph.html:8971,perform,performing,8971,docs/3.1.0/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/graph.html,1,['perform'],['performing']
Performance,"s). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. [docs]def weighted_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular. This function looks at both the structure and ABS values of the; underlying matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices"", SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). """""". nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'). if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(). perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. © Copyri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/graph.html:8277,perform,performing,8277,docs/4.4/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/graph.html,1,['perform'],['performing']
Performance,"s). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. [docs]def weighted_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular. This function looks at both the structure and ABS values of the; underlying matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices"", SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). """"""; ; nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'). if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(). perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float), ; A.indices, A.indptr, nrows). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. © Cop",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/graph.html:8283,perform,performing,8283,docs/4.2/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/graph.html,5,['perform'],['performing']
Performance,"s); if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'); return perm. [docs]def weighted_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular. This function looks at both the structure and ABS values of the underlying; matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices"", SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997).; """"""; _deprecate(); nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'); if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(); perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows); if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'); return",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/graph.html:8533,perform,performing,8533,docs/4.6/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html,2,['perform'],['performing']
Performance,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-control.html:12957,optimiz,optimization,12957,docs/4.3/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html,4,['optimiz'],['optimization']
Performance,"s, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:4973,perform,performance,4973,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,6,['perform'],"['performance', 'performed', 'performer']"
Performance,"s. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.; There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised.; TerminationConditions; This is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:15982,perform,performed,15982,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,2,['perform'],['performed']
Performance,"s; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/correlation.html:36625,load,loaded,36625,docs/4.4/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/correlation.html,1,['load'],['loaded']
Performance,"s; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:36678,load,loaded,36678,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,1,['load'],['loaded']
Performance,"s; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:37254,load,loaded,37254,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,1,['load'],['loaded']
Performance,"s; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add; ; if t_idx == 1:; options.rhs_reuse = True; ; if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:36298,load,loaded,36298,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,4,['load'],['loaded']
Performance,"s; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:188299,optimiz,optimize,188299,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"s; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [5]: a * vac; Out[5",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-states.html:1297,perform,performing,1297,docs/4.2/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-states.html,3,['perform'],['performing']
Performance,"s; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [5]: a * vac; Out[5]: ; Quant",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:1297,perform,performing,1297,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,2,['perform'],['performing']
Performance,"s; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : stri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:147668,optimiz,optimize,147668,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"s; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:156552,optimiz,optimize,156552,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"s; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:164364,optimiz,optimize,164364,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"s; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : stri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:162457,optimiz,optimize,162457,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"s; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:171345,optimiz,optimize,171345,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"s; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:179161,optimiz,optimize,179161,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"sation will; terminate when the fidelity error falls below this value; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:174412,perform,performane,174412,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['perform'],['performane']
Performance,"sation will; terminate when the fidelity error falls below this value; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:182982,perform,performane,182982,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['perform'],['performane']
Performance,"scaling : float. Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string. Fidelity error (and fidelity error gradient) comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:173441,optimiz,optimize,173441,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"scaling : float. Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict. Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string. Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:182072,optimiz,optimize,182072,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:188242,optimiz,optimize,188242,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:196877,optimiz,optimize,196877,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"se, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:9537,perform,perform,9537,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,1,['perform'],['perform']
Performance,"se, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; True, False; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:9070,perform,perform,9070,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,2,['perform'],['perform']
Performance,"self, blist, tlist, tau, c1=None, c2=None, notrace=False)[source]¶; Compute propagator for computing output field expectation values; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:36970,perform,performed,36970,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['perform'],['performed']
Performance,"show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. task_vec: array / list; The list or array of values for which the task function is to be; evaluated. args: list / dictionary; The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:; result : list; The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced vi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:213572,load,load-balanced,213572,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['load'],['load-balanced']
Performance,"show_scheduling=False, show_progressbar=False)¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. The list or array of values for which the task function is to be; evaluated. args: list / dictionary :. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:108543,load,load-balanced,108543,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['load'],['load-balanced']
Performance,"si0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.21111367, 3.243081 , 2.64337648, 2.2162089 , 1.90369673,; 1.67257851, 1.50071221, 1.37250326, 1.27667537, 1.20496022]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [16]: a =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-saving.html:4238,load,load,4238,docs/4.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-saving.html,1,['load'],['load']
Performance,"si0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 5.47236604, 4.25321934, 3.40221147, 2.78459863, 2.32939541,; 1.99152365, 1.739766 , 1.55173281, 1.41108289, 1.30577149]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [16]: a =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:5038,load,load,5038,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,1,['load'],['load']
Performance,"si0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.04416292, 3.22336973, 2.64206514, 2.2194952 , 1.90787059,; 1.67647333, 1.50399675, 1.37514572, 1.27874735, 1.20656019]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [16]: a =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-saving.html:4246,load,load,4246,docs/4.4/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-saving.html,1,['load'],['load']
Performance,"si0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.40942767, 3.44132235, 2.80622054, 2.3433275 , 2.00107858,; 1.74653819, 1.55662702, 1.41466358, 1.30841238, 1.22882551]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [16]: a =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-saving.html:4250,load,load,4250,docs/4.3/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html,1,['load'],['load']
Performance,"si0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [16]: a =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-saving.html:4291,load,load,4291,docs/4.5/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-saving.html,1,['load'],['load']
Performance,"si0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 5.05864971, 3.933244 , 3.16570274, 2.60846057, 2.19781898,; 1.8930801 , 1.66604188, 1.49648702, 1.36966702, 1.27471483]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [17]: a =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-saving.html:4999,load,load,4999,docs/3.0.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html,1,['load'],['load']
Performance,"sible. Can be slower. Returns:oper : qobj. Operator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters:method : str. Algorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:oper : qobj. A valid density operator. unit(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:norm : str. Requested norm for states / operators. sparse : bool. Use sparse eigensolver for trace norm. Does not affect other norms. tol : float. Tolerance used by sparse eigensolver. maxiter : int. Number of maximum iterations performed by sparse eigensolver. Returns:oper : qobj. Normalized quantum object. eseries¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects.; Attributes. ampl; (ndarray) Array of amplitudes for exponential series. rates; (ndarray) Array of rates for exponential series. dims; (list) Dimensions of exponential series components. shape; (list) Shape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:wlist : array_like. Array/list of frequenies. Returns:val_list : ndarray. Values of exponential series at frequencies in wlist. tidyup(*args)[sourc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:15565,perform,performed,15565,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performed']
Performance,"simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options is None:; options = Options(). if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # print("" ""); H = solver_safe[""mcsolve""]; else:; pass; # raise Exception(""Could not find the Hamiltonian to reuse.""). if not ntraj:; ntraj = options.ntraj. if len(c_ops) == 0 and not options.rhs_reuse:; warn(""No c_ops, using sesolve""); return sesolve(H, psi0, tlist, e_ops=e_ops, args=args,; options=options, progress_bar=progress_bar,; _safe_mode=_safe_mode). try:; num_traj = int(ntraj); except:; num_traj = max(ntraj). # set the physics; if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). # load monte carlo class; mc = _MC(options). if isinstance(H, SolverSystem):; mc.ss = H; else:; mc.make_system(H, c_ops, tlist, args, options). mc.reset(tlist[0], psi0). mc.set_e_ops(e_ops). if options.seeds is not None:; mc.seed(num_traj, options.seeds). if _safe_mode:; mc.run_test(). # Run the simulation; mc.run(num_traj=num_traj, tlist=tlist,; progress_bar=progress_bar,; map_func=map_func, map_kwargs=map_kwargs). return mc.get_result(ntraj). # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """"""; def __init__(self, options=None):; if options is None:; options = Options(); self.options = options; self.ss = None; self.tlist = None; self.e_ops = None; self.ran = False; self.psi0 = None; self.seeds = []; self.t = 0.; self.num_traj = 0; self.args_col = None. self._psi_out = []; self._expect_out = [];",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mcsolve.html:6799,load,load,6799,docs/4.5/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mcsolve.html,1,['load'],['load']
Performance,"sion 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [3]: Qobj(); Out[3]: ; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-basics.html:2354,load,loaded,2354,docs/3.1.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html,1,['load'],['loaded']
Performance,"sion 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. Version 4.6.3 (February ?, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:2145,perform,performance,2145,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,1,['perform'],['performance']
Performance,"slot. Parameters; ----------; file_name: string; Name of the file. inctime: bool, optional; True if the time list should be included in the first column.; """"""; self._is_pulses_valid(); # TODO this works only for step_func; # TODO replace this by get_complete_coeffs; coeffs = np.array(self.get_full_coeffs()); if inctime:; shp = coeffs.T.shape; data = np.empty((shp[0], shp[1] + 1), dtype=np.float); data[:, 0] = self.get_full_tlist(); data[:, 1:] = coeffs.T; else:; data = coeffs.T. np.savetxt(file_name, data, delimiter='\t', fmt='%1.16f'). [docs] def read_coeff(self, file_name, inctime=True):; """"""; Read the control amplitudes matrix and time list; saved in the file by `save_amp`. Parameters; ----------; file_name: string; Name of the file. inctime: bool, optional; True if the time list in included in the first column. Returns; -------; tlist: array_like; The time list read from the file. coeffs: array_like; The pulse matrix read from the file.; """"""; data = np.loadtxt(file_name, delimiter='\t'); if not inctime:; self.coeffs = data.T; return self.coeffs; else:; tlist = data[:, 0]; self.set_all_tlist(tlist); self.coeffs = data[:, 1:].T; return self.get_full_tlist, self.coeffs. [docs] def get_noisy_pulses(self, device_noise=False, drift=False):; """"""; It takes the pulses defined in the `Processor` and; adds noise according to `Processor.noise`. It does not modify the; pulses saved in `Processor.pulses` but returns a new list.; The length of the new list of noisy pulses might be longer; because of drift Hamiltonian and device noise. They will be; added to the end of the pulses list. Parameters; ----------; device_noise: bool, optional; If true, include pulse independent noise such as single qubit; Relaxation. Default is False.; drift: bool, optional; If true, include drift Hamiltonians. Default is False. Returns; -------; noisy_pulses: list of :class""`qutip.qip.Pulse`/:class:`qutip.qip.Drift`; A list of noisy pulses.; """"""; # TODO add tests; pulses = deepcopy(self.pulses); no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:13467,load,loadtxt,13467,docs/4.5/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html,1,['load'],['loadtxt']
Performance,"sm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; permute(order); Returns composite qobj with indices reordered.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. """"""; __array_priority__ = 100 # sets Qobj priority above numpy arrays. def __init__(self, inpt=None, dims=[[], []], shape=[],; type=None, isherm=None, copy=True,; fast=False, superrep=None):; """"""; Qobj constructor.; """"""; self._isherm = isherm; self._type = type; self.superrep = superrep. if fast == 'mc':; # fast Qobj construction for use in mcsolve with ket output; self._data = inpt; self.dims = dims; self._isherm = False; return. if fa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:6956,perform,performing,6956,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,1,['perform'],['performing']
Performance,"source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result – The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. Return type:list. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table – Return an HTML-formatted string containing version information for; QuTi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:202337,load,load-balanced,202337,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['load'],['load-balanced']
Performance,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:4664,perform,performs,4664,docs/4.0.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html,1,['perform'],['performs']
Performance,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:4664,perform,performs,4664,docs/4.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html,1,['perform'],['performs']
Performance,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/partial_transpose.html:4664,perform,performs,4664,docs/4.1/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/partial_transpose.html,1,['perform'],['performs']
Performance,"ss:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental.; ; """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another operator. Parameters; ----------; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B.; ; """"""; return mts.dnorm(self, B); ; ; @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.superrep in ('choi', 'chi'):; qobj = s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:43242,cache,cached,43242,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['cache'],['cached']
Performance,"ss; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-basics.html:1234,load,load,1234,docs/4.5/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-basics.html,1,['load'],['load']
Performance,"ssumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] arra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:170734,optimiz,optimizer,170734,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimizer']
Performance,"st_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.options.average_states):; states = np.array([Qobj()] * nstep); if (self.sparse_dms):; # averaged sparse density matrices; for i in range",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13351,queue,queue,13351,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,2,['queue'],['queue']
Performance,"stance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsU",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:91856,perform,performs,91856,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['perform'],['performs']
Performance,"stances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes:¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012):¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes:¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:9520,perform,performance,9520,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,7,['perform'],['performance']
Performance,"state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstates = eigenstates_or_projectors; state = eigenstates[i]; else:; projectors = eigenstates_or_projectors; state = (projectors[i] * state * projectors[i]) / probabilities[i]; return eigenvalues[i], state. [docs]def measure_povm(state, ops, targets=None):; r""""""; Perform a measurement specified by list of POVMs. This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/measurement.html:8348,perform,perform,8348,docs/4.7/modules/qutip/measurement.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/measurement.html,1,['perform'],['perform']
Performance,"state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstates = eigenstates_or_projectors; state = eigenstates[i]; else:; projectors = eigenstates_or_projectors; state = (projectors[i] * state * projectors[i]) / probabilities[i]; return eigenvalues[i], state. def measure_povm(state, ops, targets=None):; r""""""; Perform a measurement specified by list of POVMs. This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operator cor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/measurement.html:10022,perform,perform,10022,docs/4.6/modules/qutip/measurement.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/measurement.html,1,['perform'],['perform']
Performance,"state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters:; order : str {‘C’, ‘F’}; Return array in C (default) or Fortran ordering. squeeze : bool {False, True}; Squeeze output array. Returns:; data : array; Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True); Check for degenerate ground state. Returns:; eigval : float; Eigenvalue for the ground state of quantum operator. eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type ‘bra’ or ‘ket’. ket : qobj; Quantum object of type ‘ket’. Returns:; elem : complex; Complex valued matrix element. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm : str; Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:10711,perform,performed,10711,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performed']
Performance,"sted.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:81738,optimiz,optimize,81738,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"ston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/metrics.html:12323,optimiz,optimization,12323,docs/4.4/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/metrics.html,3,['optimiz'],['optimization']
Performance,"ston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:10783,optimiz,optimization,10783,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,3,['optimiz'],['optimization']
Performance,"ston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value.; ; if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/metrics.html:10810,optimiz,optimization,10810,docs/4.3/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/metrics.html,2,['optimiz'],['optimization']
Performance,"sts:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); return full_tlist. [docs] def print_info(self):; """"""; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise.; """"""; print(""-----------------------------------""; ""-----------------------------------""); if self.label is not None:; print(""Pulse label:"", self.label); print(""The pulse contains: {} coherent noise elements and {} ""; ""Lindblad noise elements."".format(; len(self.coherent_noise), len(self.lindblad_noise))); print(); print(""Ideal pulse:""); print(self.ideal_pulse); if self.coherent_noise:; print(); print(""Coherent noise:""); for ele in self.coherent_noise:; print(ele); if self.lindblad_noise:; print(); print(""Lindblad noise:""); for ele in self.lindblad_noise:; print(ele); print(""-----------------------------------""; ""-----------------------------------""). class Drift():; """"""; The time independent drift Hamiltonian. Usually its the intrinsic; evolution of the quantum system that can not be tuned. Parameters; ----------; qobj: :class:`qutip.Qobj` or list of :class:`qutip.Qobj`, optional; The drift Hamiltonians. Attributes; ----------; qobj: list of :class:`qutip.Qobj`; A list of the the drift Hamiltonians.; """"""; def __init__(self, qobj=None):; if qobj is None:; self.drift_hamiltonians = []; elif isinstance(qobj, list):; self.drift_hamiltonians = qobj; else:; self.drift_hamiltonians = [qobj]. def add_drift(self, qobj, targets):; """"""; Add a Hamiltonian to the drift. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; """"""; self.drift_hamiltonians.append(_EvoElement(qobj, targets)). def get_ideal_qobjevo(self, dims):; """"""; Get the QobjEvo representation of the drift Hamiltonian. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:13125,tune,tuned,13125,docs/4.5/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html,1,['tune'],['tuned']
Performance,"sualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [4]: Qobj(); Out[4]: ; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-basics.html:1640,load,loaded,1640,docs/4.5/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-basics.html,1,['load'],['loaded']
Performance,"sured_valuefloatThe result of the measurement (one of the eigenvalues of op). stateQobjThe new state (a ket if a ket was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measure_povm(state, ops, targets=None)[source]¶; Perform a measurement specified by list of POVMs.; This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operator corresponding to the collapsed state as well as the; collapsed state. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opslist of QobjList of measurement operators \(M_i\) or kets. Either:. specifying a POVM s.t. \(E_i = M_i^\dagger M_i\); projection operators if ops correspond to projectors (s.t.;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:74363,perform,perform,74363,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['perform'],['perform']
Performance,"sured_valuefloatThe result of the measurement (one of the eigenvalues of op). stateQobjThe new state (a ket if a ket was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measurement_statistics(state, ops, targets=None)[source]¶; A dispatch method that provides measurement statistics handling both; observable style measurements and projector style measurements(POVMs and; PVMs).; For return signatures, please check:. measurement_statistics_observable for observable measurements.; measurement_statistics_povm for POVM measurements. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opsQobj or list of Qobj; measurement observable (:class:.Qobj); or; list of measurement operators \(M_i\) or kets (list of; Qobj) Either:. specifying a POVM",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:72144,perform,perform,72144,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['perform'],['perform']
Performance,"system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:7983,perform,perform,7983,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,2,['perform'],['perform']
Performance,"system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:8223,perform,perform,8223,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,5,['perform'],['perform']
Performance,"system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (5) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (5) from physical arguments, and hence perform a calculation in QuTiP:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html:8316,perform,perform,8316,docs/4.5/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html,1,['perform'],['perform']
Performance,"t Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide.html:2677,load,loading,2677,docs/4.6/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide.html,2,['load'],['loading']
Performance,"t is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer¶; PropagatorComputer (subclass instance) – Used to compute the propagators and their gradients. fid_computer¶; FidelityComputer (subclass instance) – Used to computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more infor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:76780,perform,performance,76780,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performance']
Performance,"t quantum objects. """""". if isinstance(state, Qobj):. if self.isbra:; if state.isket:; return (self.data * state.data)[0, 0]; elif state.isbra:; return (self.data * state.data.H)[0, 0]. elif self.isket:; if state.isbra:; return (self.data.H * state.data.H)[0, 0]; elif state.isket:; return (self.data.H * state.data)[0, 0]. raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:37710,perform,performed,37710,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,2,['perform'],['performed']
Performance,"t space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created usi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/frontmatter.html:5611,perform,performance,5611,docs/3.1.0/frontmatter.html,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html,1,['perform'],['performance']
Performance,"t square. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(self, other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(self, order)[source]¶; Permutes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:12161,perform,performed,12161,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['perform'],['performed']
Performance,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:3791,perform,performs,3791,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,5,['perform'],['performs']
Performance,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.contr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:3800,perform,performs,3800,docs/4.5/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html,1,['perform'],['performs']
Performance,"t the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:63402,optimiz,optimize,63402,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,6,['optimiz'],['optimize']
Performance,"t, U_f_list, H_ops_data,; dt, eps, alpha_val, beta_val, phase_sensitive,; use_u_limits, u_min, u_max). if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[-1, j, :]] for j in range(J)]. progress_bar.finished(). return GRAPEResult(u=u, U_f=Qobj(U_f_list[-1], dims=U.dims),; H_t=H_td_func). [docs]def grape_unitary_adaptive(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear',; use_interp=False, alpha=None, beta=None,; phase_sensitive=False, overlap_terminate=1.0,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that; the unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). eps_vec = np.array([eps / 2, eps, 2 * eps]); eps_log = np.zeros(R); overlap_log = np.zeros(R). best_k = 0; _k_overlap = np.array([0.0, 0.0, 0.0]). M = len(times); J = len(H_ops); K = len(eps_vec); Uf = [None for _ in range(K)]. u = np.zeros((R, J, M, K)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:12676,tune,tuned,12676,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['tune'],['tuned']
Performance,"t.shape[0])], [int(inpt.shape[1])]]; else:; self.dims = dims. elif isinstance(inpt, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; # if input is int, float, or complex then convert to array; _tmp = sp.csr_matrix([[inpt]], dtype=complex); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr), ; shape = _tmp.shape); if not np.any(dims):; self.dims = [[1], [1]]; else:; self.dims = dims. else:; warnings.warn(""Initializing Qobj from unsupported type: %s"" %; builtins.type(inpt)); inpt = np.array([[0]]); _tmp = sp.csr_matrix(inpt, dtype=complex, copy=copy); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr), ; shape = _tmp.shape); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]. if type == 'super':; if self.type == 'oper':; self.dims = [[[d] for d in self.dims[0]],; [[d] for d in self.dims[1]]]. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # clear type cache; self._type = None. ; def get_data(self):; return self._data; #Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data); ; def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; other = Qobj(other). if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.data = self.data + dat * fast_identity(; self.shape[0]); else:; out.data = self.data; out.data.data = out.data.data + dat. out.dims = self.dims; if isinstance(dat, (int, float)):; out._isherm = self._isherm; else:; # We use _isherm here to prevent recalculating on self ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:10547,cache,cache,10547,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['cache'],['cache']
Performance,"t; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:59125,optimiz,optimizer,59125,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"t; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012):¶. Bug Fixes:¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011):¶. New Functions:¶. Allow custom naming of Bloch sphere. Bug Fixes:¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:10395,concurren,concurrence,10395,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,9,['concurren'],['concurrence']
Performance,"t; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012)¶. Bug Fixes¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011)¶. New Functions¶. Allow custom naming of Bloch sphere. Bug Fixes¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are ze",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:44711,concurren,concurrence,44711,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['concurren'],['concurrence']
Performance,"tFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attrib",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:185788,perform,performane,185788,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['perform'],['performane']
Performance,"tFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringdetermines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object; The key value pairs are as",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:194236,perform,performane,194236,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['perform'],['performane']
Performance,"tate. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:13530,optimiz,optimize,13530,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,2,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"te matrix elements for bra and ket vectors.""). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets.; """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; #Since we deal mainly with ket vectors, the bra-bra combo; #is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:39480,optimiz,optimized,39480,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['optimiz'],['optimized']
Performance,"te the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-correlation.html:4861,perform,performs,4861,docs/4.7/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html,1,['perform'],['performs']
Performance,"ted Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Gri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/frontmatter.html:4116,perform,performance,4116,docs/4.4/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html,2,['perform'],['performance']
Performance,"ted Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/frontmatter.html:4261,perform,performance,4261,docs/4.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html,2,['perform'],['performance']
Performance,"ted Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:4197,perform,performance,4197,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,2,['perform'],['performance']
Performance,"tems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/biblio.html:3011,optimiz,optimization,3011,docs/4.4/biblio.html,https://qutip.org,https://qutip.org/docs/4.4/biblio.html,2,['optimiz'],['optimization']
Performance,"tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; _op = self*self.dag(); vals = sp_eigs(_op.data, _op.isherm, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(np.sqrt(np.abs(vals))); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm must be 'l2', or 'max'.""). [docs] def proj(self):; """"""Form the projector from a given ket or b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:26248,perform,performed,26248,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,3,['perform'],['performed']
Performance,"tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; _op = self.data * zcsr_adjoint(self.data); vals = sp_eigs(_op, True, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(np.sqrt(np.abs(vals))); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm must be 'l2', or 'max'.""). [docs] def proj(self):; """"""Form the projector from a given",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:27415,perform,performed,27415,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['perform'],['performed']
Performance,"tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; vals = sp_eigs(self.data, self.isherm, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(sqrt(abs(vals) ** 2)); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm must be 'l2', or 'max'.""). [docs] def tr(self):; """"""Trace of a quantum object. Returns; -------; trace : float; Retu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:25443,perform,performed,25443,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['perform'],['performed']
Performance,"ter Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:2105,perform,perform,2105,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,8,['perform'],['perform']
Performance,"ter, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:64670,optimiz,optimizer,64670,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"ter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:5118,perform,performance,5118,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,8,['perform'],['performance']
Performance,"term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:70651,optimiz,optimize,70651,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function valu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:67656,optimiz,optimize,67656,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,3,['optimiz'],['optimize']
Performance,"terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the; ``termination_conditions`` matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:23223,optimiz,optimize,23223,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the ``termination_conditions`` matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~qutip.control.dynamics.Dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:21764,optimiz,optimize,21764,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"ternal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:1643,load,loading,1643,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,2,['load'],"['load', 'loading']"
Performance,"tes & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). I",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-parfor.html:1969,perform,performing,1969,docs/3.0.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html,1,['perform'],['performing']
Performance,"tes & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for construc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-bloch.html:1781,load,load,1781,docs/4.6/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html,1,['load'],['load']
Performance,"tes; -----; Uses the Q.expm() method. """"""; if self.dims[0][0] == self.dims[1][0]:; return 0.5 * ((1j * self).expm() + (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'). [docs] def sinm(self):; """"""Sine of a quantum operator. Operator must be square. Returns; -------; oper : qobj; Matrix sine of operator. Raises; ------; TypeError; Quantum object is not square. Notes; -----; Uses the Q.expm() method. """"""; if self.dims[0][0] == self.dims[1][0]:; return -0.5j * ((1j * self).expm() - (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'). [docs] def unit(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : qobj; Normalized quantum object. """"""; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out. [docs] def ptrace(self, sel):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q. [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : qobj; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:30800,perform,performed,30800,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,2,['perform'],['performed']
Performance,"that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code.; Attributes. H_sys; (Qobj) System Hamiltonian. coup_op; (Qobj) Operator describing the coupling between system and bath. coup_strength; (float) Coupling strength. temperature; (float) Bath temperature, in units corresponding to planck. N_cut; (int) Cutoff parameter for the bath. N_exp; (int) Number of exponential terms used to approximate the bath correlation functions. planck; (float) reduced Planck constant. boltzmann; (float) Boltzmann’s constant. options; (qutip.solver.Options) Generic solver options. If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for showing the progress of the simulation. stats; (qutip.solver.Stats) optional container for holding performance statitics If None is set, then statistics are not collected There may be an overhead in collecting statistics. exp_coeff; (list of complex) Coefficients for the exponential series terms. exp_freq; (list of complex) Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:options : qutip.solver.Options. Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`. Optional instance of solver.Stats, or a subclass the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:24342,perform,performance,24342,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performance']
Performance,the Eseries Class — QuTiP 4.5 Documentation; Guide Overview — QuTiP 4.5 Documentation; Parallel computation — QuTiP 4.5 Documentation; Quantum Information Processing — QuTiP 4.5 Documentation; Generating Random Quantum States & Operators — QuTiP 4.5 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.5 Documentation; Modifying Internal QuTiP Settings — QuTiP 4.5 Documentation; Manipulating States and Operators — QuTiP 4.5 Documentation; guide-states-1.pdf; guide-states-1.py; Solving for Steady-State Solutions — QuTiP 4.5 Documentation; Using Tensor Products and Partial Traces — QuTiP 4.5 Documentation; Visualization of quantum states and processes — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python (4.5) — QuTiP 4.5 Documentation; Installation — QuTiP 4.5 Documentation. /modules; . /qutip; . /control; ; qutip.control.dump — QuTiP 4.5 Documentation; qutip.control.dynamics — QuTiP 4.5 Documentation; qutip.control.fidcomp — QuTiP 4.5 Documentation; qutip.control.optimizer — QuTiP 4.5 Documentation; qutip.control.optimresult — QuTiP 4.5 Documentation; qutip.control.propcomp — QuTiP 4.5 Documentation; qutip.control.pulsegen — QuTiP 4.5 Documentation; qutip.control.pulseoptim — QuTiP 4.5 Documentation; qutip.control.stats — QuTiP 4.5 Documentation; qutip.control.termcond — QuTiP 4.5 Documentation; qutip.control.tslotcomp — QuTiP 4.5 Documentation. /nonmarkov; ; qutip.nonmarkov.heom — QuTiP 4.5 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.5 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.5 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.5 Documentation. /device; ; qutip.qip.device.modelprocessor — QuTiP 4.5 Documentation; qutip.qip.device.optpulseprocessor — QuTiP 4.5 Documentation; qutip.qip.device.processor — QuTiP 4.5 Documentation; qutip.qip.device.spinchain — QuTiP 4.5 Documentation. /operations; ; qutip.qip.operations.gates — QuTiP 4.5 Documentation. qutip.qip.circuit — QuTiP 4.5 Documentation; qutip.qip.nois,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:43506,optimiz,optimizer,43506,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['optimiz'],['optimizer']
Performance,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:8411,perform,performance,8411,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,7,['perform'],['performance']
Performance,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`qutip.control.dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html:7647,perform,performance,7647,docs/4.7/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html,1,['perform'],['performance']
Performance,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : dump.OptimDump; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:70148,perform,performance,70148,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performance']
Performance,"the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,3.2109553666e+00,3.6897715490e-01,1.8500286728e-02; 1.0101010101e+00,2.6754598872e+00,1.2982511320e-01,-3.3036729565e-01; 2.0202020202e+00,2.2743186810e+00,-2.1062412999e-01,-2.6238942773e-01; 3.0303030303e+00,1.9726633457e+00,-3.0373116210e-01,3.9733092145e-02. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-saving.html:8347,load,loaded,8347,docs/4.5/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-saving.html,1,['load'],['loaded']
Performance,"the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stand",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:7816,load,load,7816,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['load'],['load']
Performance,"the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. Semidefinite Programming¶; This module implements internal-use functions for semidefinite programming. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:252432,load,load-balanced,252432,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['load'],['load-balanced']
Performance,"this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,4.6283109309,-0.7139985949,-1.9302925449; 1.0101010101,3.7394716905,-1.5795745709,-0.2887283809; 2.0202020202,3.0806355195,-0.8933912070,1.0022231476; 3.0303030303,2.5873637218,0.3268461698,1.0991113962. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,4.6283109309e+00,-7.1399859487e-01,-1.9302925449e+00; 1.0101010101e+00,3.7394716905e+00,-1.5795745709e+00,-2.8872838088e-01; 2.0202020202e+00,3.0806355195e+00,-8.9339120701e-01,1.0022231476e+00; 3.0303030303e+00,2.5873637218e+00,3.2684616978e-01,1.0991113962e+00. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:8341,load,loaded,8341,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,1,['load'],['loaded']
Performance,"this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [27]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [28]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,5.6885201844,1.8969583115,-0.7610878745; 1.0101010101,4.4922228586,0.1636458173,-1.6411357401; 2.0202020202,3.6464536329,-1.1039557484,-0.8507373294; 3.0303030303,3.0175130081,-1.1224844139,0.4154688442. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [29]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [30]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,5.6885201844e+00,1.8969583115e+00,-7.6108787447e-01; 1.0101010101e+00,4.4922228586e+00,1.6364581733e-01,-1.6411357401e+00; 2.0202020202e+00,3.6464536329e+00,-1.1039557484e+00,-8.5073732939e-01; 3.0303030303e+00,3.0175130081e+00,-1.1224844139e+00,4.1546884424e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [31]: input_data = file_data_read('expect.dat'). In [32]: shape(input_data); Out[32]: (100, 4). In [33]: from pylab import *. In [34]: plot(input_data[:,0], input_data[:,1]); # plot the data; Out[34]: [<matplotlib.lines.Line2D at 0x2b1237fcc7d0>]. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-saving.html:9052,load,loaded,9052,docs/3.0.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html,1,['load'],['loaded']
Performance,"thm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:228619,optimiz,optimize,228619,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"thm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) com",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:161749,optimiz,optimize,161749,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"thm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringdetermines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDAT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:170425,optimiz,optimize,170425,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"tial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox counterpart by a substantial margin as the system size increases. To test the Monte Carlo solvers, here we simulate a trilinear Hamiltonian over a range of Hilbert space sizes. Since QuTiP uses multiprocessing, we can measure the performance gain when using several CPU’s. In contrast, the qotoolbox is limited to a single processor only. In the legend, we show the speed-up factor in the parenthesis, which should ideally be equal to the number of processors. Finally, we have included the results using hyperthreading, written here as 4+(x) where x is the number of hyperthreads, found in some newer Intel processors. We see however that the performance benefits from hy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-performance.html:1572,perform,performance,1572,docs/3.0.0/guide/dynamics/dynamics-performance.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-performance.html,1,['perform'],['performance']
Performance,"tically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r' $ \\ \left(\begin{matrix}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%.1f"" % value; else",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobj.html:21284,load,loading,21284,docs/4.7/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html,1,['load'],['loading']
Performance,"tically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:20924,load,loading,20924,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,6,['load'],['loading']
Performance,ties). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls (Dynamics attribute). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot_qubism() (in module qutip.visualization). plot_schmidt() (in module qutip.visualization). plot_spin_distribution_2d() (in module qutip.visualization). pl,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/genindex.html:11016,optimiz,optimizer,11016,docs/4.1/genindex.html,https://qutip.org,https://qutip.org/docs/4.1/genindex.html,2,['optimiz'],['optimizer']
Performance,"timisation will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :class:`~qutip.control.optimizer.Optimizer` object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the :c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:32362,perform,performane,32362,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['perform'],['performane']
Performance,"timisation will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key val",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:33631,perform,performane,33631,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['perform'],['performane']
Performance,"ting This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/frontmatter.html:1796,perform,performed,1796,docs/4.3/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html,3,['perform'],['performed']
Performance,"ting statistics. exp_coeff; (list of complex) Coefficients for the exponential series terms. exp_freq; (list of complex) Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:options : qutip.solver.Options. Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`. Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4).; Attributes. cut_freq; (float) Bath spectral density cutoff frequency. r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:25403,perform,performance,25403,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performance']
Performance,"ting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:28584,perform,performance,28584,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performance']
Performance,"tion for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:84959,optimiz,optimize,84959,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"tion will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(self, params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(self, params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:77595,optimiz,optimize,77595,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,tion — QuTiP 4.7 Documentation; Measurement of Quantum Objects — QuTiP 4.7 Documentation; Guide Overview — QuTiP 4.7 Documentation; Parallel computation — QuTiP 4.7 Documentation; Quantum Information Processing — QuTiP 4.7 Documentation; Generating Random Quantum States & Operators — QuTiP 4.7 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation; Modifying Internal QuTiP Settings — QuTiP 4.7 Documentation; Manipulating States and Operators — QuTiP 4.7 Documentation; Solving for Steady-State Solutions — QuTiP 4.7 Documentation; Using Tensor Products and Partial Traces — QuTiP 4.7 Documentation; Visualization of quantum states and processes — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python — QuTiP 4.7 Documentation; Installation — QuTiP 4.7 Documentation. /modules; . /qutip; . /control; ; qutip.control.dump — QuTiP 4.7 Documentation; qutip.control.dynamics — QuTiP 4.7 Documentation; qutip.control.fidcomp — QuTiP 4.7 Documentation; qutip.control.optimizer — QuTiP 4.7 Documentation; qutip.control.optimresult — QuTiP 4.7 Documentation; qutip.control.propcomp — QuTiP 4.7 Documentation; qutip.control.pulsegen — QuTiP 4.7 Documentation; qutip.control.pulseoptim — QuTiP 4.7 Documentation; qutip.control.stats — QuTiP 4.7 Documentation; qutip.control.termcond — QuTiP 4.7 Documentation; qutip.control.tslotcomp — QuTiP 4.7 Documentation. /nonmarkov; ; qutip.nonmarkov.bofin_baths — QuTiP 4.7 Documentation; qutip.nonmarkov.bofin_solvers — QuTiP 4.7 Documentation; qutip.nonmarkov.dlheom_solver — QuTiP 4.7 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.7 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.7 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.7 Documentation. /compiler; ; qutip.qip.compiler.cavityqedcompiler — QuTiP 4.7 Documentation; qutip.qip.compiler.gatecompiler — QuTiP 4.7 Documentation; qutip.qip.compiler.instruction — QuTiP 4.7 Documentation; qutip.qip.compiler.scheduler — QuTiP 4.7 Documentatio,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:61847,optimiz,optimizer,61847,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['optimiz'],['optimizer']
Performance,"tip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.super",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:46717,cache,cached,46717,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['cache'],['cached']
Performance,"tip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.su",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:48214,cache,cached,48214,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['cache'],['cached']
Performance,"tip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:3057,load,load,3057,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,2,['load'],['load']
Performance,"tip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arguments. See; q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:64844,optimiz,optimizing,64844,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,2,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"tip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:75904,optimiz,optimizing,75904,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,4,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:86187,perform,perform,86187,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,6,['perform'],['perform']
Performance,"tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteractions.; """"""; eigenvalues1, eigenvectors1 = eigh(T[0:, 0:]); U1 = np.matmul(krylov_basis[0:, 0:].T, eigenvectors1); e01 = eigenvectors1.conj().T[:, 0]. eigenvalues2, eigenvectors2 = eigh(T[0:-1, 0: T.shape[1] - 1]); U2 = np.matmul(krylov_basis[0:-1, :].T, eigenvectors2); e02 = eigenvectors2.conj().T[:, 0]. def f(t):; delta_t = -1j * (t - t0). aux1 = np.multiply(np.exp(delta_t * eigenvalues1), e01); psi1 = np.matmul(U1, aux1). aux2 = np.multiply(np.exp(delta_t * eigenvalues2), e02); psi2 = np.matmul(U2, aux2). error = np.linalg.norm(psi1 - psi2). steps = max(1, (tf - t0) // (t - t0)); return np.log10(error) + np.log10(steps) - np.log10(target_tolerance). return f. def _make_partitions(tlist, n_timesteps):; """"""Generates an internal 'partitions' list of np.arrays to iterate Lanczos; algorithms on each of them, based on 'tlist' and the optimized number of; iterations 'n_timesteps'.; """""". _tlist = np.copy(tlist). if n_timesteps == 1:; _tlist = np.insert(_tlist, 0, tlist[0]); _tlist = np.append(_tlist, tlist[-1]); partitions = [_tlist]; return partitions. n_timesteps += 1; krylov_tlist = np.linspace(tlist[0], tlist[-1], n_timesteps); krylov_partitions = [; np.array(krylov_tlist[i: i + 2]) for i in range(n_timesteps - 1); ]; partitions = []; for krylov_partition in krylov_partitions:; start = krylov_partition[0]; end = krylov_partition[-1]; condition = _tlist <= end; partitions.append([start] + _tlist[condition].tolist() + [end]); _tlist = _tlist[~condition]. return partitions. def _e_ops_outputs(krylov_results, e_ops, n_tlist_steps, opt):; krylov_results.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; krylov_results.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; krylov_results.num_expect = n_expt_op; if n_expt_op == 0:; # fall back o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:16671,optimiz,optimized,16671,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['optimiz'],['optimized']
Performance,"trix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type ‘bra’ or ‘ket’. ket : qobj; Quantum object of type ‘ket’. Returns:; elem : complex; Complex valued matrix element. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm : str; Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:; norm : float; The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. Parameters:; other : qobj; Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:; overlap : complex; Complex valued overlap. Raises:; TypeError; Can only calculate overlap between a bra and ket quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner product; call is the ket-ket version that computes the product <self|other> with; both vectors expressed as kets. permute(order)[source]¶; Permutes a composite quantum object. Parameters:; order : list/array; List specifying new tensor order. Returns:; P : qobj; Permuted quantum ob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:12075,perform,performed,12075,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performed']
Performance,trls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (DispersivecQED method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot_qubism() (in module qutip.visualization). plot_schmidt() (in module qutip.visualization). plot_spin_distributio,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/genindex.html:12570,optimiz,optimizer,12570,docs/4.4/genindex.html,https://qutip.org,https://qutip.org/docs/4.4/genindex.html,1,['optimiz'],['optimizer']
Performance,"trol amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParame",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:236808,optimiz,optimize,236808,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"trol amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParame",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:248926,optimiz,optimize,248926,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"trol_fields(times, u, labels, uniform_axes=False)[source]¶; Plot a series of plots showing the GRAPE control fields given in the; given control pulse matrix u. Parameters:times : array. Time coordinate array. u : array. Control pulse matrix. labels : list. List of labels for each control pulse sequence in the control pulse; matrix. uniform_axes : bool. Whether or not to plot all pulse sequences using the same y-axis scale. grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None, u_limits=None, interp_kind='linear', use_interp=False, alpha=None, beta=None, phase_sensitive=True, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x107b6fd90>)[source]¶; Calculate control pulses for the Hamiltonian operators in H_ops so that the; unitary U is realized.; Experimental: Work in progress. Parameters:U : Qobj. Target unitary evolution operator. H0 : Qobj. Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj. A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int. Number of GRAPE iterations. time : array / list. Array of time coordinates for control pulse evalutation. u_start : array. Optional array with initial control pulse values. Returns:Instance of GRAPEResult, which contains the control pulses calculated. with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator. grape_unitary_adaptive(U, H0, H_ops, R, times, eps=None, u_start=None, u_limits=None, interp_kind='linear', use_interp=False, alpha=None, beta=None, phase_sensitive=False, overlap_terminate=1.0, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x107be58d0>)[source]¶; Calculate control pulses for the Hamiltonian operators in H_ops so that; the unitary U is realized.; Experimental: Work in progress. Parameters:U : Qobj. Target unitary evolution operator. H0 : Qobj. Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj. A list of ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:128141,tune,tuned,128141,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['tune'],['tuned']
Performance,"ts attribute). num_tslot_recompute (Stats attribute). num_tslots (Dynamics attribute). (PulseGen attribute). num_waves (PulseGenPeriodic attribute). O. ode2es() (in module qutip.essolve). offset (PulseGen attribute). omega (DynamicsSymplectic attribute). onto_evo (Dynamics attribute), [1]. onwd_evo (Dynamics attribute), [1]. oper_dtype (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). optim_method (Optimizer attribute). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). optimizer (OptimResult attribute). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). options (HEOMSolver attribute). (MemoryCascade attribute). (StochasticSolverOptions attribute). (TTMSolverOptions attribute). orbital() (in module qutip.orbital). order (Options attribute). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel (MemoryCascade attribute). parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). params (Dynamics attribute). (Optimizer attribute). parent (Dump attribute). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). periodic (PulseGen attribute). permute() (Qobj method), [1]. phase() (in module qutip.operators). phase_basis() (in module qutip.states). phase_option (FidCompUnitary attribute). phasegate() (i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:18960,optimiz,optimizer,18960,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['optimiz'],['optimizer']
Performance,"ts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete spar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:7466,perform,perform,7466,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['perform'],['perform']
Performance,"ttr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:29921,optimiz,optimize,29921,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['optimiz'],['optimize']
Performance,"tum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/frontmatter.html:4207,perform,performance,4207,docs/4.0.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html,2,['perform'],['performance']
Performance,"tum object. cosm()¶; Cosine of quantum object. dag()¶; Adjoint (dagger) of quantum object. dnorm()¶; Diamond norm of quantum operator. dual_chan()¶; Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Returns eigenenergies and eigenstates of quantum object. expm()¶; Matrix exponential of quantum object. full()¶; Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000)¶; Returns eigenvalue and eigenket for the groundstate of a quantum; object. matrix_element(bra, ket)¶; Returns the matrix element of operator between bra and ket vectors. norm(norm='tr', sparse=False, tol=0, maxiter=100000)¶; Returns norm of a ket or an operator. permute(order)¶; Returns composite qobj with indices reordered. ptrace(sel)¶; Returns quantum object for selected dimensions after performing; partial trace. sinm()¶; Sine of quantum object. sqrtm()¶; Matrix square root of quantum object. tidyup(atol=1e-12)¶; Removes small elements from quantum object. tr()¶; Trace of quantum object. trans()¶; Transpose of quantum object. transform(inpt, inverse=False)¶; Performs a basis transformation defined by inpt matrix. trunc_neg(method='clip')¶; Removes negative eigenvalues and returns a new Qobj that is; a valid density operator. unit(norm='tr', sparse=False, tol=0, maxiter=100000)¶; Returns normalized quantum object. check_herm()[source]¶; Check if the quantum object is hermitian. Returns:isherm – Returns the new value of isherm property. Return type:bool. conj()[source]¶; Conjugate operator of quantum object. cosm()[source]¶; Cosine of a quantum operator.; Operator must be square. Returns:oper – Matrix cosine of operator. Return type:qobj. Raises:TypeError – Quantum object is not square. Notes; Uses the Q.expm() method. dag()[source]¶; Adjoint operat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:3888,perform,performing,3888,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performing']
Performance,"tware without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:2158,concurren,concurrence,2158,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,1,['concurren'],['concurrence']
Performance,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:5383,optimiz,optimized,5383,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,2,['optimiz'],['optimized']
Performance,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:7946,optimiz,optimized,7946,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,7,['optimiz'],['optimized']
Performance,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:39702,optimiz,optimized,39702,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['optimiz'],['optimized']
Performance,"ty error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; :class:`~qutip.control.optimizer.Optimizer` object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:53402,optimiz,optimize,53402,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"ty error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:54304,optimiz,optimize,54304,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"ty error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_typ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:22546,optimiz,optimize,22546,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance,"u[r + 1, j, -1] = u[r + 1, j, -2]. if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[-1, j, :]] for j in range(J)]. progress_bar.finished(). # return U_f_list[-1], H_td_func, u; return GRAPEResult(u=u, U_f=U_f_list[-1], H_t=H_td_func). def cy_grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamitonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). H_ops_data = [H_op.data for H_op in H_ops]. if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:9504,tune,tuned,9504,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['tune'],['tuned']
Performance,uantum States & Operators — QuTiP 4.6 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.6 Documentation; guide-saving-4.pdf; Modifying Internal QuTiP Settings — QuTiP 4.6 Documentation; Manipulating States and Operators — QuTiP 4.6 Documentation; guide-states-1.pdf; Solving for Steady-State Solutions — QuTiP 4.6 Documentation; Using Tensor Products and Partial Traces — QuTiP 4.6 Documentation; Visualization of quantum states and processes — QuTiP 4.6 Documentation; guide-visualization-13.pdf; guide-visualization-3.pdf; guide-visualization-4.pdf; guide-visualization-5.pdf; guide-visualization-6.pdf; guide-visualization-7.pdf; guide-visualization-8.pdf; guide-visualization-9.pdf. QuTiP: Quantum Toolbox in Python — QuTiP 4.6 Documentation; Installation — QuTiP 4.6 Documentation. /modules; . /qutip; . /control; ; qutip.control.dump — QuTiP 4.6 Documentation; qutip.control.dynamics — QuTiP 4.6 Documentation; qutip.control.fidcomp — QuTiP 4.6 Documentation; qutip.control.optimizer — QuTiP 4.6 Documentation; qutip.control.optimresult — QuTiP 4.6 Documentation; qutip.control.propcomp — QuTiP 4.6 Documentation; qutip.control.pulsegen — QuTiP 4.6 Documentation; qutip.control.pulseoptim — QuTiP 4.6 Documentation; qutip.control.stats — QuTiP 4.6 Documentation; qutip.control.termcond — QuTiP 4.6 Documentation; qutip.control.tslotcomp — QuTiP 4.6 Documentation. /nonmarkov; ; qutip.nonmarkov.heom — QuTiP 4.6 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.6 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.6 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.6 Documentation. /compiler; ; qutip.qip.compiler.cavityqedcompiler — QuTiP 4.6 Documentation; qutip.qip.compiler.gatecompiler — QuTiP 4.6 Documentation; qutip.qip.compiler.instruction — QuTiP 4.6 Documentation; qutip.qip.compiler.scheduler — QuTiP 4.6 Documentation; qutip.qip.compiler.spinchaincompiler — QuTiP 4.6 Documentation. /device; ; qutip.qip.device.cavityqed — QuTiP 4.6 Docu,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:53188,optimiz,optimizer,53188,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['optimiz'],['optimizer']
Performance,"uantum objects.; ; """""". if isinstance(state, Qobj):. if self.isbra:; if state.isket:; return (self.data * state.data)[0, 0]; elif state.isbra:; return (self.data * state.data.H)[0, 0]. elif self.isket:; if state.isbra:; return (self.data.H * state.data.H)[0, 0]; elif state.isket:; return (self.data.H * state.data)[0, 0]. raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:37504,perform,performed,37504,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['perform'],['performed']
Performance,"uantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value appl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:6481,optimiz,optimize,6481,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['optimiz'],['optimize']
Performance,"udes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:12274,load,loading,12274,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['load'],['loading']
Performance,"udes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information abou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:11285,load,loading,11285,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['load'],['loading']
Performance,"ue in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; progress_bar (ProgressBar) – Progress bar class instance for showing progress. Returns:result – The result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. Return type:list. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; task_vec (array / list) – The list or array of values for which the task function is to be; evaluated.; args (list / dictionary) – The optional additional argument to the task function. For example; a dictionary with parameter values.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:199866,load,load-balanced,199866,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['load'],['load-balanced']
Performance,"ue, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_typ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:149429,optimiz,optimize,149429,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"ue, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:158261,optimiz,optimize,158261,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"ue, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:166020,optimiz,optimize,166020,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"ulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and detail",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:68611,optimiz,optimize,68611,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"um System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-parfor.html:1300,perform,performed,1300,docs/4.2/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-parfor.html,5,['perform'],['performed']
Performance,"um of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimresult.html:2324,optimiz,optimizer,2324,docs/4.7/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimresult.html,2,['optimiz'],['optimizer']
Performance,um() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:19830,optimiz,optimizer,19830,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,2,['optimiz'],['optimizer']
Performance,"um_ctrl_amp_updates (Stats attribute). num_ctrls (Dynamics attribute), [1]. num_expect (Result attribute). num_fidelity_computes (Stats attribute). num_fidelity_func_calls (Stats attribute). num_grad_computes (Stats attribute). num_grad_func_calls (Stats attribute). num_iter (OptimResult attribute). (Stats attribute). num_timeslot_changes (Stats attribute). num_tslot_recompute (Stats attribute). num_tslots (Dynamics attribute). (PulseGen attribute). num_waves (PulseGenPeriodic attribute). O. ode2es() (in module qutip.essolve). offset (PulseGen attribute). omega (DynamicsSymplectic attribute). onto_evo (Dynamics attribute), [1]. onwd_evo (Dynamics attribute), [1]. oper_dtype (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). optim_method (Optimizer attribute). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). optimizer (OptimResult attribute). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). options (HEOMSolver attribute). (MemoryCascade attribute). (StochasticSolverOptions attribute). (TTMSolverOptions attribute). orbital() (in module qutip.orbital). order (Options attribute). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel (MemoryCascade attribute). parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). params (Dynamics attribute). (Optimizer attribute",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:18615,optimiz,optimizer,18615,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['optimiz'],['optimizer']
Performance,"umped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:12749,optimiz,optimizer,12749,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,3,['optimiz'],['optimizer']
Performance,"un_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. iter_num¶; int – Iteration number of the pulse optimisation. fid_func_call_num¶; int – Fidel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:71140,optimiz,optimize,71140,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/changelog.html:3651,optimiz,optimization,3651,docs/4.3/changelog.html,https://qutip.org,https://qutip.org/docs/4.3/changelog.html,3,['optimiz'],['optimization']
Performance,"unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:26127,optimiz,optimization,26127,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['optimiz'],['optimization']
Performance,"up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:64554,optimiz,optimizer,64554,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"urn _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/partial_transpose.html:5911,perform,performs,5911,docs/3.1.0/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/partial_transpose.html,1,['perform'],['performs']
Performance,"urn dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t); for n in range(A_len)]). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is subopti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:51086,optimiz,optimizations,51086,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['optimiz'],['optimizations']
Performance,"urn_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint {10}MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsbool {True, False}MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingbool {True, False}MKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, optional, default=1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, optional, default=1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optional, default=NoneITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matolfloat, optional, default=1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optional, default=’COLAMD’ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool optional, default = F",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:104038,perform,perform,104038,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['perform'],['perform']
Performance,"urns:oper – Operator in new basis. Return type:qobj. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters:method (str) – Algorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:oper – A valid density operator. Return type:qobj. unit(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:; norm (str) – Requested norm for states / operators.; sparse (bool) – Use sparse eigensolver for trace norm. Does not affect other norms.; tol (float) – Tolerance used by sparse eigensolver.; maxiter (int) – Number of maximum iterations performed by sparse eigensolver. Returns:oper – Normalized quantum object. Return type:qobj. eseries¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. ampl¶; ndarray – Array of amplitudes for exponential series. rates¶; ndarray – Array of rates for exponential series. dims¶; list – Dimensions of exponential series components. shape¶; list – Shape corresponding to exponential series components. value(tlist)¶; Evaluate an exponential series at the times listed in tlist. spec(wlist)¶; Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup()¶; Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:wlist (array_like) – Array/list of frequenies. Returns:val_list – Values of exponential series at frequencies in wlist. Return type:ndarray. t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:15733,perform,performed,15733,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performed']
Performance,"ute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = ac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:59198,optimiz,optimizer,59198,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"ute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:7004,perform,performed,7004,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,8,['perform'],['performed']
Performance,"ute). (Stats attribute). num_timeslot_changes (Stats attribute). num_tslot_recompute (Stats attribute). num_tslots (Dynamics attribute). (PulseGen attribute). num_waves (PulseGenPeriodic attribute). O. ode2es() (in module qutip.essolve). offset (PulseGen attribute). omega (DynamicsSymplectic attribute). onto_evo (Dynamics attribute), [1]. onwd_evo (Dynamics attribute), [1]. oper_dtype (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). optim_method (Optimizer attribute). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). optimizer (OptimResult attribute). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). options (HEOMSolver attribute). (MemoryCascade attribute). (StochasticSolverOptions attribute). (TTMSolverOptions attribute). orbital() (in module qutip.orbital). order (Options attribute). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel (MemoryCascade attribute). parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). params (Dynamics attribute). (Optimizer attribute). parent (Dump attribute). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). periodic (PulseGen attribute). permute() (Qobj method), [1]. phase() (in module qutip.operators). phase_basis() (in module qutip.states). phase",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:18910,optimiz,optimizer,18910,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['optimiz'],['optimizer']
Performance,"uter, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65242,optimiz,optimizer,65242,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,utip.operators). N. n_thermal() (in module qutip.utilities). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls (Dynamics attribute). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot_qubism() (in module qutip.visualization). plot_schmidt() (in module qutip.visualization). plot_spin,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/genindex.html:10962,optimiz,optimizer,10962,docs/4.1/genindex.html,https://qutip.org,https://qutip.org/docs/4.1/genindex.html,2,['optimiz'],['optimizer']
Performance,"utput.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:20405,load,loading,20405,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,1,['load'],['loading']
Performance,"utput.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:22771,load,loading,22771,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,1,['load'],['loading']
Performance,"utput.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/changelog.html:21109,load,loading,21109,docs/4.1/changelog.html,https://qutip.org,https://qutip.org/docs/4.1/changelog.html,1,['load'],['loading']
Performance,"uture.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of puls",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:15036,load,loadparams,15036,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['load'],['loadparams']
Performance,"value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string. Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer. The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float. Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string. Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float. (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity er",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:133420,optimiz,optimize,133420,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string. Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer. The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float. Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. amp_update_mode : string. determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string. type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW. (see PulseGen classes for details). pulse_scaling : float. Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output fro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:139961,optimiz,optimize,139961,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity er",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:7912,optimiz,optimize,7912,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimize']
Performance,"value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output fro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:16647,optimiz,optimize,16647,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"ve knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:144086,optimiz,optimize,144086,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:5133,load,load,5133,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['load'],['load']
Performance,"view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that wi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:211131,load,load-balanced,211131,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['load'],['load-balanced']
Performance,"view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string contai",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:254755,load,load-balanced,254755,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['load'],['load-balanced']
Performance,"void these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip.; Some developments tasks remain, including providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. status; completed. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:13721,perform,performance,13721,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,1,['perform'],['performance']
Performance,"w Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:29835,load,loading,29835,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,1,['load'],['loading']
Performance,"w_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instanc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:253153,load,load-balanced,253153,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['load'],['load-balanced']
Performance,"w_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Misc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:212847,load,load-balanced,212847,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['load'],['load-balanced']
Performance,"wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset = pulse_offset; p_gen.lbound = amp_lbound; p_gen.ubound = amp_ubound. # If the pulse is a periodic type, then set the pulse to be one complete; # wave; if isinstance(p_gen, pulsegen.PulseGenPeriodic):; p_gen.num_waves = 1.0; optim.pulse_generator = p_gen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + p_gen.__class__.__name__). return optim. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:31446,optimiz,optimizer,31446,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:4392,optimiz,optimization,4392,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimization']
Performance,"was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:4396,optimiz,optimization,4396,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,4,['optimiz'],['optimization']
Performance,"was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:4405,optimiz,optimization,4405,docs/4.5/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimization']
Performance,"was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measure_povm(state, ops, targets=None)[source]¶; Perform a measurement specified by list of POVMs.; This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operator corresponding to the collapsed state as well as the; collapsed state. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opslist of QobjList of measurement operators \(M_i\) or kets. Either:. specifying a POVM s.t. \(E_i = M_i^\dagger M_i\); projection operators if ops correspond to projectors (s.t.; \(E_i = M_i^\dagger = M_i\)); kets (transformed to projectors). targetslist of ints, optionalSpecifies a list of ta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:74415,perform,perform,74415,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['perform'],['perform']
Performance,"was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measurement_statistics(state, ops, targets=None)[source]¶; A dispatch method that provides measurement statistics handling both; observable style measurements and projector style measurements(POVMs and; PVMs).; For return signatures, please check:. measurement_statistics_observable for observable measurements.; measurement_statistics_povm for POVM measurements. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opsQobj or list of Qobj; measurement observable (:class:.Qobj); or; list of measurement operators \(M_i\) or kets (list of; Qobj) Either:. specifying a POVM s.t. \(E_i = M_i^\dagger * M_i\); projection operators if ops correspond to projectors (s.t.; \(E_i = M_i^\dagger =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:72196,perform,perform,72196,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['perform'],['perform']
Performance,"we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:157024,optimiz,optimize,157024,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:8993,cache,cache,8993,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,2,['cache'],['cache']
Performance,"with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; calculate the of controls from the length of the control list. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:86740,cache,cache,86740,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['cache'],['cache']
Performance,"x element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError :. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparse : bool. Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float. Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:norm : float. The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(state)¶; Overlap between two state vectors.; Gives the overlap (scalar product) for the quantum object and state; state vector. Parameters:state : qobj. Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:overlap : complex. Complex valued overlap. Raises:TypeError :. Can only calculate overlap between a bra and ket quantum objects. permute(order)¶; Permutes a composite quantum object. Parameters:order : list/array. List specifying new tensor order. Returns:P : qobj. Permuted quantum object. i :. ptrace(sel)¶; Partial trace of the quantum object. Parameters:sel : int/list. An int or list of components to keep after partial trace. Returns:oper: qobj :. Quantum object representing partial trace with selected components; remaini",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:10644,perform,performed,10644,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['perform'],['performed']
Performance,"x is a subclass of FidCompTraceDiff; # so need to check this type first; if fid_type == 'DEF' or fid_type is None or fid_type == '':; # None given, use the default for the Dynamics; pass; elif fid_type == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:29404,optimiz,optimizer,29404,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"xist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_params : dict; Parameters for the :obj:`~qutip.control.propcomp.PropagatorComputer`; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_params : dict; Parameters for the :obj:`~qutip.control.fidco",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:43880,optimiz,optimizer,43880,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"xpect[1], '--', lw=2); Out[31]: ; [<matplotlib.lines.Line2D at 0x1096d45d0>,; <matplotlib.lines.Line2D at 0x1096d47d0>]. In [32]: title('Monte Carlo time evolution'); Out[32]: <matplotlib.text.Text at 0x107db4790>. In [33]: xlabel('Time', fontsize=14); Out[33]: <matplotlib.text.Text at 0x1078fcd10>. In [34]: ylabel('Expectation values', fontsize=14); Out[34]: <matplotlib.text.Text at 0x107df7150>. In [35]: legend((""cavity photon number"", ""atom excitation probability"")); Out[35]: <matplotlib.legend.Legend at 0x107a31b90>. In [36]: show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has enhanced performance for systems with small Hilbert space dimensionality. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstration; In [37]: data1 = mcsolve_f90(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:16583,perform,performing,16583,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,3,['perform'],"['performance', 'performing']"
Performance,"y serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""); ; if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other); ; if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""); ; elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:20735,load,loading,20735,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['load'],['loading']
Performance,y). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine() (BosonicBath class method). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase(),MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/genindex.html:5542,concurren,concurrence,5542,docs/4.7/genindex.html,https://qutip.org,https://qutip.org/docs/4.7/genindex.html,1,['concurren'],['concurrence']
Performance,"y: https://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Cho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:10248,optimiz,optimization,10248,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,1,['optimiz'],['optimization']
Performance,"y_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`qutip.control.optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/dump.html:6364,optimiz,optimizer,6364,docs/4.7/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/dump.html,1,['optimiz'],['optimizer']
Performance,"ynamics of the (quantum) system. to be control optimised. Attributes. dumping. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value Note: attributes are created if they do not exist already, and are overwritten if they do. alg; (string) Algorithm to use in pulse optimisation. Options are: ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering ‘CRAB’ - Chopped RAndom Basis. alg_params; (Dictionary) options that are specific to the pulse optim algorithm that is GRAPE or CRAB. disp_conv_msg; (bool) Set true to display a convergence message (for scipy.optimize.minimize methods anyway). optim_method; (string) a scipy.optimize.minimize method that will be used to optimise the pulse for minimum fidelity error. method_params; (Dictionary) Options for the optim_method. Note that where there is an equivalent attribute of this instance or the termination_conditions (for example maxiter) it will override an value in these options. approx_grad; (bool) If set True then the method will approximate the gradient itself (if it has requirement and facility for this) This will mean that the fid_err_grad_wrapper will not get called Note it should be left False when using the Dynamics to calculate approximate gradients Note it is set True automatically when the alg is CRAB. amp_lbound; (float or list of floats) lower boundaries for the control amplitudes Can be a scalar value applied to all controls or a list of bounds for each control. amp_ubound; (float or list of floats) upper boundaries for the control amplitudes Can be a scalar value applied to all c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:57700,optimiz,optimize,57700,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"ys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/frontmatter.html:3289,perform,performed,3289,docs/3.0.0/frontmatter.html,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html,5,['perform'],['performed']
Performance,"ystem at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r_2\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. The advantage of the Monte Carlo method over the mas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:5069,perform,performed,5069,docs/4.6/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html,1,['perform'],['performed']
Performance,"ystem at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r_2\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). The advantage of the Monte Carlo method over the master equation approach is that only the state vec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:5156,perform,performed,5156,docs/4.7/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html,1,['perform'],['performed']
Performance,"ystem, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the state of the environment does not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:8959,perform,perform,8959,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,2,['perform'],['perform']
Performance,"zation of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox counterpart by a substantial margin as the system size increases. To test the Monte Carlo solvers, here we simulate a trilinear Hamiltonian over a range of Hilbert space sizes. Since QuTiP uses multiprocessing, we can measure the performance gain when using several CPU’s. In contrast, the qotoolbox is limited to a single processor only. In the legend, we show the speed-up factor in the parenthesis, which should ideally be equal to the number of processors. Finally, we have included the results using hyperthreading, written here as 4+(x) where x is the number of hyperthreads, found in some newer Intel processors. We see however that the performance benefits from hyperthreading are marginal at best. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-performance.html:1974,perform,performs,1974,docs/3.0.1/guide/dynamics/dynamics-performance.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-performance.html,3,['perform'],"['performance', 'performs']"
Performance,"{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\) [Hav03], [Wat13].; To represent superoperators acting on \(\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)\) thus takes some tensor rearrangement to get the desired ordering; \(\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2\).; In particular, this means that qutip.tensor does not act as; one might expect on the results of qutip.to_super:; In [27]: A = qeye([2]). In [28]: B = qeye([3]). In [29]: to_super(tensor(A, B)).dims; Out[29]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. In [30]: tensor(to_super(A), to_super(B)).dims; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-tensor.html:10680,perform,performs,10680,docs/4.2/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-tensor.html,5,['perform'],['performs']
Performance,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Features. QuTiP is the original quantum framework written in Python; the most widely ; used programming language in the quantum sciences. Python's straightforward syntax allows for constructing, manipulating, and evolving quantum objects using QuTiP with just a few lines of code. Easy to learn, and 100% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming lang",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/features.html:728,perform,performing,728,features.html,https://qutip.org,https://qutip.org/features.html,2,['perform'],"['performance', 'performing']"
Performance,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Contributors; The development of QuTiP is a community based effort with several developers contributing, or helping to add, many new features to the growing list of QuTiP functions:; Original Developers. Paul Nation; IBM Q; Library designer and main contributor. Robert Johansson; Tokyo, Japan; Library designer and main contributor. Project Governance; The governance process and model for the QuTiP Project can be found here. It contains a charter document.; Admin Team. Alex Pitchford; Aberystwyth University; Main focus: Quantum optimal control, solvers. Eric Giguère; Université de Sherbrooke; Main focus: Stochastic solvers, code optimization. Nathan Shammah; RIKEN; Main focus: Symmetrical models, education and outreach. Shahnawaz Ahmed; Chalmers; Main focus: Machine learning, Non-Markovian dynamics. Neill Lambert; RIKEN; Main focus: Non-Markovian dynamics, counting statistics. Boxi Li; Forschungszentrum Juelich; Main focus: Quantum control, Quantum device simulation. Jake Lishman; Imperial College London; Main focus: Core data model and linear algebra. Simon Cross; RIKEN; Main focus: Quantum control, machine learning, general maintenance. Asier Galicia; Forschungszentrum Juelich; Main focus: Core data model and backends. Paul Menczel; RIKEN; Main focus: Quantum control, non-Markovian solvers, MPI. Patrick Hopf; Technical University of Munich; Main focus: Quantum control. Board Members. Anton Frisk Kockum; Chalmers University of Technology. Daniel Burgarth; Macquarie University. Franco Nori; RIKEN / University of Michigan. Rob Johansson; Rakuten. Will Zeng; Unitary Fund. Core Contributors. Arne Grimsmo; Université de Sherbrooke. Chris Grenade; University of Sydney. Additional Developers. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/devs.html:922,optimiz,optimization,922,devs.html,https://qutip.org,https://qutip.org/devs.html,1,['optimiz'],['optimization']
Performance,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Virtual Lab. Exploring simple quantum systems with QuTiP can help build intuition for them,; but there are many cases where writing code and Jupyter notebooks can get; in the way:. When teaching, coding can be a big distraction. Quantum mechanics is complex ; enough without your students having to struggle with installing software,; messing up their notebooks or learning QuTiP at the same time. When doing research, coding can be a big detour. You just want to do a quick; check to remind yourself how a simple system works, not spend the afternoon; fiddling in a text editor. You have papers to write and grant reports to fill; in. Time is precious. When at a party or while pitching your cool ideas, you don’t want to take out; your laptop to show people how cool your ideas are. It breaks the flow. You; need to be able to show them on your tablet. For all of these use cases, there is QuTiP Virtual Lab – a tablet and web; optimized graphical interface for building and exploring simple quantum systems.; It runs entirely in your browser, so there’s no server and nothing to install.; Click the button below to get started!; Enter QuTiP Virtual Lab.; There’s a handy tutorial with videos included in the virtual lab itself and some pre-built systems; to get you started. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-virtual-lab.html:1216,optimiz,optimized,1216,qutip-virtual-lab.html,https://qutip.org,https://qutip.org/qutip-virtual-lab.html,1,['optimiz'],['optimized']
Performance,"﻿. Saving QuTiP Objects and Data Sets — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename exte",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:566,load,loading,566,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,2,['load'],['loading']
Safety," # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * sqrt_dt); psi_t_m = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt -; d2(A, psi_t)[0] * sqrt_dt). dpsi_t += (; 0.50 * (d1(A, psi_t_1) + d1(A, psi_t)) * dt +; 0.25 * (d2(A, psi_t_p)[0] + d2(A, psi_t_m)[0] +; 2 * d2(A, psi_t)[0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:50403,detect,detection,50403,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['detect'],['detection']
Safety," 'general_stochastic']. def stochastic_solvers():; """"""Available solvers for ssesolve and smesolve; euler-maruyama:; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations.; Only solver which could take non-commuting sc_ops. *not tested*; -Order 0.5; -Code: 'euler-maruyama', 'euler', 0.5. milstein, Order 1.0 strong Taylor scheme:; Better approximate numerical solution to stochastic; differential equations.; -Order strong 1.0; -Code: 'milstein', 1.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.3 Eq. (3.1), By Peter E. Kloeden, Eckhard Platen. milstein-imp, Order 1.0 implicit strong Taylor scheme:; Implicit milstein scheme for the numerical simulation of stiff; stochastic differential equations.; -Order strong 1.0; -Code: 'milstein-imp'; Numerical Solution of Stochastic Differential Equations; Chapter 12.2 Eq. (2.9), By Peter E. Kloeden, Eckhard Platen. predictor-corrector:; Generalization of the trapezoidal method to stochastic; differential equations. More stable than explicit methods.; -Order strong 0.5, weak 1.0; Only the stochastic part is corrected.; (alpha = 0, eta = 1/2); -Code: 'pred-corr', 'predictor-corrector', 'pc-euler'; Both the deterministic and stochastic part corrected.; (alpha = 1/2, eta = 1/2); -Code: 'pc-euler-imp', 'pc-euler-2', 'pred-corr-2'; Numerical Solution of Stochastic Differential Equations; Chapter 15.5 Eq. (5.4), By Peter E. Kloeden, Eckhard Platen. platen:; Explicit scheme, create the milstein using finite difference instead of; derivatives. Also contain some higher order terms, thus converge better; than milstein while staying strong order 1.0.; Do not require derivatives, therefore usable for; :func:`qutip.stochastic.general_stochastic`; -Order strong 1.0, weak 2.0; -Code: 'platen', 'platen1', 'explicit1'; The Theory of Open Quantum Systems; Chapter 7 Eq. (7.47), H.-P Breuer, F. Petruccione. rouchon:; Scheme keeping the positivity of the density matr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:3801,predict,predictor-corrector,3801,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.36s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.64s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.93s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.21s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.48s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.76s. Est. time left: 00:00:00:01; 70.0%. Run time: 2.00s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.23s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.46s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:14374,avoid,avoid,14374,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.95s. Est. time left: 00:00:00:08; 20.0%. Run time: 1.81s. Est. time left: 00:00:00:07; 30.0%. Run time: 2.67s. Est. time left: 00:00:00:06; 40.0%. Run time: 3.59s. Est. time left: 00:00:00:05; 50.0%. Run time: 4.42s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.27s. Est. time left: 00:00:00:03; 70.0%. Run time: 6.10s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.91s. Est. time left: 00:00:00:01; 90.0%. Run time: 7.74s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:13914,avoid,avoid,13914,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety," A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; stor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:4980,detect,detection,4980,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety," Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs¶; function – Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops¶; function – Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise¶; function – Function for generate an array of pre-computed noise signal. homogeneous¶; bool (True) – Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver¶; string – Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’,; ‘pc-euler’ is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’,; ‘milstein-imp’ is semi-implicit Milstein method,; 3/2 order algorithms: ‘taylor15’,; ‘taylor15-imp’ is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {‘tol’:value},; default is {‘tol’:1e-6}. method¶; string (‘homodyne’, ‘heterodyne’, ‘photocurrent’) – The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution¶; string (‘normal’, ‘poission’) – The name of the distribution used for the stochastic increments. store_measurements¶; bool (default False) – Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise¶; array – Vector specifying the noise. normalize¶; bool (default True) – Whether or not to normalize the wave function during",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:46790,predict,predictor-corrector,46790,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['predict'],['predictor-corrector']
Safety," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/stats.html:2324,redund,redundant,2324,docs/4.1/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/stats.html,7,['redund'],['redundant']
Safety," Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.superop_reps. Source code for qutip.superop_reps; # -*- coding: utf-8 -*-; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, operator_to_vector, sprepost; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the choi matrix corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefull",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:1130,avoid,avoid,1130,docs/4.7/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html,1,['avoid'],['avoid']
Safety," NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.sparse import sp_reshape. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : array_like; A ``list`` or ``array`` of collapse operators. Returns; -------; L : qobj; Liouvillian superoperator. """""". if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). if H is not None:; if H.isoper:; op_dims = H.dims; op_shape = H.shape; elif H.issuper:; op_dims = H.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issuper:; op_dims = c.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for collapse operator.""); else:; raise TypeError(""Either H or c_ops must be given.""). sop_dims = [[op_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html:3864,avoid,avoids,3864,docs/3.1.0/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html,1,['avoid'],['avoids']
Safety," QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a list with 2 possibly time-dependent elements.; if isinstance(Q_object, list) and len(Q_object) == 2:; try:; # Test if parsing succeeds on this as a single element.; self._td_op_type(Q_object); Q_object = [Q_object]; except (TypeError, ValueError):; pass. op_type = self._td_format_check(Q_object); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise TypeError(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:13678,safe,safePickle,13678,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['safe'],['safePickle']
Safety," StepCoeffT(; self.ops, None, self.tlist); else:; self.coeff_get = InterCoeffT(; self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). else:; pass. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key is not ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(CQobjCt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:43876,safe,safePickle,43876,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,2,['safe'],"['safe', 'safePickle']"
Safety," Stochastic Solver; Homodyne detection. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{2} -\frac{e_n}{2} C_n; + \frac{e_n^2}{8} \right) \psi \delta t; + \sum_n \left( C_n - \frac{e_n}{2} \right) \psi \delta \omega\]; with. \[ \begin{align}\begin{aligned}:label: jump_rate\\e_n = \left<\psi(t)|C_n + C_n^{+}|\psi(t)\right>\end{aligned}\end{align} \]; Here \(\delta \omega\) is a Wiener increment.; In QuTiP, this is available with the function ssesolve.; In [1]: times = np.linspace(0.0, 10.0, 201). In [2]: p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html:1425,detect,detection,1425,docs/4.4/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html,1,['detect'],['detection']
Safety," TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(self, sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:10285,safe,safe,10285,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['safe'],['safe']
Safety," TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued mat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:10173,safe,safe,10173,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['safe'],['safe']
Safety," Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:3928,avoid,avoid,3928,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,6,['avoid'],['avoid']
Safety," \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=, []data_only=False)¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:H : qobj. System Hamiltonian. c_ops : array_like. A list or array of collapse operators. Returns:L : qobj. Liouvillian superoperator. spost(A)¶; Superoperator formed from post-multiplication by operator A. Parameters:A : qobj. Quantum operator for post multiplication. Returns:super : qobj. Superoperator formed from input qauntum object. spre(A)¶; Superoperator formed from pre-multiplication by operator A. Parameters:A : qobj. Quantum operator for pre-multiplication. Returns:super :qobj :. Superoperator formed from input quantum object. lindblad_dissipator(a, b=None, data_only=False)¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters:a : qobj. Left part of collapse operator. b : qobj (optiona",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:21190,avoid,avoids,21190,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['avoid'],['avoids']
Safety," a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part of collapse operator. bQobj or QobjEvo (optional)Right part of collapse operator. If not specified, b defaults to a. Returns. Dqobj, QobjEvoLindblad dissipator superoperator. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters. HQobj or QobjEvoSystem Hamiltonian. c_opsarray_like of Qobj or QobjEvoA list or array of collapse operators. Returns. LQobj or QobjEvoLiouvillian superoperator. operator_to_vector(op)[source]¶; Create a vector representation given a quantum operator in matrix form.; The passed object should have a Qobj.type of ‘oper’ or ‘super’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in matrix form. This must have a type of ‘oper’ or; ‘super’. Returns. Qobj or QobjEvoThe same object, but re-cast into a column-stacked-vector form of type; ‘operator-ket’. The output is the same type as the passed object. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters. AQobj or QobjEvoQuantum operator for post multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input qauntum object. spre(A)[source]¶;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:44836,avoid,avoids,44836,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['avoid'],['avoids']
Safety," compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (J",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:17316,unsafe,unsafe,17316,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,4,['unsafe'],['unsafe']
Safety," e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effectiv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:9355,avoid,avoid,9355,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,2,['avoid'],['avoid']
Safety," eig_vec = np.linalg.eigh(H); else:; if sparse:; H = self._dyn_gen[k].toarray(); else:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = la.eigh(H). # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isinstance(factors, np.ndarray):; self._dyn_gen_factormatrix[k] = factors; else:; self._dyn_gen_factormatrix[k] = np.array(factors). if self.oper_dtype == Qobj:; self._prop_eigen[k] = Qobj(np.diagflat(prop_eig),; dims=self.dyn_dims); self._dyn_gen_eigenvectors[k] = Qobj(eig_vec,; dims=self.dyn_dims); # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); else",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:44630,avoid,avoid,44630,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,6,['avoid'],['avoid']
Safety," equations to stochastic differential equations.; Only solver which could take non-commuting sc_ops. not tested; -Order 0.5; -Code: ‘euler-maruyama’, ‘euler’, 0.5. milstein, Order 1.0 strong Taylor scheme:Better approximate numerical solution to stochastic; differential equations.; -Order strong 1.0; -Code: ‘milstein’, 1.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.3 Eq. (3.1), By Peter E. Kloeden, Eckhard Platen. milstein-imp, Order 1.0 implicit strong Taylor scheme:Implicit milstein scheme for the numerical simulation of stiff; stochastic differential equations.; -Order strong 1.0; -Code: ‘milstein-imp’; Numerical Solution of Stochastic Differential Equations; Chapter 12.2 Eq. (2.9), By Peter E. Kloeden, Eckhard Platen. predictor-corrector:Generalization of the trapezoidal method to stochastic; differential equations. More stable than explicit methods.; -Order strong 0.5, weak 1.0; Only the stochastic part is corrected. (alpha = 0, eta = 1/2); -Code: ‘pred-corr’, ‘predictor-corrector’, ‘pc-euler’. Both the deterministic and stochastic part corrected.(alpha = 1/2, eta = 1/2); -Code: ‘pc-euler-imp’, ‘pc-euler-2’, ‘pred-corr-2’. Numerical Solution of Stochastic Differential Equations; Chapter 15.5 Eq. (5.4), By Peter E. Kloeden, Eckhard Platen. platen:Explicit scheme, create the milstein using finite difference instead of; derivatives. Also contain some higher order terms, thus converge better; than milstein while staying strong order 1.0.; Do not require derivatives, therefore usable for; qutip.stochastic.general_stochastic; -Order strong 1.0, weak 2.0; -Code: ‘platen’, ‘platen1’, ‘explicit1’; The Theory of Open Quantum Systems; Chapter 7 Eq. (7.47), H.-P Breuer, F. Petruccione. rouchon:Scheme keeping the positivity of the density matrix. (smesolve only); -Order strong 1.0?; -Code: ‘rouchon’, ‘Rouchon’; Eq. 4 of arXiv:1410.5345 with eta=1; Efficient Quantum Filtering for Quantum Feedback Control; Pierre Rouchon, Jason F. Ralph; arXiv:1410.53",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:95223,predict,predictor-corrector,95223,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['predict'],['predictor-corrector']
Safety," example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-parfor.html:2536,avoid,avoid,2536,docs/4.2/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-parfor.html,5,['avoid'],['avoid']
Safety," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.12s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.20s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.28s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.36s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.44s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.52s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.60s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.68s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:16964,avoid,avoid,16964,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.13s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.22s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.31s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.40s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.49s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.58s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.67s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.86s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:16798,avoid,avoid,16798,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.24s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.44s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.62s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.80s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.00s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.23s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.42s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.62s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:16895,avoid,avoid,16895,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety," keyword except check can be removed once scipy 1.1; # is a minimum requirement; try:; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=drho_t + a,; tol=args['tol'], atol='legacy'); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=drho_t + a,; tol=args['tol']). return v. def _rhs_rho_taylor_15_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Taylor 1.5 (alpha = 1/2, beta = doesn't matter); Chaptert 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0]; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms:; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. #FIXME: This atol keyword except check can be removed once scipy 1.1; # is a minimum requirement; try:; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol'], atol='legacy'); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol']); return v. def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:56768,predict,prediction,56768,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['predict'],['prediction']
Safety," len(times)""); if noise.shape[2] < nsubsteps:; raise Exception(""'noise' does not have the right shape"" +; ""shape[2] >= nsubsteps""); if noise.shape[3] < len(self.sc_ops) * dw_len:; raise Exception(""'noise' does not have the right shape: "" +; ""shape[3] >= len(self.sc_ops)"" +; dw_len_str); self.noise_type = 1; self.noise = noise. else:; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); self.noise_type = 0. # Map; self.progress_bar = progress_bar; if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map; self.map_kwargs = map_kwargs if map_kwargs is not None else {}. # Other; self.options = options; self.args = args; self.set_solver(); self.p = noiseDepth. def set_solver(self):; if self.solver in ['euler-maruyama', 'euler', 50, 0.5]:; self.solver_code = 50; self.solver = 'euler-maruyama'; elif self.solver in ['platen', 'platen1', 'explicit1', 100]:; self.solver_code = 100; self.solver = 'platen'; elif self.solver in ['pred-corr', 'predictor-corrector',; 'pc-euler', 101]:; self.solver_code = 101; self.solver = 'pred-corr'; elif self.solver in ['milstein', 102, 1.0]:; self.solver_code = 102; self.solver = 'milstein'; elif self.solver in ['milstein-imp', 103]:; self.solver_code = 103; self.solver = 'milstein-imp'; elif self.solver in ['pred-corr-2', 'pc-euler-2', 'pc-euler-imp', 104]:; self.solver_code = 104; self.solver = 'pred-corr-2'; elif self.solver in ['Rouchon', 'rouchon', 120]:; self.solver_code = 120; self.solver = 'rouchon'; if not all((op.const for op in self.sc_ops)):; raise Exception(""Rouchon only work with constant sc_ops""); elif self.solver in ['platen15', 'explicit1.5', 'explicit15', 150]:; self.solver_code = 150; self.solver = 'explicit1.5'; elif self.solver in ['taylor15', 'taylor1.5', None, 1.5, 152]:; self.solver_code = 152; self.solver = 'taylor1.5'; elif self.solver in ['taylor15-imp', 'taylor1.5-imp', 153]:; self.solver_code = 153; self.solver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'taylor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:15851,predict,predictor-corrector,15851,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety," mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/parallel.html:8056,timeout,timeout,8056,docs/4.3/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety," np.ndarray) and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1], [1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:20138,safe,safePickle,20138,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety," qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:2031,avoid,avoid,2031,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,1,['avoid'],['avoid']
Safety," simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2307,avoid,avoid,2307,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,1,['avoid'],['avoid']
Safety," that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters:; order : str {‘C’, ‘F’}; Return array in C (default) or Fortran ordering. squeeze : bool {False, True}; Squeeze output array. Returns:; data : array; Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True); Check for degenerate ground state. Returns:; eigval : float; Eigenvalue for the ground state of quantum operator. eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type ‘bra’ or ‘ket’. ket : qobj; Quantum object of type ‘ket’. Returns:; elem : complex; Complex valued matrix element. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm : str; Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:10749,safe,safe,10749,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['safe'],['safe']
Safety," the class qutip.solver.Result. stochastic_solvers()[source]¶. Available solvers for ssesolve and smesolve; euler-maruyama:A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations.; Only solver which could take non-commuting sc_ops. not tested; -Order 0.5; -Code: ‘euler-maruyama’, ‘euler’, 0.5. milstein, Order 1.0 strong Taylor scheme:Better approximate numerical solution to stochastic; differential equations.; -Order strong 1.0; -Code: ‘milstein’, 1.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.3 Eq. (3.1), By Peter E. Kloeden, Eckhard Platen. milstein-imp, Order 1.0 implicit strong Taylor scheme:Implicit milstein scheme for the numerical simulation of stiff; stochastic differential equations.; -Order strong 1.0; -Code: ‘milstein-imp’; Numerical Solution of Stochastic Differential Equations; Chapter 12.2 Eq. (2.9), By Peter E. Kloeden, Eckhard Platen. predictor-corrector:Generalization of the trapezoidal method to stochastic; differential equations. More stable than explicit methods.; -Order strong 0.5, weak 1.0; Only the stochastic part is corrected. (alpha = 0, eta = 1/2); -Code: ‘pred-corr’, ‘predictor-corrector’, ‘pc-euler’. Both the deterministic and stochastic part corrected.(alpha = 1/2, eta = 1/2); -Code: ‘pc-euler-imp’, ‘pc-euler-2’, ‘pred-corr-2’. Numerical Solution of Stochastic Differential Equations; Chapter 15.5 Eq. (5.4), By Peter E. Kloeden, Eckhard Platen. platen:Explicit scheme, create the milstein using finite difference instead of; derivatives. Also contain some higher order terms, thus converge better; than milstein while staying strong order 1.0.; Do not require derivatives, therefore usable for; qutip.stochastic.general_stochastic; -Order strong 1.0, weak 2.0; -Code: ‘platen’, ‘platen1’, ‘explicit1’; The Theory of Open Quantum Systems; Chapter 7 Eq. (7.47), H.-P Breuer, F. Petruccione. rouchon:Scheme keeping the positivity of the density matrix. (smesolve on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:94974,predict,predictor-corrector,94974,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['predict'],['predictor-corrector']
Safety," the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCte`` or ``CQobjEvoTd``; Cython version of the QobjEvo. coeff_get : callable; Object called to obtain a list of all the coefficients at a particular; time. coeff_files : list; Runtime created files to delete with the instance. dummy_cte : bool; Is self.cte an empty Qobj. const : bool; Indicates if quantum object is constant. type : {""cte"", ""string"", ""func"", ""array"", ""spline"", ""mixed_callable"", \; ""mixed_compilable""}; Information about the type of coefficients used in the entire object. num_obj : int; Number of :obj:`~qutip.Qobj` in the QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:11105,safe,safePickle,11105,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety," use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; In [11]: result = parfor(func1, range(5)). In [12]: print(result); [array([0, 1, 2, 3, 4]), array([ 0, 1, 4, 9, 16]), array([ 0, 1, 8, 27, 64])]. In [13]: result = parallel_map(func1, range(5)). In [14]: print(result); [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]. The qutip.parallel.parallel_map and qutip.parallel.parfor functions are not limited to just numbers, but also works for a variety of outputs:; In [15]: def func2(x): return x, Qobj(x), 'a' * x. In [16]: a, b, c = parfor(func2, range(5)). In [17]: print(a); [0 1 2 3 4]. In [18]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 1.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 2.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = Tr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-parfor.html:3184,avoid,avoid,3184,docs/3.1.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html,1,['avoid'],['avoid']
Safety," use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; In [11]: result = parfor(func1, range(5)). In [12]: print(result); [array([0, 1, 2, 3, 4]), array([ 0, 1, 4, 9, 16]), array([ 0, 1, 8, 27, 64])]. In [13]: result = parallel_map(func1, range(5)). In [14]: print(result); [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]. The qutip.parallel.parallel_map and qutip.parallel.parfor functions are not limited to just numbers, but also works for a variety of outputs:; In [15]: def func2(x): return x, Qobj(x), 'a' * x. In [16]: a, b, c = parfor(func2, range(5)). In [17]: print(a); [0 1 2 3 4]. In [18]: print(b); [Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[1.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[2.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[3.]]; Quantum object: dims = [[1], [1]], shape = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-parfor.html:2425,avoid,avoid,2425,docs/4.5/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-parfor.html,1,['avoid'],['avoid']
Safety," {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:31775,avoid,avoided,31775,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,5,['avoid'],['avoided']
Safety,"""""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:56711,avoid,avoid,56711,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:53905,avoid,avoid,53905,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qobj.html:53825,avoid,avoid,53825,docs/4.1/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"#############################################################; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline; from functools import partial, wraps; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import _compile_str_single, _compiled_coeffs; from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi, spmv, cy_spmm_tr); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff); import pickle; import sys; import scipy; import os. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = False; if sys.platform == 'win32':; safePickle = True. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf+0j. str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; for i, file_ in enumerate(self.files):; try:; os.remove(file_); except:; pass; if not os.path.isfile(file_):; # Don't exist anymore; del self.files[i]. def __del__(self):; self.clean(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:2987,safe,safePickle,2987,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"##########################################; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:3023,safe,safePickle,3023,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"########; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial, wraps; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv, cy_spmm_tr); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import pickle; import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:3037,safe,safePickle,3037,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"######; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:3074,safe,safePickle,3074,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,")).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the Fock states in the range ``first``; to ``last``, excluding the end point. The first two axes are the y-; and x-coordinates of phase space (i.e. Cartesian indexing, like; ``numpy.meshgrid``), and the last runs over the selected range of; Fock-space dimensions.; """"""; ns = np.arange(first, last).reshape(1, 1, -1); # Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.; out = np.empty(self.grid.shape + (ns.size,), dtype=np.complex128); out[:, :, 0] = self._start(ns.flat[0]); for i in range(ns.size - 1):; out[:, :, i+1] = out[:, :, i] * self.grid; out /= np.sqrt(scipy.special.factorial(ns)); return out. [docs]class QFunc:; r""""""; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points ``0.5*g* (xvec + i*yvec)``.; This class has slightly higher first-usage costs than :obj:`.qfunc`, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters; ----------; xvec, yvec : array_like; x- and y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the valu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:20480,avoid,avoid,20480,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,2,['avoid'],['avoid']
Safety,"* rho_t * (0.5 * dt); e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1). drho_t = b * dW[0] ; drho_t += a; drho_t += (A[0] * b - TrAb * rho_t - e0 * b) * dW[1] # Milstein term; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = drho_t + a, tol=args['tol']). return v; ; def _rhs_rho_taylor_15_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Taylor 1.5 (alpha = 1/2, beta = doesn't matter); Chaptert 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:56544,predict,prediction,56544,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['predict'],['prediction']
Safety,"* rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0]; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms:; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. #FIXME: This atol keyword except check can be removed once scipy 1.1; # is a minimum requirement; try:; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol'], atol='legacy'); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol']); return v. def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt). #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:57462,predict,predictor-corrector,57462,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,2,"['detect', 'predict']","['detection', 'predictor-corrector']"
Safety,", k]); / (1 - np.abs(dot)**2)**0.5). subspace = vecs.conj().T @ ops[i].data @ vecs; eigvals, eigvecs = la.eig(subspace). perm = np.argsort(eigvals); eigvals = eigvals[perm]. vecs_new = vecs @ eigvecs[:, perm]; for k in range(len(eigvals)):; vecs_new[:, k] = vecs_new[:, k] / la.norm(vecs_new[:, k]). k = 0; while k < len(eigvals):; ttol = max(tol, tol * abs(eigvals[k])); inds, = np.where(abs(eigvals - eigvals[k]) < ttol); if len(inds) > 1: # if at least 2 eigvals are degenerate; vecs_new[:, inds] = _degen(tol, vecs_new[:, inds], ops, i+1); k = inds[-1] + 1; return vecs_new. [docs]def simdiag(ops, evals: bool = True, *,; tol: float = 1e-14, safe_mode: bool = True):; """"""Simultaneous diagonalization of commuting Hermitian matrices. Parameters; ----------; ops : list/array; ``list`` or ``array`` of qobjs representing commuting Hermitian; operators. evals : bool [True]; Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tol : float [1e-14]; Tolerance for detecting degenerate eigenstates. safe_mode : bool [True]; Whether to check that all ops are Hermitian and commuting. If set to; ``False`` and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns; --------; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. """"""; if not ops:; raise ValueError(""No input matrices.""); N = ops[0].shape[0]; num_ops = len(ops) if safe_mode else 0; for jj in range(num_ops):; A = ops[jj]; shape = A.shape; if shape[0] != shape[1]:; raise TypeError('Matricies must be square.'); if shape[0] != N:; raise TypeError('All matrices. must be the same shape'); if not A.isherm:; raise TypeError('Matricies must be Hermitian'); for kk in range(jj):; B = ops[kk]; if (A * B - B * A).norm() / (A * B).norm() > tol:; raise TypeError('Matricies must commute.'). eigvals, eigvecs = la.eigh(ops[0].full()); p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/simdiag.html:3541,detect,detecting,3541,docs/4.6/modules/qutip/simdiag.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/simdiag.html,2,['detect'],['detecting']
Safety,", method=’dense’; is set as default.s. Returns:oper – Exponentiated quantum operator. Return type:qobj. Raises:TypeError – Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds (list of integer) – The states that should be kept.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data attribute. Return type:array. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used).; safe (bool (default=True)) – Check for degenerate ground state. Returns:; eigval (float) – Eigenvalue for the ground state of quantum operator.; eigvec (qobj) – Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:10024,safe,safe,10024,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['safe'],['safe']
Safety,", n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = ddW[:, 0]; sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:49646,detect,detection,49646,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['detect'],['detection']
Safety,", np.ndarray) and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1],[1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:21785,safe,safePickle,21785,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,",; self.cte.dims[1]]). elif isinstance(state, np.ndarray) and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1],[1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). def copy(self):; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). def arguments(self, new_args):; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:21447,safe,safePickle,21447,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,",; type, local arguments ), ... ]; type :; 1: function; 2: string; 3: np.array; 4: Cubic_Spline. args : map; arguments of the coefficients. dynamics_args : list; arguments that change during evolution. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : string; Has the cython version of the QobjEvo been created. compiled_qobjevo : cy_qobj (CQobjCte or CQobjEvoTd); Cython version of the QobjEvo. coeff_get : callable object; object called to obtain a list of coefficient at t. coeff_files : list; runtime created files to delete with the instance. dummy_cte : bool; is self.cte a empty Qobj. const : bool; Indicates if quantum object is Constant. type : string; information about the type of coefficient; ""string"", ""func"", ""array"",; ""spline"", ""mixed_callable"", ""mixed_compilable"". num_obj : int; number of Qobj in the QobjEvo : len(ops) + (1 if not dummy_cte). use_cython : bool; flag to compile string to cython or python. safePickle : bool; flag to not share pointers between thread. Methods; -------; copy() :; Create copy of Qobj. arguments(new_args):; Update the args of the object. Math:; +/- QobjEvo, Qobj, scalar:; Addition is possible between QobjEvo and with Qobj or scalar; -:; Negation operator; * Qobj, scalar:; Product is possible with Qobj or scalar; / scalar:; It is possible to divide by scalar only; conj(); Return the conjugate of quantum object. dag(); Return the adjoint (dagger) of quantum object. trans(); Return the transpose of quantum object. _cdc(); Return self.dag() * self. permute(order); Returns composite qobj with indices reordered. apply(f, *args, **kw_args); Apply the function f to every Qobj. f(Qobj) -> Qobj; Return a modified QobjEvo and let the original one untouched. apply_decorator(decorator, *args, str_mod=None,; inplace_np=False, **kw_args):; Apply the decorator to each function of the ops.; The *args and **kw_args are passed to the decorator.; new_coeff_function = decorator(coeff_function, *args, **kw_ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:10272,safe,safePickle,10272,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"-- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . R0be8dcf25d86-1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters. HQobj or QobjEvoSystem Hamiltonian. c_opsarray_like of Qobj or QobjEvoA list or array of collapse operators. Returns. LQobj or QobjEvoLiouvillian superoperator. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters. AQobj or QobjEvoQuantum operator for post multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input qauntum object. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters. AQobj or QobjEvoQuantum operator for pre-multiplication. Returns. super :Qobj or QobjEvoSuperoperator formed from input quantum object. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters. AQobj or QobjEvoQuantum operator for pre-multiplication. BQobj or QobjEvoQuantum operator for post-multiplication. Returns. superQobj or QobjEvoSuperoperator form",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:36065,avoid,avoids,36065,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['avoid'],['avoids']
Safety,"-------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:H : qobj. System Hamiltonian. c_ops : array_like. A list or array of collapse operators. Returns:L : qobj. Liouvillian superoperator. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:A : qobj. Quantum operator for post multiplication. Returns:super : qobj. Superoperator formed from input qauntum object. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:A : qobj. Quantum operator for pre-multiplication. Returns:super :qobj. Superoperator formed from input quantum object. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:A : Qobj. Quantum operator for pre-multiplication. B : Qobj. Quantum operator for post-multiplication. Returns:super : Qobj. Superoperator formed from input quantum objects. lindblad_dissipator(a, b=None, data_only=False)[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:36713,avoid,avoids,36713,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['avoid'],['avoids']
Safety,"------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . [R0be8dcf25d86-1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:; states : array; array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:; ops : array; array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:; H : qobj; System Hamiltonian. c_ops : array_like; A list or array of collapse operators. Returns:; L : qobj; Liouvillian superoperator. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:; A : qobj; Quantum operator for post multiplication. Returns:; super : qobj; Superoperator formed from input qauntum object. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:; A : qobj; Quantum operator for pre-multiplication. Returns:; super :qobj; Superoperator formed from input quantum object. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:; A : Qobj; Quantum operator for pre-multiplication. B : Qobj; Quantum operator for post-multiplication. Returns:; super : Qobj; Superoperator formed from input quantum objects. lindblad_dissipator(a, b=None, d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:36982,avoid,avoids,36982,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['avoid'],['avoids']
Safety,"-----|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:H : qobj. System Hamiltonian. c_ops : array_like. A list or array of collapse operators. Returns:L : qobj. Liouvillian superoperator. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:A : qobj. Quantum operator for post multiplication. Returns:super : qobj. Superoperator formed from input qauntum object. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:A : qobj. Quantum operator for pre-multiplication. Returns:super :qobj. Superoperator formed from input quantum object. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:A : Qobj. Quantum operator for pre-multiplication. B : Qobj. Quantum operator for post-multiplication. Returns:super : Qobj. Superoperator formed from input quantum objects. lindblad_dissipator(a, b=None, data_only=False)[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:26453,avoid,avoids,26453,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['avoid'],['avoids']
Safety,". . Stochastic Solver — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Homodyne detection. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html:450,detect,detection,450,docs/4.4/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html,1,['detect'],['detection']
Safety,". . Stochastic Solver — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Homodyne detection. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html:454,detect,detection,454,docs/4.5/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html,1,['detect'],['detection']
Safety,". qutip.control.stats — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.stats. Source code for qutip.control.stats; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/stats.html:634,redund,redundant,634,docs/4.7/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/stats.html,1,['redund'],['redundant']
Safety,".0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:53016,detect,detection,53016,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,4,['detect'],['detection']
Safety,".scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/fidcomp.html:23776,avoid,avoids,23776,docs/4.5/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,".solver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'taylor20', 2.0, 202]:; self.solver_code = 202; self.solver = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(""Taylor2.0 only works with 1 constant "" +; ""sc_ops and for homodyne method""); else:; raise ValueError((; ""The solver should be one of ""; ""[None, 'euler-maruyama', 'platen', 'pc-euler', ""; ""'pc-euler-imp', 'milstein', 'milstein-imp', ""; ""'rouchon', ""; ""'taylor1.5', 'taylor1.5-imp', 'explicit1.5' ""; ""'taylor2.0']"")). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:18047,predict,predictor-corrector,18047,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t); for n in range(A_len)]). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:51000,detect,detection,51000,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['detect'],['detection']
Safety,"0]):; self.coeff_get = InterCoeffCte(self.ops, None,; self.tlist); else:; self.coeff_get = InterCoeffT(self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get); elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get); else:; pass; coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key is not ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteO",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:39446,safe,safePickle,39446,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,2,['safe'],"['safe', 'safePickle']"
Safety,"1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F. Petruccione, *The Theory of Open Quantum; Systems*.; .. [3] Pierre Rouchon and Jason F. Ralpha, *Efficient Quantum Filtering for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photoc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:7011,predict,predictor,7011,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['predict'],['predictor']
Safety,"2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = ssesolve(H, psi0, times, sc_ops=[np.sqrt(0.1) * a], e_ops=[a.dag() * a, sm.dag() * sm], method=""homodyne""); Total run time: 0.01s. In [7]: figure(); Out[7]: <Figure size 640x480 with 0 Axes>. In [8]: plot(times, data.expect[0], times, data.expect[1]); Out[8]: ; [<matplotlib.lines.Line2D at 0x1a25a75c18>,; <matplotlib.lines.Line2D at 0x1a25a755c0>]. In [9]: title('Homodyne time evolution'); Out[9]: Text(0.5,1,'Homodyne time evolution'). In [10]: xlabel('Time'); Out[10]: Text(0.5,0,'Time'). In [11]: ylabel('Expectation values'); Out[11]: Text(0,0.5,'Expectation values'). In [12]: legend((""cavity photon number"", ""atom excitation probability"")); Out[12]: <matplotlib.legend.Legend at 0x1a263e9860>. In [13]: show(). Open system¶; In open systems, 2 types of collapse operators are considered, \(S_i\); represent the dissipation in the environment, \(C_i\) are monitored operators.; The deterministic part of the evolution is the liouvillian with both types of; collapses. (2)¶\[L(\rho(t)) = - i[H(t),\rho(t)]; + \sum_n D(S_n, \rho); + \sum_i D(C_i, \rho),\]; with. (3)¶\[D(C, \rho) = \frac{1}{2} \left[2 C \rho(t) C^{+}; - \rho(t) C^{+} C - C^{+} C \rho(t) \right].\]; The stochastic part is given by. (4)¶\[d_2 = \left(C \rho(t) + \rho(t) C^{+} - \rm{tr}\left(C \times \rho; + \rho \times C^{+} \right)\rho(t) \right),\]; resulting in the stochastic differential equation. (5)¶\[\delta \rho(t) = L(\rho(t)) \delta t + d_2 \delta \omega\]; The function smesolve covert these cases in QuTiP. Heterodyne detection¶; With heterodyne detection, two measurements are made in order to obtain; information about 2 orthogonal quadratures at once. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html:4208,detect,detection,4208,docs/4.5/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:2692,detect,detect,2692,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['detect'],['detect']
Safety,"2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = - np.inner(e, dW) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_taylor_15_one(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = a * dt; drho_t += b * dW[0]; drho_t += Lb * dW[1] # Milstein term. # new terms: ; drho_t += A[-1] * b * dW[2]; drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]; drho_t += A[-1] * a * (0.5 * dt*dt); drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4] ; ; return rho_t + drho_t. #include _rhs_rho_Taylor_15_two#. def _rhs_rho_milstein_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Milstein (theta = 1/2, eta = 0); Wang, X., Gan, S., & Wang, D. (2012). ; A family of fully implicit Milstein methods for stiff stochastic differential ; equations with multiplicative noise. ; BIT Numerical Mathema",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:54379,detect,detection,54379,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['detect'],['detection']
Safety,"2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = - np.inner(e, dW) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_taylor_15_one(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = a * dt; drho_t += b * dW[0]; drho_t += Lb * dW[1] # Milstein term. # new terms:; drho_t += A[-1] * b * dW[2]; drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]; drho_t += A[-1] * a * (0.5 * dt*dt); drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]. return rho_t + drho_t. #include _rhs_rho_Taylor_15_two#. def _rhs_rho_milstein_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Milstein (theta = 1/2, eta = 0); Wang, X., Gan, S., & Wang, D. (2012).; A family of fully implicit Milstein methods for stiff stochastic differential; equations with multiplicative noise.; BIT Numerical Mathematics, 5",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:54347,detect,detection,54347,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['detect'],['detection']
Safety,": list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N], [N]], [[N], [N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre', seed=seed). # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()). if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible; # improvement, iterative methods exist to find inverse square root; # matrices directly, as this is important in statistics.; Z = np.kron(; np.eye(N),; la.sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]])",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/random_objects.html:17754,avoid,avoid,17754,docs/4.6/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/random_objects.html,2,['avoid'],['avoid']
Safety,":Solver with more terms of the Stratonovich expansion.; -Order strong 2.0; -Code: ‘taylor2.0’, ‘taylor20’, 2.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.5 Eq. (5.2), By Peter E. Kloeden, Eckhard Platen. —All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only work for 1 stochastic; operator not dependent of time with the homodyne method.; The qutip.stochastic.general_stochastic only accept derivatives; free solvers: [‘euler’, ‘platen’, ‘explicit1.5’]. Available solver for photocurrent_sesolve and photocurrent_mesolve:; Photocurrent use ordinary differential equations between; stochastic “jump/collapse”. euler:Euler method for ordinary differential equations between jumps.; Only 1 jumps per time interval.; Default solver; -Order 1.0; -Code: ‘euler’; Quantum measurement and control; Chapter 4, Eq 4.19, 4.40, By Howard M. Wiseman, Gerard J. Milburn. predictor–corrector:predictor–corrector method (PECE) for ordinary differential equations.; Use poisson distribution to obtain the number of jump at each timestep.; -Order 2.0; -Code: ‘pred-corr’. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:98269,predict,predictor,98269,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,2,['predict'],['predictor']
Safety,"; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-settings.html:2756,detect,detect,2756,docs/4.0.2/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html,1,['detect'],['detect']
Safety,"; if noise.shape[1] < len(times):; raise ValueError(msg + ""shape[1] >= len(times)""); if noise.shape[2] < nsubsteps:; raise ValueError(msg + ""shape[2] >= nsubsteps""); if noise.shape[3] < len(self.sc_ops) * dw_len:; raise ValueError(msg + ""shape[3] >= len(self.sc_ops)"" +; dw_len_str); self.noise_type = 1; self.noise = noise. else:; self.noise = np.random.randint(0, 2**32, ntraj, dtype=np.uint32); self.noise_type = 0. # Map; self.progress_bar = progress_bar; if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map; self.map_kwargs = map_kwargs if map_kwargs is not None else {}. # Other; self.options = options; self.args = args; self.set_solver(); self.p = noiseDepth. def set_solver(self):; if self.solver in ['euler-maruyama', 'euler', 50, 0.5]:; self.solver_code = 50; self.solver = 'euler-maruyama'; elif self.solver in ['platen', 'platen1', 'explicit1', 100]:; self.solver_code = 100; self.solver = 'platen'; elif self.solver in ['pred-corr', 'predictor-corrector',; 'pc-euler', 101]:; self.solver_code = 101; self.solver = 'pred-corr'; elif self.solver in ['milstein', 102, 1.0]:; self.solver_code = 102; self.solver = 'milstein'; elif self.solver in ['milstein-imp', 103]:; self.solver_code = 103; self.solver = 'milstein-imp'; elif self.solver in ['pred-corr-2', 'pc-euler-2', 'pc-euler-imp', 104]:; self.solver_code = 104; self.solver = 'pred-corr-2'; elif self.solver in ['Rouchon', 'rouchon', 120]:; self.solver_code = 120; self.solver = 'rouchon'; if not all((op.const for op in self.sc_ops)):; raise ValueError(""Rouchon only works with constant sc_ops""); elif self.solver in ['platen15', 'explicit1.5', 'explicit15', 150]:; self.solver_code = 150; self.solver = 'explicit1.5'; elif self.solver in ['taylor15', 'taylor1.5', None, 1.5, 152]:; self.solver_code = 152; self.solver = 'taylor1.5'; elif self.solver in ['taylor15-imp', 'taylor1.5-imp', 153]:; self.solver_code = 153; self.solver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'tayl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:16447,predict,predictor-corrector,16447,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['predict'],['predictor-corrector']
Safety,"; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/parallel.html:8065,timeout,timeout,8065,docs/4.5/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:23729,avoid,avoids,23729,docs/4.6/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:2146,avoid,avoidance,2146,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['avoid'],['avoidance']
Safety,Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotations; Imports and Exports QASM circuit; QuTiP example: Quantum Gates and their usage; Quantum Teleportation Circuit. Pulse-level circuit simulation. Compiling and simulating a 10-qubit Quantum Fourier Transform (QFT) algorithm; Custimize the pulse-level simulation; Examples for OptPulseProcessor; Scheduler for quantum gates and instructions; Simulating randomized benchmarking; Simulating the Deutsch–Jozsa algorithm at the pulse level; measuring the relaxation time with the idling gate. Time evolution. QobjEvo: time-dependent quantum objects; Schrödinger Equation Solver: Larmor precession; Master Equation Solver: Single-Qubit Dynamics; Master Equation Solver: Vacuum Rabi oscillations; Master Equation Solver: Dynamics of a Spin Chain; Monte Carlo Solver: Birth and Death of Photons in a Cavity; Bloch-Redfield Solver: Two Level System; Bloch-Redfield Solver: Time dependent operators; Bloch-Redfield Solver: Dissipative Atom-Cavity system; Bloch-Redfield Solver: Phonon-assisted initialization; Floquet Solvers; Floquet Formalism; Time-dependent Master Equation: Landau-Zener transitions; Time-dependent Master Equation: Landau-Zener-Stuckelberg inteferometry; Stochastic Solver: Heterodyne Detection; Stochastic Solver: Mixing stochastic and deterministic equations; Stochastic Solver: Photo-current detection in a JC model; Stochastic vs. Monte-Carlo Solver: Cat states become coherent; Steady-State: Optomechanical System in the Single-Photon Strong-Coupling Regime; Steady-State: Homodyned Jaynes-Cummings emission; Steady-State: Time-dependent (periodic) quantum system. Optimal control. Overview ; Hadamard ; QFT ; Lindbladian ; Symplectic ; QFT (CRAB) ; State to state (CRAB) ; CNOT ; iSWAP ; Single-qubit rotation ; Toffoli gate . Tomography. Density matrix estimation with iterative maximum likelihood estimation . Permutational invariant Lindblad dynamics. Overview ; Superradiant light emission ; Steady stat,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-tutorials/index-v4.html:3310,detect,detection,3310,qutip-tutorials/index-v4.html,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html,1,['detect'],['detection']
Safety,"F SUCH DAMAGE.; ###############################################################################; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline; from functools import partial, wraps; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import _compile_str_single, _compiled_coeffs; from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi, spmv, cy_spmm_tr); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff); import pickle; import sys; import scipy; import os. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = False; if sys.platform == 'win32':; safePickle = True. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf+0j. str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; for i, file_ in enumerate(self.files):; try:; os.remove(file_); except:; pass; if not os.path.isfile(file_):; # Don't exist anymore; del self.files[i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:2938,safe,safePickle,2938,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under W",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:2625,safe,safety,2625,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,4,['safe'],['safety']
Safety,"Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial, wraps; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv, cy_spmm_tr); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import pickle; import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:3088,safe,safePickle,3088,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:58032,avoid,avoid,58032,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : array_like; A ``list`` or ``array`` of collapse operators. Returns; -------; L : qobj; Liouvillian superoperator. """""". if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). if H is not None:; if H.isoper:; op_dims = H.dims; op_shape = H.shape; elif H.issuper:; op_dims = H.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issuper:; op_dims = c.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for collapse operator.""); else:; raise TypeError(""Either H or c_ops must be given.""). sop_dims = [[op_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superoperator.html:2713,avoid,avoids,2713,docs/4.1/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superoperator.html,4,['avoid'],['avoids']
Safety,"R CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron; from functools import partial. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : Qobj or QobjEvo; System Hamiltonian. c_ops : array_like of Qobj or QobjEvo; A ``list`` or ``array`` of collapse operators. Returns; -------; L : Qobj or QobjEvo; Liouvillian superoperator. """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]; if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). h = None; if H is not None:; if isinstance(H, QobjEvo):; h = H.cte; else:; h = H; if h.isoper:; op_dims = h.dims; op_shape = h.shape; elif h.issuper:; op_dims = h.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; if isinstance(c_ops[0], QobjEvo):; c = c_ops[0].cte; else:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issup",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/superoperator.html:2740,avoid,avoids,2740,docs/4.4/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/superoperator.html,3,['avoid'],['avoids']
Safety,"RACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, operator_to_vector, sprepost; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the choi matrix corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefull",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html:2845,avoid,avoid,2845,docs/4.5/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html,2,['avoid'],['avoid']
Safety,"RACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, spre, spost, operator_to_vector; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the choi matrix corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopef",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html:2836,avoid,avoid,2836,docs/4.1/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html,5,['avoid'],['avoid']
Safety,"Rep. 6, 8 (2016). 240. Guo et al., ""Giant acoustic atom: A single quantum system with a deterministic time delay"", ; Phys. Rev. A 95, 053821 (2017). 239. Vermersch et al., ""Quantum State Transfer via Noisy Photonic and Phononic Waveguides"", ; Phys. Rev. Lett. 118, 133601 (2017). 238. Gudmundsson et al., ""Time-dependent current into and through multilevel parallel quantum dots in a photon cavity"", ; Phys. Rev. B 95, 195307 (2017). 237. Braumüller et al., ""Analog quantum simulation of the Rabi model in the ultra-strong coupling regime"", ; Nat. Commun. 8, 779 (2017). 236. Lagoudakis et al., ""Ultrafast coherent manipulation of trions in site-controlled nanowire quantum dots"", ; Optica 3, 1430 (2016). 235. Roghani et al., ""Dissipative Preparation of Entangled Many-Body States with Rydberg Atoms"", ; arXiv:1611.09612. 234. Lambert et al., ""Superradiance with an ensemble of superconducting flux qubits"", ; Phys. Rev. B 94, 224510 (2016). 233. Yanay et al., ""Shelving-style QND phonon-number detection in quantum optomechanics"", ; New J. Phys. 19, 033014 (2017). 232. Kirton et al., ""Suppressing and Restoring the Dicke Superradiance Transition by Dephasing and Decay"", ; Phys. Rev. Lett. 118, 123602 (2017). 231. Fischer et al., ""On-Chip Architecture for Self-Homodyned Nonclassical Light"", ; Phys. Rev. Applied 7, 044002 (2017).; Notebook. 230. Combes et al., ""The SLH framework for modeling quantum input-output networks"", ; Advances in Physics: X 2, 784 (2017). 229. Lucarelli, ""Quantum optimal control via gradient ascent in function space and the time-bandwidth quantum speed limit"", ; arXiv:1611.00188. 228. Bulutay, ""Cat-state generation and stabilization for a nuclear spin through electric quadrupole interaction"", ; Phys. Rev. A 96, 012312 (2017). 227. De Roeck et al., ""Step Density Profiles in Localized Chains"", ; J. Stat. Phys. 167, 1143 (2017). 226. Granade et al., ""QInfer: Statistical inference software for quantum applications"", ; Quantum 1, 5 (2017). 225. Cotrufo et al., ""Coh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:18199,detect,detection,18199,users.html,https://qutip.org,https://qutip.org/users.html,1,['detect'],['detection']
Safety,"Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/changelog.html:2266,avoid,avoid,2266,docs/4.1/changelog.html,https://qutip.org,https://qutip.org/docs/4.1/changelog.html,1,['avoid'],['avoid']
Safety,"] = '1'. import sys; import warnings. import qutip.settings; import qutip.version; from qutip.version import version as __version__; from qutip.utilities import _version2int. # -----------------------------------------------------------------------------; # Check if we're in IPython.; try:; __IPYTHON__; qutip.settings.ipython = True; except:; qutip.settings.ipython = False. # -----------------------------------------------------------------------------; # Check for minimum requirements of dependencies, give the user a warning; # if the requirements aren't fulfilled; #. numpy_requirement = ""1.6.0""; try:; import numpy; if _version2int(numpy.__version__) < _version2int(numpy_requirement):; print(""QuTiP warning: old version of numpy detected "" +; (""(%s), requiring %s."" %; (numpy.__version__, numpy_requirement))); except:; warnings.warn(""numpy not found.""). scipy_requirement = ""0.11.0""; try:; import scipy; if _version2int(scipy.__version__) < _version2int(scipy_requirement):; print(""QuTiP warning: old version of scipy detected "" +; (""(%s), requiring %s."" %; (scipy.__version__, scipy_requirement))); except:; warnings.warn(""scipy not found.""). # -----------------------------------------------------------------------------; # check to see if running from install directory for released versions.; #; top_path = os.path.dirname(os.path.dirname(__file__)); try:; setup_file = open(top_path + '/setup.py', 'r'); except:; pass; else:; if ('QuTiP' in setup_file.readlines()[1][3:]) and qutip.version.release:; print(""You are in the installation directory. "" +; ""Change directories before running QuTiP.""); setup_file.close(). del top_path. # -----------------------------------------------------------------------------; # setup the cython environment; #; _cython_requirement = ""0.15.0""; try:; import Cython; if _version2int(Cython.__version__) < _version2int(_cython_requirement):; print(""QuTiP warning: old version of cython detected "" +; (""(%s), requiring %s."" %; (Cython.__version__, _cytho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:4944,detect,detected,4944,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['detect'],['detected']
Safety,"_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:3476,avoid,avoid,3476,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,6,['avoid'],['avoid']
Safety,"ably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:10736,safe,safebool,10736,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['safe'],['safebool']
Safety,"actors; (array) Array of length d2_len, containing scaling factors for each measurement operator in m_ops. rhs; (function) Function for calculating the deterministic and stochastic contributions to the right-hand side of the stochastic differential equation. This only needs to be specified when implementing a custom SDE solver. generate_A_ops; (function) Function that generates a list of pre-computed operators or super- operators. These precomputed operators are used in some d1 and d2 functions. generate_noise; (function) Function for generate an array of pre-computed noise signal. homogeneous; (bool (True)) Wheter or not the stochastic process is homogenous. Inhomogenous processes are only supported for poisson distributions. solver; (string) Name of the solver method to use for solving the stochastic equations. Valid values are: 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’, ‘pc-euler’ is a predictor-corrector method which is more stable than explicit methods, 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’, ‘milstein-imp’ is semi-implicit Milstein method, 3/2 order algorithms: ‘taylor15’, ‘taylor15-imp’ is semi-implicit Taylor 1.5 method. Implicit methods can adjust tolerance via args = {‘tol’:value}, default is {‘tol’:1e-6}. method; (string (‘homodyne’, ‘heterodyne’, ‘photocurrent’)) The name of the type of measurement process that give rise to the stochastic equation to solve. Specifying a method with this keyword argument is a short-hand notation for using pre-defined d1 and d2 functions for the corresponding stochastic processes. distribution; (string (‘normal’, ‘poission’)) The name of the distribution used for the stochastic increments. store_measurements; (bool (default False)) Whether or not to store the measurement results in the qutip.solver.SolverResult instance returned by the solver. noise; (array) Vector specifying the noise. normalize; (bool (default True)) Whether or not to normalize the wave function during the evolution",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:43554,predict,predictor-corrector,43554,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['predict'],['predictor-corrector']
Safety,"aj""); if noise.shape[1] < len(times):; raise ValueError(msg + ""shape[1] >= len(times)""); if noise.shape[2] < nsubsteps:; raise ValueError(msg + ""shape[2] >= nsubsteps""); if noise.shape[3] < len(self.sc_ops) * dw_len:; raise ValueError(msg + ""shape[3] >= len(self.sc_ops)"" +; dw_len_str); self.noise_type = 1; self.noise = noise. else:; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); self.noise_type = 0. # Map; self.progress_bar = progress_bar; if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map; self.map_kwargs = map_kwargs if map_kwargs is not None else {}. # Other; self.options = options; self.args = args; self.set_solver(); self.p = noiseDepth. def set_solver(self):; if self.solver in ['euler-maruyama', 'euler', 50, 0.5]:; self.solver_code = 50; self.solver = 'euler-maruyama'; elif self.solver in ['platen', 'platen1', 'explicit1', 100]:; self.solver_code = 100; self.solver = 'platen'; elif self.solver in ['pred-corr', 'predictor-corrector',; 'pc-euler', 101]:; self.solver_code = 101; self.solver = 'pred-corr'; elif self.solver in ['milstein', 102, 1.0]:; self.solver_code = 102; self.solver = 'milstein'; elif self.solver in ['milstein-imp', 103]:; self.solver_code = 103; self.solver = 'milstein-imp'; elif self.solver in ['pred-corr-2', 'pc-euler-2', 'pc-euler-imp', 104]:; self.solver_code = 104; self.solver = 'pred-corr-2'; elif self.solver in ['Rouchon', 'rouchon', 120]:; self.solver_code = 120; self.solver = 'rouchon'; if not all((op.const for op in self.sc_ops)):; raise ValueError(""Rouchon only works with constant sc_ops""); elif self.solver in ['platen15', 'explicit1.5', 'explicit15', 150]:; self.solver_code = 150; self.solver = 'explicit1.5'; elif self.solver in ['taylor15', 'taylor1.5', None, 1.5, 152]:; self.solver_code = 152; self.solver = 'taylor1.5'; elif self.solver in ['taylor15-imp', 'taylor1.5-imp', 153]:; self.solver_code = 153; self.solver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'tayl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:16108,predict,predictor-corrector,16108,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"alculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. E",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:60980,detect,detect,60980,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['detect'],['detect']
Safety,"allel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/parallel.html:6463,timeout,timeout,6463,docs/4.7/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1],[1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:21803,safe,safePickle,21803,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"antum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:60260,avoid,avoid,60260,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"arameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). [docs]def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat13]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:8033,avoid,avoid,8033,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,1,['avoid'],['avoid']
Safety,"arameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use spars",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:9716,avoid,avoid,9716,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,1,['avoid'],['avoid']
Safety,"at; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.tr() * U2.tr()); else:; return (U1 * U2).tr(). [docs]def average_gate_fidelity(oper, target=None):; """"""; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters; ----------; A : Qobj; Quantum object representing a superoperator.; target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns; -------; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:4287,avoid,avoid,4287,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,1,['avoid'],['avoid']
Safety,"ay; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are: ; 1/2 order algorithms: 'euler-maruyama', 'fast-euler-maruyama',; 'pc-euler' is a predictor-corrector method which is more ; stable than explicit methods,; 1 order algorithms: 'milstein', 'fast-milstein', 'platen',; 'milstein-imp' is semi-implicit Milstein method,; 3/2 order algorithms: 'taylor15', ; 'taylor15-imp' is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {'tol':value},; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:6601,predict,predictor-corrector,6601,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['predict'],['predictor-corrector']
Safety,"bj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True). Check for degenerate ground state. Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/classes.html:10296,safe,safe,10296,docs/4.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/classes.html,1,['safe'],['safe']
Safety,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-settings.html:3556,detect,detect,3556,docs/3.1.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html,1,['detect'],['detect']
Safety,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-settings.html:3516,detect,detect,3516,docs/3.0.1/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-settings.html,1,['detect'],['detect']
Safety,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-settings.html:3454,detect,detect,3454,docs/3.0.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html,1,['detect'],['detect']
Safety,"chastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = - np.inner(e, dW) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_taylor_15_one(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:53579,detect,detection,53579,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,4,['detect'],['detection']
Safety,"class-based version, more efficient if you want to calculate the; Husimi-Q function for several states over the same coordinates.; """"""; state = _qfunc_check_state(state); xvec, yvec = _qfunc_check_coordinates(xvec, yvec); required_memory = state.shape[0] * xvec.size * yvec.size * 16 / (1024 ** 2); enough_memory = (; precompute_memory is not None; and precompute_memory > required_memory; ); if state.isoper and enough_memory:; return QFunc(xvec, yvec, g)(state); if precompute_memory is not None and state.isoper:; warnings.warn(; ""Falling back to iterative algorithm due to lack of memory.""; f"" Needed {required_memory:.2f} MB, but only allowed to use""; f"" {precompute_memory:.2f} MB. Increase `precompute_memory` to""; "" raise limit, or set to `None` to suppress warning.""; ); alpha_grid = _QFuncCoherentGrid(xvec, yvec, g); if state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * _qfunc_iterative_single(vectors[0], alpha_grid, g); for value, vector in zip(values[1:], vectors[1:]):; out += value * _qfunc_iterative_single(vector, alpha_grid, g); out /= np.pi; return out. # -----------------------------------------------------------------------------; # PSEUDO DISTRIBUTION FUNCTIONS FOR SPINS; #; [docs]def spin_q_function(rho, theta, phi):; r""""""The Husimi Q function for spins is defined as ``Q(theta, phi) =; SCS.dag() * rho * SCS`` for the spin coherent state ``SCS = spin_coherent(; j, theta, phi)`` where j is the spin length.; The implementation here is more efficient as it doesn't; generate all of the SCS at theta and phi (see references). The spin Q function is normal when integrated over the surface of the; sphere. .. math:: \frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; stat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:27376,avoid,avoid,27376,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,2,['avoid'],['avoid']
Safety,"ct_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0]; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms:; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. #FIXME: This atol keyword except check can be removed once scipy 1.1; # is a minimum requirement; try:; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol'], atol='legacy'); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol']); return v. def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt). #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme prov",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:57562,predict,predictor,57562,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['predict'],['predictor']
Safety,"e a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:14928,safe,safe,14928,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['safe'],['safe']
Safety,"e, *task_args, **task_kwargs); results.append(result); progress_bar.finished(). return results. [docs]def parallel_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Parallel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to:. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. progress_bar: ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; pool.terminate(); pool.join(); raise e. progress_bar.finished(). return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html:9120,timeout,timeout,9120,docs/3.1.0/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"een A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.tr() * U2.tr()); else:; return (U1 * U2).tr(). [docs]def average_gate_fidelity(oper, target=None):; """"""; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters; ----------; A : Qobj; Quantum object representing a superoperator.; target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns; -------; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:2598,avoid,avoid,2598,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,1,['avoid'],['avoid']
Safety,"ef groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; sh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:43561,safe,safe,43561,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"el.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [array([0, 1, 2, 3, 4]), array([ 0, 1, 4, 9, 16]), array([ 0, 1, 8, 27, 64])]. >>> result = parallel_map(func1, range(5)). >>> print(result); [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]. The qutip.parallel.parallel_map and qutip.parallel.parfor functions are not limited to just numbers, but also works for a variety of outputs:; >>> def func2(x): return x, Qobj(x), 'a' * x. >>> a, b, c = parfor(func2, range(5)). >>> print(a); [0 1 2 3 4]. >>> print(b); [Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[1.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[2.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[3.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[4.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-parfor.html:2402,avoid,avoid,2402,docs/4.6/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html,2,['avoid'],['avoid']
Safety,"elf._memory_mb} MB is allowed.""; ); if self._cache is None:; self._cache = self._coherent_grid(self._current_size, size); else:; self._cache = np.dstack(; [self._cache, self._coherent_grid(self._current_size, size)]; ); self._current_size = size; return self._cache. def _single(self, vector: np.ndarray, alphas: np.ndarray):; r""""""; Get the Q function (without the :math:`\pi` scaling factor) of a single; state vector.; """"""; return np.abs(np.dot(alphas, (self._g * 0.5) * vector)) ** 2. def __call__(self, state: Qobj):; """"""; Get the Husimi-Q function for the given state vector or density matrix,; over the coordinates used to initialise the class. If called multiple; times, the states do not need to have the same dimensions, but none of; them can have tensor-product structure.; """"""; state = _qfunc_check_state(state); alphas = self._alphas(state.shape[0]); if state.isket:; return self._single(state.full().ravel(), alphas) / np.pi; # We don't use Qobj.eigenstates() to avoid building many unnecessary; # CSR versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * self._single(vectors[0], alphas); for value, vector in zip(values[1:], vectors[1:]):; out += value * self._single(vector, alphas); return out / np.pi. def _qfunc_iterative_single(; vector: np.ndarray, alpha_grid: _QFuncCoherentGrid, g: float,; ):; r""""""; Get the Q function (without the :math:`\pi` scaling factor) of a single; state vector, using the iterative algorithm which recomputes the powers of; the coherent-state matrix.; """"""; ns = np.arange(vector.shape[0]); out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha_grid.grid,; ); out *= alpha_grid.prefactor; return np.abs(out)**2. [docs]def qfunc(; state: Qobj,; xvec,; yvec,; g: float = sqrt(2),; precompute_memory: float = 1024,; ):; r""""""; Husimi-Q function of a given state vector or density matrix at phase-space; points ``0.5 * g * (xvec + i*yvec)``. Parameters; ----------; state ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:24310,avoid,avoid,24310,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,2,['avoid'],['avoid']
Safety,"elf.num_comp_waves = 20; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; try:; self.max_wavelen = 2*self.pulse_time; except:; self.max_wavelen = 10.0; self.apply_params(). def gen_pulse(self, num_comp_waves=None,; min_wavelen=None, max_wavelen=None):; """"""; Generate a random pulse by summing sine waves with random freq,; amplitude and phase offset; """""". if num_comp_waves is not None:; self.num_comp_waves = num_comp_waves; if min_wavelen is not None:; self.min_wavelen = min_wavelen; if max_wavelen is not None:; self.max_wavelen = max_wavelen. num_comp_waves = self.num_comp_waves; min_wavelen = self.min_wavelen; max_wavelen = self.max_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if max_wavelen <= min_wavelen:; raise ValueError(""Maximum wavelength must be greater than ""; ""the minimum wavelength""). if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape). t = self.time; wl_range = max_wavelen - min_wavelen; amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); for n in range(num_comp_waves):; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; wavelen = min_wavelen + np.random.rand()*wl_range; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWalk1(PulseGen):; """"""; Generates pulses by using a random walk algorithm. Attributes; ----------; scaling : float; Used as the range for the starting amplitude; Note must used bounds if values must be restricted.; Also scales the max_d_amp value; (copied from Dynamics.initial_ctrl_scaling if given). max_d_amp : float; Maximum amount amplitude will change between timeslots; Note this is also factored by the scaling attribute; """"""; def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.res",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:15055,avoid,avoid,15055,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,8,['avoid'],['avoid']
Safety,"ent norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_evo); if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1].dot(evo_grad); g = -2*self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_grad))); if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:21718,avoid,avoids,21718,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,5,['avoid'],['avoids']
Safety,"ent norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_evo); if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1].dot(evo_grad); g = -2*self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_grad))); if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:21697,avoid,avoids,21697,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,3,['avoid'],['avoids']
Safety,"ents to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:3845,sanity check,sanity checks,3845,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['sanity check'],['sanity checks']
Safety,"ents {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html:31719,avoid,avoided,31719,docs/4.4/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html,1,['avoid'],['avoided']
Safety,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:43046,safe,safe,43046,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:45880,safe,safe,45880,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:39847,safe,safe,39847,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['safe'],['safe']
Safety,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39641,safe,safe,39641,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['safe'],['safe']
Safety,"er = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise Exception(""Taylor2.0 only work with 1 constant sc_ops "" +; ""and for homodyne method""); else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler-maruyama', 'platen', 'pc-euler', "" +; ""'pc-euler-imp', 'milstein', 'milstein-imp', "" +; ""'rouchon', "" +; ""'taylor1.5', 'taylor1.5-imp', 'explicit1.5' "" +; ""'taylor2.0']""). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a determinist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:17949,predict,predictor-corrector,17949,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"erated.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N],[N]], [[N],[N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre'); ; # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()); ; if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible improvement,; # iterative methods exist to find inverse square root matrices directly,; # as this is important in statistics.; Z = np.kron(; np.eye(N),; sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/random_objects.html:15588,avoid,avoid,15588,docs/4.2/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/random_objects.html,4,['avoid'],['avoid']
Safety,"erator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:10357,safe,safe,10357,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['safe'],['safe']
Safety,"es if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B.; ; """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:53859,avoid,avoid,53859,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"et = StepCoeffT(; self.ops, None, self.tlist); else:; self.coeff_get = InterCoeffT(; self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). else:; pass. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key != ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(; func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(; obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(; C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:46367,safe,safePickle,46367,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['safe'],"['safe', 'safePickle']"
Safety,"et = StepCoeffT(; self.ops, None, self.tlist); else:; self.coeff_get = InterCoeffT(; self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). else:; pass. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key != ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(CQobjCt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:48015,safe,safePickle,48015,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['safe'],"['safe', 'safePickle']"
Safety,"eturn results. [docs]def parallel_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Parallel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; pool.terminate(); pool.join(); raise e. progress_bar.finished(). return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/parallel.html:7886,timeout,timeout,7886,docs/4.0.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"ext = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:23762,avoid,avoids,23762,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"f Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:62120,avoid,avoid,62120,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"f you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:6117,detect,detection,6117,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['detect'],['detection']
Safety,"fficients.; [(Qobj, coefficient as a function, original coefficient,. type, local arguments ), … ]. type :1: function; 2: string; 3: np.array; 4: Cubic_Spline. argsmaparguments of the coefficients. dynamics_argslistarguments that change during evolution. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstringHas the cython version of the QobjEvo been created. compiled_qobjevocy_qobj (CQobjCte or CQobjEvoTd)Cython version of the QobjEvo. coeff_getcallable objectobject called to obtain a list of coefficient at t. coeff_fileslistruntime created files to delete with the instance. dummy_cteboolis self.cte a empty Qobj. constboolIndicates if quantum object is Constant. typestring; information about the type of coefficient“string”, “func”, “array”,; “spline”, “mixed_callable”, “mixed_compilable”. num_objintnumber of Qobj in the QobjEvo : len(ops) + (1 if not dummy_cte). use_cythonboolflag to compile string to cython or python. safePickleboolflag to not share pointers between thread. Methods. copy() :; Create copy of Qobj. arguments(new_args):; Update the args of the object. Math:; +/- QobjEvo, Qobj, scalar: Addition is possible between QobjEvo and with Qobj or scalar -: Negation operator * Qobj, scalar: Product is possible with Qobj or scalar / scalar: It is possible to divide by scalar only. conj(); Return the conjugate of quantum object. dag(); Return the adjoint (dagger) of quantum object. trans(); Return the transpose of quantum object. _cdc(); Return self.dag() * self. permute(order); Returns composite qobj with indices reordered. apply(f, *args, **kw_args); Apply the function f to every Qobj. f(Qobj) -> Qobj Return a modified QobjEvo and let the original one untouched. apply_decorator(decorator, *args, str_mod=None,; inplace_np=False, **kw_args): Apply the decorator to each function of the ops. The *args and **kw_args are passed to the decorator. new_coeff_function = decorator(coeff_function, *args, **kw_args) str_mod : list of 2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:20778,safe,safePickleboolflag,20778,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['safe'],['safePickleboolflag']
Safety,"gs; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() - 0.5; ypos = ypos.T.flatten() - 0.5; zpos = np.zeros(n); dx = dy = 0.8 * np.ones(n); Mvec = M.flatten(); dz = abs(Mvec). # make small numbers real, to avoid random colors; idx, = np.where(abs(Mvec) < 0.001); Mvec[idx] = abs(Mvec[idx]). if phase_limits: # check that limits is a list type; phase_min = phase_limits[0]; phase_max = phase_limits[1]; else:; phase_min = -pi; phase_max = pi. norm = mpl.colors.Normalize(phase_min, phase_max); cmap = complex_phase_cmap(). colors = cmap(norm(angle(Mvec))); if threshold is not None:; colors[:, 3] = 1 * (dz > threshold). if ax is None:; fig = plt.figure(); ax = Axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use mi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/visualization.html:12878,avoid,avoid,12878,docs/4.1/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/visualization.html,7,['avoid'],['avoid']
Safety,"gs; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() - 0.5; ypos = ypos.T.flatten() - 0.5; zpos = np.zeros(n); dx = dy = 0.8 * np.ones(n); Mvec = M.flatten(); dz = abs(Mvec). # make small numbers real, to avoid random colors; idx, = np.where(abs(Mvec) < 0.001); Mvec[idx] = abs(Mvec[idx]). if phase_limits: # check that limits is a list type; phase_min = phase_limits[0]; phase_max = phase_limits[1]; else:; phase_min = -pi; phase_max = pi. norm = mpl.colors.Normalize(phase_min, phase_max); cmap = complex_phase_cmap(). colors = cmap(norm(angle(Mvec))); if threshold is not None:; colors[:, 3] = 1 * (dz > threshold). if ax is None:; fig = plt.figure(); ax = _axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; xtics = -0.5 + np.arange(M.shape[0]); ax.axes.w_xaxis.set_major_locator(plt.FixedLocator(xtics)); if xlabels:; nxlabels = len(xlabels); if nxlabels != len(xtics):; raise ValueError(f""got {nxlabels} xlabels but needed {len(xtics)}""); ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ytics = -0.5 + np.arange(M.shape[1]); ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics))",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/visualization.html:16408,avoid,avoid,16408,docs/4.6/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html,1,['avoid'],['avoid']
Safety,"gs; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() - 0.5; ypos = ypos.T.flatten() - 0.5; zpos = np.zeros(n); dx = dy = 0.8 * np.ones(n); Mvec = M.flatten(); dz = abs(Mvec). # make small numbers real, to avoid random colors; idx, = np.where(abs(Mvec) < 0.001); Mvec[idx] = abs(Mvec[idx]). if phase_limits: # check that limits is a list type; phase_min = phase_limits[0]; phase_max = phase_limits[1]; else:; phase_min = -pi; phase_max = pi. norm = mpl.colors.Normalize(phase_min, phase_max); cmap = complex_phase_cmap(). colors = cmap(norm(angle(Mvec))); if threshold is not None:; colors[:, 3] = 1 * (dz > threshold). if ax is None:; fig = plt.figure(); ax = _axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title:; ax.set_title(title). # x axis; xtics = -0.5 + np.arange(M.shape[0]); if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.xaxis.set_major_locator(plt.FixedLocator(xtics)); else:; ax.axes.w_xaxis.set_major_locator(plt.FixedLocator(xtics)); if xlabels:; nxlabels = len(xlabels); if nxlabels != len(xtics):; raise ValueError(f""got {nxlabels} xlabels but needed {len(xtics)}""); ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:21994,avoid,avoid,21994,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,1,['avoid'],['avoid']
Safety,"h fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:13886,avoid,avoided,13886,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['avoid'],['avoided']
Safety,"he super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:15801,avoid,avoid,15801,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['avoid'],['avoid']
Safety,"hings in parallel. Should be set; # by user directly in a script or notebook if >1 is needed.; # Must be set BEFORE importing NumPy; if 'MKL_NUM_THREADS' not in os.environ:; os.environ['MKL_NUM_THREADS'] = '1'. if 'OPENBLAS_NUM_THREADS' not in os.environ:; os.environ['OPENBLAS_NUM_THREADS'] = '1'. import sys; import warnings. import qutip.settings; import qutip.version; from qutip.version import version as __version__; from qutip.utilities import _version2int. # -----------------------------------------------------------------------------; # Check if we're in IPython.; try:; __IPYTHON__; qutip.settings.ipython = True; except:; qutip.settings.ipython = False. # -----------------------------------------------------------------------------; # Check for minimum requirements of dependencies, give the user a warning; # if the requirements aren't fulfilled; #. numpy_requirement = ""1.6.0""; try:; import numpy; if _version2int(numpy.__version__) < _version2int(numpy_requirement):; print(""QuTiP warning: old version of numpy detected "" +; (""(%s), requiring %s."" %; (numpy.__version__, numpy_requirement))); except:; warnings.warn(""numpy not found.""). scipy_requirement = ""0.11.0""; try:; import scipy; if _version2int(scipy.__version__) < _version2int(scipy_requirement):; print(""QuTiP warning: old version of scipy detected "" +; (""(%s), requiring %s."" %; (scipy.__version__, scipy_requirement))); except:; warnings.warn(""scipy not found.""). # -----------------------------------------------------------------------------; # check to see if running from install directory for released versions.; #; top_path = os.path.dirname(os.path.dirname(__file__)); try:; setup_file = open(top_path + '/setup.py', 'r'); except:; pass; else:; if ('QuTiP' in setup_file.readlines()[1][3:]) and qutip.version.release:; print(""You are in the installation directory. "" +; ""Change directories before running QuTiP.""); setup_file.close(). del top_path. # --------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:4654,detect,detected,4654,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['detect'],['detected']
Safety,"ho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:7056,detect,detect,7056,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,2,['detect'],['detect']
Safety,"ho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/entropy.html:2807,avoid,avoid,2807,docs/4.7/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html,1,['avoid'],['avoid']
Safety,"hod for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``. platen; Explicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; :func:`~general_stochastic`. See eq. (7.47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\eta=1` of [3]_. - Order strong 1.0?; - Code: ``'rouchon'`` or ``'Rouchon'``. taylor1.5; Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for :obj:`~smesolve` and; :obj:`~ssesolve`. See eq. (4.6) of chapter 10.4 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:4426,predict,predictor-corrector,4426,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['predict'],['predictor-corrector']
Safety,"ht law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,; to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;; Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing scheme can be waived, the Licensor waives the exclusive; right to collect such royalties for any exercise by You of the; rights granted under this License; and,; Voluntary License Schemes. The Licensor waives the right to collect; royalties, whether individually or, in the event that the Licensor; is a member of a collecting society that administers voluntary; licensing schemes, via that society, from any exercise by You of; the rights granted under this License. The above rights may be exercised in all media and form",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:7677,avoid,avoidance,7677,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['avoid'],['avoidance']
Safety,"ients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:31718,avoid,avoided,31718,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,2,['avoid'],['avoided']
Safety,"iff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:12405,avoid,avoid,12405,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,2,['avoid'],['avoid']
Safety,"iff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; St",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:33256,avoid,avoid,33256,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['avoid'],['avoid']
Safety,"iff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions; get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:6929,avoid,avoid,6929,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,4,['avoid'],['avoid']
Safety,"ight) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) are the stochastic collapse operators, and \(e_n\) is. (3)¶\[e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>\]; In QuTiP, this equation can be solved using the function qutip.stochastic.ssesolve, which is implemented by defining \(d_1\) and \(d_{2,n}\) from Equation (1) as. (4)¶\[d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),\]; and. (5)¶\[d_{2, n} = S_n - \frac{e_n}{2}.\]; The solver qutip.stochastic.ssesolve will construct the operators \(d_1\) and \(d_{2,n}\) once the user passes the Hamiltonian (H) and the stochastic operator list (sc_ops). As with the qutip.mcsolve, the number of trajectories and the seed for the noise realisation can be fixed using the arguments: ntraj and noise, respectively. If the user also requires the measurement output, the argument store_measurement=True should be included.; Additionally, homodyne and heterodyne detections can be easily simulated by passing the arguments method='homodyne' or method='heterodyne' to qutip.stochastic.ssesolve.; Examples of how to solve the stochastic Schrodinger equation using QuTiP can be found in this development notebook. Stochastic Master Equation¶; When the initial state of the system is a density matrix \(\rho\), the stochastic master equation solver qutip.stochastic.smesolve must be used. The stochastic master equation is given by (see section 4.4, [Wis09]). (6)¶\[ d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:3273,detect,detections,3273,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detections']
Safety,"ill violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``. platen; Explicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; :func:`~general_stochastic`. See eq. (7.47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:4115,predict,predictor-corrector,4115,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['predict'],['predictor-corrector']
Safety,"interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained.; Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.23s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.39s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.54s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.71s. Est. time left: 00:00:00:01; 50.0%. Run time: 0.85s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.97s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.12s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.28s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.46s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:18017,avoid,avoid,18017,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety,"interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained.; Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.31s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.59s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.90s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.13s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.38s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.62s. Est. time left: 00:00:00:01; 70.0%. Run time: 1.84s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.07s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.33s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:17597,avoid,avoid,17597,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety,"ion(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with; # time-independent c_ops. If we _always_ pass it, it may appear to; # QobjEvo that there is a tlist mismatch, even though it is not used.; if isinstance(op, Qobj):; op_td = QobjEvo(op); elif isinstance(op, QobjEvo):; op_td = QobjEvo(op, args); else:; op_td = QobjEvo(op, args, tlist=tlist); if not issuper(op_td.cte):; op_td = lindblad_dissipator(op_td); L_td += op_td. if opt.rhs_with_state:; L_td._check_old_with_state(). nthread = opt.openmp_threads if opt.use_openmp else 0; L_td.compile(omp=nthread). ss = SolverSystem(); ss.H = L_td; ss.makefunc = _qobjevo_set; solver_safe[""mesolve""] = ss; return ss. def _test_liouvillian_dimensions(L_dims, rho_dims):; """"""; Raise ValueError if the dimensions of the Liouvillian and the density; matrix or superoperator state are incompatible with the master equation.; """"""; if L_dims[0] != L_dims[1]:; raise ValueError(""Liouvillia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:11283,avoid,avoid,11283,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,2,['avoid'],['avoid']
Safety,"ional Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Homodyne detection. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-dynamics.html:1590,detect,detection,1590,docs/4.5/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-dynamics.html,1,['detect'],['detection']
Safety,"ional-order switched systems and its digital implementation"", ; International Journal of Electronics and Communications (2017). 297. Yoshihara et al., ""Characteristic spectra of circuit quantum electrodynamics systems from the ultrastrong- to the deep-strong-coupling regime"", ; Phys. Rev. A 95, 053824 (2017). 296. Endo et al., ""Dynamics of an ultra-strongly-coupled system interacting with a driven nonlinear resonator"", ; arXiv:1705.08688. 295. Venkatesh et al., ""Cooperative Effects in Closely Packed Quantum Emitters with Collective Dephasing"", ; Phys. Rev. Lett. 120, 033602 (2018). 294. Snijders et al., ""A fiber coupled cavity QED source of identical single photons"", ; arXiv:1705.05876. 293. Zanker et al., ""Analyzing the spectral density of a perturbed analog quantum simulator using Keldysh formalism"", ; arXiv:1705.02325. 292. Csurgay et al., ""Toward engineering design of quantum circuits"", ; Int. J. Circ. Theor. Appl. (2017). 291. Megyeri et al., ""Why material slow light does not improve cavity-enhanced atom detection"", ; J. Mod. Phys. (2017). 290. Huembeli et al., ""Towards a heralded eigenstate-preserving measurement of multi-qubit parity in circuit QED"", ; Phys. Rev. A 96, 012313 (2017). 289. Shammah et al., ""Superradiance with local phase-breaking effects"", ; Phys. Rev. A 96, 023863 (2017). 288. Arenz et al., ""The roles of drift and control field constraints upon quantum control speed limits"", ; New J. Phys. 19, 103015 (2017). 287. Leroux et al., ""Simple variational ground state and pure-cat-state generation in the quantum Rabi model"", ; Phys. Rev. A 96, 043834 (2017). 286. Laflamme et al., ""Continuous measurement of an atomic current"", ; Phys. Rev. A 95, 043843 (2017). 285. de Assis et al., ""Negative response with an optical cavity and traveling wave fields"", ; Phys. Rev. A 96, 013821 (2017). 284. Gough, ""The Tyranny of Qubits - Quantum Technology's Scalability Bottleneck"", ; arXiv:1703.05342. 283. Hamsen et al., ""Two-Photon Blockade in an Atom-Driven Cavity QED",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:10708,detect,detection,10708,users.html,https://qutip.org,https://qutip.org/users.html,1,['detect'],['detection']
Safety,"is; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/parallel.html:8052,timeout,timeout,8052,docs/4.4/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"isinstance(H, list) and isinstance(H[0], Qobj) and; issuper(H[0])); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; not options.rhs_with_state and issuper(H(0., args))); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; options.rhs_with_state)). if not use_mesolve:; return sesolve(H, rho0, tlist, e_ops=e_ops, args=args, options=options,; progress_bar=progress_bar, _safe_mode=_safe_mode). if isket(rho0):; rho0 = ket2dm(rho0); if (not (rho0.isoper or rho0.issuper)) or (rho0.dims[0] != rho0.dims[1]):; raise ValueError(; ""input state must be a pure state vector, square density matrix, ""; ""or superoperator""; ). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); elif callable(H):; ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options); else:; raise Exception(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:10471,safe,safety,10471,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,2,['safe'],['safety']
Safety,"isplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:268536,detect,detecting,268536,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['detect'],['detecting']
Safety,"iter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:40347,safe,safe,40347,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['safe'],['safe']
Safety,"iter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Retu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:40141,safe,safe,40141,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['safe'],['safe']
Safety,"ix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Prob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:18186,avoid,avoid,18186,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety,"jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dsigma_t = spmv(L.data, sigma_t) * dt. # deterministic evolution with correction for norm decay; drho_t = spmv(L.data, rho_t) * dt. rho_t += drho_t. # increment density matrices; sigma_t += dsigma_t; rho_t += drho_t. return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Helper-functions for stochastic DE; #; # d1 = deterministic part of the contribution to the DE RHS function, to be; # multiplied by the increament dt; #; # d1 = stochastic part of the contribution to the DE RHS function, to be; # multiplied by the increament dW; #. #; # For SSE; #. # Function sigurature:; #; # def d(A, psi):; #; # psi = wave function at the current time step; #; # A[0] = c; # A[1] = c + c.dag(); # A[2] = c - c.dag(); # A[3] = c.dag() * c; #; # where c is a collapse operator. The combinations of c's stored in A are; # precomputed before the time-evolution is started to avoid repeated; # computations. def _generate_psi_A_ops(sc_ops, H):; """"""; pre-compute superoperator operator combinations that are commonly needed; when evaluating the RHS of stochastic schrodinger equations; """""". A_ops = []; for c_idx, c in enumerate(sc_ops):; A_ops.append([c.data,; (c + c.dag()).data,; (c - c.dag()).data,; (c.dag() * c).data]). return A_ops. def d1_psi_homodyne(t, psi, A, args):; """"""; OK; Need to cythonize. .. math::. D_1(C, \psi) = \\frac{1}{2}(\\langle C + C^\\dagger\\rangle\\C psi -; C^\\dagger C\\psi - \\frac{1}{4}\\langle C + C^\\dagger\\rangle^2\\psi). """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); return 0.5 * (e1 * spmv(A[0], psi) -; spmv(A[3], psi) -; 0.25 * e1 ** 2 * psi). def d2_psi_homodyne(t, psi, A, args):; """"""; OK; Need to cythonize. .. math::. D_2(\psi, t) = (C - \\frac{1}{2}\\langle C + C^\\dagger\\rangle)\\psi. """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); retur",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:37108,avoid,avoid,37108,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,4,['avoid'],['avoid']
Safety,"jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dsigma_t = spmv(L.data, sigma_t) * dt. # deterministic evolution with correction for norm decay; drho_t = spmv(L.data, rho_t) * dt. rho_t += drho_t. # increment density matrices; sigma_t += dsigma_t; rho_t += drho_t. return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Helper-functions for stochastic DE; #; # d1 = deterministic part of the contribution to the DE RHS function, to be; # multiplied by the increament dt; #; # d1 = stochastic part of the contribution to the DE RHS function, to be; # multiplied by the increament dW; #. #; # For SSE; #. # Function sigurature:; #; # def d(A, psi):; #; # psi = wave function at the current time step; #; # A[0] = c; # A[1] = c + c.dag(); # A[2] = c - c.dag(); # A[3] = c.dag() * c; #; # where c is a collapse operator. The combinations of c's stored in A are; # precomputed before the time-evolution is started to avoid repeated; # computations. def _generate_psi_A_ops(sc_ops, H):; """"""; pre-compute superoperator operator combinations that are commonly needed; when evaluating the RHS of stochastic schrodinger equations; """""". A_ops = []; for c_idx, c in enumerate(sc_ops):; A_ops.append([c.data,; (c + c.dag()).data,; (c - c.dag()).data,; (c.dag() * c).data]). return A_ops. def d1_psi_homodyne(t, psi, A, args):; """"""; OK; Todo: cythonize. .. math::. D_1(C, \psi) = \\frac{1}{2}(\\langle C + C^\\dagger\\rangle\\C psi -; C^\\dagger C\\psi - \\frac{1}{4}\\langle C + C^\\dagger\\rangle^2\\psi). """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); return 0.5 * (e1 * spmv(A[0], psi) -; spmv(A[3], psi) -; 0.25 * e1 ** 2 * psi). def d2_psi_homodyne(t, psi, A, args):; """"""; OK; Todo: cythonize. .. math::. D_2(\psi, t) = (C - \\frac{1}{2}\\langle C + C^\\dagger\\rangle)\\psi. """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); return [s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:36066,avoid,avoid,36066,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['avoid'],['avoid']
Safety,"l equations.; Only solver which could take non-commuting sc_ops. *not tested*; -Order 0.5; -Code: 'euler-maruyama', 'euler', 0.5. milstein, Order 1.0 strong Taylor scheme:; Better approximate numerical solution to stochastic; differential equations.; -Order strong 1.0; -Code: 'milstein', 1.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.3 Eq. (3.1), By Peter E. Kloeden, Eckhard Platen. milstein-imp, Order 1.0 implicit strong Taylor scheme:; Implicit milstein scheme for the numerical simulation of stiff; stochastic differential equations.; -Order strong 1.0; -Code: 'milstein-imp'; Numerical Solution of Stochastic Differential Equations; Chapter 12.2 Eq. (2.9), By Peter E. Kloeden, Eckhard Platen. predictor-corrector:; Generalization of the trapezoidal method to stochastic; differential equations. More stable than explicit methods.; -Order strong 0.5, weak 1.0; Only the stochastic part is corrected.; (alpha = 0, eta = 1/2); -Code: 'pred-corr', 'predictor-corrector', 'pc-euler'; Both the deterministic and stochastic part corrected.; (alpha = 1/2, eta = 1/2); -Code: 'pc-euler-imp', 'pc-euler-2', 'pred-corr-2'; Numerical Solution of Stochastic Differential Equations; Chapter 15.5 Eq. (5.4), By Peter E. Kloeden, Eckhard Platen. platen:; Explicit scheme, create the milstein using finite difference instead of; derivatives. Also contain some higher order terms, thus converge better; than milstein while staying strong order 1.0.; Do not require derivatives, therefore usable for; :func:`qutip.stochastic.general_stochastic`; -Order strong 1.0, weak 2.0; -Code: 'platen', 'platen1', 'explicit1'; The Theory of Open Quantum Systems; Chapter 7 Eq. (7.47), H.-P Breuer, F. Petruccione. rouchon:; Scheme keeping the positivity of the density matrix. (smesolve only); -Order strong 1.0?; -Code: 'rouchon', 'Rouchon'; Eq. 4 of arXiv:1410.5345 with eta=1; Efficient Quantum Filtering for Quantum Feedback Control; Pierre Rouchon, Jason F. Ralph; arXiv:1410.5345 [quant-ph",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:4053,predict,predictor-corrector,4053,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,2,['predict'],['predictor-corrector']
Safety,"l, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15469,avoid,avoid,15469,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,2,['avoid'],['avoid']
Safety,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6539,detect,detection,6539,docs/4.7/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"lf.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:23746,avoid,avoids,23746,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"lor1.5-imp'; elif self.solver in ['taylor2.0', 'taylor20', 2.0, 202]:; self.solver_code = 202; self.solver = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(; ""Taylor2.0 only works with 1 constant sc_ops and for""; "" homodyne method""; ); else:; known = [; None, 'euler-maruyama', 'platen', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18400,predict,predictor-corrector,18400,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['predict'],['predictor-corrector']
Safety,"lse). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data attribute. Return type:array. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used).; safe (bool (default=True)) – Check for degenerate ground state. Returns:; eigval (float) – Eigenvalue for the ground state of quantum operator.; eigvec (qobj) – Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Complex valued matrix element. Return type:complex. Raises:TypeError – Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm (str) – Which norm to use for ket/br",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:10424,safe,safe,10424,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['safe'],['safe']
Safety,"lue of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:22867,safe,safePickleboolFlag,22867,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['safe'],['safePickleboolFlag']
Safety,"lver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'taylor20', 2.0, 202]:; self.solver_code = 202; self.solver = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise Exception(""Taylor2.0 only work with 1 constant sc_ops "" +; ""and for homodyne method""); else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler-maruyama', 'platen', 'pc-euler', "" +; ""'pc-euler-imp', 'milstein', 'milstein-imp', "" +; ""'rouchon', "" +; ""'taylor1.5', 'taylor1.5-imp', 'explicit1.5' "" +; ""'taylor2.0']""). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:17791,predict,predictor-corrector,17791,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties and methods were renamed at the same time. A full list is given here. All modules; - function: set_log_level -> property: log_level; dynamics functions. _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decom",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:9960,avoid,avoided,9960,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,4,['avoid'],['avoided']
Safety,"magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties and methods were renamed at the same time. A full list is given here. All modules; - function: set_log_level -> property: log_level; dynamics functions; _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decom",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:4484,avoid,avoided,4484,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,4,['avoid'],['avoided']
Safety,"mand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:43413,safe,safe,43413,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"mand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:46247,safe,safe,46247,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/parallel.html:8056,timeout,timeout,8056,docs/4.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/parallel.html:8056,timeout,timeout,8056,docs/4.1/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"mes of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCte`` or ``CQobjEvoTd``; Cython version of the QobjEvo. coeff_get : callable; Object called to obtain a list of all the coefficients at a particular; time. coeff_files : list; Runtime created files to delete with the instance. dummy_cte : bool; Is self.cte an empty Qobj. const : bool; Indicates if quantum object is constant. type : {""cte"", ""string"", ""func"", ""array"", ""spline"", ""mixed_callable"", \; ""mixed_compilable""}; Information about the type of coefficients used in the entire object. num_obj : int; Number of :obj:`~Qobj` in the QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:12764,safe,safePickle,12764,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"ms[1]]). elif isinstance(state, np.ndarray) and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1],[1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). def copy(self):; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). def arguments(self, new_args):; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:21465,safe,safePickle,21465,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"n case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homod",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:52530,detect,detection,52530,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,4,['detect'],['detection']
Safety,"n of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:26586,safe,safety,26586,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['safe'],['safety']
Safety,"n the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:256335,detect,detecting,256335,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['detect'],['detecting']
Safety,"n, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = ddW[:, 0]; sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:50198,detect,detection,50198,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['detect'],['detection']
Safety,"n. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.superoperator. Source code for qutip.superoperator; __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron; from functools import partial. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : Qobj or QobjEvo; System Hamiltonian. c_ops : array_like of Qobj or QobjEvo; A ``list`` or ``array`` of collapse operators. Returns; -------; L : Qobj or QobjEvo; Liouvillian superoperator. """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]; if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). h = None; if H is not None:; if isinstance(H, QobjEvo):; h = H.cte; else:; h = H; if h.isoper:; op_dims = h.dims; op_shape = h.shape; elif h.issuper:; op_dims = h.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; if isinstance(c_ops[0], QobjEvo):; c = c_ops[0].cte; else:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issup",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/superoperator.html:1038,avoid,avoids,1038,docs/4.7/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superoperator.html,1,['avoid'],['avoids']
Safety,"n2, n3, ...)) for a system with dimensions given by dims. Example:. >>> for state in state_number_enumerate([2,2]): # doctest: +SKIP; >>> print(state) # doctest: +SKIP; ( 0 0 ); ( 0 1 ); ( 1 0 ); ( 1 1 ). Parameters; ----------; dims : list or array; The quantum state dimensions array, as it would appear in a Qobj. excitations : integer (None); Restrict state space to states with excitation numbers below or; equal to this value. Returns; -------; state_number : tuple; Successive state number tuples that can be used in loops and other; iterations, using standard state enumeration *by definition*. """""". if excitations is None:; # in this case, state numbers are a direct product; yield from itertools.product(*(range(d) for d in dims)); return. # From here on, excitations is not None. # General idea of algorithm: add excitations one by one in last mode (idx =; # len(dims)-1), and carry over to the next index when the limit is reached.; # Keep track of the number of excitations while doing so to avoid having to; # do explicit sums over the states.; state = (0,)*len(dims); nexc = 0; while True:; yield state; idx = len(dims) - 1; state = state[:idx] + (state[idx]+1,); nexc += 1; while nexc > excitations or state[idx] >= dims[idx]:; # remove all excitations in mode idx, add one in idx-1; idx -= 1; if idx < 0:; return; nexc -= state[idx+1] - 1; state = state[:idx] + (state[idx]+1, 0) + state[idx+2:]. [docs]def state_number_index(dims, state):; """"""; Return the index of a quantum state corresponding to state,; given a system with dimensions given by dims. Example:. >>> state_number_index([2, 2, 2], [1, 1, 0]); 6. Parameters; ----------; dims : list or array; The quantum state dimensions array, as it would appear in a Qobj. state : list; State number array. Returns; -------; idx : int; The index of the state given by `state` in standard enumeration; ordering. """"""; return np.ravel_multi_index(state, dims). [docs]def state_index_number(dims, index):; """"""; Return a quantum number r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/states.html:19814,avoid,avoid,19814,docs/4.7/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html,1,['avoid'],['avoid']
Safety,"nalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; """"""; H = self.H[k]; # assuming H is an nxn matrix, find n; n = H.shape[0]; # returns row vector of eigen values,; # columns with the eigenvectors; eig_val, eig_vec = np.linalg.eig(H). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvals and eigenvectors for use by other functions, e.g.; # gradient_exact; self.decomp_curr[k] = True; self.prop_eigen[k] = prop_eig; self.dyn_gen_eigenvectors[k] = eig_vec; self.dyn_gen_factormatrix[k] = factors. [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; """""". def reset(self):; Dynamics.reset(self); sel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:26195,avoid,avoid,26195,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['avoid'],['avoid']
Safety,"nd state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1], [1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:20156,safe,safePickle,20156,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"nential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns:oper : qobj. Exponentiated quantum operator. Raises:TypeError. Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:states_inds : list of integer. The states that should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True). Check for degenerate ground state. Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/classes.html:9903,safe,safe,9903,docs/4.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/classes.html,1,['safe'],['safe']
Safety,"ntum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters:; order : str {‘C’, ‘F’}; Return array in C (default) or Fortran ordering. squeeze : bool {False, True}; Squeeze output array. Returns:; data : array; Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True); Check for degenerate ground state. Returns:; eigval : float; Eigenvalue for the ground state of quantum operator. eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type ‘bra’ or ‘ket’. ket : qobj; Quantum object of type ‘ket’. Returns:; elem : compl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:10354,safe,safe,10354,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['safe'],['safe']
Safety,"objevo; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """""". def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:1339,safe,safePickle,1339,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"ochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolutio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:111648,predict,predictor,111648,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['predict'],['predictor']
Safety,"olver = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(""Taylor2.0 only works with 1 constant "" +; ""sc_ops and for homodyne method""); else:; raise ValueError((; ""The solver should be one of ""; ""[None, 'euler-maruyama', 'platen', 'pc-euler', ""; ""'pc-euler-imp', 'milstein', 'milstein-imp', ""; ""'rouchon', ""; ""'taylor1.5', 'taylor1.5-imp', 'explicit1.5' ""; ""'taylor2.0']"")). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a determinist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:18205,predict,predictor-corrector,18205,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"omodyne detection. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{2} -\frac{e_n}{2} C_n; + \frac{e_n^2}{8} \right) \psi \delta t; + \sum_n \left( C_n - \frac{e_n}{2} \right) \psi \delta \omega\]; with. \[ \begin{align}\begin{aligned}:label: jump_rate\\e_n = \left<\psi(t)|C_n + C_n^{+}|\psi(t)\right>\end{aligned}\end{align} \]; Here \(\delta \omega\) is a Wiener increment.; In QuTiP, this is available with the function ssesolve.; In [1]: times = np.linspace(0.0, 10.0, 201). In [2]: p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html:1450,detect,detection,1450,docs/4.5/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html,1,['detect'],['detection']
Safety,"onte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:1357,detect,detection,1357,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,1,['detect'],['detection']
Safety,"oper_dtype == np.ndarray:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = eigh(H). else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isinstance(factors, np.ndarray):; self._dyn_gen_factormatrix[k] = factors; else:; self._dyn_gen_factormatrix[k] = np.array(factors). if self.oper_dtype == Qobj:; self._prop_eigen[k] = Qobj(np.diagflat(prop_eig),; dims=self.dyn_dims); self._dyn_gen_eigenvectors[k] = Qobj(eig_vec,; dims=self.dyn_dims); # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); elif",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:48936,avoid,avoid,48936,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,2,['avoid'],['avoid']
Safety,"opy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:22429,safe,safePickle,22429,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,"opy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). def arguments(self, new_args):; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] is not ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:22091,safe,safePickle,22091,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"or. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobj.html:60581,avoid,avoid,60581,docs/4.7/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"ore terms of the Stratonovich expansion.; -Order strong 2.0; -Code: 'taylor2.0', 'taylor20', 2.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.5 Eq. (5.2), By Peter E. Kloeden, Eckhard Platen. ---All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only work for 1 stochastic; operator not dependent of time with the homodyne method.; The :func:`qutip.stochastic.general_stochastic` only accept derivatives; free solvers: ['euler', 'platen', 'explicit1.5']. Available solver for photocurrent_sesolve and photocurrent_mesolve:; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"".; euler:; Euler method for ordinary differential equations between jumps.; Only 1 jumps per time interval.; Default solver; -Order 1.0; -Code: 'euler'; Quantum measurement and control; Chapter 4, Eq 4.19, 4.40, By Howard M. Wiseman, Gerard J. Milburn. predictor–corrector:; predictor–corrector method (PECE) for ordinary differential equations.; Use poisson distribution to obtain the number of jump at each timestep.; -Order 2.0; -Code: 'pred-corr'. """"""; pass. [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Attributes; ----------. H : :class:`qutip.Qobj`, time-dependent Qobj as a list*; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list* / *array*; List ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:7109,predict,predictor,7109,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,4,['predict'],['predictor']
Safety,"ort scipy; if _version2int(scipy.__version__) < _version2int(scipy_requirement):; print(""QuTiP warning: old version of scipy detected "" +; (""(%s), requiring %s."" %; (scipy.__version__, scipy_requirement))); except:; warnings.warn(""scipy not found.""). # -----------------------------------------------------------------------------; # check to see if running from install directory for released versions.; #; top_path = os.path.dirname(os.path.dirname(__file__)); try:; setup_file = open(top_path + '/setup.py', 'r'); except:; pass; else:; if ('QuTiP' in setup_file.readlines()[1][3:]) and qutip.version.release:; print(""You are in the installation directory. "" +; ""Change directories before running QuTiP.""); setup_file.close(). del top_path. # -----------------------------------------------------------------------------; # setup the cython environment; #; _cython_requirement = ""0.15.0""; try:; import Cython; if _version2int(Cython.__version__) < _version2int(_cython_requirement):; print(""QuTiP warning: old version of cython detected "" +; (""(%s), requiring %s."" %; (Cython.__version__, _cython_requirement))). import pyximport; os.environ['CFLAGS'] = '-O3 -w -ffast-math -march=native -mfpmath=sse'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}). except Exception as e:; print(""QuTiP warning: Cython setup failed: "" + str(e)); else:; del Cython, pyximport. # -----------------------------------------------------------------------------; # Load user configuration if present: override defaults.; #; try:; if os.name == ""nt"":; qutip_rc_file = os.path.join(; os.getenv('APPDATA'), 'qutip', ""qutiprc""; ); else:; qutip_rc_file = os.path.join(; # This should possibly be changed to ~/.config/qutiprc,; # to follow XDG specs. Also, OS X uses a different naming; # convention as well.; os.environ['HOME'], "".qutiprc""; ); qutip.settings.load_rc_file(qutip_rc_file). except Exception as e:; try:; qutip.settings._logger.warning(""Error loading RC file."", exc_info=1); except:; pass",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:5849,detect,detected,5849,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['detect'],['detected']
Safety,p.; Quantum circuits and algorithms. Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotations; Imports and Exports QASM circuit; QuTiP example: Quantum Gates and their usage; Quantum Teleportation Circuit. Pulse-level circuit simulation. Compiling and simulating a 10-qubit Quantum Fourier Transform (QFT) algorithm; Custimize the pulse-level simulation; Examples for OptPulseProcessor; Scheduler for quantum gates and instructions; Simulating randomized benchmarking; Simulating the Deutsch–Jozsa algorithm at the pulse level; measuring the relaxation time with the idling gate. Time evolution. QobjEvo: time-dependent quantum objects; Schrödinger Equation Solver: Larmor precession; Master Equation Solver: Single-Qubit Dynamics; Master Equation Solver: Vacuum Rabi oscillations; Master Equation Solver: Dynamics of a Spin Chain; Monte Carlo Solver: Birth and Death of Photons in a Cavity; Bloch-Redfield Solver: Two Level System; Bloch-Redfield Solver: Time dependent operators; Bloch-Redfield Solver: Dissipative Atom-Cavity system; Bloch-Redfield Solver: Phonon-assisted initialization; Floquet Solvers; Floquet Formalism; Non-Markovian Monte Carlo Solver: Two Physical Examples; Stochastic Solver: Heterodyne Detection; Stochastic Solver: Mixing stochastic and deterministic equations; Stochastic Solver: Photo-current detection in a JC model; Stochastic vs. Monte-Carlo Solver: Cat states become coherent; Steady-State: Optomechanical System in the Single-Photon Strong-Coupling Regime; Steady-State: Homodyned Jaynes-Cummings emission; Steady-State: Time-dependent (periodic) quantum system. Optimal control. Overview ; Hadamard ; QFT ; Lindbladian ; Symplectic ; QFT (CRAB) ; State to state (CRAB) ; CNOT ; iSWAP ; Single-qubit rotation ; Toffoli gate . Tomography. Density matrix estimation with iterative maximum likelihood estimation . Permutational invariant Lindblad dynamics. Overview ; Superradiant light emission ; Steady state superradiance ; Open Dicke model ; ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-tutorials/index.html:3254,detect,detection,3254,qutip-tutorials/index.html,https://qutip.org,https://qutip.org/qutip-tutorials/index.html,1,['detect'],['detection']
Safety,"params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:19478,avoid,avoids,19478,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,8,['avoid'],['avoids']
Safety,"pecified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). (png, hires.png, pdf). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:6474,detect,detection,6474,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"port to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:3616,avoid,avoid,3616,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,1,['avoid'],['avoid']
Safety,"r the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return psi_t + dpsi_t. def _rhs_rho_euler_maruyama(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for density matrix solver.; """"""; dW_len = len(dW[0, :]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, rho_t, A, args); drho_t += d1(t, rho_t, A, args) * dt; drho_t += np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return rho_t + drho_t. def _rhs_rho_euler_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Fast Euler-Maruyama for homodyne detection.; """""". dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2). drho_t = d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]); drho_t += (1.0 - np.inner(np.real(e), dW)) * rho_t; return drho_t. # -----------------------------------------------------------------------------; # Platen method; #; def _rhs_psi_platen(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; TODO: support multiple stochastic increments. .. note::. Experimental. """""". sqrt_dt = np.sqrt(dt). dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:48768,detect,detection,48768,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['detect'],['detection']
Safety,"r you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:5862,detect,detect,5862,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['detect'],['detect']
Safety,"r2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(; ""Taylor2.0 only works with 1 constant sc_ops and for""; "" homodyne method""; ); else:; known = [; None, 'euler-maruyama', 'platen', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a determinist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18558,predict,predictor-corrector,18558,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['predict'],['predictor-corrector']
Safety,"ral_stochastic']. [docs]def stochastic_solvers():; """"""Available solvers for ssesolve and smesolve; euler-maruyama:; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations.; Only solver which could take non-commuting sc_ops. *not tested*; -Order 0.5; -Code: 'euler-maruyama', 'euler', 0.5. milstein, Order 1.0 strong Taylor scheme:; Better approximate numerical solution to stochastic; differential equations.; -Order strong 1.0; -Code: 'milstein', 1.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.3 Eq. (3.1), By Peter E. Kloeden, Eckhard Platen. milstein-imp, Order 1.0 implicit strong Taylor scheme:; Implicit milstein scheme for the numerical simulation of stiff; stochastic differential equations.; -Order strong 1.0; -Code: 'milstein-imp'; Numerical Solution of Stochastic Differential Equations; Chapter 12.2 Eq. (2.9), By Peter E. Kloeden, Eckhard Platen. predictor-corrector:; Generalization of the trapezoidal method to stochastic; differential equations. More stable than explicit methods.; -Order strong 0.5, weak 1.0; Only the stochastic part is corrected.; (alpha = 0, eta = 1/2); -Code: 'pred-corr', 'predictor-corrector', 'pc-euler'; Both the deterministic and stochastic part corrected.; (alpha = 1/2, eta = 1/2); -Code: 'pc-euler-imp', 'pc-euler-2', 'pred-corr-2'; Numerical Solution of Stochastic Differential Equations; Chapter 15.5 Eq. (5.4), By Peter E. Kloeden, Eckhard Platen. platen:; Explicit scheme, create the milstein using finite difference instead of; derivatives. Also contain some higher order terms, thus converge better; than milstein while staying strong order 1.0.; Do not require derivatives, therefore usable for; :func:`qutip.stochastic.general_stochastic`; -Order strong 1.0, weak 2.0; -Code: 'platen', 'platen1', 'explicit1'; The Theory of Open Quantum Systems; Chapter 7 Eq. (7.47), H.-P Breuer, F. Petruccione. rouchon:; Scheme keeping the positivity of the density matr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:3820,predict,predictor-corrector,3820,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"random coefficients. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.random = True; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1. def gen_pulse(self, min_wavelen=None):; """"""; Generate a random pulse based on a Fourier series with a minimum; wavelength; """""". if min_wavelen is not None:; self.min_wavelen = min_wavelen; min_wavelen = self.min_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape); wavelen = 2.0*self.pulse_time. t = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; t[k+1] = t[k] + self.tau[k]. wl = []; while wavelen > min_wavelen:; wl.append(wavelen); wavelen = wavelen/2.0. num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves). for wavelen in wl:; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWaves(PulseGen):; """"""; Generates pulses by summing sine waves with random frequencies; amplitudes and phase offset. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). nu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:11354,avoid,avoid,11354,docs/3.1.0/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html,1,['avoid'],['avoid']
Safety,"ree> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states – array of three level atom basis vectors. Return type:array. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops – array of three level operators. Return type:array. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:; H (qobj) – System Hamiltonian.; c_ops (array_like) – A list or array of collapse operators. Returns:L – Liouvillian superoperator. Return type:qobj. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:A (qobj) – Quantum operator for post multiplication. Returns:super – Superoperator formed from input qauntum object. Return type:qobj. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:A (qobj) – Quantum operator for pre-multiplication. Returns:super – Superoperator formed from input quantum object. Return type:qobj. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:; A (Qobj) – Quantum operator for pre-multiplication.; B (Qobj) – Quantum operator for post-multiplication. Returns:super – Superoperator formed from input quantum objects. Retur",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:38051,avoid,avoids,38051,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['avoid'],['avoids']
Safety,"requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:40199,safe,safe,40199,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['safe'],['safe']
Safety,"requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors norm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39993,safe,safe,39993,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['safe'],['safe']
Safety,"res and Hellinger distances""; arXiv:1611.03449. Parameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> hellinger_dist(x,y); 1.3725145002591095. """"""; if A.dims != B.dims:; raise TypeError(""A and B do not have same dimensions.""). if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). product = sqrtmA*sqrtmB. eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); #np.maximum() is to avoid nan appearing sometimes due to numerical; #instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; #when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is; taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default); or ""SCS"". The latter tends to be significantly faster,; but somewhat less accurate.; verbose : bool; If True, prints additional information about the; solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument. Returns; -------; dn : float; Diamond norm of q_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/metrics.html:9536,avoid,avoid,9536,docs/4.4/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/metrics.html,2,['avoid'],['avoid']
Safety,"res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, method=""brentq"", xtol=options.atol); if sol.converged:; delta_t = sol.root; return delta_t; else:; raise Exception(; ""Method did not converge, try increasing 'krylov_dim', ""; ""taking a lesser final time 'tlist[-1]' or decreasing the ""; ""tolerance via Options().atol. ""; ""If nothing works, this problem m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:14444,avoid,avoid,14444,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['avoid'],['avoid']
Safety,"rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""to",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:5677,avoid,avoid,5677,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,1,['avoid'],['avoid']
Safety,"rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:4489,avoid,avoid,4489,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,7,['avoid'],['avoid']
Safety,"ror. Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:states_inds : list of integer. The states that should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters:order : str {‘C’, ‘F’}. Return array in C (default) or Fortran ordering. squeeze : bool {False, True}. Squeeze output array. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True). Check for degenerate ground state. Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:10059,safe,safe,10059,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,1,['safe'],['safe']
Safety,"roundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:46395,safe,safe,46395,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"rray; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: 'euler-maruyama', 'fast-euler-maruyama',; 'pc-euler' is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: 'milstein', 'fast-milstein', 'platen',; 'milstein-imp' is semi-implicit Milstein method,; 3/2 order algorithms: 'taylor15',; 'taylor15-imp' is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {'tol':value},; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function du",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:6600,predict,predictor-corrector,6600,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"rray; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’,; ‘pc-euler’ is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’,; ‘milstein-imp’ is semi-implicit Milstein method,; 3/2 order algorithms: ‘taylor15’,; ‘taylor15-imp’ is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {‘tol’:value},; default is {‘tol’:1e-6}. method : string (‘homodyne’, ‘heterodyne’, ‘photocurrent’); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string (‘normal’, ‘poission’); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:44591,predict,predictor-corrector,44591,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['predict'],['predictor-corrector']
Safety,"rror:; return False. def _is_inline_backend(self):; backend = matplotlib.get_backend(); return backend == ""module://matplotlib_inline.backend_inline"". [docs] def render(self):; """"""; Render the Bloch sphere and its data sets in on given figure and axes.; """"""; if not self._ext_fig and not self._is_inline_backend():; # If no external figure was supplied, we check to see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_front(); self.plot_axe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/bloch.html:15702,avoid,avoid,15702,docs/4.6/modules/qutip/bloch.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html,1,['avoid'],['avoid']
Safety,"rror:; return False. def _is_inline_backend(self):; backend = matplotlib.get_backend(); return backend == ""module://matplotlib_inline.backend_inline"". [docs] def render(self):; """"""; Render the Bloch sphere and its data sets in on given figure and axes.; """"""; if not self._ext_fig and not self._is_inline_backend():; # If no external figure was supplied, we check to see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_lines(); self.plot_arc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch.html:18772,avoid,avoid,18772,docs/4.7/modules/qutip/bloch.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html,1,['avoid'],['avoid']
Safety,"s : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N],[N]], [[N],[N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre', seed=seed). # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()). if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible improvement,; # iterative methods exist to find inverse square root matrices directly,; # as this is important in statistics.; Z = np.kron(; np.eye(N),; sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]]). D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/random_objects.html:16088,avoid,avoid,16088,docs/4.4/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/random_objects.html,1,['avoid'],['avoid']
Safety,"s : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N],[N]], [[N],[N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre', seed=seed). # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()). if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible; # improvement, iterative methods exist to find inverse square root; # matrices directly, as this is important in statistics.; Z = np.kron(; np.eye(N),; sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]]). D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/random_objects.html:17322,avoid,avoid,17322,docs/4.5/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/random_objects.html,1,['avoid'],['avoid']
Safety,"s A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.tr() * U2.tr()); else:; return (U1 * U2).tr(). [docs]def average_gate_fidelity(oper, target=None):; """"""; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters; ----------; A : Qobj; Quantum object representing a superoperator.; target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns; -------; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:4147,avoid,avoid,4147,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,6,['avoid'],['avoid']
Safety,"s Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Homodyne detection. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{2} -\frac{e_n}{2} C_n; + \frac{e_n^2}{8} \right) \psi \delta t; + \sum_n \left( C_n - \frac{e_n}{2} \right) \psi \delta \omega\]; with. \[ \begin{align}\begin{aligned}:label: jump_rate\\e_n = \left<\psi(t)|C_n + C_n^{+}|\psi(t)\right>\end{aligned}\end{align} \]; Here \(\delta \omega\) is a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html:1227,detect,detection,1227,docs/4.5/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:42644,safe,safe,42644,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:45478,safe,safe,45478,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Groun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:39445,safe,safe,39445,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['safe'],['safe']
Safety,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Groun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39239,safe,safe,39239,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['safe'],['safe']
Safety,"scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.random = True; self._uses_time = True; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; self.apply_params(). def gen_pulse(self, min_wavelen=None):; """"""; Generate a random pulse based on a Fourier series with a minimum; wavelength; """""". if min_wavelen is not None:; self.min_wavelen = min_wavelen; min_wavelen = self.min_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape); wavelen = 2.0*self.pulse_time. t = self.time; wl = []; while wavelen > min_wavelen:; wl.append(wavelen); wavelen = wavelen/2.0. num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves). for wavelen in wl:; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWaves(PulseGen):; """"""; Generates pulses by summing sine waves with random frequencies; amplitudes and phase offset. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). num_comp_waves : integer; Number of component waves. That is the number of waves that; are summe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:12659,avoid,avoid,12659,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,8,['avoid'],['avoid']
Safety,"se of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:49171,detect,detection,49171,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['detect'],['detection']
Safety,"self.random = True; self.num_comp_waves = 20; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; try:; self.max_wavelen = 2*self.pulse_time; except:; self.max_wavelen = 10.0. def gen_pulse(self, num_comp_waves=None,; min_wavelen=None, max_wavelen=None):; """"""; Generate a random pulse by summing sine waves with random freq,; amplitude and phase offset; """""". if num_comp_waves is not None:; self.num_comp_waves = num_comp_waves; if min_wavelen is not None:; self.min_wavelen = min_wavelen; if max_wavelen is not None:; self.max_wavelen = max_wavelen. num_comp_waves = self.num_comp_waves; min_wavelen = self.min_wavelen; max_wavelen = self.max_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if max_wavelen <= min_wavelen:; raise ValueError(""Maximum wavelength must be greater than ""; ""the minimum wavelength""). if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape). t = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; t[k+1] = t[k] + self.tau[k]. wl_range = max_wavelen - min_wavelen; amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); for n in range(num_comp_waves):; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; wavelen = min_wavelen + np.random.rand()*wl_range; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWalk1(PulseGen):; """"""; Generates pulses by using a random walk algorithm. Attributes; ----------; scaling : float; Used as the range for the starting amplitude; Note must used bounds if values must be restricted.; Also scales the max_d_amp value; (copied from Dynamics.initial_ctrl_scaling if given). max_d_amp : float; Maximum amount amplitude will change between timeslots; Note this is also factored by the scalin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:13799,avoid,avoid,13799,docs/3.1.0/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html,1,['avoid'],['avoid']
Safety,"ses with strongly magnetic atoms"", ; Phys. Rev. A 96, 033602 (2017). 261. Poonia et al., ""Functional window of the avian compass"", ; Phys. Rev. E 95, 052417 (2017). 260. Su et al., ""Generating double NOON states of photons in circuit QED"", ; Phys. Rev. A 95, 022339 (2017). 259. Kiukas et al., ""Remote parameter estimation in a quantum spin chain enhanced by local control"", ; Phys. Rev. A 95, 052132 (2017). 258. Gely et al., ""Convergence of the multimode quantum Rabi model of circuit quantum electrodynamics"", ; Phys. Rev. B 95, 245115 (2017). 257. Radtke et al., ""Photonic Quantum Operations via the Quantum Carburettor Effect"", ; arXiv:1701.04251. 256. Lagoudakis et al., ""Observation of Mollow Triplets with Tunable Interactions in Double Lambda Systems of Individual Hole Spins"", ; Phys. Rev. Lett. 118, 013602 (2017). 255. Pucci et al., ""Quantum effects in the cooperative scattering of light by atomic clouds"", ; Phys. Rev. A 95, 053625 (2017). 254. Gessner et al., ""Resolution-enhanced entanglement detection"", ; Phys. Rev. A 95, 032326 (2017). 253. Nigg et al., ""Superconducting Grid-Bus Surface Code Architecture for Hole-Spin Qubits"", ; Phys. Rev. Lett. 118, 147701 (2017). 252. Lüer et al., ""Lévy Defects in Matrix-Immobilized J Aggregates: Tracing Intra-and Intersegmental Exciton Relaxation"", ; J. Phys. Chem. Lett. 8, 547 (2017). 251. Dive et al., ""In situ upgrade of quantum simulators to universal computers"", ; arXiv:1701.01723. 250. Barnes et al., ""Fast microwave-driven three-qubit gates for cavity-coupled superconducting qubits"", ; Phys. Rev. B 96, 024504 (2017). 249. Hu, ""Spin-based single-photon transistor, dynamic random access memory, diodes, and routers in semiconductors"", ; Phys. Rev. B 94, 245307 (2016). 248. Leung et al., ""Speedup for quantum optimal control from automatic differentiation based on graphics processing units"", ; Phys. Rev. A 95, 042318 (2017). 247. Bruhat et al., ""Strong coupling between an electron in a quantum dot circuit and a photon in a cavi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:15384,detect,detection,15384,users.html,https://qutip.org,https://qutip.org/users.html,1,['detect'],['detection']
Safety,"sesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:109317,predict,predictor-corrector,109317,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['predict'],['predictor-corrector']
Safety,"simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2351,avoid,avoid,2351,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,1,['avoid'],['avoid']
Safety,"st = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_ch",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:22448,safe,safePickle,22448,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,"st = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). def arguments(self, new_args):; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] is not ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:22110,safe,safePickle,22110,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"stic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:1445,detect,detection,1445,docs/4.7/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html,1,['detect'],['detection']
Safety,"t 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:56975,predict,predictor-corrector,56975,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,9,"['detect', 'predict']","['detection', 'predictor', 'predictor-corrector']"
Safety,"t = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/parallel.html:8179,timeout,timeout,8179,docs/4.6/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"t to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters:order : str {‘C’, ‘F’}. Return array in C (default) or Fortran ordering. squeeze : bool {False, True}. Squeeze output array. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True). Check for degenerate ground state. Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:10452,safe,safe,10452,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,1,['safe'],['safe']
Safety,"t(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html:22010,avoid,avoids,22010,docs/4.7/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:4811,detect,detection,4811,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"table of simulation times for the single-photon example using the different time-dependent formats and both the master equation and Monte Carlo solver. Format; Master Equation; Monte Carlo. Python Function; 2.1 sec; 27 sec. Cython String; 1.4 sec; 9 sec. Hamiltonian Function; 1.0 sec; 238 sec. For the current example, the table indicates that the Hamiltonian function method is in fact the fastest when using the master equation solver. This is because the simulation is quite small. In contrast, the Hamiltonian function is over 26x slower than the compiled string version when using the Monte Carlo solver. In this case, the 500 trajectories needed in the simulation highlights the inefficient nature of the Python function calls. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do:; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). In this case, the second call to qutip.mcsolve takes 3 seconds less than the first. Of course our parameters are different, but this also shows how much time one can save by not reorganizing the data, and in the case of the string format, not recompiling the code. If you need to call the solvers many times for different parameters, this savings will obviously start to add",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:15359,avoid,avoid,15359,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['avoid'],['avoid']
Safety,"tates, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:12734,avoid,avoid,12734,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,1,['avoid'],['avoid']
Safety,"tates, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full releas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:15017,avoid,avoid,15017,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,1,['avoid'],['avoid']
Safety,"tem Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Homodyne detection. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{2} -\frac{e_n}{2} C_n; + \frac{e_n^2}{8} \right) \psi \delta t; + \sum_n \left( C_n - \frac{e_n}{2} \right) \psi \delta \omega\]; with. \[ \begin{align}\begin{aligned}:label: jump_rate\\e_n = \left<\psi(t)|C_n + C_n^{+}|\psi(t)\right>\end{aligned}\end{align} \]; Here \(\delta \omega\) is a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html:1202,detect,detection,1202,docs/4.4/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"ter equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Homodyne detection. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-dynamics.html:1565,detect,detection,1565,docs/4.4/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-dynamics.html,1,['detect'],['detection']
Safety,"th psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17948,avoid,avoid,17948,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety,"ticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:109029,predict,predictor-correctorGeneralization,109029,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['predict'],['predictor-correctorGeneralization']
Safety,"tip.qobjevo. Source code for qutip.qobjevo; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """""". def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:1288,safe,safePickle,1288,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(self, sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:10664,safe,safebool,10664,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['safe'],['safebool']
Safety,"to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:10552,safe,safebool,10552,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['safe'],['safebool']
Safety,"tum object (if operator,; no check) and state psi.; Return only the real part if herm.; *Faster after compilation. to_list():; Return the time-dependent quantum object as a list; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = tlist; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. if isinstance(Q_object, list) and len(Q_object) == 2:; if isinstance(Q_object[0], Qobj) and not isinstance(Q_object[1],; (Qobj, list)):; # The format is [Qobj, f/str]; Q_object = [Q_object]. op_type = self._td_format_check_single(Q_object, tlist); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise Exception(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _CubicSplineWrapper(tlist, op[1], args=self.args),; op[1].copy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:13654,safe,safePickle,13654,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:5476,avoid,avoiding,5476,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,2,['avoid'],['avoiding']
Safety,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:8039,avoid,avoiding,8039,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,7,['avoid'],['avoiding']
Safety,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:39795,avoid,avoiding,39795,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['avoid'],['avoiding']
Safety,"uce the adjoint of the coherent states to save an operation; # later when computing dot products, hence the negative imaginary part.; self.grid.imag = -y; self.prefactor = np.exp(-0.5 * (x * x + y * y)).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the Fock states in the range ``first``; to ``last``, excluding the end point. The first two axes are the y-; and x-coordinates of phase space (i.e. Cartesian indexing, like; ``numpy.meshgrid``), and the last runs over the selected range of; Fock-space dimensions.; """"""; ns = np.arange(first, last).reshape(1, 1, -1); # Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.; out = np.empty(self.grid.shape + (ns.size,), dtype=np.complex128); out[:, :, 0] = self._start(ns.flat[0]); for i in range(ns.size - 1):; out[:, :, i+1] = out[:, :, i] * self.grid; out /= np.sqrt(scipy.special.factorial(ns)); return out. [docs]class QFunc:; r""""""; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points ``0.5*g* (xvec + i*yvec)``.; This class has slightly higher first-usage costs than :obj:`.qfunc`, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters; ----------; xvec, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:20214,avoid,avoid,20214,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,2,['avoid'],['avoid']
Safety,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., “French translation of the Work by Original; Author,” or “Screenplay based on original Work by Original Author”). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties.; Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author’s honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author’s honor and reputation, the; Licensor will w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:12115,avoid,avoidance,12115,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['avoid'],['avoidance']
Safety,"vements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:1562,avoid,avoid,1562,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,1,['avoid'],['avoid']
Safety,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:23734,avoid,avoids,23734,docs/4.0.2/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:23734,avoid,avoids,23734,docs/4.2/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:23734,avoid,avoids,23734,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"ython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=""avconv"", codec=""libx264""). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = video.encode(""base64""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html:11973,timeout,timeout,11973,docs/3.1.0/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html,1,['timeout'],['timeout']
Safety,"ython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;ba",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:11379,timeout,timeout,11379,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,3,['timeout'],['timeout']
Safety,"ython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:11377,timeout,timeout,11377,docs/4.3/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html,5,['timeout'],['timeout']
Security," (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Instance of an Optimizer, through which the. Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer. The optimisation can be run through the optimizer.run_optimization. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:; LIN - Linear,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:147865,access,accessed,147865,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['accessed']
Security," 256. Lagoudakis et al., ""Observation of Mollow Triplets with Tunable Interactions in Double Lambda Systems of Individual Hole Spins"", ; Phys. Rev. Lett. 118, 013602 (2017). 255. Pucci et al., ""Quantum effects in the cooperative scattering of light by atomic clouds"", ; Phys. Rev. A 95, 053625 (2017). 254. Gessner et al., ""Resolution-enhanced entanglement detection"", ; Phys. Rev. A 95, 032326 (2017). 253. Nigg et al., ""Superconducting Grid-Bus Surface Code Architecture for Hole-Spin Qubits"", ; Phys. Rev. Lett. 118, 147701 (2017). 252. Lüer et al., ""Lévy Defects in Matrix-Immobilized J Aggregates: Tracing Intra-and Intersegmental Exciton Relaxation"", ; J. Phys. Chem. Lett. 8, 547 (2017). 251. Dive et al., ""In situ upgrade of quantum simulators to universal computers"", ; arXiv:1701.01723. 250. Barnes et al., ""Fast microwave-driven three-qubit gates for cavity-coupled superconducting qubits"", ; Phys. Rev. B 96, 024504 (2017). 249. Hu, ""Spin-based single-photon transistor, dynamic random access memory, diodes, and routers in semiconductors"", ; Phys. Rev. B 94, 245307 (2016). 248. Leung et al., ""Speedup for quantum optimal control from automatic differentiation based on graphics processing units"", ; Phys. Rev. A 95, 042318 (2017). 247. Bruhat et al., ""Strong coupling between an electron in a quantum dot circuit and a photon in a cavity"", ; arXiv:1612.05214. 246. Zanoci et al., ""Entanglement and thermalization in open fermion systems"", ; arXiv:1612.04840. 245. Volokitin et al., ""Computation of the asymptotic states of modulated open quantum systems with a numerically exact realization of the quantum trajectory method"", ; Phys. Rev. E 96, 053313 (2017). 244. Montenegro et al., ""Macroscopic nonclassical-state preparation via postselection"", ; Phys. Rev. A 96, 053851 (2017). 243. Cirio et al., ""Amplified Optomechanical Transduction of Virtual Radiation Pressure"", ; Phys. Rev. Lett. 119, 053601 (2017). 242. Romero et al., ""Quantum autoencoders for efficient compression of quan",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:16025,access,access,16025,users.html,https://qutip.org,https://qutip.org/users.html,1,['access'],['access']
Security," 512 (2016). 207. Fischer et al., ""Dynamical modeling of pulsed two-photon interference"", ; New J. Phys. 18, 113053 (2016).; Notebook1; Notebook2. 206. Seifoory et al., ""The properties of squeezed optical states created in lossy cavities"", ; arXiv:1608.05005. 205. Qin et al., ""Heralded quantum controlled-phase gates with dissipative dynamics in macroscopically distant resonators"", ; Phys. Rev. A 96, 012315 (2017). 204. Cruzeiro et al., ""Interactively Applying the Variational Method to the Dihydrogen Molecule: Exploring Bonding and Antibonding"", ; Journal of Chemical Education (2016). 203. Pleinert et al., ""Quantum signatures of collective behavior of a coherently driven two atom system coupled to a single-mode of the electromagnetic field"", ; arXiv:1608.00137. 202. Wang et al., ""Multiple-output microwave single-photon source using superconducting circuits with longitudinal and transverse couplings"", ; Phys. Rev. A 94, 053858 (2016). 201. Marshall et al., ""Continuous-variable quantum computing on encrypted data"", ; Nat. Comm. 7, 13795 (2016). 200. Dajka et al., ""Leggett–Garg inequalities for a quantum top affected by classical noise"", ; J. Quantum Inf. Process. (2016). 199. Rouxinol et al., ""Measurements of nanoresonator-qubit interactions in a hybrid quantum electromechanical system"", ; Nanotechnology 27, 364003 (2016). 198. Hocker et al., ""PEET: a Matlab tool for estimating physical gate errors in quantum information processing systems"", ; Quantum Information Processing (2016). 197. Daskin, ""Quantum eigenvalue estimation for irreducible non-negative matrices"", ; Int. J. Quantum Inform. 14, 1650005 (2016). 196. Dlaska et al., ""Robust quantum state transfer via topologically protected edge channels in dipolar arrays"", ; Quantum Sci. Technol. 2, 015001 (2017). 195. Juliusson et al., ""Manipulating Fock states of a harmonic oscillator while preserving its linearity"", ; Phys. Rev. A 94, 063861 (2016). 194. Banchi et al., ""Quantum gate learning in qubit networks: Toffoli g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:22561,encrypt,encrypted,22561,users.html,https://qutip.org,https://qutip.org/users.html,1,['encrypt'],['encrypted']
Security," =; [[0.]; [0.]; [0.]; [1.]; [0.]]. >>> coherent(5,0.5-0.5j); Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.7788017 +0.j ]; [ 0.38939142-0.38939142j]; [ 0. -0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. >>> destroy(4); Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. ]; [0. 0. 1.41421356 0. ]; [0. 0. 0. 1.73205081]; [0. 0. 0. 0. ]]. >>> sigmaz(); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. >>> jmat(5/2.0,'+'); Quantum object: dims = [[6], [6]], shape = (6, 6), type = oper, isherm = False; Qobj data =; [[0. 2.23606798 0. 0. 0. 0. ]; [0. 0. 2.82842712 0. 0. 0. ]; [0. 0. 0. 3. 0. 0. ]; [0. 0. 0. 0. 2.82842712 0. ]; [0. 0. 0. 0. 0. 2.23606798]; [0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; >>> q = destroy(4). >>> q.dims; [[4], [4]]. >>> q.shape; (4, 4). In general, the attributes (properties) of a Qobj object (or any Python object) can be retrieved using the Q.attribute notation.; In addition to the those shown with the print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:7366,access,accessed,7366,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,2,['access'],['accessed']
Security," CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:2812,access,accessible,2812,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['access'],['accessible']
Security," CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2841,access,accessible,2841,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security," Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulseoptim. Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:1122,access,accessible,1122,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security," Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.3. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-overview.html:1737,access,accessible,1737,docs/4.3/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-overview.html,1,['access'],['accessible']
Security," Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:19523,expose,exposed,19523,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,1,['expose'],['exposed']
Security," Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-states.html:19581,expose,exposed,19581,docs/4.7/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html,1,['expose'],['exposed']
Security," The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first paramete",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:19821,access,access,19821,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['access'],['access']
Security," The figure canvas on which the plot will be drawn.; ax (a matplotlib axis instance) – The axis context in which the plot will be drawn.; figsize ((width, height)) – The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest.; More information:. J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:; ket (Qobj) – Pure state for plotting.; theme ('light' (default) or 'dark') – Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb.; how ('pairs' (default), 'pairs_skewed' or 'before_after') – Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration (int (default 1)) – Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others.; legend_iteration (int (default 0) or 'grid_iteration' or 'all') – Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration.; Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig (a matplotlib figure instance) – The figure canvas on which the plot will be drawn.; ax (a matplotlib axis instance) – T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:124123,access,access,124123,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['access']
Security," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:5812,access,access,5812,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['access'],['access']
Security," basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:4713,access,access,4713,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['access'],['access']
Security," deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:2633,hash,hash,2633,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,1,['hash'],['hash']
Security," figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis contex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:109645,access,access,109645,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['access']
Security," for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:181896,access,accessed,181896,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,3,['access'],['accessed']
Security," from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8445,hash,hash,8445,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['hash'],['hash']
Security," in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:48497,access,accessible,48497,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security," in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take preced",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:47569,access,accessible,47569,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security," in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWAL",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:185403,access,accessible,185403,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security," in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:160434,access,accessible,160434,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security," in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:177254,access,accessible,177254,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security," in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dyn",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:152181,access,accessible,152181,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security," it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray([total_ampl],; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/eseries.html:10322,access,accessing,10322,docs/4.5/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/eseries.html,1,['access'],['accessing']
Security," modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:183630,access,accessed,183630,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessed']
Security," operators for which to evaluate; expectation values. learningtimes : array_like; list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:156942,access,accessible,156942,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security," or list of operators for which to evaluate; expectation values. learningtimes : array_like. list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like. optional list of precomputed tensors \(T_k\). kwargs : dictionary. Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output: qutip.solver.Result. An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:142155,access,accessible,142155,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security," the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector.¶. For the destruction operator above:; In [18]: q.type; Out[18]: 'oper'. In [19]: q.isherm; Out[19]: False. In [20]: q.data; Out[20]: ; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [21]: q = destroy(4). In [22]: x = sigmax(). In [23]: q + 5; Out[23]: ; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. In [24]: x * x; Out[24]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. In [25]: q ** 3; Out[25]: ; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. In [26]: x / np.sqrt(2); Out[26]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible sha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-basics.html:8705,access,access,8705,docs/4.5/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-basics.html,1,['access'],['access']
Security," to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:9184,hash,hashes,9184,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['hash'],['hashes']
Security," v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time']",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:25644,access,accessible,25644,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['access'],['accessible']
Security," value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, gu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:219726,access,accessible,219726,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['access'],['accessible']
Security," ‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b=Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-bloch.html:12817,access,accessed,12817,docs/3.0.0/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html,2,['access'],['accessed']
Security,", which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : Optimizer. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:168831,access,accessed,168831,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessed']
Security,"- pe / 2., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().full(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:5055,expose,exposed,5055,docs/4.6/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html,2,['expose'],['exposed']
Security,"-Phonon Interaction through Mode Field Coupling in Hybrid Optomechanical Systems"", ; Phys. Rev. Lett. 118, 133603 (2017). 224. Jonsson et al., ""Efficient determination of the Markovian time-evolution towards a steady-state of a complex open quantum system"", ; Comput. Phys. Commun. 220, 81 (2017). 223. Lahoz-Beltra, ""Quantum Genetic Algorithms for Computer Scientists"", ; Computers 5, 24 (2016). 222. Davis-Tilley et al., ""Synchronization of micromasers"", ; Phys. Rev. A 94, 063819 (2016). 221. Weinberg et al., ""QuSpin: a Python package for dynamics and exact diagonalisation of quantum many body systems part I: spin chains"", ; SciPost Phys. 2, 003 (2017). 220. Dory et al., ""Tuning the photon statistics of a strongly coupled nanophotonic system"", ; Phys. Rev. A 95, 023804 (2017). 219. Lachance-Quirion et al., ""Resolving quanta of collective spin excitations in a millimeter-sized ferromagnet"", ; Science Advances 3, (2017). 218. Doyeux et al., ""Excitation injector in an atomic chain: Long-range transport and efficiency amplification"", ; Phys. Rev. A 95, 012138 (2017). 217. Roulet et al., ""Autonomous Rotor Heat Engine"", ; Phys. Rev. E 95, 062131 (2017). 216. Nigg et al., ""Robust quantum optimizer with full connectivity"", ; Science Advances 3, 1602273 (2017). 215. Puri et al., ""Quantum annealing with all-to-all connected nonlinear oscillators"", ; Nat. Commun. 8, 15785 (2017).>. 214. Shi et al., ""Model reduction of cavity nonlinear optics for photonic logic: a quasi-principal components approach"", ; J. Phys. D: Appl. Phys. 49, 465501 (2016). 213. McNally et al., ""Performance of 1D quantum cellular automata in the presence of error"", ; AIP Advances 6, 095115 (2016). 212. Zhong et al., ""Towards quantum entanglement of micromirrors via a two-level atom and radiation pressure"", ; arXiv:1609.00590. 211. Roth et al., ""Synchronization of active atomic clocks via quantum and classical channels"", ; Phys. Rev. A 94, 043841 (2016). 210. Jarlov et al., ""Effect of Pure Dephasing and Phono",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:20177,inject,injector,20177,users.html,https://qutip.org,https://qutip.org/users.html,1,['inject'],['injector']
Security,"-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-overview.html:2470,access,accessible,2470,docs/3.0.1/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-overview.html,2,['access'],['accessible']
Security,". Wood, J. Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/biblio.html:2678,access,access,2678,docs/4.6/biblio.html,https://qutip.org,https://qutip.org/docs/4.6/biblio.html,1,['access'],['access']
Security,"., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html:5043,expose,exposed,5043,docs/4.5/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html,1,['expose'],['exposed']
Security,"., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html:5037,expose,exposed,5037,docs/4.1/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html,5,['expose'],['exposed']
Security,"., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def super_to_choi(q_oper):; # TODO: deprecate and make private in favor of to_choi,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a superoperator to a Choi matrix; TODO: Sanitiz",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html:6115,expose,exposed,6115,docs/3.1.0/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html,1,['expose'],['exposed']
Security,"0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25747,access,accessed,25747,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"2], [2]], [1]], shape = [4, 1], type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [103]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-states.html:20575,expose,exposed,20575,docs/3.1.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html,1,['expose'],['exposed']
Security,"2], [2]], [1]], shape = [4, 1], type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [104]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-states.html:20355,expose,exposed,20355,docs/3.0.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html,2,['expose'],['exposed']
Security,"CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38167,access,accessible,38167,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Instance of an Optimizer, through which the. Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer. The optimisation can be run through the optimizer.run_optimization. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:147762,access,accessed,147762,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['accessed']
Security,"Out[11]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.7788017 +0.j ]; [ 0.38939142-0.38939142j]; [ 0. -0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. In [12]: destroy(4); Out[12]: ; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. ]; [0. 0. 1.41421356 0. ]; [0. 0. 0. 1.73205081]; [0. 0. 0. 0. ]]. In [13]: sigmaz(); Out[13]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [14]: jmat(5/2.0,'+'); Out[14]: ; Quantum object: dims = [[6], [6]], shape = (6, 6), type = oper, isherm = False; Qobj data =; [[0. 2.23606798 0. 0. 0. 0. ]; [0. 0. 2.82842712 0. 0. 0. ]; [0. 0. 0. 3. 0. 0. ]; [0. 0. 0. 0. 2.82842712 0. ]; [0. 0. 0. 0. 0. 2.23606798]; [0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; In [15]: q = destroy(4). In [16]: q.dims; Out[16]: [[4], [4]]. In [17]: q.shape; Out[17]: (4, 4). In general, the attributes (properties) of a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector.¶. For the destruction operator above:; In [18]: q.type; Out[18]: 'oper'. In [19]: q.isherm; Out[19]: False. In [20]: q.data; Out[20]: ; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-basics.html:7416,access,accessed,7416,docs/4.5/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-basics.html,1,['access'],['accessed']
Security,"Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP cir",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:1112,access,accessible,1112,docs/4.6/development/ideas/qutip-interactive.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html,1,['access'],['accessible']
Security,"The maximum depth for the hierarchy is {self.max_depth} but""; f"" {n} levels of excitation filters were given.""; ); if level is None:; if not filters:; # fast path for when there are no excitation filters; return self.labels[:]; else:; if not filters:; # fast path for when there are no excitation filters; return [label for label in self.labels if sum(label) == level]; if level != n:; raise ValueError(; f""The level parameter is {level} but {n} levels of""; "" excitation filters were given.""; ). filtered_dims = [1] * len(self.exponents); for lvl in range(n):; level_filters = [; (attr, f[lvl]) for attr, f in filters; if f[lvl] is not None; ]; for j, exp in enumerate(self.exponents):; if any(getattr(exp, attr) != f for attr, f in level_filters):; continue; filtered_dims[j] += 1; filtered_dims[j] = min(self.dims[j], filtered_dims[j]). return [; label for label in state_number_enumerate(filtered_dims, n); if sum(label) == n; ]. [docs]class HierarchyADOsState:; """"""; Provides convenient access to the full hierarchy ADO state at a particular; point in time, ``t``. Parameters; ----------; rho : :class:`~qutip.Qobj`; The current state of the system (i.e. the 0th component of the; hierarchy).; ados : :class:`HierarchyADOs`; The description of the hierarchy.; ado_state : numpy.array; The full state of the hierarchy. Attributes; ----------; rho : Qobj; The system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly. See :class:`HierarchyADOs` for a full list of the available attributes; and methods.; """"""; def __init__(self, rho, ados, ado_state):; self.rho = rho; self._ado_state = ado_state; self._ados = ados. def __getattr__(self, name):; return getattr(self._ados, name). [docs] def extract(self, idx_or_label):; """"""; Extract a Qobj representing specified ADO from a full representation of; the ADO state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:9063,access,access,9063,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,1,['access'],['access']
Security,"], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [103]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-states.html:20370,expose,exposed,20370,docs/4.2/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-states.html,3,['expose'],['exposed']
Security,"_key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/eseries.html:10436,access,accessing,10436,docs/4.3/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:181999,access,accessed,181999,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,3,['access'],['accessed']
Security,"alculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/biblio.html:3250,access,access,3250,docs/4.3/biblio.html,https://qutip.org,https://qutip.org/docs/4.3/biblio.html,1,['access'],['access']
Security,"antum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-overview.html:1775,access,accessible,1775,docs/4.6/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-overview.html,1,['access'],['accessible']
Security,"any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:58192,access,accessible,58192,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58274,access,accessible,58274,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['access'],['accessible']
Security,"any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; ra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:58370,access,accessible,58370,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"apses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~Qobj` or :class:`~QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:11180,access,access,11180,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,1,['access'],['access']
Security,"ation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _pa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:58108,access,accessed,58108,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"atter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.4. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-overview.html:1733,access,accessible,1733,docs/4.4/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-overview.html,1,['access'],['accessible']
Security,"ave; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~qutip.Qobj` or :class:`~qutip.QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~qutip.Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:9509,access,access,9509,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,1,['access'],['access']
Security,"ay'. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; ['r', 'g', 'b', 'y']. b.point_mode; Type of point markers to draw; 'sphere'. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; '#808080'. b.size; Sets size of figure window; [500, 500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; ['r', 'g', 'b', 'y']. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45, 65]. b.xlabel; Labels for x-axis; ['|x>', ''] +x and -x. b.xlpos; Position of x-axis labels; [1.07, -1.07]. b.ylabel; Labels for y-axis; ['$y$', ''] +y and -y. b.ylpos; Position of y-axis labels; [1.07, -1.07]. b.zlabel; Labels for z-axis; ['|0>', '|1>'] +z and -z. b.zlpos; Position of z-axis labels; [1.07, -1.07]. These properties can also be accessed via the print command:; >>> b = qutip.Bloch(). >>> print(b) ; Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-bloch.html:11064,access,accessed,11064,docs/4.6/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html,2,['access'],['accessed']
Security,"be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iterationint (default 0) or ‘grid_iteration’ or ‘all’Show labels for first 2*legend_iteration particles. Option; ‘grid_iteration’ sets the same number of particles as for; grid_iteration. Option ‘all’ makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Notes; See also [1].; References. 1; J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, Qubism: self-similar visualization of many-body; wavefunctions, New J. Phys. 14 053028, arXiv:1112.3560; (2012), open access. plot_schmidt(ket, splitting=None, labels_iteration=(3, 2), theme='light', fig=None, ax=None, figsize=(6, 6))[source]¶; Plotting scheme related to Schmidt decomposition.; Converts a state into a matrix (A_ij -> A_i^j),; where rows are first particles and columns - last.; See also: plot_qubism with how=’before_after’ for a similar plot. Parameters. ketQobjPure state for plotting. splittingintPlot for a number of first particles versus the rest.; If not given, it is (number of particles + 1) // 2. theme‘light’ (default) or ‘dark’Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. labels_iterationint or pair of ints (default (3,2))Number of particles to be shown as tick labels,; for first (vertical) and last (horizontal) particles, respectively. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:172550,access,access,172550,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['access'],['access']
Security,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html:3173,access,access,3173,docs/4.2/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html,7,['access'],['access']
Security,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:2851,access,access,2851,docs/4.6/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html,2,['access'],['access']
Security,"cle. style : 'ket' (default), 'bra' or 'bare'; Style of LaTeX (i.e. |01> or <01| or 01, respectively). Returns; -------; latex : str; LaTeX output. """"""; if style == 'ket':; latex = ""$\\left|{0}\\right\\rangle$""; elif style == 'bra':; latex = ""$\\left\\langle{0}\\right|$""; elif style == 'bare':; latex = ""${0}$""; else:; raise Exception(""No such style.""); return latex.format("""".join(map(str, seq))). [docs]def plot_qubism(ket, theme='light', how='pairs',; grid_iteration=1, legend_iteration=0,; fig=None, ax=None, figsize=(6, 6)):; """"""; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; ""Qubism: self-similar visualization of many-body wavefunctions"",; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters; ----------; ket : Qobj; Pure state for plotting. theme : 'light' (default) or 'dark'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : 'pairs' (default), 'pairs_skewed' or 'before_after'; Type of Qubism plotting.; Options:; 'pairs' - typical coordinates,; 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1); Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or 'grid_iteration' or 'all'; Show labels for first 2*legend_iteration particles.; Option 'grid_iteration' sets the same number of particles; as for grid_iteration.; Option 'all' makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:33758,access,access,33758,docs/3.1.0/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html,1,['access'],['access']
Security,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:186973,access,accessible,186973,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:162168,access,accessible,162168,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:178887,access,accessible,178887,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:153973,access,accessible,153973,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"d_iteration' or 'all'; Show labels for first ``2*legend_iteration`` particles. Option; 'grid_iteration' sets the same number of particles as for; grid_iteration. Option 'all' makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Notes; -----; See also [1]_. References; ----------; .. [1] J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, *Qubism: self-similar visualization of many-body; wavefunctions*, `New J. Phys. 14 053028; <https://dx.doi.org/10.1088/1367-2630/14/5/053028>`_, arXiv:1112.3560; (2012), open access.; """""". if not isket(ket):; raise Exception(""Qubism works only for pure states, i.e. kets.""); # add for dm? (perhaps a separate function, plot_qubism_dm). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]; n = len(dim_list). # for odd number of particles - pixels are rectangular; if n % 2 == 1:; ket = tensor(ket, Qobj([1] * dim_list[-1])); dim_list = ket.dims[0]; n += 1. ketdata = ket.full(). if how == 'pairs':; dim_list_y = dim_list[::2]; dim_list_x = dim_list[1::2]; elif how == 'pairs_skewed':; dim_list_y = dim_list[::2]; dim_list_x = dim_list[1::2]; if dim_list_x != dim_list_y:; raise Exception(""For 'pairs_skewed' pairs "" +; ""of dimensions need to be the same.""); elif how == 'before_after':; dim_list_y = list(reversed(dim_list[:(n // 2)])); dim_list_x = dim_list[(n // 2):]; else:; raise Exception(""No such 'how'.""). size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). qub = np.zeros([size_x, size_y], dtype=complex); for i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:42916,access,access,42916,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,1,['access'],['access']
Security,"dd it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray([total_ampl],; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/eseries.html:10309,access,accessing,10309,docs/4.4/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"dded; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:58768,access,accessible,58768,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"dded; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:183436,access,accessible,183436,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security,"derneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:16804,access,access,16804,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['access'],['access']
Security,"do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:3898,access,access,3898,docs/4.6/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html,2,['access'],['access']
Security,"e print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); -----------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:8602,access,access,8602,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,2,['access'],['access']
Security,"e(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeEr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25459,access,accessible,25459,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"e. label) match the given filters or level. idx(label)[source]¶; Return the index of the ADO label within the list of labels,; i.e. within self.labels. Parameters. labeltupleThe label to look up. Returns. intThe index of the label within the list of ADO labels. next(label, k)[source]¶; Return the ADO label with one more excitation in the k’th exponent; dimension or None if adding the excitation would exceed the; dimension or maximum depth of the hierarchy. Parameters. labeltupleThe ADO label to add an excitation to. kintThe exponent to add the excitation to. Returns. tuple or NoneThe next label. prev(label, k)[source]¶; Return the ADO label with one fewer excitation in the k’th; exponent dimension or None if the label has no exciations in the; k’th exponent. Parameters. labeltupleThe ADO label to remove the excitation from. kintThe exponent to remove the excitation from. Returns. tuple or NoneThe previous label. class HierarchyADOsState(rho, ados, ado_state)[source]¶; Provides convenient access to the full hierarchy ADO state at a particular; point in time, t. Parameters. rhoQobjThe current state of the system (i.e. the 0th component of the; hierarchy). adosHierarchyADOsThe description of the hierarchy. ado_statenumpy.arrayThe full state of the hierarchy. Attributes. rhoQobjThe system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly.; See :class:`HierarchyADOs` for a full list of the available attributes; and methods. extract(idx_or_label)[source]¶; Extract a Qobj representing specified ADO from a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:67292,access,access,67292,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['access'],['access']
Security,"e. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:183733,access,accessed,183733,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessed']
Security,"e. style : 'ket' (default), 'bra' or 'bare'; Style of LaTeX (i.e. |01> or <01| or 01, respectively). Returns; -------; latex : str; LaTeX output. """"""; if style == 'ket':; latex = ""$\\left|{0}\\right\\rangle$""; elif style == 'bra':; latex = ""$\\left\\langle{0}\\right|$""; elif style == 'bare':; latex = ""${0}$""; else:; raise Exception(""No such style.""); return latex.format("""".join(map(str, seq))). [docs]def plot_qubism(ket, theme='light', how='pairs',; grid_iteration=1, legend_iteration=0,; fig=None, ax=None, figsize=(6, 6)):; """"""; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; ; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; ""Qubism: self-similar visualization of many-body wavefunctions"",; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters; ----------; ket : Qobj; Pure state for plotting. theme : 'light' (default) or 'dark'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : 'pairs' (default), 'pairs_skewed' or 'before_after'; Type of Qubism plotting.; Options:; ; 'pairs' - typical coordinates,; 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1); Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or 'grid_iteration' or 'all'; Show labels for first 2*legend_iteration particles.; Option 'grid_iteration' sets the same number of particles; as for grid_iteration.; Option 'all' makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/visualization.html:31932,access,access,31932,docs/4.1/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/visualization.html,6,['access'],['access']
Security,"e_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/eseries.html:10363,access,accessing,10363,docs/4.6/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"ed for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:220017,access,accessed,220017,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['access'],['accessed']
Security,"ed in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr'",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:14209,access,accessible,14209,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"ed in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:12724,access,accessible,12724,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"ed; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:57906,access,accessible,57906,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"ededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:89408,access,access,89408,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,4,['access'],['access']
Security,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-overview.html:2408,access,accessible,2408,docs/3.0.0/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html,2,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:38032,access,accessible,38032,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,10,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:37665,access,accessible,37665,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' para",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:13968,access,accessible,13968,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:13869,access,accessible,13869,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # check parameters here, as names are different than in; # create_pulse_optimizer, so TypeErrors would be confusing. if not isinstance(H_d, Qobj):; if not isinstance(H_d, (list, tuple)):; raise TypeError(""H_d should be a Qobj or a list of Qobj""); else:; for H in H_d:; if not isinstance(H, Qobj):; raise TypeError(""H_d should be a Qobj or a list of Qobj""). if not isinstance(H_c, (list, tuple)):; raise TypeError(""H_c should be a list of Qobj""); else:; for ctrl in H_c:; if not isinstance(ctrl, Qobj):; raise TypeError(""H_c should be a list of Qobj""). if not isinstance(U_0, Qobj):; raise TypeError(""U_0 must be a Qobj""). if not isinstance(U_targ, Qobj):; raise TypeError(""U_targ must be a Qobj""); ; # The deprecation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:26651,access,accessible,26651,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'acc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:26843,access,accessible,26843,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser; ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:26872,access,accessible,26872,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['access'],['accessible']
Security,"erty; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [14]: q.type; Out[14]: 'oper'. In [15]: q.isherm; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-basics.html:10126,access,access,10126,docs/4.2/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-basics.html,4,['access'],['access']
Security,"fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8388,hash,hash,8388,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['hash'],['hash']
Security,"figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest.; More information:. J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters. ketQobjPure state for plotting. theme‘light’ (default) or ‘dark’Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iterationint (default 1)Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iterationint (default 0) or ‘grid_iteration’ or ‘all’Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:137086,access,access,137086,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['access'],['access']
Security,"figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest.; More information:. J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis contex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:122913,access,access,122913,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['access']
Security,"generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:10629,access,accessible,10629,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # check parameters here, as names are different than in; # create_pulse_optimizer, so TypeErrors would be confusing. if not isinstance(H_d, Qobj):; raise TypeError(""H_d must be a Qobj""). if not isinstance(H_c, (list, tuple)):; raise TypeError(""H_c should be a list of Qobj""); else:; for ctrl in H_c:; if not isinstance(ctrl, Qobj):; raise TypeError(""H_c should be a list of Qobj""). if not isinstance(U_0, Qobj):; raise TypeError(""U_0 must be a Qobj""). if not isinstance(U_targ, Qobj):; raise TypeError(""U_targ must be a Qobj""). return optimize_pulse(drift=H_d, ctrls=H_c, initial=U_0, target=U_targ,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=mi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:18369,access,accessible,18369,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"gure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest.; More information:. J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:; ket : Qobj; Pure state for plotting. theme : ‘light’ (default) or ‘dark’; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’; Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1); Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’; Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis cont",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:137569,access,access,137569,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['access']
Security,"heir filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:18820,checksum,checksum,18820,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['checksum'],['checksum']
Security,"hon. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Code of conduct; As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.; We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.; Examples of unacceptable behavior by participants include:. The use of sexualized language or imagery; Personal attacks; Trolling or insulting/derogatory comments; Public or private harassment; Publishing other’s private information, such as physical or electronic addresses, without explicit permission; Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.; This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.; Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers.; This Code of Conduct is adapted from the Contributor Covenant, version",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/cofc.html:995,attack,attacks,995,cofc.html,https://qutip.org,https://qutip.org/cofc.html,1,['attack'],['attacks']
Security,"id_iteration' or 'all'; Show labels for first ``2*legend_iteration`` particles. Option; 'grid_iteration' sets the same number of particles as for; grid_iteration. Option 'all' makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Notes; -----; See also [1]_. References; ----------; .. [1] J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, *Qubism: self-similar visualization of many-body; wavefunctions*, `New J. Phys. 14 053028; <http://dx.doi.org/10.1088/1367-2630/14/5/053028>`_, arXiv:1112.3560; (2012), open access.; """""". if not isket(ket):; raise Exception(""Qubism works only for pure states, i.e. kets.""); # add for dm? (perhaps a separate function, plot_qubism_dm). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]; n = len(dim_list). # for odd number of particles - pixels are rectangular; if n % 2 == 1:; ket = tensor(ket, Qobj([1] * dim_list[-1])); dim_list = ket.dims[0]; n += 1. ketdata = ket.full(). if how == 'pairs':; dim_list_y = dim_list[::2]; dim_list_x = dim_list[1::2]; elif how == 'pairs_skewed':; dim_list_y = dim_list[::2]; dim_list_x = dim_list[1::2]; if dim_list_x != dim_list_y:; raise Exception(""For 'pairs_skewed' pairs "" +; ""of dimensions need to be the same.""); elif how == 'before_after':; dim_list_y = list(reversed(dim_list[:(n // 2)])); dim_list_x = dim_list[(n // 2):]; else:; raise Exception(""No such 'how'.""). size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). qub = np.zeros([size_x, size_y], dtype=complex); for i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/visualization.html:37109,access,access,37109,docs/4.6/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html,1,['access'],['access']
Security,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-overview.html:1834,access,accessible,1834,docs/4.7/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html,1,['access'],['accessible']
Security,"idelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())). if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed. if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None. if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False. if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html:8736,access,access,8736,docs/4.4/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html,1,['access'],['access']
Security,"iew of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-overview.html:2509,access,accessible,2509,docs/3.1.0/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-overview.html,2,['access'],['accessible']
Security,"ing : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25644,access,accessed,25644,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"ing modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[sour",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:170506,access,accessed,170506,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessed']
Security,"interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-visualization.html:13401,access,access,13401,docs/3.0.0/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html,3,['access'],['access']
Security,"ion; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP cir",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1155,access,accessible,1155,docs/4.7/development/ideas/qutip-interactive.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html,1,['access'],['accessible']
Security,"ious version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:19257,checksum,checksum,19257,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['checksum'],['checksum']
Security,"is purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combine",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:170609,access,accessed,170609,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessed']
Security,"is value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, gue",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:181708,access,accessible,181708,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,3,['access'],['accessible']
Security,"it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a ver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8663,hash,hash,8663,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['hash'],['hash']
Security,"ity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:8758,access,access,8758,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,7,['access'],['access']
Security,"key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/eseries.html:10436,access,accessing,10436,docs/4.0.2/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/eseries.html:10436,access,accessing,10436,docs/4.2/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/eseries.html:10436,access,accessing,10436,docs/4.1/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"lapsed during the optimisation. wall_time_limit_exceeded; (boolean) True if the wall time limit was reached. time; (array[num_tslots+1] of float) Time are the start of each timeslot with the final value being the total evolution time. initial_amps; (array[num_tslots, n_ctrls]) The amplitudes at the start of the optimisation. final_amps; (array[num_tslots, n_ctrls]) The amplitudes at the end of the optimisation. evo_full_final; (Qobj) The evolution operator from t=0 to t=T based on the final amps. stats; (Stats) Object contaning the stats for the run (if any collected). optimizer; (Optimizer) Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However; Attributes. num_ctrls. dyn_gen. prop. prop_grad. fwd_evo. onwd_evo. onto_evo. dumping. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:72650,access,access,72650,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['access'],['access']
Security,"lculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/biblio.html:3250,access,access,3250,docs/4.2/biblio.html,https://qutip.org,https://qutip.org/docs/4.2/biblio.html,1,['access'],['access']
Security,"legend(loc=0, fontsize=12). The plot above is not very exciting. What we would really like to see in; this case are the currents between the system and the two baths. We will plot; these in the next section using the auxiliary density operators (ADOs); returned by the solver. Determining currents¶; The currents between the system and a fermionic bath may be calculated from the; first level auxiliary density operators (ADOs) associated with the exponents; of that bath.; The contribution to the current into a given bath from each exponent in that; bath is:. \[\mathrm{Contribution from Exponent} = \pm i \mathrm{Tr}(Q^\pm \cdot A)\]; where the \(\pm\) sign is the sign of the exponent (see the; description later in Padé expansion coefficients) and; \(Q^\pm\) is \(Q\) for + exponents and \(Q^{\dagger}\) for; - exponents.; The first-level exponents for the left bath are retrieved by calling; .filter(tags=[""L""]) on ado_state which is an instance of; HierarchyADOsState and also provides access to; the methods of HierarchyADOs which describes the; structure of the hierarchy for a given problem.; Here the tag “L” matches the tag passed when constructing bath_L earlier; in this example.; Similarly, we may calculate the current to the right bath from the exponents; tagged with “R”.; def exp_current(aux, exp):; """""" Calculate the current for a single exponent. """"""; sign = 1 if exp.type == exp.types[""+""] else -1; op = exp.Q if exp.type == exp.types[""+""] else exp.Q.dag(); return 1j * sign * (op * aux).tr(). def heom_current(tag, ado_state):; """""" Calculate the current between the system and the given bath. """"""; level_1_ados = [; (ado_state.extract(label), ado_state.exps(label)[0]); for label in ado_state.filter(tags=[tag]); ]; return np.real(sum(exp_current(aux, exp) for aux, exp in level_1_ados)). heom_left_current = lambda t, ado_state: heom_current(""L"", ado_state); heom_right_current = lambda t, ado_state: heom_current(""R"", ado_state). Once we have defined functions for retrieving",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/fermionic.html:6956,access,access,6956,docs/4.7/guide/heom/fermionic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html,1,['access'],['access']
Security,"lf.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._phase_application = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = Non",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:15388,access,accessors,15388,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,3,['access'],['accessors']
Security,"m object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.77880170+0.j ]; [ 0.38939142-0.38939142j]; [ 0.00000000-0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. In [11]: destroy(4); Out[11]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. ]; [ 0. 0. 1.41421356 0. ]; [ 0. 0. 0. 1.73205081]; [ 0. 0. 0. 0. ]]. In [12]: sigmaz(); Out[12]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [13]: jmat(5/2.0,'+'); Out[13]: ; Quantum object: dims = [[6], [6]], shape = [6, 6], type = oper, isherm = False; Qobj data =; [[ 0. 2.23606798 0. 0. 0. 0. ]; [ 0. 0. 2.82842712 0. 0. 0. ]; [ 0. 0. 0. 3. 0. 0. ]; [ 0. 0. 0. 0. 2.82842712 0. ]; [ 0. 0. 0. 0. 0. 2.23606798]; [ 0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; In [14]: q = destroy(4). In [15]: q.dims; Out[15]: [[4], [4]]. In [16]: q.shape; Out[16]: [4, 4]. In general, the attributes (properties) of a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-basics.html:7393,access,accessed,7393,docs/3.0.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html,3,['access'],['accessed']
Security,"mes of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:9428,access,access,9428,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,1,['access'],['access']
Security,"mes of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :cl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:7739,access,access,7739,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,1,['access'],['access']
Security,"mit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps. stats : Stats; Object contaning the stats for the run (if any collected). optimizer : Optimizer; Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:83648,access,access,83648,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['access'],['access']
Security,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:200208,access,accessible,200208,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:175227,access,accessible,175227,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:192055,access,accessible,192055,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:166970,access,accessible,166970,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/biblio.html:2703,access,access,2703,docs/4.7/biblio.html,https://qutip.org,https://qutip.org/docs/4.7/biblio.html,1,['access'],['access']
Security,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/biblio.html:3229,access,access,3229,docs/4.5/biblio.html,https://qutip.org,https://qutip.org/docs/4.5/biblio.html,1,['access'],['access']
Security,"n CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils` in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:27265,access,accessible,27265,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"n CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils` in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:25969,access,accessible,25969,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"n, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:58395,access,accessed,58395,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"n, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58477,access,accessed,58477,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['access'],['accessed']
Security,"n, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:58573,access,accessed,58573,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['access'],['accessed']
Security,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:3138,access,accessible,3138,docs/3.0.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html,3,['access'],['accessible']
Security,"ng_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:59073,access,accessed,59073,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"nique_rates.keys():; if abs(self.rates[r_idx] - unique_rates[ur_key]) < rate_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/eseries.html:8634,access,accessing,8634,docs/4.7/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"nsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:155819,access,accessible,155819,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,3,['access'],['accessible']
Security,"nts); for lvl in range(n):; level_filters = [; (attr, f[lvl]) for attr, f in filters; if f[lvl] is not None; ]; for j, exp in enumerate(self.exponents):; if any(getattr(exp, attr) != f for attr, f in level_filters):; continue; filtered_dims[j] += 1; filtered_dims[j] = min(self.dims[j], filtered_dims[j]). return [; label for label in state_number_enumerate(filtered_dims, n); if sum(label) == n; ]. [docs]class HierarchyADOsState:; """"""; Provides convenient access to the full hierarchy ADO state at a particular; point in time, ``t``. Parameters; ----------; rho : :class:`~qutip.Qobj`; The current state of the system (i.e. the 0th component of the; hierarchy).; ados : :class:`HierarchyADOs`; The description of the hierarchy.; ado_state : numpy.array; The full state of the hierarchy. Attributes; ----------; rho : Qobj; The system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly. See :class:`HierarchyADOs` for a full list of the available attributes; and methods.; """"""; def __init__(self, rho, ados, ado_state):; self.rho = rho; self._ado_state = ado_state; self._ados = ados. def __getattr__(self, name):; return getattr(self._ados, name). [docs] def extract(self, idx_or_label):; """"""; Extract a Qobj representing specified ADO from a full representation of; the ADO states. Parameters; ----------; idx : int or label; The index of the ADO to extract. If an ADO label, e.g.; ``(0, 1, 0, ...)`` is supplied instead, then the ADO; is extracted by label instead. Returns; -------; Qobj; A :obj:`~qutip.Qobj` representing the state of the specified ADO.; """"""; if isinstance(idx_or_label, int):; idx = idx_or_label; else:; idx = self._ados.idx(idx_or_label); return Qobj(self._ado_state[idx, :].T, dims=self.rho.dims). [docs]class HEOMSolver:; """"""; HEOM solver that supports multiple baths. The baths must be al",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:9605,access,access,9605,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,1,['access'],['access']
Security,"ny initial / guess pulses generated. ramping_pulse_type : string. Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : Optimizer. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:168639,access,accessible,168639,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security,"o methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:3520,access,access,3520,docs/3.0.0/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html,2,['access'],['access']
Security,"o not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:4566,access,access,4566,docs/3.0.0/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html,2,['access'],['access']
Security,"o not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html:4219,access,access,4219,docs/4.2/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html,7,['access'],['access']
Security,"of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:11017,access,access,11017,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,1,['access'],['access']
Security,"om the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_res",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:4387,access,accessed,4387,docs/4.6/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html,2,['access'],['accessed']
Security,"on, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4x4 sparse matrix of type '<type 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / np.sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of inco",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-basics.html:8791,access,access,8791,docs/3.1.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html,1,['access'],['access']
Security,"on, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4x4 sparse matrix of type '<type 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-basics.html:8679,access,access,8679,docs/3.0.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html,2,['access'],['access']
Security,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:224052,access,accessible,224052,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['access'],['accessible']
Security,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:232530,access,accessible,232530,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['access'],['accessible']
Security,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:236167,access,accessible,236167,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['access'],['accessible']
Security,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:244648,access,accessible,244648,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['access'],['accessible']
Security,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:216080,access,accessible,216080,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['access'],['accessible']
Security,"operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:21421,access,access,21421,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['access'],['access']
Security,"or a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a contro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:219914,access,accessed,219914,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['access'],['accessed']
Security,"ors for which to evaluate; expectation values.; learningtimes (array_like) – list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:144004,access,accessible,144004,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"ose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : Optimizer. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:168934,access,accessed,168934,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessed']
Security,"ould be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5889,access,access,5889,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,6,['access'],['access']
Security,"ow to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:2136,hash,hash,2136,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,1,['hash'],['hash']
Security,"pulse_params : dict; Parameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:58211,access,accessed,58211,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:58498,access,accessed,58498,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58580,access,accessed,58580,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['access'],['accessed']
Security,"pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:58676,access,accessed,58676,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['access'],['accessed']
Security,"pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Returns instance of OptimResult, which has attributes giving the. reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, dyn_type='GEN_MAT', prop_type='DEF', fid_type='DEF', phase_option=None, fid_err_scale_factor=None, amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the alg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:141683,access,accessible,141683,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['accessible']
Security,"pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Returns instance of OptimResult, which has attributes giving the. reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, phase_option='PSU', amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, out_file_ext='.txt', gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:136137,access,accessible,136137,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['accessible']
Security,"r offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ramping_pulse_type (string) – Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:170325,access,accessible,170325,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"rator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:210357,access,accessible,210357,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['access'],['accessible']
Security,"requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:11099,access,accessible,11099,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['access'],['accessible']
Security,"ributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computer",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:14141,access,accessors,14141,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['access'],['accessors']
Security,"rview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.4. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-overview.html:1778,access,accessible,1778,docs/4.5/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-overview.html,1,['access'],['accessible']
Security,"s = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. In [103]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:20205,expose,exposed,20205,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,1,['expose'],['exposed']
Security,"s = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. In [104]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-states.html:20516,expose,exposed,20516,docs/4.4/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-states.html,2,['expose'],['exposed']
Security,"s branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will eith",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8619,hash,hash,8619,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['hash'],['hash']
Security,"s only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RN",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:240603,access,accessible,240603,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['access'],['accessible']
Security,"s only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RN",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:252721,access,accessible,252721,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['access'],['accessible']
Security,"s only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RN",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:198116,access,accessible,198116,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['access'],['accessible']
Security,"s only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:173706,access,accessible,173706,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['access'],['accessible']
Security,"s only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:190140,access,accessible,190140,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['access'],['accessible']
Security,"s only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:165641,access,accessible,165641,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['access'],['accessible']
Security,"s to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the conda-forge package, but it is required at runtime for the string format time-dependence solvers. When installing Visual Studio 2015 be sure to select options for the C++ compiler.; The ‘Community’ edition of Visual Studio 2015 is free to download use, however it does require ap",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:5877,access,access,5877,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,5,['access'],['access']
Security,"s. labeltupleThe ADO label to add an excitation to. kintThe exponent to add the excitation to. Returns. tuple or NoneThe next label. prev(label, k)[source]¶; Return the ADO label with one fewer excitation in the k’th; exponent dimension or None if the label has no exciations in the; k’th exponent. Parameters. labeltupleThe ADO label to remove the excitation from. kintThe exponent to remove the excitation from. Returns. tuple or NoneThe previous label. class HierarchyADOsState(rho, ados, ado_state)[source]¶; Provides convenient access to the full hierarchy ADO state at a particular; point in time, t. Parameters. rhoQobjThe current state of the system (i.e. the 0th component of the; hierarchy). adosHierarchyADOsThe description of the hierarchy. ado_statenumpy.arrayThe full state of the hierarchy. Attributes. rhoQobjThe system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly.; See :class:`HierarchyADOs` for a full list of the available attributes; and methods. extract(idx_or_label)[source]¶; Extract a Qobj representing specified ADO from a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For prac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:67759,access,access,67759,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['access'],['access']
Security,"self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:15356,access,accessors,15356,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,1,['access'],['accessors']
Security,"self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # This will be either ndarray or Qobj; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._phase_application = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = Non",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:15316,access,accessors,15316,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,2,['access'],['accessors']
Security,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:2689,access,accessible,2689,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,6,['access'],['accessible']
Security,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:2828,access,accessible,2828,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,1,['access'],['accessible']
Security,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.sesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:2915,access,accessible,2915,docs/4.7/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html,1,['access'],['accessible']
Security,"solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:4754,access,accessed,4754,docs/4.3/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html,3,['access'],['accessed']
Security,"solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html:4728,access,accessed,4728,docs/4.2/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html,4,['access'],['accessed']
Security,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Dev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:12269,access,accessible,12269,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,1,['access'],['accessible']
Security,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:14552,access,accessible,14552,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,1,['access'],['accessible']
Security,"tems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/biblio.html:3216,access,access,3216,docs/4.4/biblio.html,https://qutip.org,https://qutip.org/docs/4.4/biblio.html,1,['access'],['access']
Security,"terpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-visualization.html:12713,access,access,12713,docs/4.2/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-visualization.html,8,['access'],['access']
Security,"the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:5144,access,accessed,5144,docs/3.0.0/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html,2,['access'],['accessed']
Security,"to initialise the; the control amplitudes. Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW. (see PulseGen classes for details). pulse_scaling : float. Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Instance of an Optimizer, through which the. Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer. The optimisation can be run through the optimizer.run_optimization. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:147587,access,accessible,147587,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['accessible']
Security,"tplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options: ‘pairs’ - typical coordinates, ‘pairs_skewed’ - for; ferromagnetic/antriferromagnetic plots, ‘before_after’ - related to; Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles. Option; ‘grid_iteration’ sets the same number of particles as for; grid_iteration. Option ‘all’ makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:87550,access,access,87550,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['access'],['access']
Security,"tplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis contex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:87610,access,access,87610,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['access'],['access']
Security,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-overview.html:1719,access,accessible,1719,docs/4.0.2/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html,2,['access'],['accessible']
Security,"tum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-overview.html:1719,access,accessible,1719,docs/4.1/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-overview.html,2,['access'],['accessible']
Security,"tum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-overview.html:1719,access,accessible,1719,docs/4.2/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-overview.html,2,['access'],['accessible']
Security,"ty; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector.¶. For the destruction operator above:; In [18]: q.type; Out[18]: 'oper'. In [19]: q.isherm; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-basics.html:10552,access,access,10552,docs/4.4/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-basics.html,1,['access'],['access']
Security,"ulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _par",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:58970,access,accessed,58970,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"uring the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the optimisation. final_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the end of the optimisation. evo_full_final¶; Qobj – The evolution operator from t=0 to t=T based on the final amps. stats¶; Stats – Object contaning the stats for the run (if any collected). optimizer¶; Optimizer – Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:75653,access,access,75653,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['access'],['access']
Security,"when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the las",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8961,hash,hash,8961,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['hash'],['hash']
Security,"with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever ve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:9313,hash,hashes,9313,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['hash'],['hashes']
Security,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b = Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-bloch.html:12130,access,accessed,12130,docs/4.2/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-bloch.html,4,['access'],['accessed']
Security,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b = Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-bloch.html:12130,access,accessed,12130,docs/4.3/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html,1,['access'],['accessed']
Security,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [53]: b = Bloch(). In [54]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-bloch.html:12547,access,accessed,12547,docs/4.4/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-bloch.html,1,['access'],['accessed']
Security,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’’] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [53]: b = Bloch(). In [54]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-bloch.html:11646,access,accessed,11646,docs/4.5/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-bloch.html,1,['access'],['accessed']
Security,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Citing QuTiP; QuTiP is developed by several physicists in their spare time.; As with anyone in academics,; their life and death is determined entirely by citations and paper count. ; Therefore, if you find QuTiP useful, please consider citing this project as:. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234 (2013), DOI: 10.1016/j.cpc.2012.11.019. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP: An open-source Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 183, 1760–1772 (2012), DOI: 10.1016/j.cpc.2012.02.021. This will also help us secure future funding supporting the development of this software.; PDF versions of these papers may be found on the ArXiv preprint server; here and here.; If you do use QuTiP in a publication, please take a few minutes and let us know; by posting on the QuTiP message board.; We would love to hear how QuTiP is being used as a research tool. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/citing.html:950,secur,secure,950,citing.html,https://qutip.org,https://qutip.org/citing.html,1,['secur'],['secure']
Testability," ""; ""'onto_evo_target' property""); return self.onto_evo_target. def _get_onto_evo_target(self):; """"""; Get the inverse of the target.; Used for calculating the 'onto target' evolution; This is actually only relevant for unitary dynamics where; the target.dag() is what is required; However, for completeness, in general the inverse of the target; operator is is required; For state-to-state, the bra corresponding to the is required ket; """"""; if self.target.shape[0] == self.target.shape[1]:; #Target is operator; targ = la.inv(self.target.full()); if self.oper_dtype == Qobj:; rev_dims = [self.target.dims[1], self.target.dims[0]]; self._onto_evo_target = Qobj(targ, dims=rev_dims); elif self.oper_dtype == np.ndarray:; self._onto_evo_target = targ; else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}""; else:; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); elif self.oper_dtype == np.ndarray:; self._onto_evo_target = self.target.dag().full(); else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". return self._onto_evo_target. [docs] def combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; """"""; _func_deprecation(""'combine_dyn_gen' has been replaced by ""; ""'_combine_dyn_gen'""); self._combine_dyn_gen(k); return self._dyn_gen(k). def _combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; Also applies the phase (if any required by the propagation); """"""; if self.time_depend_drift:; dg = self._drift_dyn_gen[k]; else:; dg = self._drift_dyn_gen; for j in range(self._num_ctrls):; if self.time_depend_ctrl_dyn_gen:; dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[k, j]; else:; dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[j]. self._dyn_gen[k] = dg; if self.cache_phased_dyn_gen:; self._phased_dyn_gen[k] = self._apply_phase(dg). [docs] def get_dyn_gen(self, k):; """"""; Get the com",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:36617,assert,assert,36617,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,2,['assert'],['assert']
Testability," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:18567,log,logging,18567,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['log'],['logging']
Testability," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:18892,log,logging,18892,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['log'],['logging']
Testability," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:18646,log,logging,18646,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['log'],['logging']
Testability," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:3173,log,logging,3173,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,3,['log'],"['logger', 'logging']"
Testability," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:3177,log,logging,3177,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,12,['log'],"['logger', 'logging']"
Testability," 'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape,; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None,; 'residual_norm': None,; 'solver': None, 'method': None}. return def_info. def _default_steadystate_args():; def_args = {'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'use_precond': False,; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4,; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2',; 'restart': 20,; 'max_iter_refine': 10,; 'scaling_vectors': True,; 'weighted_matching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/steadystate.html:3283,log,logger,3283,docs/4.5/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/steadystate.html,1,['log'],['logger']
Testability," 'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape,; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None,; 'residual_norm': None,; 'solver': None, 'method': None}. return def_info. def _default_steadystate_args():; def_args = {'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False,; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4,; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2',; 'restart': 20, 'return_info': False,; 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy'}. return def_args. def _mkl_steadystate_args():; def_args = {'max_ite",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:3274,log,logger,3274,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,2,['log'],['logger']
Testability," * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u[r + 1, :, :, :] = u[r, :, :, :]; eps_vec /= 2; else:. if best_k == 0:; eps_vec /= 2. elif best_k == 2:; eps_vec *= 2. _prev_overlap = _k_overlap[best_k]. overlap_log[r] = _k_overlap[best_k]. if overlap_terminate < 1.0:; if _k_overlap[best_k] > overlap_terminate:; logger.info(""Reached target fidelity, terminating.""); break. logger.debug(""Time 4: %fs"" % (time.time() - _t0)); _t0 = time.time(). if use_interp:; ip_funcs = [interp1d(times, u[_r, j, :, best_k], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[_r, j, :, best_k]] for j in range(J)]. progress_bar.finished(). result = GRAPEResult(u=u[:_r, :, :, best_k], U_f=Uf[best_k],; H_t=H_td_func). result.eps = eps_log; result.overlap = overlap_log. return result. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:16797,log,logger,16797,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,2,['log'],['logger']
Testability," ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; Use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:18467,log,logger,18467,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,6,['log'],['logger']
Testability," ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = prod(L.dims[0][0]); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True, useUmfpack=ss_args['use_umfpack']). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning faile",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:18588,log,logger,18588,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability," - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scale) + self.ubound; self._bound_scale_cond = self._BSC_GT_MEAN. elif self.ubound is None:; # only lower bound; if self.lbound < 0:; self._bound_mean = 0.0; self._bound_scale = abs(self.lbound); else:; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_gu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:32282,log,logger,32282,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,2,['log'],['logger']
Testability," 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scale) + self.ubound; self._bound_scale_cond = self._BSC_GT_MEAN. elif self.ubound is None:; # only lower bound; if self.lbound < 0:; self._bound_mean = 0.0; self._bound_scale = abs(self.lbound); else:; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_gu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html:32284,log,logger,32284,docs/4.4/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html,1,['log'],['logger']
Testability," : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur. SUMMARY; A summary will be recorded. FULL; All possible dumping. CUSTOM; Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsD",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dump.html:4758,log,logger,4758,docs/4.6/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html,2,['log'],['logger']
Testability," : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur; - SUMMARY : A summary will be recorded; - FULL : All possible dumping; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:4729,log,logger,4729,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,6,['log'],['logger']
Testability," ; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. . init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:57898,log,logger,57898,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['log'],['logger']
Testability," = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:14704,log,logger,14704,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,8,['log'],['logger']
Testability," = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:10581,log,log,10581,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,8,['log'],['log']
Testability," = np.loadtxt(file_name, delimiter='\t'); if not inctime:; self.coeffs = data.T; return self.coeffs; else:; tlist = data[:, 0]; self.set_all_tlist(tlist); self.coeffs = data[:, 1:].T; return self.get_full_tlist, self.coeffs. [docs] def get_noisy_pulses(self, device_noise=False, drift=False):; """"""; It takes the pulses defined in the `Processor` and; adds noise according to `Processor.noise`. It does not modify the; pulses saved in `Processor.pulses` but returns a new list.; The length of the new list of noisy pulses might be longer; because of drift Hamiltonian and device noise. They will be; added to the end of the pulses list. Parameters; ----------; device_noise: bool, optional; If true, include pulse independent noise such as single qubit; Relaxation. Default is False.; drift: bool, optional; If true, include drift Hamiltonians. Default is False. Returns; -------; noisy_pulses: list of :class""`qutip.qip.Pulse`/:class:`qutip.qip.Drift`; A list of noisy pulses.; """"""; # TODO add tests; pulses = deepcopy(self.pulses); noisy_pulses = process_noise(; pulses, self.noise, self.dims, t1=self.t1, t2=self.t2,; device_noise=device_noise); if drift:; noisy_pulses += [self.drift]; return noisy_pulses. [docs] def get_qobjevo(self, args=None, noisy=False):; """"""; Create a :class:`qutip.QobjEvo` representation of the evolution.; It calls the method `get_noisy_pulses` and create the `QobjEvo`; from it. Parameters; ----------; args: dict, optional; Arguments for :class:`qutip.QobjEvo`; noisy: bool, optional; If noise are included. Default is False. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The :class:`qutip.QobjEvo` representation of the unitary evolution.; c_ops: list of :class:`qutip.QobjEvo`; A list of lindblad operators is also returned. if ``noisy==Flase``,; it is always an empty list.; """"""; # TODO test it for non array-like coeff; # check validity; self._is_pulses_valid(). if args is None:; args = {}; else:; args = args; # set step function. if not noisy:; dynamics = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:14455,test,tests,14455,docs/4.5/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html,1,['test'],['tests']
Testability," = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:18347,log,logging,18347,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,3,['log'],['logging']
Testability," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]. [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs"""""". if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes, "";",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:33416,log,log,33416,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,8,['log'],"['log', 'logging']"
Testability," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:28915,log,log,28915,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,8,['log'],"['log', 'logging']"
